{"version":3,"sources":["ngGo.js","board/board.directive.js","board/board.service.js","board/defaultClearHandler.service.js","board/grid.service.js","board/gridChanges.service.js","board/layer.service.js","board/object.service.js","board/shellPattern.service.js","board/theme.service.js","errors/invalidDataError.service.js","errors/invalidPositionError.service.js","game/game.service.js","game/node.service.js","game/path.service.js","game/position.service.js","game/score.service.js","game/scorer.service.js","kifu/blank.service.js","kifu/parser.service.js","player/player.directive.js","player/player.service.js","board/layer/gridLayer.service.js","board/layer/hoverLayer.service.js","board/layer/markupLayer.service.js","board/layer/scoreLayer.service.js","board/layer/shadowLayer.service.js","board/layer/stonesLayer.service.js","board/object/coordinates.service.js","board/object/markup.service.js","board/object/stone.service.js","board/object/stoneFaded.service.js","board/object/stoneMini.service.js","board/object/stoneShadow.service.js","kifu/parsers/gib2jgf.service.js","kifu/parsers/jgf2sgf.service.js","kifu/parsers/sgf2jgf.service.js","player/mode/common.service.js","player/mode/edit.service.js","player/mode/replay.service.js","player/mode/solve.service.js","ngGo.min.js"],"names":["window","angular","undefined","module","constant","name","version","error","POSITION_OUT_OF_BOUNDS","POSITION_ALREADY_HAS_STONE","POSITION_IS_SUICIDE","POSITION_IS_REPEATING","NO_DATA","UNKNOWN_DATA","INVALID_SGF","INVALID_GIB","INVALID_JGF_JSON","INVALID_JGF_TREE_JSON","E","EMPTY","B","BLACK","W","WHITE","TRIANGLE","CIRCLE","SQUARE","MARK","SELECT","LABEL","LAST","SAD","HAPPY","PLAY","REPLAY","EDIT","SOLVE","NONE","MOVE","SCORE","SETUP","MARKUP","LEFT","RIGHT","UP","DOWN","ESC","ENTER","SPACE","TAB","SHIFT","CTRL","ALT","HOME","END","PAGEUP","PAGEDOWN","directive","$window","Board","pixelRatio","createLayerCanvas","canvas","document","createElement","context","getContext","scale","className","width","this","clientWidth","height","clientHeight","appendChild","determineDrawSize","scope","availableWidth","availableHeight","drawWidth","drawHeight","cellSize","Math","min","floor","lastDrawWidth","lastDrawHeight","$broadcast","restrict","instance","link","element","attrs","i","layer","playerElement","parent","sizingElement","existingInstance","linkElement","tagName","$on","event","find","length","forceSize","css","setDrawSize","on","board","resized","addClass","makeStatic","call","layerOrder","layers","setContext","$observe","size","toLowerCase","indexOf","split","setSize","attr","toggleCoordinates","isDefined","setCutoff","swapColors","$parent","Player","setBoard","redraw","provider","defaultConfig","cutoff","section","top","right","bottom","left","coordinates","colorMultiplier","setConfig","config","extend","$get","$rootScope","$injector","BoardTheme","init","parseConfig","prototype","removeAll","theme","drawMarginHor","drawMarginVer","gridDrawWidth","gridDrawHeight","l","layerClass","toUpperCase","substr","LayerClass","get","margin","grid","setCoordinates","setSection","setMargin","isArray","changes","side","hasOwnProperty","parseInt","isNaN","show","multiplier","getTheme","setTheme","add","x","y","value","remove","has","setAll","updatePosition","position","pathChanged","stones","markup","getState","getAll","state","isEmpty","restoreState","clear","draw","xLeft","xRight","yTop","yBot","noCellsHor","noCellsVer","getCellSize","getAbsX","gridX","offset","round","getAbsY","gridY","getGridX","absX","getGridY","absY","isOnBoard","factory","obj","s","r","clearRect","BoardGridChanges","toObject","valueKey","BoardGrid","emptyValue","set","isOnGrid","unset","is","all","objects","push","populate","empty","clone","newGrid","copy","isSameAs","compare","console","warn","whenEmpty","getSize","setSubtract","a","b","q","n","j","concat","newChanges","BoardLayer","clearCell","drawCell","redrawCell","DefaultClearHandler","BoardObject","drawheight","shellLine","ctx","radius","startAngle","endAngle","strokeStyle","shadowBlur","lineWidth","thickness","beginPath","max","m","angle","x1","cos","PI","y1","sin","x2","y2","atan","c","factor","dx","dy","bx1","by1","bx2","by2","moveTo","bezierCurveTo","stroke","lines","StoneColor","MarkupTypes","defaultTheme","stone","style","shadow","shell","color","stoneColor","types","mono","lineColor","mini","alpha","faded","blur","offsetX","ceil","offsetY","triangle","square","circle","mark","lineCap","last","smiley","label","font","variation","type","text","String","fromCharCode","solution","valid","invalid","star","points","vertical","inverse","ch","horizontal","merge","instanceTheme","reset","property","path","prop","args","arguments","apply","canvasTranslate","ngGo","InvalidDataError","code","message","Error","constructor","InvalidPositionError","POSTITION_OUT_OF_BOUNDS","POSTITION_ALREADY_HAS_STONE","POSTITION_IS_SUICIDE","POSTITION_IS_REPEATING","defaultSize","defaultKomi","defaultHandicap","rememberPath","checkRepeat","allowSuicide","GamePath","GameNode","GamePosition","KifuParser","KifuBlank","validateInfo","info","game","komi","handicap","nextNode","node","children","rememberedPath","advance","previousNode","retreat","firstNode","root","setTurn","initializeHistory","history","pushPosition","newPosition","popPosition","pop","replacePosition","executeNode","isMove","move","pass","validateMove","turn","setup","Game","data","Object","defineProperty","load","jgf","fromData","errorCode","first","reload","isLoaded","props","getOwnPropertyNames","p","charAt","fromSgf","fromJgf","fromGib","gib","gib2jgf","sgf","sgf2jgf","fromJson","tree","toSgf","jgf2sgf","toJgf","stringify","toJson","getNode","getNodes","nodes","getChild","getMoveNode","getMoveNodes","fromMove","toMove","filter","getMoveNumber","getMove","getMoveCount","moveNodes","getMoveVariation","getPosition","getPath","clonePath","getPathToNode","nodeName","findNode","getKomi","parseFloat","setKomi","getName","getResult","getTurn","getCaptureCount","captures","defaultValue","key","isMoveVariation","isRepeatingPosition","checkPosition","stop","isValidMove","captureAdjacent","hasLiberties","captureGroup","validatePlacement","addStone","tempPosition","appendTo","addMarkup","removeStone","foundInSetup","splice","removeMarkup","hasStone","hasMarkup","getStone","getMarkup","play","next","previous","target","setMove","nodeAt","nextFork","previousFork","nextComment","hasComments","previousComment","aChar","charCodeAt","convertCoordinates","coords","coordinatesObject","baseObject","toStringColor","toColorConstant","convertMoveToJgf","jgfMove","convertMoveFromJgf","convertSetupToJgf","jgfSetup","convertSetupFromJgf","gameSetup","convertMarkupToJgf","jgfMarkup","convertMarkupFromJgf","gameMarkup","convertTurnToJgf","convertTurnFromJgf","conversionMap","properties","getChildren","hasChildren","getParent","hasMoveVariations","moveVariations","getMoveVariations","comments","moveUp","temp","moveDown","insertNode","gameNode","variationNode","container","variationsContainer","variationContainer","branches","no","otherPath","newPath","findNodeName","rootNode","setStone","setMarkup","groupColor","tested","friendlyColor","captured","canCapture","enemyColor","doCapture","captureStone","setCaptures","getCaptures","switchTurn","calcTotal","territory","GameScore","self","black","white","total","winner","w","scoreState","UNKNOWN","BLACK_STONE","WHITE_STONE","BLACK_CANDIDATE","WHITE_CANDIDATE","NEUTRAL","territorySet","candidateColor","boundaryColor","posColor","origColor","territoryReset","determineScoreState","curState","newState","adjacent","change","GameScorer","score","getScore","getPoints","calculate","blankJgf","record","application","charset","players","blankSgf","AP","CA","FF","GM","SZ","PB","PW","base","blank","CP","SO","US","AN","GN","KM","HA","RE","RU","TM","OT","DT","PC","EV","RO","ON","GC","BT","WT","BR","WR","N","C","CR","TR","SQ","MA","SL","LB",1,2,3,4,6,7,8,"Gib2Jgf","Sgf2Jgf","Jgf2Sgf","stringified","parse","controller","$scope","mode","switchMode","tool","switchTool","setVariationMarkup","toggleSolutionPaths","setLastMoveMarker","PlayerModes","PlayerTools","arrowKeysNavigation","scrollWheelNavigation","lastMoveMarker","variationMarkup","variationChildren","variationSiblings","$document","processMouseEvent","broadcastEvent","mouseEvent","originalEvent","layerX","layerY","devicePixelRatio","drag","modes","tools","restrictNodeStart","restrictNodeEnd","registerElementEvent","setArrowKeysNavigation","setScrollWheelNavigation","arrowKeys","broadcast","scrollWheel","registerMode","PlayerMode","setTools","hasMode","hasTool","force","saveState","playerState","saveGameState","restoreGameState","allowPlayerConfig","processPosition","gameState","goto","restrictNode","end","updateBoard","showMoveNumbers","forEach","newGame","scoreGame","getBoard","off","bind","listener","querySelector","preventClickEvent","t","$$phase","$apply","Coordinates","drawStarPoint","starRadius","starColor","fillStyle","arc","fill","GridLayer","tx","ty","starPoints","translate","lineTo","Markup","StoneFaded","HoverLayer","restore","hover","object","objectClass","MarkupLayer","StoneMini","ScoreLayer","StoneShadow","ShadowLayer","shadowSize","setTransform","Stone","StonesLayer","kanji","aCharLc","numbers","letters","xl","xr","yt","yb","textBaseline","textAlign","fillText","cosPi4","cosPi6","drawTriangle","closePath","drawSquare","rcos","rect","drawCircle","drawMark","drawSelect","drawLast","drawHappySmiley","drawSadSmiley","drawLabel","toString","clearLabel","ShellPattern","shellSeed","drawMono","globalAlpha","drawGlass","createRadialGradient","addColorStop","drawSlateShell","random","shellTypes","z","handler","shadowColor","regMove","regPlayer","regKomi","regDate","regResultMargin","regResultOther","parsePlayer","match","player","rank","parseKomi","parseDate","dates","parseResult","result","parseMove","Parser","exec","sgfAliases","sgfGames","jgfAliases","sgfProp","escapeSgf","replace","writeGroup","values","output","escape","parseSetup","parseScore","parseMarkup","parseTurn","parseComments","flatComments","comment","parseNodeName","parseGame","parseApplication","parts","rootProperties","st","ST","parseBoard","parsePlayers","team","parsingMap","record.application","game.type","game.players","writeTree","extractRootProperties","subKey","jgfKey","regSequence","regNode","regProperty","regValues","parseApp","app","parseSgfFormat","parseComment","parseLabel","parseSize","d","parseVariations","AB","AW","AE","PL","TW","TB","needsNode","setInfo","stack","sequence","k","substring","run","PlayerModeCommon","keyDown","mouseWheel","mouseMove","mouseOut","mouseDown","mouseUp","KeyCodes","normalizeMousewheelEvent","deltaX","deltaY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","mouseWheelX","mouseWheelY","dragObject","start","mouse","dragStart","lastX","lastY","keyboardEvent","keyCode","preventDefault","delta","CLEAR","TEXT","NUMBER","PlayerModeEdit","pathChange","toolSwitch","modeEnter","mouseDrag","click","SetupTools","MarkupTools","updateHoverMark","isDrag","setupTool","setupToolColor","markupTool","markupLabel","markupLabels","determineMarkupLabel","findAllMarkupLabels","switchSetupTool","switchMarkupTool","setMarkupLabel","statePreScoring","PlayerModeReplay","settingChange","boardUpdate","modeExit","autoPlayDelay","$interval","showMoveVariations","variations","hideMoveVariations","drawMoveVariations","autoPlaying","autoPlayPromise","setAutoPlayDelay","delay","cancel","setting","PlayerModeSolve","playerColor","solutionPaths","solveAutoPlay","solveAutoPlayDelay","$timeout","canMakeMove","problemSolved","problemOffPath","showSolutionPaths","hideSolutionPaths","drawSolutionPaths","problemStartPath","solveNavigationBlocked","setSolveAutoPlay","autoPlay","setSolveAutoPlayDelay","setPlayerColor","getPlayerColor","asOnBoard","autoPlayNext","immediately","solve","restartProblem"],"mappings":"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","file":"ngGo.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n/**\n * ngGo\n *\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\n * refactored to fit the Angular framework, as well as having been linted, properly commented\n * and generally cleaned up.\n *\n * Copyright (c) 2013 Jan Prokop (WGo)\n * Copyright (c) 2014-2015 Adam Buczynski (ngGo)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo', [])\n\n/**\n * ngGo constants\n */\n.constant('ngGo', {\n  name: 'ngGo',\n  version: '1.3.1',\n  error: {\n\n    //Position errors\n    POSITION_OUT_OF_BOUNDS: 1,\n    POSITION_ALREADY_HAS_STONE: 2,\n    POSITION_IS_SUICIDE: 3,\n    POSITION_IS_REPEATING: 4,\n\n    //Data loading errors\n    NO_DATA: 5,\n    UNKNOWN_DATA: 6,\n    INVALID_SGF: 7,\n    INVALID_GIB: 8,\n    INVALID_JGF_JSON: 9,\n    INVALID_JGF_TREE_JSON: 10\n  }\n})\n\n/**\n * Stone colors\n */\n.constant('StoneColor', {\n  E: 0,\n  EMPTY: 0,\n  B: 1,\n  BLACK: 1,\n  W: -1,\n  WHITE: -1\n})\n\n/**\n * Markup types\n */\n.constant('MarkupTypes', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  LABEL: 'label',\n  LAST: 'last',\n  SAD: 'sad',\n  HAPPY: 'happy'\n})\n\n/**\n * Player modes\n */\n.constant('PlayerModes', {\n  PLAY: 'play',\n  REPLAY: 'replay',\n  EDIT: 'edit',\n  SOLVE: 'solve'\n})\n\n/**\n * Player tools\n */\n.constant('PlayerTools', {\n  NONE: 'none',\n  MOVE: 'move',\n  SCORE: 'score',\n  SETUP: 'setup',\n  MARKUP: 'markup'\n})\n\n/**\n * Key codes\n */\n.constant('KeyCodes', {\n  LEFT: 37,\n  RIGHT: 39,\n  UP: 38,\n  DOWN: 40,\n  ESC: 27,\n  ENTER: 13,\n  SPACE: 32,\n  TAB: 9,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  HOME: 36,\n  END: 35,\n  PAGEUP: 33,\n  PAGEDOWN: 34\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Directive', [\n  'ngGo.Board.Service'\n])\n\n/**\n * Directive definition\n */\n.directive('board', ['$window', 'Board', function($window, Board) {\n\n  //Get pixel ratio\n  var pixelRatio = window.pixelRatio || 1;\n\n  /**\n   * Helper to create a layer canvas\n   */\n  var createLayerCanvas = function(name) {\n\n    //Create canvas element and get context\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    //Scale context depending on pixel ratio\n    if (pixelRatio > 1) {\n      context.scale(pixelRatio, pixelRatio);\n    }\n\n    //Set class\n    canvas.className = name;\n\n    //Set initial canvas width/height based on our own size\n    canvas.width = this.clientWidth * pixelRatio;\n    canvas.height = this.clientHeight * pixelRatio;\n\n    //Append to element now and return context\n    this.appendChild(canvas);\n    return context;\n  };\n\n  /**\n   * Helper to determine draw size\n   */\n  var determineDrawSize = function(scope, availableWidth, availableHeight) {\n\n    //Init vars\n    var drawWidth, drawHeight, cellSize;\n\n    //Stretch available height to width if zero\n    if (availableHeight === 0 && availableWidth > 0) {\n      availableHeight = availableWidth;\n    }\n\n    //Grid size known?\n    if (scope.Board.width && scope.Board.height) {\n\n      //Determine smallest cell size\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\n\n      //Set draw size\n      drawWidth = Math.floor(cellSize * scope.Board.width);\n      drawHeight = Math.floor(cellSize * scope.Board.height);\n    }\n\n    //Otherwise, use the lesser of the available width/height\n    else {\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\n    }\n\n    //Broadcast new size if changed\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\n      scope.lastDrawWidth = drawWidth;\n      scope.lastDrawHeight = drawHeight;\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\n      return true;\n    }\n\n    //No change\n    return false;\n  };\n\n  /**\n   * Directive\n   */\n  return {\n    restrict: 'E',\n    scope: {\n      instance: '&'\n    },\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Init vars\n      var i, context, layer, playerElement;\n      var parent = element.parent();\n      var sizingElement = element[0];\n      var existingInstance = true;\n\n      //Remember last draw width/height\n      scope.lastDrawWidth = 0;\n      scope.lastDrawHeight = 0;\n\n      //Get board instance\n      scope.Board = scope.instance();\n\n      //Function given?\n      if (typeof scope.Board === 'function') {\n        scope.Board = scope.Board();\n      }\n\n      //Instantiate board if not present in scope\n      if (!scope.Board) {\n        existingInstance = false;\n        scope.Board = new Board();\n      }\n\n      //Link element\n      scope.Board.linkElement(element);\n\n      //Find player element\n      if (parent[0].tagName === 'PLAYER') {\n        playerElement = parent;\n        sizingElement = parent.parent()[0];\n      }\n\n      //Listen for board drawsize events\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\n\n        //First set the new dimensions on the canvas elements\n        var canvas = element.find('canvas');\n        for (i = 0; i < canvas.length; i++) {\n          canvas[i].width = width * pixelRatio;\n          canvas[i].height = height * pixelRatio;\n        }\n\n        //Set on the element if we're using a player element and if there is a size\n        if (playerElement || attrs.forceSize === 'true') {\n          element.css({width: width + 'px', height: height + 'px'});\n        }\n\n        //Next set it on the board itself\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\n      });\n\n      //Determine initial draw size\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n\n      //On window resize, determine the draw size again\n      angular.element($window).on('resize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On manual resize, determine draw size again\n      scope.$on('ngGo.board.determineDrawSize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On board grid resize, determine the draw size again\n      scope.$on('ngGo.board.resize', function(event, board) {\n\n        //Only relevent if this was our own board\n        if (board !== scope.Board) {\n          return;\n        }\n\n        //If the draw size didn't change, the draw size event won't be triggered.\n        //However, that means we should call the resized() method now manually because\n        //it won't be called with the setDrawSize() call.\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\n          scope.Board.resized();\n        }\n      });\n\n      //Static board\n      if (attrs.static && attrs.static === 'true') {\n\n        //Add static class and make the board static\n        element.addClass('static');\n        scope.Board.makeStatic();\n\n        //Create single canvas and link to all relevant layer service classes\n        context = createLayerCanvas.call(element[0], 'static');\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Dynamic board\n      else {\n\n        //Create individual layer canvasses and link the canvas context to the layer service class\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          context = createLayerCanvas.call(element[0], layer);\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Observe the board size attribute\n      attrs.$observe('size', function(size) {\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\n          size = size.split('x');\n          scope.Board.setSize(size[0], size[1]);\n        }\n        else {\n          scope.Board.setSize(size, size);\n        }\n      });\n\n      //Observe the coordinates attribute\n      attrs.$observe('coordinates', function(attr) {\n        scope.Board.toggleCoordinates(attr === 'true');\n      });\n\n      //Observe the cutoff attribute\n      attrs.$observe('cutoff', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.setCutoff(attr.split(','));\n        }\n      });\n\n      //Observe color multiplier\n      attrs.$observe('colorMultiplier', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.swapColors(attr);\n        }\n      });\n\n      //Link board to player if present in parent scope\n      if (scope.$parent.Player) {\n        scope.$parent.Player.setBoard(scope.Board);\n      }\n\n      //Redraw board if we had an existing instance (it might contain data)\n      if (existingInstance) {\n        scope.Board.redraw();\n      }\n    }\n  };\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\n * and is used for placing and removing objects on the board. The class has helpers to figure out\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\n * responsible for drawing all layers on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Service', [\n  'ngGo',\n  'ngGo.Board.Directive',\n  'ngGo.Board.Theme.Service',\n  'ngGo.Board.Layer.GridLayer.Service',\n  'ngGo.Board.Layer.ShadowLayer.Service',\n  'ngGo.Board.Layer.StonesLayer.Service',\n  'ngGo.Board.Layer.MarkupLayer.Service',\n  'ngGo.Board.Layer.ScoreLayer.Service',\n  'ngGo.Board.Layer.HoverLayer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.Stone.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Board', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Width and height\n    width: 0,\n    height: 0,\n\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\n    cutoff: [],\n\n    //Section of board to display\n    section: {top: 0, right: 0, bottom: 0, left: 0},\n\n    //Show coordinates?\n    coordinates: false,\n\n    //Color multiplier (use -1 to swap colors)\n    colorMultiplier: 1\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$injector', 'BoardTheme', function($rootScope, $injector, BoardTheme) {\n\n    /**\n     * Board constructor\n     */\n    var Board = function(config) {\n\n      //Initialize board\n      this.init();\n\n      //Parse config\n      this.parseConfig(config || {});\n    };\n\n    /**\n     * Initialize board\n     */\n    Board.prototype.init = function() {\n\n      //Remove everything\n      this.removeAll();\n\n      //Set board theme\n      this.theme = new BoardTheme();\n\n      //Initialize board draw dimensions in pixels\n      this.cellSize = 0;\n      this.drawWidth = 0;\n      this.drawHeight = 0;\n      this.drawMarginHor = 0;\n      this.drawMarginVer = 0;\n      this.gridDrawWidth = 0;\n      this.gridDrawHeight = 0;\n\n      //Set layer order\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\n\n      //Initialize layers\n      this.layers = {};\n      for (var l = 0; l < this.layerOrder.length; l++) {\n        var layer = this.layerOrder[l];\n        var layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\n        var LayerClass = $injector.get(layerClass);\n        this.layers[layer] = new LayerClass(this);\n      }\n\n      //Static board flag\n      this.static = false;\n\n      //Get margin from theme\n      this.margin = this.theme.get('board.margin');\n\n      //Color multiplier (to allow color swapping)\n      this.colorMultiplier = 1;\n\n      //Turn off coordinates\n      this.coordinates = false;\n      this.layers.grid.setCoordinates(false);\n\n      //Initialize grid size\n      this.width = 0;\n      this.height = 0;\n\n      //Initialize cutoff\n      this.cutoff = {\n        top: false,\n        left: false,\n        right: false,\n        bottom: false\n      };\n\n      //Initialize section\n      this.section = {\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    };\n\n    /**\n     * Link the board to a HTML element\n     */\n    Board.prototype.linkElement = function(element) {\n      this.element = element;\n    };\n\n    /**\n     * Make this board static (one canvas layer, only grid, stones and markup)\n     */\n    Board.prototype.makeStatic = function() {\n      this.static = true;\n      this.layerOrder = ['grid', 'stones', 'markup'];\n    };\n\n    /*****************************************************************************\n     * Configuration\n     ***/\n\n    /**\n     * Parse config instructions\n     */\n    Board.prototype.parseConfig = function(config) {\n\n      //Validate\n      if (typeof config !== 'object') {\n        return;\n      }\n\n      //Extend from default config\n      config = angular.extend({}, defaultConfig, config);\n\n      //Process settigns\n      this.toggleCoordinates(config.coordinates);\n      this.swapColors(config.colorMultiplier);\n      this.setCutoff(config.cutoff);\n      this.setSection(config.section);\n      this.setSize(config.width, config.height);\n    };\n\n    /**\n     * Set margin\n     */\n    Board.prototype.setMargin = function(margin) {\n\n      //Reset when not defined\n      if (typeof margin === 'undefined') {\n        margin = this.theme.get('board.margin');\n      }\n\n      //Set margin if changed\n      if (this.margin !== margin) {\n        this.margin = margin;\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set grid cut-off\n     */\n    Board.prototype.setCutoff = function(cutoff) {\n\n      //Nothing given? Reset cutoff\n      if (!cutoff || !angular.isArray(cutoff)) {\n        cutoff = [];\n      }\n\n      //Init\n      var changes = false;\n\n      //Check if there's a change\n      for (var side in this.cutoff) {\n        if (this.cutoff.hasOwnProperty(side)) {\n          if (cutoff.indexOf(side) !== -1) {\n            if (!this.cutoff[side]) {\n              this.cutoff[side] = true;\n              changes = true;\n            }\n          }\n          else {\n            if (this.cutoff[side]) {\n              this.cutoff[side] = false;\n              changes = true;\n            }\n          }\n        }\n      }\n\n      //Trigger resized if there were changes\n      if (changes) {\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set section of the board to be displayed\n     */\n    Board.prototype.setSection = function(section) {\n\n      //Nothing given?\n      if (!section || typeof section !== 'object') {\n        return this;\n      }\n\n      //Expand on default\n      section = angular.extend({\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      }, section);\n\n      //No changes?\n      if (\n        this.section.top === section.top && this.section.bottom === section.bottom &&\n        this.section.left === section.left && this.section.right === section.right\n      ) {\n        return this;\n      }\n\n      //Set section and call resized handler\n      this.section = section;\n      this.resized();\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set board size. This will clear the board objects.\n     */\n    Board.prototype.setSize = function(width, height) {\n\n      //Check what's given\n      width = parseInt(width || height || 0);\n      height = parseInt(height || width || 0);\n\n      //Invalid?\n      if (isNaN(width) || isNaN(height)) {\n        return;\n      }\n\n      //Changing?\n      if (width !== this.width || height !== this.height) {\n\n        //Remember size\n        this.width = width;\n        this.height = height;\n\n        //Set size in layers\n        for (var layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].setSize(width, height);\n          }\n        }\n\n        //Broadcast event (no call to resized, as that is handled in the directive)\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set new draw size\n     */\n    Board.prototype.setDrawSize = function(width, height) {\n      if (width !== this.drawWidth || height !== this.drawHeight) {\n        this.drawWidth = width;\n        this.drawHeight = height;\n        this.resized();\n      }\n    };\n\n    /**\n     * Toggle the coordinates\n     */\n    Board.prototype.toggleCoordinates = function(show) {\n\n      //Set or toggle\n      if (typeof show !== 'undefined') {\n        this.coordinates = show;\n      }\n      else {\n        this.coordinates = !this.coordinates;\n      }\n\n      //Set in grid layer\n      this.layers.grid.setCoordinates(this.coordinates);\n\n      //Set the proper board margin\n      if (this.coordinates) {\n        this.setMargin(this.theme.get('coordinates.margin'));\n      }\n      else {\n        this.setMargin(this.theme.get('board.margin'));\n      }\n    };\n\n    /**\n     * Swap colors on the board\n     */\n    Board.prototype.swapColors = function(multiplier) {\n\n      //Multiplier not given? Set to inverse of current value\n      if (typeof multiplier === 'undefined') {\n        multiplier = -this.colorMultiplier;\n      }\n      else {\n        multiplier = parseInt(multiplier);\n        if (isNaN(multiplier)) {\n          return;\n        }\n      }\n\n      //No change?\n      if (multiplier === this.colorMultiplier) {\n        return;\n      }\n\n      //Set new value\n      this.colorMultiplier = multiplier;\n\n      //For static board, redraw the whole thing\n      if (this.static) {\n        this.redraw();\n      }\n\n      //For a dynamic board, only these layers\n      else {\n        this.redraw('stones');\n        this.redraw('markup');\n      }\n    };\n\n    /*****************************************************************************\n     * Theme handling\n     ***/\n\n    /**\n     * Get the current theme object\n     */\n    Board.prototype.getTheme = function() {\n      return this.theme;\n    };\n\n    /**\n     * Set the theme object\n     */\n    Board.prototype.setTheme = function(theme) {\n      this.theme = theme;\n      return this;\n    };\n\n    /*****************************************************************************\n     * Object handling\n     ***/\n\n    /**\n     * Add an object to a board layer\n     */\n    Board.prototype.add = function(layer, x, y, value) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].add(x, y, value);\n      }\n    };\n\n    /**\n     * Remove an object from a board layer\n     */\n    Board.prototype.remove = function(layer, x, y) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].remove(x, y);\n      }\n    };\n\n    /**\n     * Get something from a board layer\n     */\n    Board.prototype.get = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].get(x, y));\n    };\n\n    /**\n     * Check if we have something at given coordinates for a given layer\n     */\n    Board.prototype.has = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].has(x, y));\n    };\n\n    /**\n     * Set all objects (grid) for a given layer\n     */\n    Board.prototype.setAll = function(layer, grid) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].setAll(grid);\n      }\n    };\n\n    /**\n     * Remove all objects from the board, optionally for a given layer\n     */\n    Board.prototype.removeAll = function(layer) {\n      if (layer) {\n        if (typeof this.layers[layer] !== 'undefined') {\n          this.layers[layer].removeAll();\n        }\n      }\n      else {\n        for (layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].removeAll();\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Position handling\n     ***/\n\n    /**\n     * Update the board with a new position\n     */\n    Board.prototype.updatePosition = function(position, pathChanged) {\n\n      //If we have no grid size yet, use what's in the position\n      if (!this.width || !this.height) {\n        this.setSize(position.width, position.height);\n      }\n\n      //Remove markup if path changed\n      if (pathChanged) {\n        this.removeAll('markup');\n      }\n\n      //Set new stones and markup grids\n      this.setAll('stones', position.stones);\n      this.setAll('markup', position.markup);\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state (list of objects per layer)\n     */\n    Board.prototype.getState = function(layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          return this.layers[layer].getAll();\n        }\n        return null;\n      }\n\n      //All layers\n      var state = {};\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          var grid = this.layers[layer].getAll();\n          if (grid && !grid.isEmpty()) {\n            state[layer] = grid;\n          }\n        }\n      }\n      return state;\n    };\n\n    /**\n     * Restore the board state from given state object\n     */\n    Board.prototype.restoreState = function(state, layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          this.layers[layer].setAll(state);\n        }\n        return;\n      }\n\n      //All layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].removeAll();\n          if (state[layer]) {\n            this.layers[layer].setAll(state[layer]);\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing control\n     ***/\n\n    /**\n     * Clear the whole board\n     */\n    Board.prototype.clear = function(layer) {\n\n      //Just clearing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Clear the layer\n        this.layers[layer].clear();\n        return;\n      }\n\n      //Static? One clear is enough\n      if (this.static) {\n        this.layers.stones.clear();\n        return;\n      }\n\n      //Clear all layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].clear();\n        }\n      }\n    };\n\n    /**\n     * Redraw everything or just a single layer\n     */\n    Board.prototype.redraw = function(layer) {\n\n      //The board can only be redrawn when there is a grid size and a draw size\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Just redrawing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Redraw the layer\n        this.layers[layer].redraw();\n        return;\n      }\n\n      //Clear the board first\n      this.clear();\n\n      //Now draw all layers again in the correct order\n      for (var i = 0; i < this.layerOrder.length; i++) {\n        layer = this.layerOrder[i];\n        this.layers[layer].draw();\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing helpers\n     ***/\n\n    /**\n     * Called after a board size change, draw size change, section change or margin change\n     */\n    Board.prototype.resized = function() {\n\n      //Determine the new grid\n      this.grid = {\n        xLeft: 0 + this.section.left,\n        xRight: this.width - 1 - this.section.right,\n        yTop: 0 + this.section.top,\n        yBot: this.height - 1 - this.section.bottom\n      };\n\n      //Only redraw when there is sensible data\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Determine number of cells horizontall and vertically\n      //The margin is a factor of the cell size, so let's add it to the number of cells\n      var noCellsHor = this.width + this.margin;\n      var noCellsVer = this.height + this.margin;\n\n      //Are we cutting off parts of the grid? Add half a cell of draw size\n      for (var side in this.cutoff) {\n        if (this.cutoff[side]) {\n          if (side === 'top' || side === 'bottom') {\n            noCellsVer += 0.5;\n          }\n          else {\n            noCellsHor += 0.5;\n          }\n        }\n      }\n\n      //Determine cell size now\n      this.cellSize = Math.floor(Math.min(\n        this.drawWidth / noCellsHor,\n        this.drawHeight / noCellsVer\n      ));\n\n      //Determine actual grid draw size (taking off the margin again)\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\n\n      //Determine draw margins\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\n\n      //Redraw\n      this.redraw();\n    };\n\n    /**\n     * Get the current cell size\n     */\n    Board.prototype.getCellSize = function() {\n      return this.cellSize;\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsX = function(gridX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsY = function(gridY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridX = function(absX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridY = function(absY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\n    };\n\n    /**\n     * Check if given grid coordinates are on board\n     */\n    Board.prototype.isOnBoard = function(gridX, gridY) {\n      return (\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\n      );\n    };\n\n    //Return object\n    return Board;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\n * a small rectangular area on the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('DefaultClearHandler', function() {\n\n  /**\n   * Clear handler definition\n   *\n   * All external handlers are called from the context of the layer that contains the object.\n   * First parameter is the canvas2d context, second parameter is the object itself.\n   */\n  return function(context, obj) {\n\n    //No context?\n    if (!context) {\n      return;\n    }\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(obj.x);\n    var y = this.board.getAbsY(obj.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Clear rectangle the size of the stone radius\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\n * stone color values for the game position class. It has built in validation of coordinates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Grid.Service', [\n  'ngGo',\n  'ngGo.Board.GridChanges.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGrid', ['BoardGridChanges', function(BoardGridChanges) {\n\n  /**\n   * Helper to convert a value at given coordinates to an object\n   */\n  var toObject = function(x, y, valueKey) {\n\n    //Create coordinates object\n    var obj = {\n      x: x,\n      y: y\n    };\n\n    //Already an object?\n    if (typeof this.grid[x][y] === 'object') {\n      return angular.extend(obj, this.grid[x][y]);\n    }\n\n    //Not an object, set value with given value key and return\n    obj[valueKey] = this.grid[x][y];\n    return obj;\n  };\n\n  /**\n   * Constructor\n   */\n  var BoardGrid = function(width, height, emptyValue) {\n\n    //Initialize size and grid array\n    this.width = 0;\n    this.height = 0;\n    this.grid = [];\n    this.emptyValue = null;\n\n    //Set empty value if given\n    if (typeof emptyValue !== 'undefined') {\n      this.emptyValue = emptyValue;\n    }\n\n    //Size given? Set it\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set a value\n   */\n  BoardGrid.prototype.set = function(x, y, value) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = value;\n    }\n  };\n\n  /**\n   * Unset a value\n   */\n  BoardGrid.prototype.unset = function(x, y) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = this.emptyValue;\n    }\n  };\n\n  /**\n   * Check if we have a non null value on the coordinates\n   */\n  BoardGrid.prototype.has = function(x, y) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\n  };\n\n  /**\n   * Check if we have a specific value on the coordinates\n   */\n  BoardGrid.prototype.is = function(x, y, value) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\n  };\n\n  /**\n   * Get a value, or an object with coordinates and the value in the given value key\n   */\n  BoardGrid.prototype.get = function(x, y, valueKey) {\n\n    //Validate\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\n      return this.emptyValue;\n    }\n\n    //Return as is?\n    if (!valueKey) {\n      return this.grid[x][y];\n    }\n\n    //Return as object\n    return toObject.call(this, x, y, valueKey);\n  };\n\n  /*****************************************************************************\n   * Mass operations\n   ***/\n\n  /**\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\n   * and the value in the given value key will be returned.\n   */\n  BoardGrid.prototype.all = function(valueKey) {\n\n    //Just get the grid?\n    if (!valueKey) {\n      return this.grid;\n    }\n\n    //Initialize objects list\n    var objects = [];\n\n    //Loop coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          objects.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return objects list\n    return objects;\n  };\n\n  /**\n   * Check if there is anything\n   */\n  BoardGrid.prototype.isEmpty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Populate the whole grid with a given value\n   */\n  BoardGrid.prototype.populate = function(value) {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = value;\n      }\n    }\n  };\n\n  /**\n   * Empty the grid\n   */\n  BoardGrid.prototype.empty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Clone ourselves\n   */\n  BoardGrid.prototype.clone = function() {\n\n    //Create new instance\n    var newGrid = new BoardGrid();\n\n    //Manually set vars for maximum efficiency\n    newGrid.grid = angular.copy(this.grid);\n    newGrid.emptyValue = this.emptyValue;\n    newGrid.width = this.width;\n    newGrid.height = this.height;\n\n    //Return\n    return newGrid;\n  };\n\n  /*****************************************************************************\n   * Comparison\n   ***/\n\n  /**\n   * Checks if a given grid is the same as the current grid\n   */\n  BoardGrid.prototype.isSameAs = function(grid) {\n\n    //Must have the same size\n    if (this.width !== grid.width || this.height !== grid.height) {\n      return false;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== grid[x][y]) {\n          return false;\n        }\n      }\n    }\n\n    //No differences found\n    return true;\n  };\n\n  /**\n   * Compares this position with another position and return change object\n   */\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\n\n    //Initialize board grid changes object\n    var changes = new BoardGridChanges();\n\n    //Must have the same size\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\n      console.warn('Trying to compare grids of a different size');\n      return changes;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n\n        //Something to add?\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\n        }\n\n        //Something to remove?\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.remove.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return changes grid\n    return changes;\n  };\n\n  /*****************************************************************************\n   * Helpers\n   ***/\n\n  /**\n   * Helper to validate coordinates (first param can be an object)\n   */\n  BoardGrid.prototype.isOnGrid = function(x, y) {\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\n  };\n\n  /**\n   * Helper to set the empty value\n   */\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\n    this.emptyValue = emptyValue;\n  };\n\n  /**\n   * Set the grid size\n   */\n  BoardGrid.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Create grid array\n    this.grid = [];\n    for (var x = 0; x < this.width; x++) {\n      this.grid[x] = [];\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Get the grid size object\n   */\n  BoardGrid.prototype.getSize = function() {\n    return {width: this.width, height: this.height};\n  };\n\n  //Return\n  return BoardGrid;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\n * grids. It simply keeps track of what was added and what was removed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.GridChanges.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGridChanges', function() {\n\n  /**\n   * Helper to subtract sets\n   */\n  var setSubtract = function(a, b) {\n    var n = [];\n    var q;\n    for (var i = 0; i < a.length; i++) {\n      q = true;\n      for (var j in b) {\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\n          q = false;\n          break;\n        }\n      }\n      if (q) {\n        n.push(a[i]);\n      }\n    }\n    return n;\n  };\n\n  /**\n   * Game position constructor\n   */\n  return function() {\n\n    /**\n     * Containers\n     */\n    this.add = [];\n    this.remove = [];\n\n    /**\n     * Concatenation helper\n     */\n    this.concat = function(newChanges) {\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\n    };\n\n    /**\n     * Check if there are changes\n     */\n    this.has = function() {\n      return !!(this.add.length || this.remove.length);\n    };\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\n * for drawing itself as well as its objects onto the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardLayer', ['BoardGrid', function(BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var BoardLayer = function(board, context) {\n\n    //Remember board reference and 2d canvas context\n    this.board = board;\n    this.context = context;\n\n    //Initialize grid for board objects\n    this.grid = new BoardGrid();\n  };\n\n  /*****************************************************************************\n   * Generic grid and object handling\n   ***/\n\n  /**\n   * Set grid size\n   */\n  BoardLayer.prototype.setSize = function(width, height) {\n\n    //Note: since this method is usually only called upon a global board resize,\n    //which also triggers the redraw method for layers, the layer is not cleared\n    //here, as it will happen anyway during the redraw cycle.\n\n    //Set it in the grid (removing all objects in the process)\n    this.grid.setSize(width, height);\n  };\n\n  /**\n   * Get all items\n   */\n  BoardLayer.prototype.getAll = function() {\n    return this.grid.clone();\n  };\n\n  /**\n   * Set all items at once\n   */\n  BoardLayer.prototype.setAll = function(grid) {\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  BoardLayer.prototype.removeAll = function() {\n    this.clear();\n    this.grid.empty();\n  };\n\n  /**\n   * Add a single item\n   */\n  BoardLayer.prototype.add = function(x, y, value) {\n    this.clearCell(x, y);\n    this.grid.set(x, y, value);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Remove a single item\n   */\n  BoardLayer.prototype.remove = function(x, y) {\n    this.clearCell(x, y);\n    this.grid.unset(x, y);\n  };\n\n  /**\n   * Get an item\n   */\n  BoardLayer.prototype.get = function(x, y) {\n    return this.grid.get(x, y);\n  };\n\n  /**\n   * Check if there is an item\n   */\n  BoardLayer.prototype.has = function(x, y) {\n    return this.grid.has(x, y);\n  };\n\n  /*****************************************************************************\n   * Generic drawing methods\n   ***/\n\n  /**\n   * Draw layer\n   */\n  BoardLayer.prototype.draw = function() {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\n   */\n  BoardLayer.prototype.clear = function() {\n    if (this.context) {\n      this.context.clearRect(\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\n      );\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  BoardLayer.prototype.redraw = function() {\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear cell\n   */\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\n    //Clearing method to be implemented in specific layer class\n  };\n\n  /**\n   * Redraw cell\n   */\n  BoardLayer.prototype.redrawCell = function(x, y) {\n    this.clearCell(x, y);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Set the canvas2d context\n   */\n  BoardLayer.prototype.setContext = function(context) {\n    this.context = context;\n  };\n\n  /**\n   * Get the canvas2d context\n   */\n  BoardLayer.prototype.getContext = function() {\n    return this.context;\n  };\n\n  //Return\n  return BoardLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardObject :: Base class for drawing board objects\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Service', [\n  'ngGo',\n  'ngGo.Board.DefaultClearHandler.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardObject', ['DefaultClearHandler', function(DefaultClearHandler) {\n\n  /**\n   * Constructor\n   */\n  var BoardObject = {\n\n    /**\n     * Draw method\n     */\n    draw: function(/*obj*/) {\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n    },\n\n    /**\n     * Clear method\n     */\n    clear: function(obj) {\n      DefaultClearHandler.call(this, this.context, obj);\n    }\n  };\n\n  //Return\n  return BoardObject;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.ShellPattern.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('ShellPattern', function() {\n\n  /**\n   * Helper to draw a shell line\n   */\n  var shellLine = function(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\n\n    //Initialize\n    ctx.shadowBlur = 2;\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = (radius / 30) * this.thickness;\n    ctx.beginPath();\n\n    //Lower radius\n    radius -= Math.max(1, ctx.lineWidth);\n\n    //Determine coordinates\n    var x1 = x + radius * Math.cos(startAngle * Math.PI);\n    var y1 = y + radius * Math.sin(startAngle * Math.PI);\n    var x2 = x + radius * Math.cos(endAngle * Math.PI);\n    var y2 = y + radius * Math.sin(endAngle * Math.PI);\n\n    //Math magic\n    var m, angle;\n    if (x2 > x1) {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m);\n    }\n    else if (x2 === x1) {\n      angle = Math.PI / 2;\n    }\n    else {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m) - Math.PI;\n    }\n\n    //Curvature factor\n    var c = this.factor * radius;\n    var dx = Math.sin(angle) * c;\n    var dy = Math.cos(angle) * c;\n\n    //Curvature coordinates\n    var bx1 = x1 + dx;\n    var by1 = y1 - dy;\n    var bx2 = x2 + dx;\n    var by2 = y2 - dy;\n\n    //Draw shell stroke\n    ctx.moveTo(x1, y1);\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\n    ctx.stroke();\n  };\n\n  /**\n   * Shell pattern drawer\n   */\n  return function(ctx, x, y, radius, angle, strokeStyle) {\n\n    //Initialize start and end angle\n    var startAngle = angle;\n    var endAngle = angle;\n\n    //Loop lines\n    for (var i = 0; i < this.lines.length; i++) {\n      startAngle += this.lines[i];\n      endAngle -= this.lines[i];\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\n    }\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\n * use static values or dynamic values depending on other properties, like the grid cell size.\n * Using the provider, the theme can be configured globally at application launch.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Theme.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.provider('BoardTheme', ['StoneColor', 'MarkupTypes', function(StoneColor, MarkupTypes) {\n\n  /**\n   * Default theme\n   */\n  var defaultTheme = {\n\n    //Board\n    board: {\n\n      //Board margin factor\n      margin: 0.25\n    },\n\n    //Stones\n    stone: {\n\n      //Stone style can be shell, glass, mono, or specify a custom handler service\n      style: 'shell',\n      shadow: true,\n      radius: function(cellSize) {\n        return Math.floor(cellSize / 2);\n      },\n\n      //Shell stones\n      shell: {\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#111';\n          }\n          return '#BFBFBA';\n        },\n        stroke: 'rgba(128,128,128,0.15)',\n        types: [\n          {\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\n            factor: 0.15,\n            thickness: 1.75\n          },\n          {\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\n            factor: 0.1,\n            thickness: 1.5\n          },\n          {\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\n            factor: 0.05,\n            thickness: 1.75\n          },\n          {\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\n            factor: 0.1,\n            thickness: 2\n          }\n        ]\n      },\n\n      //Mono stones\n      mono: {\n        lineWidth: 1,\n        lineColor: function() {\n          return '#000';\n        },\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#000';\n          }\n          return '#fff';\n        }\n      },\n\n      //Mini stones\n      mini: {\n        scale: 0.5,\n        alpha: 1\n      },\n\n      //Faded stones\n      faded: {\n        scale: 1,\n        alpha: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return 0.3;\n          }\n          return 0.4;\n        }\n      }\n    },\n\n    //Shadows\n    shadow: {\n\n      //Shadow gradient colors\n      color: 'rgba(40,30,20,0.5)',\n\n      //Shadow size\n      size: function(cellSize) {\n        return Math.floor(cellSize / 20);\n      },\n\n      //Shadow blur size\n      blur: function(cellSize) {\n        return cellSize / 20;\n      },\n\n      //Shadow offset\n      offsetX: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      },\n      offsetY: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      }\n    },\n\n    //Markup\n    markup: {\n\n      //Standard color\n      color: function(stoneColor) {\n        if (stoneColor === StoneColor.B) {\n          return 'rgba(255,255,255,0.9)';\n        }\n        return 'rgba(0,0,0,0.9)';\n      },\n\n      //Line width\n      lineWidth: function(cellSize) {\n        return Math.max(1, Math.floor(cellSize / 16));\n      },\n\n      //Triangle\n      triangle: {\n        scale: 0.85\n      },\n\n      //Square\n      square: {\n        scale: 0.85\n      },\n\n      //Cricle\n      circle: {\n        scale: 0.55\n      },\n\n      //Mark\n      mark: {\n        lineCap: 'square',\n        scale: 0.75\n      },\n\n      //Last\n      last: {\n        scale: 0.7\n      },\n\n      //Smiley\n      smiley: {\n        lineCap: 'round',\n        scale: 0.85\n      },\n\n      //Label\n      label: {\n        font: 'Arial'\n      },\n\n      //Variation markup\n      variation: {\n        type: MarkupTypes.LABEL,\n        text: function(i) {\n          return String.fromCharCode(65 + i);\n        },\n        color: 'rgba(86,114,30,0.9)'\n      },\n\n      //Solution paths markup\n      solution: {\n        valid: {\n          type: MarkupTypes.SELECT,\n          text: null,\n          color: 'rgba(86,114,30,1)',\n          scale: 0.5\n        },\n        invalid: {\n          type: MarkupTypes.MARK,\n          text: null,\n          color: 'rgba(237,9,15,1)',\n          scale: 0.3\n        }\n      }\n    },\n\n    //Grid\n    grid: {\n\n      //Line properties\n      lineColor: 'rgba(60,40,15,1)',\n      lineWidth: function(cellSize) {\n        if (cellSize > 60) {\n          return 2;\n        }\n        else if (cellSize > 50) {\n          return 1.5;\n        }\n        return 1;\n      },\n      lineCap: 'square',\n\n      //Star points\n      star: {\n\n        //Color and radius\n        color: 'rgba(60,40,15,1)',\n        radius: function(cellSize) {\n          if (cellSize > 50) {\n            return Math.floor((cellSize / 16) + 1);\n          }\n          else if (cellSize > 30) {\n            return 3;\n          }\n          else if (cellSize > 15) {\n            return 2;\n          }\n          else if (cellSize > 5) {\n            return 1.5;\n          }\n          return 1;\n        },\n\n        //Locations\n        points: function(width, height) {\n\n          //19x19\n          if (width === height && width === 19) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15,y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15,y: 9 },\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15,y: 15 }\n            ];\n          }\n\n          //13x13\n          if (width === height && width === 13) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }\n            ];\n          }\n\n          //9x9\n          if (width === height && width === 9) {\n            return [\n              { x: 4, y: 4}, { x: 2, y: 2},\n              { x: 2, y: 6}, { x: 6, y: 2},\n              { x: 6, y: 6}\n            ];\n          }\n\n          //No star points\n          return [];\n        }\n      }\n    },\n\n    //Coordinates\n    coordinates: {\n\n      //Color\n      color: 'rgba(101,69,37,0.5)',\n\n      //Board margin factor when showing coordinates\n      margin: 1.25,\n\n      //Vertical coordinates style\n      vertical: {\n        font: 'Arial',\n        style: 'numbers',\n        inverse: true,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      },\n\n      //Horizontal coordinates style\n      horizontal: {\n        font: 'Arial',\n        style: 'letters',\n        inverse: false,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      }\n    }\n  };\n\n  /**\n   * Set global default theme\n   */\n  this.setTheme = function(theme) {\n    if (theme) {\n      defaultTheme = angular.merge(defaultTheme, theme);\n    }\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function() {\n\n    /**\n     * Board theme constructor\n     */\n    var BoardTheme = function(theme) {\n\n      //Remember the given instance theme settings and (re)set the theme\n      this.instanceTheme = theme;\n      this.reset();\n    };\n\n    /**\n     * Reset the theme to defaults\n     */\n    BoardTheme.prototype.reset = function() {\n\n      //Use default theme as a base\n      this.theme = angular.copy(defaultTheme);\n\n      //Add any instance theme properties\n      if (this.instanceTheme) {\n        angular.merge(this.theme, this.instanceTheme);\n      }\n    };\n\n    /**\n     * Get a theme property\n     */\n    BoardTheme.prototype.get = function(property) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Can't find the property?\n        if (typeof prop[path[i]] === 'undefined') {\n          console.warn('Could not find theme property', property);\n          return null;\n        }\n\n        //Advance further in the object\n        prop = prop[path[i]];\n      }\n\n      //Found what we're looking for\n      if (typeof prop !== 'function') {\n        return prop;\n      }\n\n      //Prepare arguments\n      var args = [];\n      if (arguments.length > 1) {\n        for (var a = 1; a < arguments.length; a++) {\n          args.push(arguments[a]);\n        }\n      }\n\n      //Call function\n      return prop.apply(this, args);\n    };\n\n    /**\n     * Change a theme property dynamically (accepts handler function as value)\n     */\n    BoardTheme.prototype.set = function(property, value) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Time to set?\n        if ((i + 1) === path.length) {\n          prop[path[i]] = value;\n          break;\n        }\n\n        //Not set?\n        if (typeof prop[path[i]] === 'undefined') {\n          prop[path[i]] = {};\n        }\n\n        //Move on\n        prop = prop[path[i]];\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\n     */\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\n\n      //If no linewidth specified, use the grid line width as a reference\n      //to make sure stuff is aligned to the grid\n      if (typeof lineWidth === 'undefined') {\n        lineWidth = this.get('grid.lineWidth');\n      }\n\n      //Return a translation for uneven widths\n      return (lineWidth % 2) * 0.5;\n    };\n\n    //Return\n    return BoardTheme;\n  };\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidDataError :: Error class to handle invalid data.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidDataError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidDataError', ['ngGo', function(ngGo) {\n\n  /**\n   * Define error\n   */\n  var InvalidDataError = function(code) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidDataError';\n    this.message = 'Invalid data: ';\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.NO_DATA:\n        this.message += 'no data to process.';\n        break;\n      case ngGo.error.UNKNOWN_DATA:\n        this.message += 'unknown data format.';\n        break;\n      case ngGo.error.INVALID_GIB:\n        this.message += 'unable to parse GIB data.';\n        break;\n      case ngGo.error.INVALID_SGF:\n        this.message += 'unable to parse SGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_JSON:\n        this.message += 'unable to parse JGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_TREE_JSON:\n        this.message += 'unable to parse the JGF tree data.';\n        break;\n      default:\n        this.message += 'unable to parse the data.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidDataError.prototype = new Error();\n  InvalidDataError.prototype.constructor = InvalidDataError;\n\n  //Return object\n  return InvalidDataError;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidPositionError :: Error class to handle invalid moves.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidPositionError', ['ngGo', 'StoneColor', function(ngGo, StoneColor) {\n\n  /**\n   * Define error\n   */\n  var InvalidPositionError = function(code, x, y, color) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidPositionError';\n    this.message = 'Invalid position detected.';\n\n    //Add position data\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\n        ' stone on (' + x + ', ' + y + ')';\n    }\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\n        this.message += ', but these coordinates are not on the board.';\n        break;\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\n        this.message += ', but there is already a stone on those coordinates.';\n        break;\n      case ngGo.error.POSTITION_IS_SUICIDE:\n        this.message += ', but that would be suicide.';\n        break;\n      case ngGo.error.POSTITION_IS_REPEATING:\n        this.message += ', but this position already occured.';\n        break;\n      default:\n        this.message += '.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidPositionError.prototype = new Error();\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\n\n  //Return object\n  return InvalidPositionError;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Game :: This class represents a game record or a game that is being played/edited. The class\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\n * The class also keeps a stack of all board positions in memory and can validate moves to make\n * sure they are not repeating or suicide.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Service', [\n  'ngGo',\n  'ngGo.Game.Path.Service',\n  'ngGo.Game.Node.Service',\n  'ngGo.Game.Position.Service',\n  'ngGo.Kifu.Blank.Service',\n  'ngGo.Kifu.Parser.Service',\n  'ngGo.Errors.InvalidDataError.Service',\n  'ngGo.Errors.InvalidPositionError.Service'\n])\n\n/**\n * Factory definition\n */\n.provider('Game', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default size of board\n    defaultSize: 0,\n\n    //Default komi and handicap\n    defaultKomi: 0,\n    defaultHandicap: 0,\n\n    //Remember last selected variation when traversing nodes\n    rememberPath: true,\n\n    //Check for repeating positions? (KO / ALL / empty)\n    checkRepeat: 'KO',\n\n    //Allow suicide?\n    allowSuicide: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['ngGo', 'StoneColor', 'GamePath', 'GameNode', 'GamePosition', 'KifuParser', 'KifuBlank', 'InvalidDataError', 'InvalidPositionError', function(\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\n    KifuBlank, InvalidDataError, InvalidPositionError\n  ) {\n\n    /*****************************************************************************\n     * General helpers\n     ***/\n\n    /**\n     * Validate the info we have to make sure the properties exist\n     */\n    var validateInfo = function() {\n\n      //Set board info if not set\n      if (!this.info.board) {\n        this.info.board = {};\n      }\n\n      //Set game info if not set\n      if (!this.info.game) {\n        this.info.game = {};\n      }\n\n      //Set defaults\n      if (typeof this.info.board.width === 'undefined') {\n        this.info.board.width = this.config.defaultSize;\n      }\n      if (typeof this.info.board.height === 'undefined') {\n        this.info.board.height = this.config.defaultSize;\n      }\n      if (typeof this.info.game.komi === 'undefined') {\n        this.info.game.komi = this.config.defaultKomi;\n      }\n      if (typeof this.info.game.handicap === 'undefined') {\n        this.info.game.handicap = this.config.defaultHandicap;\n      }\n    };\n\n    /*****************************************************************************\n     * Node navigation helpers\n     ***/\n\n    /**\n     * Navigate to the next node\n     */\n    var nextNode = function(i) {\n\n      //Check if we have children\n      if (this.node.children.length === 0) {\n        return false;\n      }\n\n      //Remembered the path we took earlier?\n      if (i === undefined) {\n        i = this.node.rememberedPath;\n      }\n\n      //Determine which child node to process\n      i = i || 0;\n      if (i === -1) {\n        i = 0;\n      }\n\n      //Validate\n      if (i >= this.node.children.length || !this.node.children[i]) {\n        return false;\n      }\n\n      //Advance path\n      this.path.advance(i);\n\n      //Set pointer of current node\n      this.node = this.node.children[i];\n      return true;\n    };\n\n    /**\n     * Navigate to the previous node\n     */\n    var previousNode = function() {\n\n      //No parent node?\n      if (!this.node.parent) {\n        return false;\n      }\n\n      //Retreat path\n      this.path.retreat();\n\n      //Set pointer of current node\n      this.node = this.node.parent;\n      return true;\n    };\n\n    /**\n     * Navigate to the first node\n     */\n    var firstNode = function() {\n\n      //Reset path\n      this.path.reset();\n\n      //Set node pointer back to root\n      this.node = this.root;\n\n      //Set the initial turn depending on handicap\n      //Can be overwritten by game record instructions\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\n    };\n\n    /*****************************************************************************\n     * Position history helpers\n     ***/\n\n    /**\n     * Clear the position history and initialize with a blank position\n     */\n    var initializeHistory = function() {\n\n      //Already at beginning?\n      if (this.history.length === 1) {\n        return;\n      }\n\n      //Clear positions stack and create new blank position\n      this.history = [];\n      this.history.push(new GamePosition());\n\n      //Set board size if we have the info\n      if (this.info.board) {\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\n      }\n    };\n\n    /**\n     * Add position to stack. If position isn't specified current position is\n     * cloned and stacked. Pointer of actual position is moved to the new position.\n     */\n    var pushPosition = function(newPosition) {\n\n      //Position not given?\n      if (!newPosition) {\n        newPosition = this.position.clone();\n      }\n\n      //Push\n      this.history.push(newPosition);\n      return newPosition;\n    };\n\n    /**\n     * Remove current position from stack\n     */\n    var popPosition = function() {\n\n      //Nothing left?\n      if (this.history.length === 0) {\n        return null;\n      }\n\n      //Get old position\n      return this.history.pop();\n    };\n\n    /**\n     * Replace the current position in the stack\n     */\n    var replacePosition = function(newPosition) {\n      if (newPosition) {\n        this.history.pop();\n        this.history.push(newPosition);\n      }\n    };\n\n    /*****************************************************************************\n     * Execution helpers\n     ***/\n\n    /**\n     * Execute the current node\n     */\n    var executeNode = function() {\n\n      //Remember last selected node if we have a parent\n      if (this.node.parent) {\n        this.node.parent.rememberedPath = this.node.parent.children.indexOf(this.node);\n      }\n\n      //Initialize new position\n      var i;\n      var newPosition = this.position.clone();\n\n      //Handle moves\n      if (this.node.isMove()) {\n        if (this.node.move.pass) {\n          newPosition.setTurn(-this.node.move.color);\n        }\n        else {\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\n        }\n      }\n\n      //Handle turn instructions\n      if (this.node.turn) {\n        newPosition.setTurn(this.node.turn);\n      }\n\n      //Handle setup instructions\n      if (this.node.setup) {\n        for (i in this.node.setup) {\n          if (this.node.setup.hasOwnProperty(i)) {\n            newPosition.stones.set(\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\n            );\n          }\n        }\n      }\n\n      //Handle markup\n      if (this.node.markup) {\n        for (i in this.node.markup) {\n          if (this.node.markup.hasOwnProperty(i)) {\n            newPosition.markup.set(\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\n            );\n          }\n        }\n      }\n\n      //Push the new position into the history now\n      pushPosition.call(this, newPosition);\n    };\n\n    /*****************************************************************************\n     * Game class\n     ***/\n\n    /**\n     * Constructor\n     */\n    var Game = function(data, config) {\n\n      //Extend config\n      this.config = angular.extend({}, defaultConfig, config || {});\n\n      //Define property getter/setter for position\n      Object.defineProperty(this, 'position', {\n\n        //Getter returns the last position from the stack\n        get: function() {\n          return this.history[this.history.length - 1];\n        },\n\n        //Setter adds a new position to the stack\n        set: function(newPosition) {\n          this.history[this.history.length] = newPosition;\n        }\n      });\n\n      //Load data\n      if (data) {\n        this.load(data);\n      }\n      else {\n        this.init();\n      }\n    };\n\n    /**\n     * Initialize\n     */\n    Game.prototype.init = function() {\n\n      //Info properties\n      this.info = {};\n\n      //The rood node and pointer to the current node\n      this.root = null;\n      this.node = null;\n\n      //Game path\n      this.path = new GamePath();\n\n      //JGF record we loaded from\n      this.jgf = null;\n\n      //Positions history stack\n      this.history = [];\n    };\n\n    /**\n     * Load game record data\n     */\n    Game.prototype.load = function(data) {\n\n      //Initialize\n      this.init();\n\n      //Try to load game record data\n      try {\n        this.fromData(data);\n      }\n      catch (errorCode) {\n\n        //Just initialize our history with a blank position\n        initializeHistory.call(this);\n\n        //Wrap error code in error object\n        throw new InvalidDataError(errorCode);\n      }\n\n      //Go to the first move\n      this.first();\n    };\n\n    /**\n     * Reload game record\n     */\n    Game.prototype.reload = function() {\n      if (this.jgf) {\n        this.load(this.jgf);\n      }\n    };\n\n    /**\n     * Check if we managed to load a valid game record\n     */\n    Game.prototype.isLoaded = function() {\n      return this.root !== null;\n    };\n\n    /*****************************************************************************\n     * Game cloning and conversion\n     ***/\n\n    /**\n     * Clone this game\n     */\n    Game.prototype.clone = function() {\n\n      //Create new kifu object and get properties\n      var clone = new Game();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy all properties\n      for (var p = 0; p < props.length; p++) {\n        clone[p] = angular.copy(this[p]);\n      }\n\n      //Return clone\n      return clone;\n    };\n\n    /**\n     * Load from an unknown data source\n     */\n    Game.prototype.fromData = function(data) {\n\n      //No data, can't do much\n      if (!data) {\n        throw ngGo.error.NO_DATA;\n      }\n\n      //String given, could be stringified JGF, an SGF or GIB file\n      if (typeof data === 'string') {\n        var c = data.charAt(0);\n        if (c === '(') {\n          return this.fromSgf(data);\n        }\n        else if (c === '{' || c === '[') {\n          return this.fromJgf(data);\n        }\n        else if (c === '\\\\') {\n          return this.fromGib(data);\n        }\n        else {\n          throw ngGo.error.UNKNOWN_DATA;\n        }\n      }\n\n      //Object given? Probably a JGF object\n      else if (typeof data === 'object') {\n        this.fromJgf(data);\n      }\n\n      //Something else?\n      else {\n        throw ngGo.error.UNKNOWN_DATA;\n      }\n    };\n\n    /**\n     * Load from GIB data\n     */\n    Game.prototype.fromGib = function(gib) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.gib2jgf(gib);\n      if (!jgf) {\n        throw ngGo.error.INVALID_GIB;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from SGF data\n     */\n    Game.prototype.fromSgf = function(sgf) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.sgf2jgf(sgf);\n      if (!jgf) {\n        throw ngGo.error.INVALID_SGF;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from JGF data\n     */\n    Game.prototype.fromJgf = function(jgf) {\n\n      //Parse jgf string\n      if (typeof jgf === 'string') {\n        try {\n          jgf = angular.fromJson(jgf);\n        }\n        catch (error) {\n          throw ngGo.error.INVALID_JGF_JSON;\n        }\n      }\n\n      //If array given, convert to object with only tree\n      if (angular.isArray(jgf)) {\n        jgf = {\n          tree: jgf\n        };\n      }\n\n      //Parse tree string\n      if (typeof jgf.tree === 'string') {\n        if (jgf.tree.charAt(0) === '[') {\n          try {\n            jgf.tree = angular.fromJson(jgf.tree);\n          }\n          catch (error) {\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\n          }\n        }\n        else {\n          jgf.tree = [];\n        }\n      }\n\n      //Copy all properties except moves tree\n      for (var i in jgf) {\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\n          this.info[i] = angular.copy(jgf[i]);\n        }\n      }\n\n      //Validate info\n      validateInfo.call(this);\n\n      //Create root node\n      this.root = new GameNode();\n\n      //Tree given? Load all the moves\n      if (jgf.tree) {\n        this.root.fromJgf(jgf.tree);\n      }\n\n      //Remember JGF\n      this.jgf = jgf;\n    };\n\n    /**\n     * Convert to SGF\n     */\n    Game.prototype.toSgf = function() {\n      return KifuParser.jgf2sgf(this.toJgf());\n    };\n\n    /**\n     * Convert to JGF (optionally stringified)\n     */\n    Game.prototype.toJgf = function(stringify) {\n\n      //Initialize JGF and get properties\n      var jgf = KifuBlank.jgf();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy properties\n      for (var p = 0; p < props.length; p++) {\n\n        //Skip root\n        if (p === 'root') {\n          continue;\n        }\n\n        //Already present on JGF object? Extend\n        if (jgf[p]) {\n          jgf[p] = angular.extend(jgf[p], this[p]);\n        }\n\n        //Otherwise copy\n        else {\n          jgf[p] = angular.copy(this[p]);\n        }\n      }\n\n      //Build tree\n      jgf.tree = this.root.toJgf();\n\n      //Return\n      return stringify ? angular.toJson(jgf) : jgf;\n    };\n\n    /*****************************************************************************\n     * Getters\n     ***/\n\n    /**\n     * Get current node\n     */\n    Game.prototype.getNode = function() {\n      return this.node;\n    };\n\n    /**\n     * Get nodes array for currently remembered path\n     */\n    Game.prototype.getNodes = function() {\n\n      //Initialize node to process\n      var node = this.root;\n      var nodes = [node];\n\n      //Process children\n      while (node) {\n        node = node.getChild(node.rememberedPath);\n        if (node) {\n          nodes.push(node);\n        }\n      }\n\n      //Return nodes\n      return nodes;\n    };\n\n    /**\n     * Get node for a certain move\n     */\n    Game.prototype.getMoveNode = function(move) {\n      var nodes = this.getMoveNodes(move, move);\n      return nodes.length ? nodes[0] : null;\n    };\n\n    /**\n     * Get move nodes restricted by given move numbers\n     */\n    Game.prototype.getMoveNodes = function(fromMove, toMove) {\n\n      //Get all nodes for the current path\n      var nodes = this.getNodes();\n\n      //Use sensible defaults if no from/to moves given\n      fromMove = fromMove || 1;\n      toMove = toMove || nodes.length;\n\n      //Filter\n      return nodes.filter(function(node) {\n        if (node.isMove()) {\n          var move = node.getMoveNumber();\n          return (move >= fromMove && move <= toMove);\n        }\n        return false;\n      });\n    };\n\n    /**\n     * Get current move number\n     */\n    Game.prototype.getMove = function() {\n      if (this.node) {\n        return this.node.getMoveNumber();\n      }\n      return 0;\n    };\n\n    /**\n     * Get the number of moves in the main branch\n     */\n    Game.prototype.getMoveCount = function() {\n      var moveNodes = this.getMoveNodes();\n      return moveNodes.length;\n    };\n\n    /**\n     * Get the move variation for given coordinates\n     */\n    Game.prototype.getMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.getMoveVariation(x, y);\n      }\n      return -1;\n    };\n\n    /**\n     * Get the current game position\n     */\n    Game.prototype.getPosition = function() {\n      return this.position;\n    };\n\n    /**\n     * Get the game path\n     */\n    Game.prototype.getPath = function(clone) {\n      if (clone) {\n        return this.path.clone();\n      }\n      return this.path;\n    };\n\n    /**\n     * Clone the current game path\n     */\n    Game.prototype.clonePath = function() {\n      return this.path.clone();\n    };\n\n    /**\n     * Get the game path to a certain named node\n     */\n    Game.prototype.getPathToNode = function(nodeName) {\n      return GamePath.findNode(nodeName, this.root);\n    };\n\n    /**\n     * Get the game komi\n     */\n    Game.prototype.getKomi = function() {\n      var komi = this.get('game.komi', 0);\n      return parseFloat(komi);\n    };\n\n    /**\n     * Set the game komi\n     */\n    Game.prototype.setKomi = function(komi) {\n      if (typeof komi === 'undefined') {\n        komi = this.config.defaultKomi;\n      }\n      this.info.game.komi = parseFloat(komi);\n    };\n\n    /**\n     * Get the game name\n     */\n    Game.prototype.getName = function() {\n      return this.get('game.name', '');\n    };\n\n    /**\n     * Get the game result\n     */\n    Game.prototype.getResult = function() {\n      return this.get('game.result', '');\n    };\n\n    /**\n     * Get the player turn for this position\n     */\n    Game.prototype.getTurn = function() {\n\n      //Must have a position\n      if (!this.history.length) {\n        return StoneColor.B;\n      }\n\n      //Get from position\n      return this.position.getTurn();\n    };\n\n    /**\n     * Set the player turn for the current position\n     */\n    Game.prototype.setTurn = function(color) {\n\n      //Must have a position\n      if (!this.history.length) {\n        return;\n      }\n\n      //Set in position\n      this.position.setTurn(color);\n    };\n\n    /**\n     * Get the total capture count up to the current position\n     */\n    Game.prototype.getCaptureCount = function() {\n\n      //Initialize\n      var captures = {};\n      captures[StoneColor.B] = 0;\n      captures[StoneColor.W] = 0;\n\n      //Loop all positions and increment capture count\n      for (var i = 0; i < this.history.length; i++) {\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\n      }\n\n      //Return\n      return captures;\n    };\n\n    /**\n     * Get an info property\n     */\n    Game.prototype.get = function(property, defaultValue) {\n\n      //Must have a property\n      if (!property) {\n        return;\n      }\n\n      //The item's property in the object is given by dot separated strings\n      if (typeof property === 'string') {\n        property = property.split('.');\n      }\n\n      //Initialize object we're getting info from\n      var obj = this.info;\n      var key;\n\n      //Loop the properties\n      for (var p = 0; p < property.length; p++) {\n\n        //Get actual key\n        key = property[p];\n\n        //Last key reached? Done, get value\n        if ((p + 1) === property.length) {\n          if (typeof obj[key] === 'undefined') {\n            return defaultValue;\n          }\n          return obj[key];\n        }\n\n        //Must be object container\n        if (typeof obj[key] !== 'object') {\n          console.warn('Game info property', key, 'is not an object');\n          return defaultValue;\n        }\n\n        //Move up in tree\n        obj = obj[key];\n      }\n    };\n\n    /*****************************************************************************\n     * Checkers\n     ***/\n\n    /**\n     * Check if coordinates are on the board\n     */\n    Game.prototype.isOnBoard = function(x, y) {\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\n    };\n\n    /**\n     * Check if given coordinates are one of the next child node coordinates\n     */\n    Game.prototype.isMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.isMoveVariation(x, y);\n      }\n      return false;\n    };\n\n    /**\n     * Check if a given position is repeating within this game\n     */\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\n\n      //Init\n      var stop;\n\n      //Check for ko only? (Last two positions)\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\n        stop = this.history.length - 2;\n      }\n\n      //Check all history?\n      else if (this.checkRepeat === 'ALL') {\n        stop = 0;\n      }\n\n      //Not repeating\n      else {\n        return false;\n      }\n\n      //Loop history of positions to check\n      for (var i = this.history.length - 2; i >= stop; i--) {\n        if (checkPosition.isSameAs(this.history[i])) {\n          return true;\n        }\n      }\n\n      //Not repeating\n      return false;\n    };\n\n    /**\n     * Wrapper for validateMove() returning a boolean and catching any errors\n     */\n    Game.prototype.isValidMove = function(x, y, color) {\n      try {\n        this.validateMove(x, y, color);\n        return true;\n      }\n      catch (error) {\n        return false;\n      }\n    };\n\n    /**\n     * Check if a move is valid. If valid, the new game position object is returned.\n     * You can supply a pre-created position to use, or the current position is cloned.\n     */\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Something already here?\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\n      }\n\n      //Set color of move to make\n      color = color || this.position.getTurn();\n\n      //Determine position to use\n      newPosition = newPosition || this.position.clone();\n\n      //Place the stone\n      newPosition.stones.set(x, y, color);\n\n      //Capture adjacent stones if possible\n      var captures = newPosition.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created?\n        if (!newPosition.hasLiberties(x, y)) {\n\n          //Capture the group if it's allowed\n          if (this.allowSuicide) {\n            newPosition.captureGroup(x, y);\n          }\n\n          //Invalid move\n          else {\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\n          }\n        }\n      }\n\n      //Check history for repeating moves\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\n      }\n\n      //Set proper turn\n      newPosition.setTurn(-color);\n\n      //Move is valid\n      return newPosition;\n    };\n\n    /**\n     * Check if a stone (setup) placement is valid.\n     */\n    Game.prototype.validatePlacement = function(x, y, color, position) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Place the stone\n      position.stones.set(x, y, color);\n\n      //Empty spot? Don't need to check for captures\n      if (color === StoneColor.EMPTY) {\n        return;\n      }\n\n      //Capture adjacent stones if possible\n      var captures = position.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created? Capture it\n        if (!position.hasLiberties(x, y)) {\n          position.captureGroup(x, y);\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Stone and markup handling\n     ***/\n\n    /**\n     * Add a stone\n     */\n    Game.prototype.addStone = function(x, y, color) {\n\n      //Check if there's anything to do at all\n      if (this.position.stones.is(x, y, color)) {\n        return;\n      }\n\n      //Create temporary position\n      var tempPosition = this.position.clone();\n\n      //Validate placement on temp position\n      this.validatePlacement(x, y, color, tempPosition);\n\n      //No setup instructions container in this node?\n      if (typeof this.node.setup === 'undefined') {\n\n        //Is this a move node?\n        if (this.node.isMove()) {\n\n          //Clone our position\n          pushPosition.call(this);\n\n          //Create new node\n          var node = new GameNode();\n\n          //Append it to the current node and change the pointer\n          var i = node.appendTo(this.node);\n          this.node = node;\n\n          //Advance path to the added node index\n          this.path.advance(i);\n        }\n\n        //Create setup container in this node\n        this.node.setup = [];\n      }\n\n      //Replace current position\n      replacePosition.call(this, tempPosition);\n\n      //Add setup instructions to node\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\n    };\n\n    /**\n     * Add markup\n     */\n    Game.prototype.addMarkup = function(x, y, markup) {\n\n      //No markup instructions container in this node?\n      if (typeof this.node.markup === 'undefined') {\n        this.node.markup = [];\n      }\n\n      //Add markup to game position\n      this.position.markup.set(x, y, markup);\n\n      //Add markup instructions to node\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\n    };\n\n    /**\n     * Remove a stone\n     */\n    Game.prototype.removeStone = function(x, y) {\n\n      //Check if the stone is found in setup instructions\n      var foundInSetup = false;\n\n      //Remove from node setup instruction\n      if (typeof this.node.setup !== 'undefined') {\n        for (var i = 0; i < this.node.setup.length; i++) {\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\n\n            //Remove from node and unset in position\n            this.node.setup.splice(i, 1);\n            this.position.stones.unset(x, y);\n\n            //Mark as found\n            foundInSetup = true;\n            break;\n          }\n        }\n      }\n\n      //Not found in setup? Add as no stone color\n      if (!foundInSetup) {\n        this.addStone(x, y, StoneColor.EMPTY);\n      }\n    };\n\n    /**\n     * Remove markup\n     */\n    Game.prototype.removeMarkup = function(x, y) {\n\n      //Remove from node\n      if (typeof this.node.markup !== 'undefined') {\n        for (var i = 0; i < this.node.markup.length; i++) {\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\n            this.node.markup.splice(i, 1);\n            this.position.markup.unset(x, y);\n            break;\n          }\n        }\n      }\n    };\n\n    /**\n     * Check if there is a stone at the given coordinates for the current position\n     */\n    Game.prototype.hasStone = function(x, y, color) {\n      if (typeof color !== 'undefined') {\n        return this.position.stones.is(x, y, color);\n      }\n      return this.position.stones.has(x, y);\n    };\n\n    /**\n     * Check if there is markup at the given coordinate for the current position\n     */\n    Game.prototype.hasMarkup = function(x, y, type) {\n      if (typeof type !== 'undefined') {\n        return this.position.markup.is(x, y, type);\n      }\n      return this.position.markup.has(x, y);\n    };\n\n    /**\n     * Get stone on coordinates\n     */\n    Game.prototype.getStone = function(x, y) {\n      return this.position.stones.get(x, y);\n    };\n\n    /**\n     * Get markup on coordinates\n     */\n    Game.prototype.getMarkup = function(x, y) {\n      return this.position.markup.get(x, y);\n    };\n\n    /*****************************************************************************\n     * Move handling\n     ***/\n\n    /**\n     * Play move\n     */\n    Game.prototype.play = function(x, y, color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Validate move and get new position\n      var newPosition = this.validateMove(x, y, color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          x: x,\n          y: y,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node.rememberedPath = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n\n      //Valid move\n      return true;\n    };\n\n    /**\n     * Play pass\n     */\n    Game.prototype.pass = function(color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Initialize new position and switch the turn\n      var newPosition = this.position.clone();\n      newPosition.setTurn(-color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          pass: true,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node.rememberedPath = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n    };\n\n    /*****************************************************************************\n     * Game tree navigation\n     ***/\n\n    /**\n     * Go to the next position\n     */\n    Game.prototype.next = function(i) {\n\n      //Object (node) given as parameter? Find index\n      if (typeof i === 'object') {\n        i = this.node.children.indexOf(i);\n      }\n\n      //Go to the next node\n      if (nextNode.call(this, i)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n          return true;\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n\n      //Didn't go to next position\n      return false;\n    };\n\n    /**\n     * Go to the previous position\n     */\n    Game.prototype.previous = function() {\n\n      //Go to the previous node\n      if (previousNode.call(this)) {\n        popPosition.call(this);\n        return true;\n      }\n\n      //Didn't go to previous position\n      return false;\n    };\n\n    /**\n     * Go to the last position\n     */\n    Game.prototype.last = function() {\n\n      //Keep going to the next node until we reach the end\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the first position\n     */\n    Game.prototype.first = function() {\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      executeNode.call(this);\n    };\n\n    /**\n     * Go to position specified by a path object, a numeric move numer, or a node name string\n     */\n    Game.prototype.goto = function(target) {\n\n      //Must have a tree\n      if (this.root === null) {\n        return;\n      }\n\n      //Nothing given?\n      if (typeof target === 'undefined') {\n        return;\n      }\n\n      //Function given? Call now\n      if (typeof target === 'function') {\n        target = target.call(this);\n      }\n\n      //Initialize path\n      var path;\n\n      //Simple move number? Convert to path object\n      if (typeof target === 'number') {\n        path = this.path.clone();\n        path.setMove(target);\n      }\n\n      //String? Named node\n      else if (typeof target === 'string') {\n\n        //Already here?\n        if (this.node.name === target) {\n          return;\n        }\n\n        //Find path to node\n        path = this.getPathToNode(target);\n        if (path === null) {\n          return;\n        }\n      }\n\n      //Otherwise assume path object\n      else {\n        path = target;\n      }\n\n      //Already here?\n      if (this.path.compare(path)) {\n        return;\n      }\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      pushPosition.call(this);\n      executeNode.call(this);\n\n      //Loop path\n      var n = path.getMove();\n      for (var i = 0; i < n; i++) {\n\n        //Try going to the next node\n        if (!nextNode.call(this, path.nodeAt(i))) {\n          break;\n        }\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the next fork\n     */\n    Game.prototype.nextFork = function() {\n\n      //Keep going to the next node until we reach one with multiple children\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Have multiple children?\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous fork\n     */\n    Game.prototype.previousFork = function() {\n\n      //Loop until we find a node with more than one child\n      while (previousNode.call(this)) {\n        popPosition.call(this);\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the next move with comments\n     */\n    Game.prototype.nextComment = function() {\n\n      //Keep going to the next node until we find one with comments\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous move with comments\n     */\n    Game.prototype.previousComment = function() {\n\n      //Go back until we find a node with comments\n      while (previousNode.call(this)) {\n\n        //Pop the position\n        popPosition.call(this);\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state\n     */\n    Game.prototype.getState = function() {\n\n      //Can only create when we have a JGF and path\n      if (!this.jgf || !this.path) {\n        return null;\n      }\n\n      //Create state\n      var state = {\n        jgf: this.jgf,\n        path: this.path.clone()\n      };\n\n      //Return\n      return state;\n    };\n\n    /**\n     * Restore the game state\n     */\n    Game.prototype.restoreState = function(state) {\n\n      //Must have jgf and path\n      if (!state || !state.jgf || !state.path) {\n        return;\n      }\n\n      //Restore state\n      this.load(state.jgf);\n      this.goto(state.path);\n    };\n\n    //Return object\n    return Game;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GameNode :: This class represents a single node in the game moves tree. It contains\n * properties like the x and y grid coordinates, the move played, board setup instructions,\n * markup, player turn and comments. The moves tree in the game record is represented by a\n * string of GameNodes, each with pointers to their parent and children. Each node can have\n * multiple children (move variations), but only one parent.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Node.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameNode', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /**\n   * Helper to construct a coordinates base object\n   */\n  var coordinatesObject = function(coords, baseObject) {\n    baseObject = baseObject || {};\n    if (coords === '' || coords === 'pass') {\n      baseObject.pass = true;\n    }\n    else {\n\n      //Backwards compatibility with SGF string coordinates in JGF\n      if (typeof coords === 'string') {\n        coords = convertCoordinates(coords);\n      }\n\n      //Append coordinates\n      baseObject.x = coords[0] * 1;\n      baseObject.y = coords[1] * 1;\n    }\n    return baseObject;\n  };\n\n  /**\n   * Convert a numeric color value (color constant) to a string\n   */\n  var toStringColor = function(color) {\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\n  };\n\n  /**\n   * Convert a string color value to a numeric color constant\n   */\n  var toColorConstant = function(color) {\n    if (color === 'B') {\n      return StoneColor.B;\n    }\n    else if (color === 'W') {\n      return StoneColor.W;\n    }\n    return StoneColor.E;\n  };\n\n  /*****************************************************************************\n   * Helpers for conversion between JGF / KIFU format\n   ***/\n\n  /**\n   * Convert move object to JGF format\n   */\n  var convertMoveToJgf = function(move) {\n\n    //Initialize JGF move object and determine color\n    var jgfMove = angular.copy(move);\n    var color = toStringColor(move.color);\n\n    //No color?\n    if (color === '') {\n      return null;\n    }\n\n    //Pass move?\n    if (move.pass === true) {\n      jgfMove[color] = 'pass';\n    }\n\n    //Regular move\n    else {\n      jgfMove[color] = [move.x, move.y];\n    }\n\n    //Delete coordinates and color\n    delete jgfMove.x;\n    delete jgfMove.y;\n    delete jgfMove.color;\n\n    //Return move\n    return jgfMove;\n  };\n\n  /**\n   * Convert move from JGF format\n   */\n  var convertMoveFromJgf = function(move) {\n\n    //Prepare color, coordinates\n    var color, coords;\n\n    //Check whose move it was\n    if (move.W) {\n      color = 'W';\n      coords = move.W;\n    }\n    else if (move.B) {\n      color = 'B';\n      coords = move.B;\n    }\n\n    //No coordinates?\n    if (!coords) {\n      return null;\n    }\n\n    //Return coordinates object\n    return coordinatesObject(coords, {\n      color: toColorConstant(color)\n    });\n  };\n\n  /**\n   * Convert setup object to JGF format\n   */\n  var convertSetupToJgf = function(setup) {\n\n    //Initialize variables\n    var i, color;\n    var jgfSetup = {};\n\n    //Loop setup objects\n    for (i in setup) {\n      if (setup.hasOwnProperty(i)) {\n\n        //Get color\n        color = toStringColor(setup[i].color) || 'E';\n\n        //Initialize array\n        if (typeof jgfSetup[color] === 'undefined') {\n          jgfSetup[color] = [];\n        }\n\n        //Add coordinates\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\n      }\n    }\n\n    //Return\n    return jgfSetup;\n  };\n\n  /**\n   * Convert setup from JGF format\n   */\n  var convertSetupFromJgf = function(setup) {\n\n    //Initialize variables\n    var c, key, color;\n    var gameSetup = [];\n\n    //Loop setup\n    for (key in setup) {\n      if (setup.hasOwnProperty(key)) {\n\n        //Get color constant\n        color = toColorConstant(key);\n\n        //Loop coordinates\n        for (c in setup[key]) {\n          if (setup[key].hasOwnProperty(c)) {\n            gameSetup.push(coordinatesObject(setup[key][c], {\n              color: color\n            }));\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameSetup;\n  };\n\n  /**\n   * Convert markup object to JGF format\n   */\n  var convertMarkupToJgf = function(markup) {\n\n    //Initialize variables\n    var i, type;\n    var jgfMarkup = {};\n\n    //Loop setup objects\n    for (i in markup) {\n      if (markup.hasOwnProperty(i)) {\n\n        //Get type\n        type = markup[i].type;\n\n        //Initialize array\n        if (typeof jgfMarkup[type] === 'undefined') {\n          jgfMarkup[type] = [];\n        }\n\n        //Label?\n        if (type === 'label') {\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\n        }\n        else {\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\n        }\n      }\n    }\n\n    //Return\n    return jgfMarkup;\n  };\n\n  /**\n   * Convert markup from JGF format\n   */\n  var convertMarkupFromJgf = function(markup) {\n\n    //Initialize variables\n    var l, type;\n    var gameMarkup = [];\n\n    //Loop markup types\n    for (type in markup) {\n      if (markup.hasOwnProperty(type)) {\n\n        //Label?\n        if (type === 'label') {\n          for (l = 0; l < markup[type].length; l++) {\n\n            //Validate\n            if (!angular.isArray(markup[type][l])) {\n              continue;\n            }\n\n            //SGF type coordinates?\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\n              var text = markup[type][l][1];\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\n              markup[type][l].push(text);\n            }\n\n            //Validate length\n            if (markup[type][l].length < 3) {\n              continue;\n            }\n\n            //Add to stack\n            gameMarkup.push(coordinatesObject(markup[type][l], {\n              type: type,\n              text: markup[type][l][2]\n            }));\n          }\n        }\n        else {\n\n          //Loop coordinates\n          for (l in markup[type]) {\n            if (markup[type].hasOwnProperty(l)) {\n              gameMarkup.push(coordinatesObject(markup[type][l], {\n                type: type\n              }));\n            }\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameMarkup;\n  };\n\n  /**\n   * Convert turn object to JGF format\n   */\n  var convertTurnToJgf = function(turn) {\n    switch (turn) {\n      case StoneColor.W:\n        return 'W';\n      case StoneColor.B:\n        return 'B';\n      default:\n        return '';\n    }\n  };\n\n  /**\n   * Convert turn from JGF format\n   */\n  var convertTurnFromJgf = function(turn) {\n    switch (turn) {\n      case 'W':\n        return StoneColor.W;\n      case 'B':\n        return StoneColor.B;\n      default:\n        return StoneColor.EMPTY;\n    }\n  };\n\n  /**\n   * Conversions map\n   */\n  var conversionMap = {\n    toJgf: {\n      move: convertMoveToJgf,\n      setup: convertSetupToJgf,\n      markup: convertMarkupToJgf,\n      turn: convertTurnToJgf\n    },\n    fromJgf: {\n      move: convertMoveFromJgf,\n      setup: convertSetupFromJgf,\n      markup: convertMarkupFromJgf,\n      turn: convertTurnFromJgf\n    }\n  };\n\n  /**\n   * Constructor\n   */\n  var GameNode = function(properties, parent) {\n\n    //Set parent and children\n    this.parent = parent || null;\n    this.children = [];\n\n    //Save properties\n    if (properties) {\n      for (var key in properties) {\n        if (properties.hasOwnProperty(key)) {\n          this[key] = properties[key];\n        }\n      }\n    }\n  };\n\n  /**\n   * Get node's child specified by index or null if doesn't exist\n   */\n  GameNode.prototype.getChild = function(i) {\n    i = i || 0;\n    if (this.children[i]) {\n      return this.children[i];\n    }\n    return null;\n  };\n\n  /**\n   * Get all the children\n   */\n  GameNode.prototype.getChildren = function() {\n    return this.children;\n  };\n\n  /**\n   * Check if the node has any chilren\n   */\n  GameNode.prototype.hasChildren = function() {\n    return (this.children.length > 0);\n  };\n\n  /**\n   * Get parent node\n   */\n  GameNode.prototype.getParent = function() {\n    return this.parent;\n  };\n\n  /**\n   * Check if the node has more than one move variation\n   */\n  GameNode.prototype.hasMoveVariations = function() {\n\n    //Less than two child nodes?\n    if (this.children.length <= 1) {\n      return false;\n    }\n\n    //Loop children\n    var moveVariations = 0;\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].isMove()) {\n        moveVariations++;\n      }\n\n      //More than one move node present?\n      if (moveVariations > 1) {\n        return true;\n      }\n    }\n\n    //No move variations\n    return false;\n  };\n\n  /**\n   * Get all the move variation nodes\n   */\n  GameNode.prototype.getMoveVariations = function() {\n\n    //No child nodes?\n    if (this.children.length === 0) {\n      return false;\n    }\n\n    //Initialize\n    var moveVariations = [];\n\n    //Loop child nodes\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].isMove()) {\n        moveVariations.push(this.children[i]);\n      }\n    }\n\n    //Return\n    return moveVariations;\n  };\n\n  /**\n   * Get the move variation for given coordinates\n   */\n  GameNode.prototype.getMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return i;\n      }\n    }\n\n    //Not found\n    return -1;\n  };\n\n  /**\n   * Check if given coordinates are one of the next child node coordinates\n   */\n  GameNode.prototype.isMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return true;\n      }\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Check if we have comments\n   */\n  GameNode.prototype.hasComments = function() {\n    return (this.comments && this.comments.length > 0);\n  };\n\n  /**\n   * Check if this is a move node\n   */\n  GameNode.prototype.isMove = function() {\n    return !!this.move;\n  };\n\n  /**\n   * Get move number\n   */\n  GameNode.prototype.getMoveNumber = function() {\n\n    //Move node?\n    if (this.isMove()) {\n      if (this.parent) {\n        return this.parent.getMoveNumber() + 1;\n      }\n      return 1;\n    }\n\n    //Use parent move number if we have one\n    if (this.parent) {\n      return this.parent.getMoveNumber();\n    }\n\n    //No parent\n    return 0;\n  };\n\n  /*****************************************************************************\n   * Node manipulation\n   ***/\n\n  /**\n   * Remove this node from its parent\n   */\n  GameNode.prototype.remove = function() {\n\n    //Can't remove if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found remove it\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1) {\n      this.parent.children.splice(i, 1);\n    }\n\n    //Clear parent reference\n    this.parent = null;\n  };\n\n  /**\n   * Move the node up in the parent's child tree\n   */\n  GameNode.prototype.moveUp = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i > 0) {\n      var temp = this.parent.children[i - 1];\n      this.parent.children[i - 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Move the node down in the parent's child tree\n   */\n  GameNode.prototype.moveDown = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\n      var temp = this.parent.children[i + 1];\n      this.parent.children[i + 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Append this node to another node\n   */\n  GameNode.prototype.appendTo = function(node) {\n\n    //Remove from existing parent\n    this.remove();\n\n    //Set new parent\n    this.parent = node;\n    node.children.push(this);\n    return node.children.length - 1;\n  };\n\n  /**\n   * Append child node to this node.\n   */\n  GameNode.prototype.appendChild = function(node) {\n    node.parent = this;\n    this.children.push(node);\n    return this.children.length - 1;\n  };\n\n  /**\n   * Insert another node after this one\n   */\n  GameNode.prototype.insertNode = function(node) {\n\n    //Loop our children and change parent node\n    for (var i = 0; i < this.children.length; i++) {\n      this.children[i].parent = node;\n    }\n\n    //Merge children, set this node as the parent of given node\n    node.children = node.children.concat(this.children);\n    node.parent = this;\n\n    //Set given node as the child of this node\n    this.children = [node];\n  };\n\n  /*****************************************************************************\n   * JGF conversion\n   ***/\n\n  /**\n   * Build a Game Node from a given JGF tree\n   */\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\n\n    //Root JGF file given?\n    if (typeof jgf.tree !== 'undefined') {\n      return GameNode.fromJgf(jgf.tree, gameNode);\n    }\n\n    //Initialize helper vars\n    var variationNode, nextNode, i, j;\n\n    //Node to work with given? Otherwise, work with ourselves\n    gameNode = gameNode || this;\n\n    //Loop moves in the JGF tree\n    for (i = 0; i < jgf.length; i++) {\n\n      //Array? That means a variation branch\n      if (angular.isArray(jgf[i])) {\n\n        //Loop variation stacks\n        for (j = 0; j < jgf[i].length; j++) {\n\n          //Build the variation node\n          variationNode = new GameNode();\n          variationNode.fromJgf(jgf[i][j]);\n\n          //Append to working node\n          gameNode.appendChild(variationNode);\n        }\n      }\n\n      //Regular node\n      else {\n\n        //Get properties to copy\n        var properties = Object.getOwnPropertyNames(jgf[i]);\n\n        //Copy node properties\n        for (var key in properties) {\n          if (properties.hasOwnProperty(key)) {\n            var prop = properties[key];\n\n            //Conversion function present?\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\n            }\n            else if (typeof jgf[i][prop] === 'object') {\n              gameNode[prop] = angular.copy(jgf[i][prop]);\n            }\n            else {\n              gameNode[prop] = jgf[i][prop];\n            }\n          }\n        }\n      }\n\n      //Next element is a regular node? Prepare new working node\n      //Otherwise, if there are no more nodes or if the next element is\n      //an array (e.g. variations), we keep our working node as the current one\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\n        nextNode = new GameNode();\n        gameNode.appendChild(nextNode);\n        gameNode = nextNode;\n      }\n    }\n  };\n\n  /**\n   * Convert this node to a JGF node container\n   */\n  GameNode.prototype.toJgf = function(container) {\n\n    //Initialize container to add nodes to\n    container = container || [];\n\n    //Initialize node and get properties\n    var node = {};\n    var properties = Object.getOwnPropertyNames(this);\n\n    //Copy node properties\n    for (var key in properties) {\n      if (properties.hasOwnProperty(key)) {\n        var prop = properties[key];\n\n        //Skip some properties\n        if (prop === 'parent' || prop === 'children') {\n          continue;\n        }\n\n        //Conversion function present?\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\n        }\n        else if (typeof this[prop] === 'object') {\n          node[prop] = angular.copy(this[prop]);\n        }\n        else {\n          node[prop] = this[prop];\n        }\n      }\n    }\n\n    //Add node to container\n    container.push(node);\n\n    //Variations present?\n    if (this.children.length > 1) {\n\n      //Create variations container\n      var variationsContainer = [];\n      container.push(variationsContainer);\n\n      //Loop child (variation) nodes\n      for (var i = 0; i < this.children.length; i++) {\n\n        //Create container for this variation\n        var variationContainer = [];\n        variationsContainer.push(variationContainer);\n\n        //Call child node converter\n        this.children[i].toJgf(variationContainer);\n      }\n    }\n\n    //Just one child?\n    else if (this.children.length === 1) {\n      this.children[0].toJgf(container);\n    }\n\n    //Return container\n    return container;\n  };\n\n  //Return object\n  return GameNode;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePath :: A simple class that keeps track of a path taken in a game.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Path.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePath', function() {\n\n  /**\n   * Constructor\n   */\n  var GamePath = function() {\n    this.reset();\n  };\n\n  /**\n   * Reset\n   */\n  GamePath.prototype.reset = function() {\n    this.move = 0;\n    this.path = {};\n    this.branches = 0;\n    return this;\n  };\n\n  /**\n   * Advance a move\n   */\n  GamePath.prototype.advance = function(i) {\n\n    //Different child variation chosen? Remember\n    if (i > 0) {\n      this.path[this.move] = 1;\n      this.branches++;\n    }\n\n    //Increment move\n    this.move++;\n    return this;\n  };\n\n  /**\n   * Retreat a move\n   */\n  GamePath.prototype.retreat = function() {\n\n    //At start?\n    if (this.move === 0) {\n      return;\n    }\n\n    //Delete path choice\n    if (this.path[this.move]) {\n      delete this.path[this.move];\n      this.branches--;\n    }\n\n    //Decrement move\n    this.move--;\n    return this;\n  };\n\n  /**\n   * Go to a specific move number\n   */\n  GamePath.prototype.setMove = function(no) {\n\n    //Less than our current move? We need to erase any paths above the move number\n    if (no < this.move) {\n      for (var i in this.path) {\n        if (i > no) {\n          delete this.path[i];\n          this.branches--;\n        }\n      }\n    }\n\n    //Set move number\n    this.move = no;\n    return this;\n  };\n\n  /**\n   * Get the move number\n   */\n  GamePath.prototype.getMove = function() {\n    return this.move;\n  };\n\n  /**\n   * Get the node choice at a specific move number\n   */\n  GamePath.prototype.nodeAt = function(no) {\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\n  };\n\n  /**\n   * Compare to another path\n   */\n  GamePath.prototype.compare = function(otherPath) {\n\n    //Invalid object?\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\n      return;\n    }\n\n    //Different move number or path length?\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\n      return false;\n    }\n\n    //Check path\n    for (var i in this.path) {\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\n        return false;\n      }\n    }\n\n    //Same path!\n    return true;\n  };\n\n  /**\n   * Clone\n   */\n  GamePath.prototype.clone = function() {\n\n    //Create new instance\n    var newPath = new GamePath();\n\n    //Set vars\n    newPath.move = this.move;\n    newPath.branches = this.branches;\n    newPath.path = angular.copy(this.path);\n\n    //Return\n    return newPath;\n  };\n\n  /**\n   * Helper to find node name recursively\n   */\n  var findNodeName = function(node, nodeName, path) {\n\n    //Found in this node?\n    if (node.name && node.name === nodeName) {\n      return true;\n    }\n\n    //Loop children\n    for (var i = 0; i < node.children.length; i++) {\n\n      //Advance path\n      path.advance(i);\n\n      //Found in child node?\n      if (findNodeName(node.children[i], nodeName, path)) {\n        return true;\n      }\n\n      //Not found in this child node, retreat path\n      path.retreat();\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Static helper to create a path object to reach a certain node\n   */\n  GamePath.findNode = function(nodeName, rootNode) {\n\n    //Create new instance\n    var path = new GamePath();\n\n    //Find the node name\n    if (findNodeName(rootNode, nodeName, path)) {\n      return path;\n    }\n\n    //Not found\n    return null;\n  };\n\n  //Return\n  return GamePath;\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\n * markup on the board in this position, as well as any captures that were made and which player's\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\n * compare changes to other positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Position.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePosition', ['StoneColor', 'BoardGrid', function(StoneColor, BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var GamePosition = function(width, height) {\n\n    //Initialize\n    this.error = 0;\n    this.width = 0;\n    this.height = 0;\n    this.stones = new BoardGrid();\n    this.markup = new BoardGrid();\n    this.turn = StoneColor.B;\n\n    //Initialize captures\n    this.captures = {};\n    this.captures[StoneColor.B] = [];\n    this.captures[StoneColor.W] = [];\n\n    //Set empty value for stones grid\n    this.stones.whenEmpty(StoneColor.EMPTY);\n\n    //Set size\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set the grid size\n   */\n  GamePosition.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Set in grids\n    this.stones.setSize(width, height);\n    this.markup.setSize(width, height);\n\n    //Empty the position\n    this.empty();\n  };\n\n  /**\n   * Clear the whole position\n   */\n  GamePosition.prototype.empty = function() {\n    this.stones.empty();\n    this.markup.empty();\n  };\n\n  /**\n   * Sets stone color at given coordinates.\n   */\n  GamePosition.prototype.setStone = function(x, y, color) {\n    this.stones.set(x, y, color);\n  };\n\n  /**\n   * Sets markup type at given coordinates.\n   */\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\n    this.markup.set(x, y, markup);\n  };\n\n  /*****************************************************************************\n   * Liberties and capturing\n   ***/\n\n  /**\n   * Check if a group of given color has liberties, starting at the given coordinates\n   */\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\n\n    //Out of bounds? No liberties outside of the board\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Initialize tested grid if needed\n    tested = tested || new BoardGrid(this.width, this.height);\n\n    //See what color is present on the coordinates\n    var color = this.stones.get(x, y);\n\n    //If no group color was given, use what's on the position\n    groupColor = groupColor || color;\n\n    //Already tested, or enemy stone? Not giving any liberties\n    if (tested.get(x, y) === true || color === -groupColor) {\n      return false;\n    }\n\n    //Empty? That's a liberty\n    if (color === StoneColor.EMPTY) {\n      return true;\n    }\n\n    //Mark this position as tested now\n    tested.set(x, y, true);\n\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\n    //If we get at least one true, we have a liberty\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\n        this.hasLiberties(x + 1, y, groupColor, tested);\n  };\n\n  /**\n   * Helper to capture adjacent groups\n   */\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    friendlyColor = friendlyColor || this.stones.get(x, y);\n\n    //Can't capture empty spots\n    if (friendlyColor === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Flag to see if we captured stuff\n    var captured = false;\n\n    //Check adjacent positions now, capturing stones in the process if possible\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n\n    //Return\n    return captured;\n  };\n\n  /**\n   * Helper if we can capture a certain group\n   */\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\n\n    //Out of bounds? Nothing to capture\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Empty spot? Can't capture\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //We need to have a stone of matching group color in order to be able to capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //There is a capturable stone, let's see if it has any liberties left\n    if (this.hasLiberties(x, y, enemyColor)) {\n      return false;\n    }\n\n    //No liberties left, the group is capturable. Capture if we want to\n    if (doCapture) {\n      this.captureGroup(x, y, enemyColor);\n    }\n\n    //Capturable\n    return true;\n  };\n\n  /**\n   * Capture a group of certain color, starting at the given coordinates\n   */\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //If no group color was given, use what's on the position\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //Stone at position does not match the given group color? Can't capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //Capture the stone\n    this.captureStone(x, y);\n\n    //Capture the rest of the group\n    this.captureGroup(x, y - 1, enemyColor);\n    this.captureGroup(x, y + 1, enemyColor);\n    this.captureGroup(x - 1, y, enemyColor);\n    this.captureGroup(x + 1, y, enemyColor);\n\n    //At least one stone was captured\n    return true;\n  };\n\n  /**\n   * Capture a stone at given coordinates\n   */\n  GamePosition.prototype.captureStone = function(x, y) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Get color\n    var color = this.stones.get(x, y);\n\n    //Empty?\n    if (color === StoneColor.EMPTY) {\n      return;\n    }\n\n    //Ok, stone present, capture it\n    this.stones.set(x, y, StoneColor.EMPTY);\n    this.captures[color].push({x: x, y: y});\n  };\n\n  /**\n   * Set captures for a color (expects array with capture object coordinates)\n   */\n  GamePosition.prototype.setCaptures = function(color, captures) {\n    this.captures[color] = captures;\n  };\n\n  /**\n   * Get captures for a color\n   */\n  GamePosition.prototype.getCaptures = function(color) {\n    return this.captures[color] || [];\n  };\n\n  /**\n   * Get the capture count for a color (= the number of captures of the opposing color)\n   */\n  GamePosition.prototype.getCaptureCount = function(color) {\n    return this.captures[-color].length;\n  };\n\n  /*****************************************************************************\n   * Turn control\n   ***/\n\n  /**\n   * Set color for whose move it is at this position\n   */\n  GamePosition.prototype.setTurn = function(color) {\n    this.turn = color;\n  };\n\n  /**\n   * Get color for whose move it is at this position\n   */\n  GamePosition.prototype.getTurn = function() {\n    return this.turn;\n  };\n\n  /**\n   * Switch the player turn on this position\n   */\n  GamePosition.prototype.switchTurn = function() {\n    this.turn = -this.turn;\n  };\n\n  /*****************************************************************************\n   * Cloning and comparison\n   ***/\n\n  /**\n   * Clones the whole position except turn and captures\n   */\n  GamePosition.prototype.clone = function() {\n\n    //Create a new position\n    var newPosition = new GamePosition();\n\n    //Set vars manually for maximum efficiency\n    newPosition.turn = this.turn;\n    newPosition.width = this.width;\n    newPosition.height = this.height;\n    newPosition.stones = this.stones.clone();\n    newPosition.markup = new BoardGrid(this.width, this.height);\n\n    //Return\n    return newPosition;\n  };\n\n  /**\n   * Checks if a given position is the same as the current position\n   */\n  GamePosition.prototype.isSameAs = function(newPosition) {\n\n    //Must have the same size\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\n      return false;\n    }\n\n    //Compare the grids\n    return this.stones.isSameAs(newPosition.stones);\n  };\n\n  //Return\n  return GamePosition;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScore :: A simple class that contains a game score\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Score.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScore', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Helper to calculate the total points\n   */\n  var calcTotal = function() {\n    return parseInt(this.stones) + parseInt(this.territory) +\n      parseInt(this.captures) + parseInt(this.komi);\n  };\n\n  /**\n   * Constructor\n   */\n  var GameScore = function() {\n\n    //Get self\n    var self = this;\n\n    //Setup score containers\n    this.black = {};\n    this.white = {};\n\n    //Initialize\n    this.reset();\n\n    //Add total handlers\n    this.black.total = function() {\n      return calcTotal.call(self.black);\n    };\n    this.white.total = function() {\n      return calcTotal.call(self.white);\n    };\n  };\n\n  /**\n   * Reset the game score\n   */\n  GameScore.prototype.reset = function() {\n\n    //Get properties to loop\n    var props = ['stones', 'territory', 'captures', 'komi'];\n\n    //Score for black player\n    for (var i = 0; i < props.length; i++) {\n      this.black[props[i]] = 0;\n      this.white[props[i]] = 0;\n    }\n  };\n\n  /**\n   * Get the winner\n   */\n  GameScore.prototype.winner = function() {\n\n    //Get totals\n    var b = this.black.total();\n    var w = this.white.total();\n\n    //Determine winner\n    if (w > b) {\n      return StoneColor.W;\n    }\n    else if (b > w) {\n      return StoneColor.B;\n    }\n    return StoneColor.E;\n  };\n\n  //Return\n  return GameScore;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScorer :: This class is used to determine the score of a certain game position. It also\n * provides handling of manual adjustment of dead / living groups.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Scorer.Service', [\n  'ngGo',\n  'ngGo.Game.Score.Service',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScorer', ['GameScore', 'StoneColor', 'BoardGrid', function(GameScore, StoneColor, BoardGrid) {\n\n  /**\n   * Possible score states\n   */\n  var scoreState = {\n    UNKNOWN: StoneColor.EMPTY,\n    BLACK_STONE: StoneColor.B,\n    WHITE_STONE: StoneColor.W,\n    BLACK_CANDIDATE: StoneColor.B * 2,\n    WHITE_CANDIDATE: StoneColor.W * 2,\n    NEUTRAL: StoneColor.B * 3\n  };\n\n  /**\n   * Helper to set territory\n   */\n  var territorySet = function(x, y, candidateColor, boundaryColor) {\n\n    //Get color at given position\n    var posColor = this.stones.get(x, y);\n    var origColor = this.game.position.stones.get(x, y);\n\n    //If border reached, or a position which is already this color, or boundary color, can't set\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\n      return;\n    }\n\n    //Don't turn stones which are already this color into candidates, instead\n    //reset their color to what they were\n    if (origColor * 2 === candidateColor) {\n      this.stones.set(x, y, origColor);\n    }\n\n    //Otherwise, mark as candidate\n    else {\n      this.stones.set(x, y, candidateColor);\n    }\n\n    //Set adjacent squares\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\n  };\n\n  /**\n   * Helper to reset territory\n   */\n  var territoryReset = function(x, y) {\n\n    //Get original color from this position\n    var origColor = this.game.position.stones.get(x, y);\n\n    //Not on grid, or already this color?\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\n      return;\n    }\n\n    //Reset the color\n    this.stones.set(x, y, origColor);\n\n    //Set adjacent squares\n    territoryReset.call(this, x - 1, y);\n    territoryReset.call(this, x, y - 1);\n    territoryReset.call(this, x + 1, y);\n    territoryReset.call(this, x, y + 1);\n  };\n\n  /**\n   * Helper to determine score state\n   */\n  var determineScoreState = function() {\n\n    //Initialize vars\n    var change = true;\n    var curState, newState, adjacent, b, w, a, x, y;\n\n    //Loop while there is change\n    while (change) {\n\n      //Set to false\n      change = false;\n\n      //Go through the whole position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get current state at position\n          curState = this.stones.get(x, y);\n\n          //Unknown or candiates?\n          if (\n            curState === scoreState.UNKNOWN ||\n            curState === scoreState.BLACK_CANDIDATE ||\n            curState === scoreState.WHITE_CANDIDATE\n          ) {\n\n            //Get state in adjacent positions\n            adjacent = [\n              this.stones.get(x - 1, y),\n              this.stones.get(x, y - 1),\n              this.stones.get(x + 1, y),\n              this.stones.get(x, y + 1)\n            ];\n\n            //Reset\n            b = w = false;\n\n            //Loop adjacent squares\n            for (a = 0; a < 4; a++) {\n              if (\n                adjacent[a] === scoreState.BLACK_STONE ||\n                adjacent[a] === scoreState.BLACK_CANDIDATE\n              ) {\n                b = true;\n              }\n              else if (\n                adjacent[a] === scoreState.WHITE_STONE ||\n                adjacent[a] === scoreState.WHITE_CANDIDATE\n              ) {\n                w = true;\n              }\n              else if (adjacent[a] === scoreState.NEUTRAL) {\n                b = w = true;\n              }\n            }\n\n            //Determine new state\n            if (b && w) {\n              newState = scoreState.NEUTRAL;\n            }\n            else if (b) {\n              newState = scoreState.BLACK_CANDIDATE;\n            }\n            else if (w) {\n              newState = scoreState.WHITE_CANDIDATE;\n            }\n            else {\n              newState = false;\n            }\n\n            //Change?\n            if (newState !== false && newState !== curState) {\n              change = true;\n              this.stones.set(x, y, newState);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * this.game scorer class\n   */\n  var GameScorer = {\n\n    //Game to score\n    game: null,\n\n    //Score\n    score: null,\n\n    //Stones, captures and points grids\n    stones: null,\n    captures: null,\n    points: null,\n\n    /**\n     * Load a game to score\n     */\n    load: function(game) {\n\n      //Reset score\n      this.score = new GameScore();\n\n      //Remember\n      this.game = game;\n\n      //Clone position to work with\n      this.stones = this.game.position.stones.clone();\n\n      //Create grids\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n    },\n\n    /**\n     * Get the calculated score\n     */\n    getScore: function() {\n      return this.score;\n    },\n\n    /**\n     * Get the points grid\n     */\n    getPoints: function() {\n      return this.points;\n    },\n\n    /**\n     * Get the captures grid\n     */\n    getCaptures: function() {\n      return this.captures;\n    },\n\n    /**\n     * Run score calculation routine\n     */\n    calculate: function() {\n\n      //No game?\n      if (!this.game) {\n        console.warn('No game loaded in game scorer, can\\'t calutlate score.');\n        return;\n      }\n\n      //Empty grids\n      this.points.empty();\n      this.captures.empty();\n\n      //Determine score state\n      determineScoreState.call(this);\n\n      //Get komi and captures\n      var komi = this.game.get('game.komi');\n      var captures = this.game.getCaptureCount();\n\n      //Reset score\n      this.score.reset();\n\n      //Set captures and komi\n      this.score.black.captures = captures[StoneColor.B];\n      this.score.white.captures = captures[StoneColor.W];\n      this.score.black.komi = komi < 0 ? komi : 0;\n      this.score.white.komi = komi > 0 ? komi : 0;\n\n      //Init helper vars\n      var x, y, state, color;\n\n      //Loop position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get state and color on original position\n          state = this.stones.get(x, y);\n          color = this.game.position.stones.get(x, y);\n\n          //Black stone\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\n            this.score.black.stones++;\n            continue;\n          }\n\n          //White stone\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\n            this.score.white.stones++;\n            continue;\n          }\n\n          //Black candidate\n          if (state === scoreState.BLACK_CANDIDATE) {\n            this.score.black.territory++;\n            this.points.set(x, y, StoneColor.B);\n\n            //White stone underneath?\n            if (color === StoneColor.W) {\n              this.score.black.captures++;\n              this.captures.set(x, y, StoneColor.W);\n            }\n            continue;\n          }\n\n          //White candidate\n          if (state === scoreState.WHITE_CANDIDATE) {\n            this.score.white.territory++;\n            this.points.set(x, y, StoneColor.W);\n\n            //Black stone underneath?\n            if (color === StoneColor.B) {\n              this.score.white.captures++;\n              this.captures.set(x, y, StoneColor.B);\n            }\n            continue;\n          }\n        }\n      }\n    },\n\n    /**\n     * Mark stones dead or alive\n     */\n    mark: function(x, y) {\n\n      //Get color of original position and state of the count position\n      var color = this.game.position.stones.get(x, y);\n      var state = this.stones.get(x, y);\n\n      //White stone\n      if (color === StoneColor.W) {\n\n        //Was white, mark it and any territory it's in as black's\n        if (state === scoreState.WHITE_STONE) {\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\n        }\n\n        //Was marked as not white, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n\n      //Black stone\n      else if (color === StoneColor.B) {\n\n        //Was black, mark it and any territory it's in as white's\n        if (state === scoreState.BLACK_STONE) {\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\n        }\n\n        //Was marked as not black, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n    }\n  };\n\n  //Return\n  return GameScorer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Blank.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('KifuBlank', ['ngGo', function(ngGo) {\n\n  /**\n   * Blank JGF\n   */\n  var blankJgf = {\n    record: {\n      application: ngGo.name + ' v' + ngGo.version,\n      version: 1,\n      charset: 'UTF-8'\n    },\n    game: {\n      type: 'go',\n      players: [\n        {\n          color: 'black',\n          name: 'Black'\n        },\n        {\n          color: 'white',\n          name: 'White'\n        }\n      ]\n    },\n    board: {\n      width: 19,\n      height: 19\n    },\n    tree: []\n  };\n\n  /**\n   * Blank SGF\n   */\n  var blankSgf = {\n    AP: ngGo.name + ':' + ngGo.version,\n    CA: 'UTF-8',\n    FF: '4',\n    GM: '1',\n    SZ: '19',\n    PB: 'Black',\n    PW: 'White'\n  };\n\n  /**\n   * Blank JGF/SGF container\n   */\n  var KifuBlank = {\n\n    /**\n     * Get blank JGF\n     */\n    jgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankJgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    },\n\n    /**\n     * Get blank SGF\n     */\n    sgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankSgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = base[p];\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    }\n  };\n\n  //Return object\n  return KifuBlank;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\n * constants used by the parsers to aid conversion.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parser.Service', [\n  'ngGo',\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service'\n])\n\n/**\n * SGF/JGF aliases constant for conversion between the two formats\n * Note: not all properties can be translated directly, so some are\n * not present here in this constant\n */\n.constant('sgfAliases', {\n\n  //Record properties\n  'AP': 'record.application',\n  'CA': 'record.charset',\n  'CP': 'record.copyright',\n  'SO': 'record.source',\n  'US': 'record.transcriber',\n  'AN': 'record.annotator',\n\n  //Game properties\n  'GM': 'game.type',\n  'GN': 'game.name',\n  'KM': 'game.komi',\n  'HA': 'game.handicap',\n  'RE': 'game.result',\n  'RU': 'game.rules',\n  'TM': 'game.time.main',\n  'OT': 'game.time.overtime',\n  'DT': 'game.dates',\n  'PC': 'game.location',\n  'EV': 'game.event',\n  'RO': 'game.round',\n  'ON': 'game.opening',\n  'GC': 'game.comment',\n\n  //Player info properties\n  'PB': 'name',\n  'PW': 'name',\n  'BT': 'team',\n  'WT': 'team',\n  'BR': 'rank',\n  'WR': 'rank',\n\n  //Node annotation\n  'N': 'name',\n  'C': 'comments',\n  'CR': 'circle',\n  'TR': 'triangle',\n  'SQ': 'square',\n  'MA': 'mark',\n  'SL': 'select',\n  'LB': 'label'\n})\n\n/**\n * SGF game definitions\n */\n.constant('sgfGames', {\n  1: 'go',\n  2: 'othello',\n  3: 'chess',\n  4: 'renju',\n  6: 'backgammon',\n  7: 'chinese chess',\n  8: 'shogi'\n})\n\n/**\n * Factory definition\n */\n.factory('KifuParser', ['Gib2Jgf', 'Sgf2Jgf', 'Jgf2Sgf', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\n\n  /**\n   * Parser wrapper class\n   */\n  var KifuParser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    gib2jgf: function(gib, stringified) {\n      return Gib2Jgf.parse(gib, stringified);\n    },\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    sgf2jgf: function(sgf, stringified) {\n      return Sgf2Jgf.parse(sgf, stringified);\n    },\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    jgf2sgf: function(jgf) {\n      return Jgf2Sgf.parse(jgf);\n    }\n  };\n\n  //Return object\n  return KifuParser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Directive', [\n  'ngGo.Board.Directive'\n])\n\n/**\n * Directive definition\n */\n.directive('player', ['Player', function(Player) {\n  return {\n    restrict: 'E',\n\n    /**\n     * Controller\n     */\n    controller: ['$scope', function($scope) {\n\n      //Set player in scope\n      if (!$scope.Player) {\n        $scope.Player = Player;\n      }\n    }],\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Link the element\n      Player.linkElement(element);\n\n      //Observe mode and tool attributes\n      attrs.$observe('mode', function(mode) {\n        Player.switchMode(mode);\n      });\n      attrs.$observe('tool', function(tool) {\n        Player.switchTool(tool);\n      });\n\n      //Observe other settings attributes\n      attrs.$observe('variationMarkup', function(attr) {\n        Player.setVariationMarkup(attr === 'true');\n      });\n      attrs.$observe('solutionPaths', function(attr) {\n        Player.toggleSolutionPaths(attr === 'true');\n      });\n      attrs.$observe('lastMoveMarker', function(attr) {\n        Player.setLastMoveMarker(attr);\n      });\n    }\n  };\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Player :: This class brings the board to life and allows a user to interact with it. It\n * handles user input, controls objects going to the board, can load game records, and allows the\n * user to manipulate the board according to the current player mode.\n * Unless you want to display static positions, this is the class you'd use by default.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Service', [\n  'ngGo',\n  'ngGo.Player.Directive',\n  'ngGo.Player.Mode.Common.Service',\n  'ngGo.Board.Service',\n  'ngGo.Game.Service',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Player', ['PlayerModes', 'PlayerTools', 'MarkupTypes', function(PlayerModes, PlayerTools, MarkupTypes) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default mode/tool\n    mode: PlayerModes.REPLAY,\n    tool: PlayerTools.MOVE,\n\n    //Keys/scrollwheel navigation\n    arrowKeysNavigation: true,\n    scrollWheelNavigation: true,\n\n    //Last move marker, leave empty for none\n    lastMoveMarker: MarkupTypes.LAST,\n\n    //Indicate variations with markup on the board, and show\n    //successor node variations or current node variations\n    variationMarkup: true,\n    variationChildren: true,\n    variationSiblings: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$document', 'Game', 'GameScorer', 'Board', 'PlayerTools', function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\n\n    /**\n     * Helper to append board grid coordinatess to the broadcast event object\n     */\n    var processMouseEvent = function(broadcastEvent, mouseEvent) {\n\n      //Can only do this with a board and mouse event\n      if (!this.board || !mouseEvent) {\n        broadcastEvent.x = -1;\n        broadcastEvent.y = -1;\n        return;\n      }\n\n      //Init\n      var x = 0;\n      var y = 0;\n\n      //Set x\n      if (typeof mouseEvent.offsetX !== 'undefined') {\n        x = mouseEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.layerX;\n      }\n\n      //Set y\n      if (typeof mouseEvent.offsetY !== 'undefined') {\n        y = mouseEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.layerY;\n      }\n\n      //Apply pixel ratio factor\n      x *= (window.devicePixelRatio || 1);\n      y *= (window.devicePixelRatio || 1);\n\n      //Append coords\n      broadcastEvent.x = this.board.getGridX(x);\n      broadcastEvent.y = this.board.getGridY(y);\n\n      //Did we drag?\n      if (mouseEvent.drag) {\n        broadcastEvent.drag = mouseEvent.drag;\n      }\n    };\n\n    /**\n     * Player class\n     */\n    var Player = {\n\n      //Player configuration\n      config: {},\n\n      //Board and game instances\n      board: null,\n      game: null,\n\n      //Available modes and tools\n      modes: {},\n      tools: [],\n\n      //Player mode and active tool\n      mode: '',\n      tool: '',\n\n      //Current path\n      path: null,\n\n      /**\n       * Initialization\n       */\n      init: function() {\n\n        //Unlink board instance, create new game\n        this.board = null;\n        this.game = new Game();\n\n        //Reset path\n        this.path = null;\n\n        //Player mode and active tool\n        this.mode = '';\n        this.tool = '';\n\n        //Arrow keys / scroll wheel navigation\n        this.arrowKeysNavigation = false;\n        this.scrollWheelNavigation = false;\n\n        //Last move marker\n        this.lastMoveMarker = '';\n\n        //Variation markup\n        this.variationMarkup = false;\n        this.variationChildren = false;\n        this.variationSiblings = false;\n\n        //Restricted nodes\n        this.restrictNodeStart = null;\n        this.restrictNodeEnd = null;\n\n        //Parse config\n        this.parseConfig();\n      },\n\n      /**\n       * Link the player to a HTML element\n       */\n      linkElement: function(element) {\n\n        //Set element\n        this.element = element;\n\n        //Register document event\n        this.registerElementEvent('keydown', $document);\n\n        //Register element events\n        this.registerElementEvent('click');\n        this.registerElementEvent('mousedown');\n        this.registerElementEvent('mouseup');\n        this.registerElementEvent('mousemove');\n        this.registerElementEvent('mouseout');\n        this.registerElementEvent('mousewheel');\n        this.registerElementEvent('wheel');\n      },\n\n      /*****************************************************************************\n       * Configuration\n       ***/\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, defaultConfig, config || {});\n\n        //Process settings\n        this.switchMode(this.config.mode);\n        this.switchTool(this.config.tool);\n        this.setArrowKeysNavigation(this.config.arrowKeysNavigation);\n        this.setScrollWheelNavigation(this.config.scrollWheelNavigation);\n        this.setLastMoveMarker(this.config.lastMoveMarker);\n        this.setVariationMarkup(\n          this.config.variationMarkup,\n          this.config.variationChildren,\n          this.config.variationSiblings\n        );\n\n        //Let the modes parse their config\n        for (var mode in this.modes) {\n          if (this.modes[mode].parseConfig) {\n            this.modes[mode].parseConfig.call(this, this.config);\n          }\n        }\n      },\n\n      /**\n       * Set arrow keys navigation\n       */\n      setArrowKeysNavigation: function(arrowKeys) {\n        if (arrowKeys !== this.arrowKeysNavigation) {\n          this.arrowKeysNavigation = arrowKeys;\n          this.broadcast('settingChange', 'arrowKeysNavigation');\n        }\n      },\n\n      /**\n       * Set scroll wheel navigation\n       */\n      setScrollWheelNavigation: function(scrollWheel) {\n        if (scrollWheel !== this.scrollWheelNavigation) {\n          this.scrollWheelNavigation = scrollWheel;\n          this.broadcast('settingChange', 'scrollWheelNavigation');\n        }\n      },\n\n      /**\n       * Set the last move marker\n       */\n      setLastMoveMarker: function(lastMoveMarker) {\n        if (lastMoveMarker !== this.lastMoveMarker) {\n          this.lastMoveMarker = lastMoveMarker;\n          this.broadcast('settingChange', 'lastMoveMarker');\n        }\n      },\n\n      /**\n       * Set variation markup on the board\n       */\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\n\n        //One change event for these three settings\n        var change = false;\n\n        //Markup setting change?\n        if (variationMarkup !== this.variationMarkup) {\n          this.variationMarkup = variationMarkup;\n          change = true;\n        }\n\n        //Children setting change?\n        if (\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\n        ) {\n          this.variationChildren = variationChildren;\n          change = true;\n        }\n\n        //Siblings setting change?\n        if (\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\n        ) {\n          this.variationSiblings = variationSiblings;\n          change = true;\n        }\n\n        //Did anything change?\n        if (change) {\n          this.broadcast('settingChange', 'variationMarkup');\n        }\n      },\n\n      /*****************************************************************************\n       * Mode and tool handling\n       ***/\n\n      /**\n       * Register a player mode\n       */\n      registerMode: function(mode, PlayerMode) {\n\n        //Register the mode and let it parse the configuration\n        this.modes[mode] = PlayerMode;\n\n        //Parse config if we have a handler\n        if (this.modes[mode].parseConfig) {\n          this.modes[mode].parseConfig.call(this, this.config);\n        }\n\n        //Force switch the mode now, if it matches the initial mode\n        if (this.mode === mode) {\n          this.switchMode(this.mode, true);\n          this.switchTool(this.tool, true);\n        }\n      },\n\n      /**\n       * Set available tools\n       */\n      setTools: function(tools) {\n        this.tools = tools || [PlayerTools.NONE];\n      },\n\n      /**\n       * Check if we have a player mode\n       */\n      hasMode: function(mode) {\n        return this.modes[mode] ? true : false;\n      },\n\n      /**\n       * Check if we have a player tool\n       */\n      hasTool: function(tool) {\n        return (this.tools.indexOf(tool) !== -1);\n      },\n\n      /**\n       * Switch player mode\n       */\n      switchMode: function(mode, force) {\n\n        //No change?\n        if (!force && (!mode || this.mode === mode)) {\n          return false;\n        }\n\n        //Broadcast mode exit\n        if (this.mode) {\n          this.broadcast('modeExit', this.mode);\n        }\n\n        //Set mode, reset tools and active tool\n        this.mode = mode;\n        this.tools = [];\n        this.tool = PlayerTools.NONE;\n\n        //Broadcast mode entry\n        this.broadcast('modeEnter', this.mode);\n        return true;\n      },\n\n      /**\n       * Switch player tool\n       */\n      switchTool: function(tool, force) {\n\n        //No change?\n        if (!force && (!tool || this.tool === tool)) {\n          return false;\n        }\n\n        //Validate tool switch (only when there is a mode)\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\n          return false;\n        }\n\n        //Change tool\n        this.tool = tool;\n        this.broadcast('toolSwitch', this.tool);\n        return true;\n      },\n\n      /**\n       * Save the full player state\n       */\n      saveState: function() {\n\n        //Save player state\n        this.playerState = {\n          mode: this.mode,\n          tool: this.tool,\n          restrictNodeStart: this.restrictNodeStart,\n          restrictNodeEnd: this.restrictNodeEnd\n        };\n\n        //Save game state\n        this.saveGameState();\n      },\n\n      /**\n       * Restore to the saved player state\n       */\n      restoreState: function() {\n\n        //Must have player state\n        if (!this.playerState) {\n          return;\n        }\n\n        //Restore\n        this.switchMode(this.playerState.mode);\n        this.switchTool(this.playerState.tool);\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\n\n        //Restore game state\n        this.restoreGameState();\n      },\n\n      /*****************************************************************************\n       * Game record handling\n       ***/\n\n      /**\n       * Load game record\n       */\n      load: function(data, allowPlayerConfig) {\n\n        //Try to load the game record data\n        try {\n          this.game.load(data);\n        }\n        catch (error) {\n          throw error;\n        }\n\n        //Reset path\n        this.path = null;\n\n        //Parse configuration from JGF if allowed\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\n          this.parseConfig(this.game.get('settings'));\n        }\n\n        //Dispatch game loaded event\n        this.broadcast('gameLoaded', this.game);\n\n        //Board present?\n        if (this.board) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n\n        //Loaded ok\n        return true;\n      },\n\n      /**\n       * Reload the existing game record\n       */\n      reload: function() {\n\n        //Must have game\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reload game\n        this.game.reload();\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Save the current state\n       */\n      saveGameState: function() {\n        if (this.game && this.game.isLoaded()) {\n          this.gameState = this.game.getState();\n        }\n      },\n\n      /**\n       * Restore to the saved state\n       */\n      restoreGameState: function() {\n\n        //Must have game and saved state\n        if (!this.game || !this.gameState) {\n          return;\n        }\n\n        //Restore state\n        this.game.restoreState(this.gameState);\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /*****************************************************************************\n       * Navigation\n       ***/\n\n      /**\n       * Go to the next position\n       */\n      next: function(i) {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.next(i);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position\n       */\n      previous: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previous();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the last position\n       */\n      last: function() {\n        if (this.game) {\n          this.game.last();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the first position\n       */\n      first: function() {\n        if (this.game) {\n          this.game.first();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to a specific move number, tree path or named node\n       */\n      goto: function(target) {\n        if (this.game && target) {\n          this.game.goto(target);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the previous fork\n       */\n      previousFork: function() {\n        if (this.game) {\n          this.game.previousFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next fork\n       */\n      nextFork: function() {\n        if (this.game) {\n          this.game.nextFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next position with a comment\n       */\n      nextComment: function() {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.nextComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position with a comment\n       */\n      previousComment: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previousComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Restrict navigation to the current node\n       */\n      restrictNode: function(end) {\n\n        //Must have game and node\n        if (!this.game || !this.game.node) {\n          return;\n        }\n\n        //Restrict to current node\n        if (end) {\n          this.restrictNodeEnd = this.game.node;\n        }\n        else {\n          this.restrictNodeStart = this.game.node;\n        }\n      },\n\n      /**\n       * Process a new game position\n       */\n      processPosition: function() {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Get current node and game position\n        var node = this.game.getNode();\n        var path = this.game.getPath();\n        var position = this.game.getPosition();\n        var pathChanged = !path.compare(this.path);\n\n        //Update board\n        this.updateBoard(node, position, pathChanged);\n\n        //Path change?\n        if (pathChanged) {\n\n          //Copy new path and broadcast path change\n          this.path = path.clone();\n          this.broadcast('pathChange', node);\n\n          //Named node reached? Broadcast event\n          if (node.name) {\n            this.broadcast('reachedNode.' + node.name, node);\n          }\n        }\n\n        //Passed?\n        if (node.move && node.move.pass) {\n          this.broadcast('movePassed', node);\n        }\n      },\n\n      /**\n       * Show move numbers\n       */\n      showMoveNumbers: function(fromMove, toMove) {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Use sensible defaults if no from/to moves given\n        fromMove = fromMove || 1;\n        toMove = toMove || this.game.getMove();\n\n        //Get nodes for these moves\n        var nodes = this.game.getMoveNodes(fromMove, toMove);\n        var move = fromMove;\n\n        //Loop nodes\n        angular.forEach(nodes, function(node) {\n          this.board.add('markup', node.move.x, node.move.y, {\n            type: MarkupTypes.LABEL,\n            text: move++\n          });\n        }, this);\n\n        //Redraw board markup\n        this.board.redraw('markup');\n      },\n\n      /*****************************************************************************\n       * Game handling\n       ***/\n\n      /**\n       * Start a new game\n       */\n      newGame: function() {\n        this.game = new Game();\n        this.processPosition();\n      },\n\n      /**\n       * Score the current game position\n       */\n      scoreGame: function() {\n\n        //Calculate score\n        GameScorer.calculate();\n\n        //Get score, points and captures\n        var score = GameScorer.getScore();\n        var points = GameScorer.getPoints();\n        var captures = GameScorer.getCaptures();\n\n        //Remove all markup, and set captures and points\n        this.board.layers.markup.removeAll();\n        this.board.layers.score.setAll(points, captures);\n\n        //Broadcast score\n        this.broadcast('scoreCalculated', score);\n      },\n\n      /*****************************************************************************\n       * Board handling\n       ***/\n\n      /**\n       * Get the board\n       */\n      getBoard: function() {\n        return this.board;\n      },\n\n      /**\n       * Set the board\n       */\n      setBoard: function(Board) {\n\n        //Set the board\n        this.board = Board;\n\n        //Board ready\n        if (this.board) {\n          this.broadcast('boardReady', this.board);\n        }\n\n        //If a game has been loaded already, parse config and update the board\n        if (this.game && this.game.isLoaded()) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Update the board\n       */\n      updateBoard: function(node, position, pathChanged) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Update board with new position\n        this.board.updatePosition(position, pathChanged);\n\n        //Mark last move\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\n        }\n\n        //Broadcast board update event\n        this.broadcast('boardUpdate', node);\n      },\n\n      /*****************************************************************************\n       * Event handling\n       ***/\n\n      /**\n       * Register an element event\n       */\n      registerElementEvent: function(event, element) {\n\n        //Which element to use\n        if (typeof element === 'undefined' || !element.on) {\n          element = this.element;\n        }\n\n        //Remove any existing event listener and apply new one\n        //TODO: Namespacing events doesn't work with Angular's jqLite\n        element.off(event/* + '.ngGo.player'*/);\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\n      },\n\n      /**\n       * Event listener\n       */\n      on: function(type, listener, mode, $scope) {\n\n        //Must have valid listener\n        if (typeof listener !== 'function') {\n          console.warn('Listener is not a function:', listener);\n          return;\n        }\n\n        //Scope given as 3rd parameter?\n        if (mode && mode.$parent) {\n          $scope = mode;\n          mode = '';\n        }\n\n        //Multiple events?\n        if (type.indexOf(' ') !== -1) {\n          var types = type.split(' ');\n          for (var t = 0; t < types.length; t++) {\n            this.on(types[t], listener, mode, $scope);\n          }\n          return;\n        }\n\n        //Get self and determine scope to use\n        var self = this;\n        var scope = $scope || $rootScope;\n\n        //Create listener and return de-registration function\n        return scope.$on('ngGo.player.' + type, function() {\n\n          //Filter on mode\n          if (mode) {\n            if (\n              (typeof mode === 'string' && mode !== self.mode) ||\n              mode.indexOf(self.mode) === -1\n            ) {\n              return;\n            }\n          }\n\n          //Inside a text field?\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\n            return;\n          }\n\n          //Append grid coordinates for mouse events\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\n            processMouseEvent.call(self, arguments[0], arguments[1]);\n          }\n\n          //Dragging? Prevent click events from firing\n          if (self.preventClickEvent && type === 'click') {\n            delete self.preventClickEvent;\n            return;\n          }\n          else if (type === 'mousedrag') {\n            self.preventClickEvent = true;\n          }\n\n          //Call listener\n          listener.apply(self, arguments);\n        });\n      },\n\n      /**\n       * Event broadcaster\n       */\n      broadcast: function(type, args) {\n\n        //Must have type\n        if (!type) {\n          return;\n        }\n\n        //Make sure we are in a digest cycle\n        if (!$rootScope.$$phase) {\n          $rootScope.$apply(function() {\n            $rootScope.$broadcast('ngGo.player.' + type, args);\n          });\n        }\n        else {\n          $rootScope.$broadcast('ngGo.player.' + type, args);\n        }\n      }\n    };\n\n    //Initialize\n    Player.init();\n\n    //Return object\n    return Player;\n  }];\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\n * gridlines, starpoints and coordinates via the Coordinates class.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Coordinates.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GridLayer', ['BoardLayer', 'Coordinates', function(BoardLayer, Coordinates) {\n\n  /**\n   * Helper for drawing starpoints\n   */\n  var drawStarPoint = function(gridX, gridY, starRadius, starColor) {\n\n    //Don't draw if it falls outsize of the board grid\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\n      return;\n    }\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\n      return;\n    }\n\n    //Get absolute coordinates and star point radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n\n    //Draw star point\n    this.context.beginPath();\n    this.context.fillStyle = starColor;\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\n    this.context.fill();\n  };\n\n  /**\n   * Constructor\n   */\n  var GridLayer = function(board, context) {\n\n    //Set coordinates setting\n    this.coordinates = false;\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Show or hide the coordinates.\n   */\n  GridLayer.prototype.setCoordinates = function(show) {\n    this.coordinates = show;\n  };\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Get all has nothing to return\n   */\n  GridLayer.prototype.getAll = function() {\n    return null;\n  };\n\n  /**\n   * Set all has nothing to set\n   */\n  GridLayer.prototype.setAll = function(/*grid*/) {\n    return;\n  };\n\n  /**\n   * Remove all has nothing to remove\n   */\n  GridLayer.prototype.removeAll = function() {\n    return;\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw method\n   */\n  GridLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Determine top x and y margin\n    var tx = this.board.drawMarginHor;\n    var ty = this.board.drawMarginVer;\n\n    //Get theme properties\n    var cellSize = this.board.getCellSize();\n    var lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\n    var lineCap = this.board.theme.get('grid.lineCap');\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', cellSize);\n    var starColor = this.board.theme.get('grid.star.color');\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n    this.context.strokeStyle = strokeStyle;\n\n    //Helper vars\n    var i, x, y;\n\n    //Draw vertical lines\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\n      x = this.board.getAbsX(i);\n      this.context.moveTo(x, ty);\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\n    }\n\n    //Draw horizontal lines\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\n      y = this.board.getAbsY(i);\n      this.context.moveTo(tx, y);\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\n    }\n\n    //Draw grid lines\n    this.context.stroke();\n\n    //Star points defined?\n    for (i = 0; i < starPoints.length; i++) {\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n\n    //Draw coordinates\n    if (this.coordinates) {\n      Coordinates.draw.call(this);\n    }\n  };\n\n  /**\n   * Clear a square cell area on the grid\n   */\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Clear rectangle\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Redraw a square cell area on the grid\n   */\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', s);\n    var starColor = this.board.theme.get('grid.star.color');\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n\n    //Determine draw coordinates\n    var x1 = (gridX === 0) ? x : x - r;\n    var x2 = (gridX === this.board.width - 1) ? x : x + r;\n    var y1 = (gridY === 0) ? y : y - r;\n    var y2 = (gridY === this.board.height - 1) ? y : y + r;\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Patch up grid lines\n    this.context.moveTo(x1, y);\n    this.context.lineTo(x2, y);\n    this.context.moveTo(x, y1);\n    this.context.lineTo(x, y2);\n    this.context.stroke();\n\n    //Check if we need to draw a star point here\n    for (var i in starPoints) {\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\n      }\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  //Return\n  return GridLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('HoverLayer', ['BoardLayer', 'Markup', 'StoneFaded', function(BoardLayer, Markup, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var HoverLayer = function(board, context) {\n\n    //Container for items to restore\n    this.restore = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add hover item\n   */\n  HoverLayer.prototype.add = function(x, y, hover) {\n\n    //Validate coordinates\n    if (!this.grid.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Remove any previous item at this position\n    this.remove(x, y);\n\n    //Create hover object\n    hover.object = {\n      x: x,\n      y: y\n    };\n\n    //Stones\n    if (hover.type === 'stones') {\n      hover.objectClass = StoneFaded;\n      hover.object.color = hover.value;\n    }\n\n    //Markup\n    else if (hover.type === 'markup') {\n      hover.objectClass = Markup;\n      if (typeof hover.value === 'object') {\n        hover.object = angular.extend(hover.object, hover.value);\n      }\n      else {\n        hover.object.type = hover.value;\n      }\n    }\n\n    //Unknown\n    else {\n      console.warn('Unknown hover type', hover.type);\n      return;\n    }\n\n    //Check if we need to hide something on layers underneath\n    if (this.board.has(hover.type, x, y)) {\n      this.restore.push({\n        x: x,\n        y: y,\n        layer: hover.type,\n        value: this.board.get(hover.type, x, y)\n      });\n      this.board.remove(hover.type, x, y);\n    }\n\n    //Add to stack\n    this.grid.set(x, y, hover);\n\n    //Draw item\n    if (hover.objectClass && hover.objectClass.draw) {\n      hover.objectClass.draw.call(this, hover.object);\n    }\n  };\n\n  /**\n   * Remove the hover object\n   */\n  HoverLayer.prototype.remove = function(x, y) {\n\n    //Validate coordinates\n    if (!this.grid.has(x, y)) {\n      return;\n    }\n\n    //Get object and clear it\n    var hover = this.grid.get(x, y);\n    if (hover.objectClass && hover.objectClass.clear) {\n      hover.objectClass.clear.call(this, hover.object);\n    }\n\n    //Other objects to restore?\n    for (var i = 0; i < this.restore.length; i++) {\n      if (this.restore[i].x === x && this.restore[i].y === y) {\n        this.board.add(\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n        );\n        this.restore.splice(i, 1);\n      }\n    }\n  };\n\n  /**\n   * Remove all hover objects\n   */\n  HoverLayer.prototype.removeAll = function() {\n\n    //Anything to do?\n    if (this.grid.isEmpty()) {\n      return;\n    }\n\n    //Get all item as objects\n    var i;\n    var hover = this.grid.all('layer');\n\n    //Clear them\n    for (i = 0; i < hover.length; i++) {\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\n        hover[i].objectClass.clear.call(this, hover[i].object);\n      }\n    }\n\n    //Clear layer and empty grid\n    this.clear();\n    this.grid.empty();\n\n    //Restore objects on other layers\n    for (i = 0; i < this.restore.length; i++) {\n      this.board.add(\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n      );\n    }\n\n    //Clear restore array\n    this.restore = [];\n  };\n\n  /**\n   * Draw layer\n   */\n  HoverLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Loop objects and clear them\n    var hover = this.grid.all('hover');\n    for (var i = 0; i < hover.length; i++) {\n      if (hover.objectClass && hover.objectClass.draw) {\n        hover.objectClass.draw.call(this, hover.object);\n      }\n    }\n  };\n\n  //Return\n  return HoverLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('MarkupLayer', ['BoardLayer', 'Markup', function(BoardLayer, Markup) {\n\n  /**\n   * Constructor\n   */\n  var MarkupLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all markup at once\n   */\n  MarkupLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'type');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Markup.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Markup.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  MarkupLayer.prototype.removeAll = function() {\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Clear them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.clear.call(this, markup[i]);\n    }\n\n    //Empty the grid now\n    this.grid.empty();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  MarkupLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Draw them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.draw.call(this, markup[i]);\n    }\n  };\n\n  /**\n   * Draw cell\n   */\n  MarkupLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  MarkupLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  //Return\n  return MarkupLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ScoreLayer', ['BoardLayer', 'StoneMini', 'StoneFaded', function(BoardLayer, StoneMini, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var ScoreLayer = function(board, context) {\n\n    //Points and captures\n    this.points = [];\n    this.captures = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set points and captures\n   */\n  ScoreLayer.prototype.setAll = function(points, captures) {\n\n    //Remove all existing stuff first\n    this.removeAll();\n\n    //Set new stuff\n    this.points = points.all('color');\n    this.captures = captures.all('color');\n\n    //Draw\n    this.draw();\n  };\n\n  /**\n   * Remove all scoring\n   */\n  ScoreLayer.prototype.removeAll = function() {\n\n    //If there are captures, draw them back onto the stones layer\n    for (var i = 0; i < this.captures.length; i++) {\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\n    }\n\n    //Clear the layer\n    this.clear();\n\n    //Remove all stuff\n    this.points = [];\n    this.captures = [];\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  ScoreLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Init\n    var i;\n\n    //Draw captures first (removing stones from the stones layer)\n    for (i = 0; i < this.captures.length; i++) {\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\n      StoneFaded.draw.call(this, this.captures[i]);\n    }\n\n    //Draw points on top of it\n    for (i = 0; i < this.points.length; i++) {\n      StoneMini.draw.call(this, this.points[i]);\n    }\n  };\n\n  //Return\n  return ScoreLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneShadow.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ShadowLayer', ['BoardLayer', 'StoneShadow', function(BoardLayer, StoneShadow) {\n\n  /**\n   * Constructor\n   */\n  var ShadowLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add a stone\n   */\n  ShadowLayer.prototype.add = function(stone) {\n\n    //Don't add if no shadow\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\n      return;\n    }\n\n    //Already have a stone here?\n    if (this.grid.has(stone.x, stone.y)) {\n      return;\n    }\n\n    //Add to grid\n    this.grid.set(stone.x, stone.y, stone.color);\n\n    //Draw it if there is a context\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\n      StoneShadow.draw.call(this, stone);\n    }\n  };\n\n  /**\n   * Remove a stone\n   */\n  ShadowLayer.prototype.remove = function(stone) {\n\n    //Remove from grid\n    this.grid.unset(stone.x, stone.y);\n\n    //Redraw whole layer\n    this.redraw();\n  };\n\n  /**\n   * Draw layer\n   */\n  ShadowLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get shadowsize from theme\n    var shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\n\n    //Apply shadow transformation\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      StoneShadow.draw.call(this, stones[i]);\n    }\n  };\n\n  //Return\n  return ShadowLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StonesLayer', ['BoardLayer', 'Stone', 'StoneColor', function(BoardLayer, Stone, StoneColor) {\n\n  /**\n   * Constructor\n   */\n  var StonesLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n\n    //Set empty value for grid\n    this.grid.whenEmpty(StoneColor.EMPTY);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all stones at once\n   */\n  StonesLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'color');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Stone.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Stone.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  StonesLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      Stone.draw.call(this, stones[i]);\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  StonesLayer.prototype.redraw = function() {\n\n    //Clear shadows layer\n    this.board.removeAll('shadow');\n\n    //Redraw ourselves\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  StonesLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  StonesLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  //Return\n  return StonesLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Coordinates :: This class is used for drawing board coordinates\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Coordinates.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('Coordinates', function() {\n\n  //Kanji\n  var kanji = [\n    '一', '二', '三', '四', '五', '六', '七', '八', '九', '十',\n    '十一', '十二', '十三', '十四', '十五', '十六', '十七', '十八', '十九', '二十',\n    '二十一', '二十二', '二十三', '二十四', '二十五', '二十六', '二十七', '二十八', '二十九', '三十',\n    '三十一', '三十二', '三十三', '三十四', '三十五', '三十六', '三十七', '三十八', '三十九', '四十'\n  ];\n\n  //Character codes\n  var aChar = 'A'.charCodeAt(0);\n  var aCharLc = 'a'.charCodeAt(0);\n\n  /**\n   * Coordinate generators\n   */\n  var coordinates = {\n\n    //Kanji coordinates\n    kanji: function(i) {\n      return kanji[i] || '';\n    },\n\n    //Numbers from 1\n    numbers: function(i) {\n      return i + 1;\n    },\n\n    //Capital letters from A\n    letters: function(i) {\n\n      //Initialize\n      var ch = '';\n\n      //Beyond Z? Prepend with A\n      if (i >= 25) {\n        ch = 'A';\n        i -= 25;\n      }\n\n      //The letter I is ommitted\n      if (i >= 8) {\n        i++;\n      }\n\n      //Return\n      return ch + String.fromCharCode(aChar + i);\n    },\n\n    //JGF coordinates (e.g. 0, 1, ...)\n    jgf: function(i) {\n      return i;\n    },\n\n    //SGF coordinates (e.g. a, b, ...)\n    sgf: function(i) {\n      var ch;\n      if (i < 26) {\n        ch = aCharLc + i;\n      }\n      else {\n        ch = aChar + i;\n      }\n      return String.fromCharCode(ch);\n    }\n  };\n\n  /**\n   * Coordinates object\n   */\n  var Coordinates = {\n\n    /**\n     * Draw\n     */\n    draw: function() {\n\n      //Can only draw when we have context and dimensions\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Get cell size\n      var cellSize = this.board.getCellSize();\n\n      //Get boundary coordinates\n      var xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\n      var xr = this.board.drawWidth - xl;\n      var yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\n      var yb = this.board.drawHeight - yt;\n\n      //Get theme properties\n      var fillStyle = this.board.theme.get('coordinates.color');\n      var vertical = {\n        font: this.board.theme.get('coordinates.vertical.font'),\n        size: this.board.theme.get('coordinates.vertical.size'),\n        style: this.board.theme.get('coordinates.vertical.style'),\n        inverse: this.board.theme.get('coordinates.vertical.inverse')\n      };\n      var horizontal = {\n        font: this.board.theme.get('coordinates.horizontal.font'),\n        size: this.board.theme.get('coordinates.horizontal.size'),\n        style: this.board.theme.get('coordinates.horizontal.style'),\n        inverse: this.board.theme.get('coordinates.horizontal.inverse')\n      };\n\n      //Configure context\n      this.context.fillStyle = fillStyle;\n      this.context.textBaseline = 'middle';\n      this.context.textAlign = 'center';\n\n      //Helper vars\n      var i, j, x, y, ch;\n\n      //Draw vertical coordinates\n      for (i = 0; i < this.board.height; i++) {\n\n        //Inverse?\n        j = i;\n        if (vertical.inverse) {\n          j = this.board.height - i - 1;\n        }\n\n        //Get character\n        if (typeof vertical.style === 'function') {\n          ch = vertical.style.call(this, j);\n        }\n        else if (coordinates[vertical.style]) {\n          ch = coordinates[vertical.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        y = this.board.getAbsY(i);\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\n        this.context.fillText(ch, xl, y);\n        this.context.fillText(ch, xr, y);\n      }\n\n      //Draw horizontal coordinates\n      for (i = 0; i < this.board.width; i++) {\n\n        //Inverse?\n        j = i;\n        if (horizontal.inverse) {\n          j = this.board.width - i - 1;\n        }\n\n        //Get character\n        if (typeof horizontal.style === 'function') {\n          ch = horizontal.style.call(this, j);\n        }\n        else if (coordinates[horizontal.style]) {\n          ch = coordinates[horizontal.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        x = this.board.getAbsX(i);\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\n        this.context.fillText(ch, x, yt);\n        this.context.fillText(ch, x, yb);\n      }\n    }\n  };\n\n  //Return\n  return Coordinates;\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Markup :: This class is used for drawing markup\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Markup.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Markup', ['MarkupTypes', 'BoardObject', function(MarkupTypes, BoardObject) {\n\n  /**\n   * Math constants\n   */\n  var cosPi4 = Math.cos(Math.PI / 4);\n  var cosPi6 = Math.cos(Math.PI / 6);\n\n  /**\n   * Triangle draw handler\n   */\n  var drawTriangle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y - r);\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.closePath();\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Square draw handler\n   */\n  var drawSquare = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw circle handler\n   */\n  var drawCircle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw mark handler\n   */\n  var drawMark = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x - rcos, y - rcos);\n    this.context.lineTo(x + rcos, y + rcos);\n    this.context.moveTo(x + rcos, y - rcos);\n    this.context.lineTo(x - rcos, y + rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw select handler\n   */\n  var drawSelect = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Last move draw handler\n   */\n  var drawLast = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(s);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y);\n    this.context.lineTo(x + r, y);\n    this.context.lineTo(x, y + r);\n    this.context.closePath();\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw happy smiley handler\n   */\n  var drawHappySmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 8);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw sad smiley handler\n   */\n  var drawSadSmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw label\n   */\n  var drawLabel = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var font = markup.font || this.board.theme.get('markup.label.font') || '';\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //First, clear grid square below for clarity\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.clearCell(markup.x, markup.y);\n    }\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.textBaseline = 'middle';\n    this.context.textAlign = 'center';\n\n    //Convert to text\n    if (typeof markup.text === 'number') {\n      markup.text = markup.text.toString();\n    }\n\n    //Determine font size\n    if (markup.text.length === 1) {\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\n    }\n    else if (markup.text.length === 2) {\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\n    }\n    else {\n      this.context.font = r + 'px ' + font;\n    }\n\n    //Draw element\n    this.context.beginPath();\n    this.context.fillText(markup.text, x, y, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Clear label\n   */\n  var clearLabel = function(markup) {\n\n    //No stone on location? Redraw the grid square, if we cleared it\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\n    }\n  };\n\n  /**\n   * Markup class\n   */\n  var Markup = {\n\n    /**\n     * Draw\n     */\n    draw: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Drawing depends on type\n      switch (markup.type) {\n\n        //Triangle\n        case MarkupTypes.TRIANGLE:\n          drawTriangle.call(this, markup);\n          break;\n\n        //Square\n        case MarkupTypes.SQUARE:\n          drawSquare.call(this, markup);\n          break;\n\n        //Circle\n        case MarkupTypes.CIRCLE:\n          drawCircle.call(this, markup);\n          break;\n\n        //Mark\n        case MarkupTypes.MARK:\n          drawMark.call(this, markup);\n          break;\n\n        //Select\n        case MarkupTypes.SELECT:\n          drawSelect.call(this, markup);\n          break;\n\n        //happy\n        case MarkupTypes.HAPPY:\n          drawHappySmiley.call(this, markup);\n          break;\n\n        //Sad\n        case MarkupTypes.SAD:\n          drawSadSmiley.call(this, markup);\n          break;\n\n        //Last move marker\n        case MarkupTypes.LAST:\n          drawLast.call(this, markup);\n          break;\n\n        //Label\n        case MarkupTypes.LABEL:\n          markup.text = markup.text || '';\n          drawLabel.call(this, markup);\n          break;\n      }\n    },\n\n    /**\n     * Clear\n     */\n    clear: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, markup);\n\n      //Special handling for label\n      if (markup.type === MarkupTypes.LABEL) {\n        clearLabel.call(this, markup);\n      }\n    }\n  };\n\n  //Return\n  return Markup;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Stone :: This class is used for drawing stones on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Stone.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n  'ngGo.Board.ShellPattern.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Stone', ['$injector', 'BoardObject', 'StoneColor', 'ShellPattern', function($injector, BoardObject, StoneColor, ShellPattern) {\n\n  /**\n   * Shell random seed\n   */\n  var shellSeed;\n\n  /**\n   * Mono colored stones\n   */\n  var drawMono = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Don't draw shadow\n    stone.shadow = false;\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\n    var fillStyle = this.board.theme.get('stone.mono.color', color);\n    var strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Configure context\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Draw outline\n    this.context.stroke();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Glass stones\n   */\n  var drawGlass = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Begin path\n    this.context.beginPath();\n\n    //Determine stone texture\n    if (color === StoneColor.W) {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#fff');\n      this.context.fillStyle.addColorStop(1, '#aaa');\n    }\n    else {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#666');\n      this.context.fillStyle.addColorStop(1, '#111');\n    }\n\n    //Complete drawing\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Slate and shell stones\n   */\n  var drawSlateShell = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Get random seed\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var shellTypes = this.board.theme.get('stone.shell.types');\n    var fillStyle = this.board.theme.get('stone.shell.color', color);\n    var strokeStyle = this.board.theme.get('stone.shell.stroke');\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fillStyle = fillStyle;\n    this.context.fill();\n\n    //Shell stones\n    if (color === StoneColor.W) {\n\n      //Get random shell type\n      var type =\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\n\n      //Determine random angle\n      var z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\n      var angle = (2 / z) * (shellSeed % z);\n\n      //Draw shell pattern\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Slate stones\n    else {\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Constructor\n   */\n  var Stone = {\n\n    /**\n     * Draw a stone\n     */\n    draw: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Determine style of stone\n      var style = this.board.theme.get('stone.style');\n\n      //Draw using the appropriate handler\n      switch (style) {\n\n        //Slate and shell\n        case 'shell':\n          drawSlateShell.call(this, stone);\n          break;\n\n        //Glass stones\n        case 'glass':\n          drawGlass.call(this, stone);\n          break;\n\n        //Mono stones\n        case 'mono':\n          drawMono.call(this, stone);\n          break;\n\n        //Custom type\n        default:\n          var handler = $injector.get(style);\n          if (handler) {\n            handler.call(this, stone);\n          }\n      }\n\n      //Add shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.add(stone);\n      }\n    },\n\n    /**\n     * Clear a stone\n     */\n    clear: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, stone);\n\n      //Remove shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.remove(stone);\n      }\n    }\n  };\n\n  //Return\n  return Stone;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneFaded', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneFaded = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.faded.scale');\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneFaded;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\n * (for scoring).\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneMini.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneMini', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneMini = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.mini.scale');\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneMini;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneShadow :: This class is used for drawing stone shadows on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneShadow', function() {\n\n  /**\n   * Constructor\n   */\n  var StoneShadow = {\n\n    /**\n     * Draw a stone shadow\n     */\n    draw: function(stone) {\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\n\n      //Apply scaling factor?\n      if (stone.scale) {\n        r = Math.round(r * stone.scale);\n      }\n\n      //Get theme properties\n      var blur = this.board.theme.get('shadow.blur', s);\n      var offsetX = this.board.theme.get('shadow.offsetX', s);\n      var offsetY = this.board.theme.get('shadow.offsetY', s);\n      var shadowColor = this.board.theme.get('shadow.color');\n\n      //Configure context\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\n      );\n      this.context.fillStyle.addColorStop(0, shadowColor);\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n\n      //Draw shadow\n      this.context.beginPath();\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\n      this.context.fill();\n    },\n\n    /**\n     * Clear a stone shadow\n     */\n    clear: function(stone) {\n\n      //Note: this method is currently not in use due to the overlapping shadows\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\n      //appropriate either, so for now we will leave it at this.\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = this.board.theme.get('stone.radius', s);\n\n      //Clear a generous rectangle\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\n    }\n  };\n\n  //Return\n  return StoneShadow;\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Gib2Jgf', ['ngGo', 'KifuBlank', function(ngGo, KifuBlank) {\n\n  /**\n   * Regular expressions\n   */\n  var regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\n  var regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\n  var regKomi = /GAMEGONGJE=([0-9]+)/gi;\n  var regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\n  var regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\n  var regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\n\n  /**\n   * Player parser function\n   */\n  var parsePlayer = function(jgf, match) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\n\n    //Create player object\n    var player = {\n      color: color,\n      name: match[2],\n      rank: match[3].toLowerCase()\n    };\n\n    //Check if player of this color already exists, if so, overwrite\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p] = player;\n        return;\n      }\n    }\n\n    //Player of this color not found, push\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, match) {\n    jgf.game.komi = parseFloat(match[1] / 10);\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, match) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Push date\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\n  };\n\n  /**\n   * Result parser function\n   */\n  var parseResult = function(jgf, match) {\n\n    //Winner color\n    var result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\n    result += '+';\n\n    //Win condition\n    if (match[2].match(/res/i)) {\n      result += 'R';\n    }\n    else if (match[2].match(/time/i)) {\n      result += 'T';\n    }\n    else {\n      result += match[2];\n    }\n\n    //Set in JGF\n    jgf.game.result = result;\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, match) {\n\n    //Determine player color\n    var color = match[2];\n    if (color === 1) {\n      color = 'B';\n    }\n    else if (color === 2) {\n      color = 'W';\n    }\n    else {\n      return;\n    }\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (false) {\n\n    }\n\n    //Regular move\n    else {\n      node.move[color] = [match[3] * 1, match[4] * 1];\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    parse: function(gib, stringified) {\n\n      //Get new JGF object\n      var jgf = KifuBlank.jgf();\n\n      //Initialize\n      var match;\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find player information\n      while ((match = regPlayer.exec(gib))) {\n        parsePlayer(jgf, match);\n      }\n\n      //Find komi\n      if ((match = regKomi.exec(gib))) {\n        parseKomi(jgf, match);\n      }\n\n      //Find game date\n      if ((match = regDate.exec(gib))) {\n        parseDate(jgf, match);\n      }\n\n      //Find game result\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\n        parseResult(jgf, match);\n      }\n\n      //Find moves\n      while ((match = regMove.exec(gib))) {\n\n        //Create new node\n        node = {};\n\n        //Parse move\n        parseMove(jgf, node, match);\n\n        //Push node to container\n        container.push(node);\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Jgf2Sgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Flip SGF alias map and create JGF alias map\n   */\n  var jgfAliases = {};\n  for (var sgfProp in sgfAliases) {\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\n    }\n  }\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert to SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Helper to escape SGF info\n   */\n  var escapeSgf = function(text) {\n    if (typeof text === 'string') {\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\n    }\n    return text;\n  };\n\n  /**\n   * Helper to write an SGF group\n   */\n  var writeGroup = function(prop, values, output, escape) {\n    if (values.length) {\n      output.sgf += prop;\n      for (var i = 0; i < values.length; i++) {\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\n      }\n    }\n  };\n\n  /**\n   * Move parser\n   */\n  var parseMove = function(move, output) {\n\n    //Determine and validate color\n    var color = move.B ? 'B' : (move.W ? 'W' : '');\n    if (color === '') {\n      return;\n    }\n\n    //Determine move\n    var coords = (move[color] === 'pass') ? '' : move[color];\n\n    //Append to SGF\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\n  };\n\n  /**\n   * Setup parser\n   */\n  var parseSetup = function(setup, output) {\n\n    //Loop colors\n    for (var color in setup) {\n      if (setup.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < setup[color].length; i++) {\n          setup[color][i] = convertCoordinates(setup[color][i]);\n        }\n\n        //Write as group\n        writeGroup('A' + color, setup[color], output);\n      }\n    }\n  };\n\n  /**\n   * Score parser\n   */\n  var parseScore = function(score, output) {\n\n    //Loop colors\n    for (var color in score) {\n      if (score.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < score[color].length; i++) {\n          score[color][i] = convertCoordinates(score[color][i]);\n        }\n\n        //Write as group\n        writeGroup('T' + color, score[color], output);\n      }\n    }\n  };\n\n  /**\n   * Markup parser\n   */\n  var parseMarkup = function(markup, output) {\n\n    //Loop markup types\n    for (var type in markup) {\n      if (markup.hasOwnProperty(type)) {\n        var i;\n\n        //Label type has the label text appended to the coords\n        if (type === 'label') {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\n          }\n        }\n        else {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]);\n          }\n        }\n\n        //Convert type\n        if (typeof jgfAliases[type] !== 'undefined') {\n          type = jgfAliases[type];\n        }\n\n        //Write as group\n        writeGroup(type, markup[type], output);\n      }\n    }\n  };\n\n  /**\n   * Turn parser\n   */\n  var parseTurn = function(turn, output) {\n    output.sgf += 'PL[' + turn + ']';\n  };\n\n  /**\n   * Comments parser\n   */\n  var parseComments = function(comments, output) {\n\n    //Determine key\n    var key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\n\n    //Flatten comment objects\n    var flatComments = [];\n    for (var c = 0; c < comments.length; c++) {\n      if (typeof comments[c] === 'string') {\n        flatComments.push(comments[c]);\n      }\n      else if (comments[c].comment) {\n        flatComments.push(comments[c].comment);\n      }\n    }\n\n    //Write as group\n    writeGroup(key, flatComments, output, true);\n  };\n\n  /**\n   * Node name parser\n   */\n  var parseNodeName = function(nodeName, output) {\n    var key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\n  };\n\n  /**\n   * Game parser\n   */\n  var parseGame = function(game) {\n\n    //Loop SGF game definitions\n    for (var i in sgfGames) {\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\n        return i;\n      }\n    }\n\n    //Not found\n    return 0;\n  };\n\n  /**\n   * Application parser\n   */\n  var parseApplication = function(application) {\n    var parts = application.split(' v');\n    if (parts.length > 1) {\n      return parts[0] + ':' + parts[1];\n    }\n    return application;\n  };\n\n  /**\n   * Player instructions parser\n   */\n  var parsePlayer = function(player, rootProperties) {\n\n    //Variation handling\n    var st = 0;\n    if (!player.variationMarkup) {\n      st += 2;\n    }\n    if (player.variationSiblings) {\n      st += 1;\n    }\n\n    //Set in root properties\n    rootProperties.ST = st;\n  };\n\n  /**\n   * Board parser\n   */\n  var parseBoard = function(board, rootProperties) {\n\n    //Both width and height should be given\n    if (board.width && board.height) {\n\n      //Same dimensions?\n      if (board.width === board.height) {\n        rootProperties.SZ = board.width;\n      }\n\n      //Different dimensions are not supported by SGF, but OGS uses the\n      //format w:h, so we will stick with that for anyone who supports it.\n      else {\n        rootProperties.SZ = board.width + ':' + board.height;\n      }\n    }\n\n    //Otherwise, check if only width or height were given at least\n    else if (board.width) {\n      rootProperties.SZ = board.width;\n    }\n    else if (board.height) {\n      rootProperties.SZ = board.height;\n    }\n\n    //Can't determine size\n    else {\n      rootProperties.SZ = '';\n    }\n  };\n\n  /**\n   * Players parser\n   */\n  var parsePlayers = function(players, rootProperties) {\n\n    //Loop players\n    for (var p = 0; p < players.length; p++) {\n\n      //Validate color\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\n        continue;\n      }\n\n      //Get SGF color\n      var color = (players[p].color === 'black') ? 'B' : 'W';\n\n      //Name given?\n      if (players[p].name) {\n        rootProperties['P' + color] = players[p].name;\n      }\n\n      //Rank given?\n      if (players[p].rank) {\n        rootProperties[color + 'R'] = players[p].rank;\n      }\n\n      //Team given?\n      if (players[p].team) {\n        rootProperties[color + 'T'] = players[p].team;\n      }\n    }\n  };\n\n  /**\n   * Parse function to property mapper\n   */\n  var parsingMap = {\n\n    //Node properties\n    'move': parseMove,\n    'setup': parseSetup,\n    'score': parseScore,\n    'markup': parseMarkup,\n    'turn': parseTurn,\n    'comments': parseComments,\n    'name': parseNodeName,\n\n    //Info properties\n    'record.application': parseApplication,\n    'player': parsePlayer,\n    'board': parseBoard,\n    'game.type': parseGame,\n    'game.players': parsePlayers\n  };\n\n  /*****************************************************************************\n   * Parser functions\n   ***/\n\n  /**\n   * Helper to write a JGF tree to SGF\n   */\n  var writeTree = function(tree, output) {\n\n    //Loop nodes in the tree\n    for (var i = 0; i < tree.length; i++) {\n      var node = tree[i];\n\n      //Array? That means a variation\n      if (angular.isArray(node)) {\n        for (var j = 0; j < node.length; j++) {\n          output.sgf += '(\\n;';\n          writeTree(node[j], output);\n          output.sgf += '\\n)';\n        }\n\n        //Continue\n        continue;\n      }\n\n      //Loop node properties\n      for (var key in node) {\n        if (node.hasOwnProperty(key)) {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[key] !== 'undefined') {\n            parsingMap[key](node[key], output);\n            continue;\n          }\n\n          //Other object, can't handle it\n          if (typeof node[key] === 'object') {\n            continue;\n          }\n\n          //Anything else, append it\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\n        }\n      }\n\n      //More to come?\n      if ((i + 1) < tree.length) {\n        output.sgf += '\\n;';\n      }\n    }\n  };\n\n  /**\n   * Helper to extract all SGF root properties from a JGF object\n   */\n  var extractRootProperties = function(jgf, rootProperties, key) {\n\n    //Initialize key\n    if (typeof key === 'undefined') {\n      key = '';\n    }\n\n    //Loop properties of jgf node\n    for (var subKey in jgf) {\n      if (jgf.hasOwnProperty(subKey)) {\n\n        //Skip SGF signature (as we keep our own)\n        if (subKey === 'sgf') {\n          continue;\n        }\n\n        //Build jgf key\n        var jgfKey = (key === '') ? subKey : key + '.' + subKey;\n\n        //If the item is an object, handle separately\n        if (typeof jgf[subKey] === 'object') {\n\n          //Handler for this object present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\n          }\n\n          //Otherwise, just flatten and call this function recursively\n          else {\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\n          }\n          continue;\n        }\n\n        //Check if it's a known key, if so, append the value to the root\n        var value;\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            value = parsingMap[jgfKey](jgf[subKey]);\n          }\n          else {\n            value = escapeSgf(jgf[subKey]);\n          }\n\n          //Set in root properties\n          rootProperties[jgfAliases[jgfKey]] = value;\n        }\n      }\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    parse: function(jgf) {\n\n      //String given?\n      if (typeof jgf === 'string') {\n        jgf = angular.fromJson(jgf);\n      }\n\n      //Must have moves tree\n      if (!jgf.tree) {\n        console.error('No moves tree in JGF object');\n        return;\n      }\n\n      //Initialize output (as object, so it remains a reference) and root properties container\n      var output = {sgf: '(\\n;'};\n      var root = angular.copy(jgf);\n      var rootProperties = KifuBlank.sgf();\n\n      //The first node of the JGF tree is the root node, and it can contain comments,\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\n      //and attach it to the root\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\n        root = angular.extend(root, jgf.tree[0]);\n        delete root.root;\n        delete jgf.tree[0];\n      }\n\n      //Set root properties\n      delete root.tree;\n      extractRootProperties(root, rootProperties);\n\n      //Write root properties\n      for (var key in rootProperties) {\n        if (rootProperties[key]) {\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\n        }\n      }\n\n      //Write game tree\n      writeTree(jgf.tree, output);\n\n      //Close SGF and return\n      output.sgf += ')';\n      return output.sgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Sgf2Jgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Regular expressions for SGF data\n   */\n  var regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\n  var regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\n  var regProperty = /[A-Z]+/;\n  var regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Application parser function (doesn't overwrite existing signature)\n   */\n  var parseApp = function(jgf, node, key, value) {\n    if (!jgf.record.application) {\n      var app = value[0].split(':');\n      if (app.length > 1) {\n        jgf.record.application = app[0] + ' v' + app[1];\n      }\n      else {\n        jgf.record.application = app[0];\n      }\n    }\n  };\n\n  /**\n   * SGF format parser\n   */\n  var parseSgfFormat = function() {\n    return;\n  };\n\n  /**\n   * Game type parser function\n   */\n  var parseGame = function(jgf, node, key, value) {\n    var game = value[0];\n    if (typeof sgfGames[game] !== 'undefined') {\n      jgf.game.type = sgfGames[game];\n    }\n    else {\n      jgf.game.type = value[0];\n    }\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, key, value) {\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\n      node.move[key] = 'pass';\n    }\n\n    //Regular move\n    else {\n      node.move[key] = convertCoordinates(value[0]);\n    }\n  };\n\n  /**\n   * Comment parser function\n   */\n  var parseComment = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Node name parser function\n   */\n  var parseNodeName = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value[0];\n  };\n\n  /**\n   * Board setup parser function\n   */\n  var parseSetup = function(jgf, node, key, value) {\n\n    //Initialize setup container on node\n    if (typeof node.setup === 'undefined') {\n      node.setup = {};\n    }\n\n    //Remove \"A\" from setup key\n    key = key.charAt(1);\n\n    //Initialize setup container of this type\n    if (typeof node.setup[key] === 'undefined') {\n      node.setup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.setup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Scoring parser function\n   */\n  var parseScore = function(jgf, node, key, value) {\n\n    //Initialize score container on node\n    if (typeof node.score === 'undefined') {\n      node.score = {\n        B: [],\n        W: []\n      };\n    }\n\n    //Remove \"T\" from setup key\n    key = key.charAt(1);\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.score[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Turn parser function\n   */\n  var parseTurn = function(jgf, node, key, value) {\n    node.turn = value[0];\n  };\n\n  /**\n   * Label parser function\n   */\n  var parseLabel = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n\n      //Split off coordinates and add label contents\n      var coords = convertCoordinates(value[i].substr(0, 2));\n      coords.push(value[i].substr(3));\n\n      //Add to node\n      node.markup[key].push(coords);\n    }\n  };\n\n  /**\n   * Markup parser function\n   */\n  var parseMarkup = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.markup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Size parser function\n   */\n  var parseSize = function(jgf, node, key, value) {\n\n    //Initialize board container\n    if (typeof jgf.board === 'undefined') {\n      jgf.board = {};\n    }\n\n    //Add size property (can be width:height or just a single size)\n    var size = value[0].split(':');\n    if (size.length > 1) {\n      jgf.board.width = parseInt(size[0]);\n      jgf.board.height = parseInt(size[1]);\n    }\n    else {\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\n    }\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, node, key, value) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Explode dates\n    var dates = value[0].split(',');\n    for (var d = 0; d < dates.length; d++) {\n      jgf.game.dates.push(dates[d]);\n    }\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, node, key, value) {\n    jgf.game.komi = parseFloat(value[0]);\n  };\n\n  /**\n   * Variations handling parser function\n   */\n  var parseVariations = function(jgf, node, key, value) {\n\n    //Initialize display property\n    if (typeof jgf.player === 'undefined') {\n      jgf.player = {};\n    }\n\n    //Initialize variation display settings\n    jgf.player.variationMarkup = false;\n    jgf.player.variationChildren = false;\n    jgf.player.variationSiblings = false;\n\n    //Parse as integer\n    var st = parseInt(value[0]);\n\n    //Determine what we want (see SGF specs for details)\n    switch (st) {\n      case 0:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationChildren = true;\n        break;\n      case 1:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationSiblings = true;\n        break;\n      case 2:\n        jgf.player.variationChildren = true;\n        break;\n      case 3:\n        jgf.player.variationSiblings = true;\n        break;\n    }\n  };\n\n  /**\n   * Player info parser function\n   */\n  var parsePlayer = function(jgf, node, key, value) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Check if player of this color already exists\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p][key] = value[0];\n        return;\n      }\n    }\n\n    //Player of this color not found, initialize\n    var player = {color: color};\n    player[key] = value[0];\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Parsing function to property mapper\n   */\n  var parsingMap = {\n\n    //Application, game type, board size, komi, date\n    'AP': parseApp,\n    'FF': parseSgfFormat,\n    'GM': parseGame,\n    'SZ': parseSize,\n    'KM': parseKomi,\n    'DT': parseDate,\n\n    //Variations handling\n    'ST': parseVariations,\n\n    //Player info handling\n    'PB': parsePlayer,\n    'PW': parsePlayer,\n    'BT': parsePlayer,\n    'WT': parsePlayer,\n    'BR': parsePlayer,\n    'WR': parsePlayer,\n\n    //Moves\n    'B': parseMove,\n    'W': parseMove,\n\n    //Node annotation\n    'C': parseComment,\n    'N': parseNodeName,\n\n    //Board setup\n    'AB': parseSetup,\n    'AW': parseSetup,\n    'AE': parseSetup,\n    'PL': parseTurn,\n    'TW': parseScore,\n    'TB': parseScore,\n\n    //Markup\n    'CR': parseMarkup,\n    'SQ': parseMarkup,\n    'TR': parseMarkup,\n    'MA': parseMarkup,\n    'SL': parseMarkup,\n    'LB': parseLabel\n  };\n\n  /**\n   * These properties need a node object\n   */\n  var needsNode = [\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB'\n  ];\n\n  /*****************************************************************************\n   * Parser helpers\n   ***/\n\n  /**\n   * Set info in the JGF tree at a certain position\n   */\n  var setInfo = function(jgf, position, value) {\n\n    //Position given must be an array\n    if (typeof position !== 'object') {\n      return;\n    }\n\n    //Initialize node to attach value to\n    var node = jgf;\n    var key;\n\n    //Loop the position\n    for (var p = 0; p < position.length; p++) {\n\n      //Get key\n      key = position[p];\n\n      //Last key reached? Done\n      if ((p + 1) === position.length) {\n        break;\n      }\n\n      //Create container if not set\n      if (typeof node[key] !== 'object') {\n        node[key] = {};\n      }\n\n      //Move up in tree\n      node = node[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    parse: function(sgf, stringified) {\n\n      //Get new JGF object (with SGF node as a base)\n      var jgf = KifuBlank.jgf({record: {sgf: {}}});\n\n      //Initialize\n      var stack = [];\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find sequence of elements\n      var sequence = sgf.match(regSequence);\n\n      //Loop sequence items\n      for (var i = 0; i < sequence.length; i++) {\n\n        //Push stack if new variation found\n        if (sequence[i] === '(') {\n\n          //First encounter, this defines the main tree branch, so skip\n          if (i === 0 || i === '0') {\n            continue;\n          }\n\n          //Push the current container to the stack\n          stack.push(container);\n\n          //Create variation container if it doesn't exist yet\n          if (!angular.isArray(container[container.length - 1])) {\n            container.push([]);\n          }\n\n          //Use variation container\n          container = container[container.length - 1];\n\n          //Now create moves container\n          container.push([]);\n          container = container[container.length - 1];\n          continue;\n        }\n\n        //Grab last container from stack if end of variation reached\n        else if (sequence[i] === ')') {\n          if (stack.length) {\n            container = stack.pop();\n          }\n          continue;\n        }\n\n        //Make array of properties within this sequence\n        var properties = sequence[i].match(regNode) || [];\n\n        //Loop them\n        for (var j = 0; j < properties.length; j++) {\n\n          //Get property's key and separate values\n          var key = regProperty.exec(properties[j])[0].toUpperCase();\n          var values = properties[j].match(regValues);\n\n          //Remove additional braces [ and ]\n          for (var k = 0; k < values.length; k++) {\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\n          }\n\n          //SGF parser present for this key? Call it, and we're done\n          if (typeof parsingMap[key] !== 'undefined') {\n\n            //Does this type of property need a node?\n            if (needsNode.indexOf(key) !== -1) {\n\n              //If no node object present, create a new node\n              //For moves, always a new node is created\n              if (!node || key === 'B' || key === 'W') {\n                node = {};\n                container.push(node);\n              }\n            }\n\n            //Apply parsing function on node\n            parsingMap[key](jgf, node, key, values);\n            continue;\n          }\n\n          //No SGF parser present, we continue with regular property handling\n\n          //If there is only one value, simplify array\n          if (values.length === 1) {\n            values = values[0];\n          }\n\n          //SGF alias known? Then this is an info element and we handle it accordingly\n          if (typeof sgfAliases[key] !== 'undefined') {\n\n            //The position in the JGF object is represented by dot separated strings\n            //in the sgfAliases array. Split the position and use the setInfo helper\n            //to set the info on the JGF object\n            setInfo(jgf, sgfAliases[key].split('.'), values);\n            continue;\n          }\n\n          //No SGF alias present either, just append the data\n\n          //Save in node\n          if (node) {\n            node[key] = values;\n          }\n\n          //Save in root\n          else {\n            jgf[key] = values;\n          }\n        }\n\n        //Reset node, unless this was the root node\n        if (node && !node.root) {\n          node = null;\n        }\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeCommon :: This class governs common event handling of the player shared by\n * various player modes. It's basically an abstract player mode and it can't be actively set.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Common.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Run block\n */\n.run(['Player', 'PlayerModes', 'PlayerModeCommon', function(Player, PlayerModes, PlayerModeCommon) {\n\n  /**\n   * Register common event handlers\n   */\n  Player.on('keydown', PlayerModeCommon.keyDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n}])\n\n/**\n * Factory definition\n */\n.factory('PlayerModeCommon', ['Player', 'PlayerTools', 'GameScorer', 'KeyCodes', function(Player, PlayerTools, GameScorer, KeyCodes) {\n\n  /**\n   * Helper to build drag object\n   */\n  var dragObject = function(event) {\n\n    //Initialize drag object\n    var drag = {\n      start: {\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y\n      },\n      stop: {\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y\n      }\n    };\n\n    //Fix boundaries\n    if (drag.start.x < 0) {\n      drag.start.x = 0;\n    }\n    if (drag.start.y < 0) {\n      drag.start.y = 0;\n    }\n    if (drag.stop.x > this.board.width - 1) {\n      drag.stop.x = this.board.width - 1;\n    }\n    if (drag.stop.y > this.board.height - 1) {\n      drag.stop.y = this.board.height - 1;\n    }\n\n    //Return\n    return drag;\n  };\n\n  /**\n   * Normalize the mousewheel event helper\n   */\n  function normalizeMousewheelEvent(event) {\n\n    //Initialize vars\n    var deltaX = 0;\n    var deltaY = 0;\n\n    //Old school scrollwheel delta\n    if ('detail' in event) {\n      deltaY = event.detail * -1;\n    }\n    if ('wheelDelta' in event) {\n      deltaY = event.wheelDelta;\n    }\n    if ('wheelDeltaY' in event) {\n      deltaY = event.wheelDeltaY;\n    }\n    if ('wheelDeltaX' in event) {\n      deltaX = event.wheelDeltaX * -1;\n    }\n\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\n      deltaX = deltaY * -1;\n      deltaY = 0;\n    }\n\n    //New type wheel delta (WheelEvent)\n    if ('deltaY' in event) {\n      deltaY = event.deltaY * -1;\n    }\n    if ('deltaX' in event) {\n      deltaX = event.deltaX;\n    }\n\n    //Set in event (have to use different property name because of strict mode)\n    event.mouseWheelX = deltaX;\n    event.mouseWheelY = deltaY;\n\n    //Return\n    return event;\n  }\n\n  /**\n   * Player extension\n   */\n  angular.extend(Player, {\n\n    /**\n     * Mouse coordinate helper vars\n     */\n    mouse: {\n\n      //Drag start\n      dragStart: null,\n\n      //Last grid coordinates\n      lastX: -1,\n      lastY: -1\n    }\n  });\n\n  /**\n   * Player mode definition\n   */\n  var PlayerMode = {\n\n    /**\n     * Handler for keydown events\n     */\n    keyDown: function(event, keyboardEvent) {\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Switch key code\n      switch (keyboardEvent.keyCode) {\n\n        //ESC\n        case KeyCodes.ESC:\n\n          //Cancel drag event, and prevent click event as well\n          this.mouse.dragStart = null;\n          this.preventClickEvent = true;\n          break;\n\n        //Right arrow\n        case KeyCodes.RIGHT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Advance to the next move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\n              this.next();\n            }\n          }\n          break;\n\n        //Left arrow\n        case KeyCodes.LEFT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Go to the previous move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\n              this.previous();\n            }\n          }\n          break;\n\n        //Up arrow\n        case KeyCodes.UP:\n          break;\n\n        //Down arrow\n        case KeyCodes.DOWN:\n          break;\n      }\n    },\n\n    /**\n     * Handler for mousewheel events\n     */\n    mouseWheel: function(event, mouseEvent) {\n\n      //Disabled or not using move tool?\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\n        return true;\n      }\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return true;\n      }\n\n      //Normalize mousewheel event\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\n\n      //Find delta\n      var delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\n\n      //Next move\n      if (delta < 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.next();\n      }\n\n      //Previous move\n      else if (delta > 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.previous();\n      }\n\n      //Don't scroll the window\n      if (delta !== 0) {\n        mouseEvent.preventDefault();\n      }\n    },\n\n    /**\n     * Mouse out handler\n     */\n    mouseOut: function() {\n      if (this.board) {\n        this.board.removeAll('hover');\n      }\n    },\n\n    /**\n     * Mouse move handler\n     */\n    mouseMove: function(event, mouseEvent) {\n\n      //Attach drag object to events\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n      }\n\n      //Nothing else to do?\n      if (!this.board || !this.board.layers.hover) {\n        return;\n      }\n\n      //Last coordinates are the same?\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\n        return;\n      }\n\n      //Remember last coordinates\n      this.mouse.lastX = event.x;\n      this.mouse.lastY = event.y;\n\n      //Broadcast hover event\n      this.broadcast('hover', mouseEvent);\n    },\n\n    /**\n     * Mouse down handler\n     */\n    mouseDown: function(event) {\n      this.mouse.dragStart = {\n        x: event.x,\n        y: event.y\n      };\n    },\n\n    /**\n     * Mouse up handler\n     */\n    mouseUp: function(event, mouseEvent) {\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n        this.broadcast('mousedrag', mouseEvent);\n      }\n      this.mouse.dragStart = null;\n    }\n  };\n\n  //Return\n  return PlayerMode;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\n * a game record and its board positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Edit.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Setup tools\n */\n.constant('SetupTools', {\n  BLACK: 'black',\n  WHITE: 'white',\n  CLEAR: 'clear'\n})\n\n/**\n * Markup tools\n */\n.constant('MarkupTools', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  SAD: 'sad',\n  HAPPY: 'happy',\n  TEXT: 'text',\n  NUMBER: 'number',\n  CLEAR: 'clear'\n})\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeEdit', function(Player, PlayerModes, PlayerModeEdit) {\n\n  //Register event handlers\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\n\n  //Register mode\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeEdit', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['Player', 'PlayerTools', 'SetupTools', 'MarkupTools', 'MarkupTypes', 'GameScorer', 'StoneColor', function(\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\n  ) {\n\n    //Character codes\n    var aChar = 'A'.charCodeAt(0);\n    var aCharLc = 'a'.charCodeAt(0);\n\n    /**\n     * Update hover mark at specific coordinates\n     */\n    var updateHoverMark = function(x, y, isDrag) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Setup tool\n        case PlayerTools.SETUP:\n\n          //Clear tool\n          if (this.setupTool === SetupTools.CLEAR) {\n\n            //Stone present? Can remove it\n            if (this.game.hasStone(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Stone color tool\n          else {\n\n            //Add or overwrite stone if no stone present of the given color\n            if (!this.game.hasStone(x, y, this.setupToolColor())) {\n              this.board.add('hover', x, y, {\n                type: 'stones',\n                value: this.setupToolColor()\n              });\n            }\n\n            //Stone present of same color? Can remove it if we're not dragging\n            else if (!isDrag) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n          break;\n\n        //Markup tool\n        case PlayerTools.MARKUP:\n\n          //Clear tool, or already markup in place?\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\n            if (this.game.hasMarkup(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Text or number\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: {\n                type: MarkupTypes.LABEL,\n                text: this.markupLabel\n              }\n            });\n          }\n\n          //Other markup\n          else {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: this.markupTool\n            });\n          }\n          break;\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to set markup\n     */\n    var setMarkup = function(x, y) {\n\n      //Already markup in place? Remove it first\n      if (this.game.hasMarkup(x, y)) {\n\n        //Check what markup there is\n        var markup = this.game.getMarkup(x, y);\n\n        //Label? Also remove from our labels list\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\n          var i = this.markupLabels.indexOf(markup.text);\n          if (i !== -1) {\n            this.markupLabels.splice(i, 1);\n          }\n        }\n\n        //Remove from game\n        this.game.removeMarkup(x, y);\n        return;\n      }\n\n      //Clear tool used? Done\n      if (this.markupTool === MarkupTools.CLEAR) {\n        return;\n      }\n\n      //Text\n      else if (this.markupTool === MarkupTools.TEXT) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next text label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Number\n      else if (this.markupTool === MarkupTools.NUMBER) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next number label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Other markup\n      else {\n        this.game.addMarkup(x, y, this.markupTool);\n      }\n    };\n\n    /**\n     * Helper to set a stone\n     */\n    var setStone = function(x, y, isDrag) {\n\n      //Get the stone color\n      var color = this.setupToolColor();\n\n      //Trying to remove a stone\n      if (color === StoneColor.EMPTY) {\n        this.game.removeStone(x, y);\n      }\n\n      //Adding a stone\n      else {\n\n        //A stone there already of the same color? Just remove if not dragging\n        if (!isDrag && this.game.hasStone(x, y, color)) {\n          this.game.removeStone(x, y);\n          return;\n        }\n\n        //Any stone present?\n        else if (this.game.hasStone(x, y)) {\n          this.game.removeStone(x, y);\n        }\n\n        //Add stone now\n        this.game.addStone(x, y, color);\n      }\n\n      //Redraw markup\n      this.board.layers.markup.redrawCell(x, y);\n    };\n\n    /**\n     * Find all markup labels in current position\n     */\n    var findAllMarkupLabels = function() {\n\n      //Clear\n      this.markupLabels = [];\n\n      //Must have game\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get all markup from position\n      var markup = this.game.position.markup.all('type');\n      for (var i = 0; i < markup.length; i++) {\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\n          this.markupLabels.push(markup[i].text);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Active setup tool and markup tool\n      setupTool: SetupTools.BLACK,\n      markupTool: MarkupTools.TRIANGLE,\n\n      //Current markup labels on the board and current markup label\n      markupLabels: [],\n      markupLabel: '',\n\n      /**\n       * Set the setup tool\n       */\n      switchSetupTool: function(tool) {\n        this.setupTool = tool;\n      },\n\n      /**\n       * Set the markup tool\n       */\n      switchMarkupTool: function(tool) {\n        this.markupTool = tool;\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          this.determineMarkupLabel();\n        }\n      },\n\n      /**\n       * Conversion of setup tool to stone color\n       */\n      setupToolColor: function() {\n        switch (this.setupTool) {\n          case SetupTools.BLACK:\n            return StoneColor.B;\n          case SetupTools.WHITE:\n            return StoneColor.W;\n          default:\n            return StoneColor.EMPTY;\n        }\n      },\n\n      /**\n       * Set the new text markup label\n       */\n      setMarkupLabel: function(label) {\n        if (label) {\n          this.markupLabel = label;\n        }\n      },\n\n      /**\n       * Determine the new text markup label\n       */\n      determineMarkupLabel: function() {\n\n        //Clear\n        this.markupLabel = '';\n\n        //Check what tool we're using\n        switch (this.markupTool) {\n\n          //Text tool?\n          case MarkupTools.TEXT:\n            var i = 0;\n\n            //Loop while the label is present\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n\n              //A-Z\n              if (i < 26) {\n                this.markupLabel = String.fromCharCode(aChar + i);\n              }\n\n              //a-z\n              else if (i < 52) {\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\n              }\n\n              //AA, AB, AC, etc.\n              else {\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\n                  String.fromCharCode(aChar + (i % 26));\n              }\n\n              //Keep going\n              i++;\n            }\n            break;\n\n          //Number tool?\n          case MarkupTools.NUMBER:\n            this.markupLabel = 0;\n\n            //Loop while the label is present\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n              this.markupLabel++;\n            }\n            break;\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeEdit = {\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Remove all hover items\n        this.board.removeAll('hover');\n\n        //Single coordinate?\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //No dragging for labels\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //Loop area\n        for (var x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n          for (var y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n            updateHoverMark.call(this, x, y, true);\n          }\n        }\n      },\n\n      /**\n       * Keydown handler\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //TODO: tool switching via keyboard input\n        }\n      },\n\n      /**\n       * Click handler\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        this.board.removeAll('hover');\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Try to play the move\n            if (!this.game.play(event.x, event.y)) {\n              return;\n            }\n            this.processPosition();\n            break;\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Set stone and update board\n            setStone.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Set markup and update board\n            setMarkup.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Mouse drag handler\n       */\n      mouseDrag: function(event) {\n\n        //Initialize vars\n        var x, y;\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setStone.call(this, x, y, true);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Don't do this for labels\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n              break;\n            }\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setMarkup.call(this, x, y);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Path change\n       */\n      pathChange: function() {\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SETUP,\n          PlayerTools.MARKUP,\n          PlayerTools.SCORE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Find all markup labels in the current game position\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeEdit;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\n * through an existing game record without the ability to deviate from the tree or its variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Replay.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeReplay', function(Player, PlayerModes, PlayerModeReplay) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\n\n  //Register the mode\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeReplay', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Auto play delay\n    autoPlayDelay: 1000\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$interval', 'Player', 'PlayerModes', 'PlayerTools', 'MarkupTypes', 'GameScorer', function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show move variations on the board\n     */\n    var showMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n\n        //Auto variation markup should never overwrite existing markup\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\n          continue;\n        }\n\n        //Add to board\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n          type: this.board.theme.get('markup.variation.type'),\n          text: this.board.theme.get('markup.variation.text', i),\n          color: this.board.theme.get('markup.variation.color')\n        });\n      }\n    };\n\n    /**\n     * Helper to hide move variations from the board\n     */\n    var hideMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) move variations on the board\n     */\n    var drawMoveVariations = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get the current node\n      var node = this.game.getNode();\n      var variations;\n      if (!node) {\n        return;\n      }\n\n      //Child variations?\n      if (this.variationChildren && node.hasMoveVariations()) {\n        variations = node.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n\n      //Sibling variations?\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\n        variations = node.parent.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Auto play vars\n      autoPlaying: false,\n      autoPlayDelay: 1000,\n      autoPlayPromise: null,\n\n      /**\n       * Set auto play delay\n       */\n      setAutoPlayDelay: function(delay) {\n        if (this.autoPlayDelay !== delay) {\n          this.autoPlayDelay = delay;\n          this.broadcast('settingChange', 'autoPlayDelay');\n        }\n      },\n\n      /**\n       * Start auto play with a given delay\n       */\n      start: function(delay) {\n\n        //Not in replay mode or already auto playing?\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\n          return;\n        }\n\n        //Already auto playing, no game or no move children?\n        if (!this.game || !this.game.node.hasChildren()) {\n          return;\n        }\n\n        //Get self\n        var self = this;\n\n        //Determine delay\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\n\n        //Switch tool\n        this.switchTool(PlayerTools.NONE);\n\n        //Create interval\n        this.autoPlaying = true;\n        this.autoPlayPromise = $interval(function() {\n\n          //Advance to the next node\n          self.next(0, true);\n\n          //Ran out of children?\n          if (!self.game.node.hasChildren()) {\n            self.stop();\n          }\n        }, delay);\n\n        //Broadcast event\n        this.broadcast('autoPlayStarted', this.game.node);\n      },\n\n      /**\n       * Stop auto play\n       */\n      stop: function() {\n\n        //Not in replay mode or not auto playing?\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\n          return;\n        }\n\n        //Cancel interval\n        if (this.autoPlayPromise) {\n          $interval.cancel(this.autoPlayPromise);\n        }\n\n        //Clear flags\n        this.autoPlayPromise = null;\n        this.autoPlaying = false;\n\n        //Broadcast event\n        this.broadcast('autoPlayStopped', this.game.node);\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeReplay = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.setAutoPlayDelay(this.config.autoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'variationMarkup') {\n          drawMoveVariations.call(this, this.variationMarkup);\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Check if we clicked a move variation, advance to the next position if so\n            if (this.game.isMoveVariation(event.x, event.y)) {\n              this.next(this.game.getMoveVariation(event.x, event.y));\n            }\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeReplay.hover.call(this, event);\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SCORE,\n          PlayerTools.NONE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Stop auto playing\n        if (this.autoPlaying) {\n          this.stop();\n        }\n\n        //Hide move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, false);\n        }\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeReplay;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\n * go problems and finding the right move or variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Solve.Service', [\n  'ngGo'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeSolve', function(Player, PlayerModes, PlayerModeSolve) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\n\n  //Register mode\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeSolve', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Player color\n    playerColor: StoneColor.B,\n\n    //Show solution paths\n    solutionPaths: false,\n\n    //Auto play settings\n    solveAutoPlay: true,\n    solveAutoPlayDelay: 500\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$timeout', 'Player', 'PlayerModes', 'PlayerTools', 'KeyCodes', function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\n\n    /**\n     * Check if we can make a move\n     */\n    var canMakeMove = function() {\n\n      //We can make a move when...\n\n      //...there is no auto play going on\n      if (!this.solveAutoPlay) {\n        return true;\n      }\n\n      //...we solved the puzzle already\n      if (this.problemSolved) {\n        return true;\n      }\n\n      //...we are off path\n      if (this.problemOffPath) {\n        return true;\n      }\n\n      //...it's our turn\n      if (this.game.getTurn() === this.playerColor) {\n        return true;\n      }\n\n      //Otherwise, we can't make a move\n      return false;\n    };\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show solution paths\n     */\n    var showSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        if (variations[i].solution === true) {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.valid.type'),\n            text: this.board.theme.get('markup.solution.valid.text', i),\n            scale: this.board.theme.get('markup.solution.valid.scale'),\n            color: this.board.theme.get('markup.solution.valid.color')\n          });\n        }\n        else {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.invalid.type'),\n            text: this.board.theme.get('markup.solution.invalid.text', i),\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\n            color: this.board.theme.get('markup.solution.invalid.color')\n          });\n        }\n      }\n    };\n\n    /**\n     * Helper to hide solution paths\n     */\n    var hideSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) solution paths\n     */\n    var drawSolutionPaths = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get node and variations\n      var node = this.game.getNode();\n      var variations = node.getMoveVariations();\n\n      //When showing, make sure it's not during the auto solver's move\n      if (show && !this.problemSolved && this.solveAutoPlay) {\n        if (this.game.getTurn() !== this.playerColor) {\n          hideSolutionPaths.call(this, variations);\n          return;\n        }\n      }\n\n      //Call helper\n      if (show) {\n        showSolutionPaths.call(this, variations);\n      }\n      else {\n        hideSolutionPaths.call(this, variations);\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Solved and off-path flags\n      problemSolved: false,\n      problemOffPath: false,\n\n      //Problem start path\n      problemStartPath: null,\n\n      //The player color\n      playerColor: 0,\n\n      //Solution paths\n      solutionPaths: false,\n\n      //Auto play vars\n      solveAutoPlay: true,\n      solveAutoPlayDelay: 500,\n\n      //Navigation blocked flag\n      solveNavigationBlocked: false,\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlay: function(autoPlay) {\n        if (this.solveAutoPlay !== autoPlay) {\n          this.solveAutoPlay = autoPlay;\n          this.broadcast('settingChange', 'solveAutoPlay');\n        }\n      },\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlayDelay: function(delay) {\n        if (this.solveAutoPlayDelay !== delay) {\n          this.solveAutoPlayDelay = delay;\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\n        }\n      },\n\n      /**\n       * Set player color\n       */\n      setPlayerColor: function(color) {\n        if (this.playerColor !== color) {\n          this.playerColor = color;\n          this.broadcast('settingChange', 'playerColor');\n        }\n      },\n\n      /**\n       * Get player color\n       */\n      getPlayerColor: function(asOnBoard) {\n        if (asOnBoard && this.board) {\n          return this.board.colorMultiplier * this.playerColor;\n        }\n        return this.playerColor;\n      },\n\n      /**\n       * Toggle solution paths\n       */\n      toggleSolutionPaths: function(solutionPaths) {\n\n        //Toggle if not given\n        if (typeof solutionPaths === 'undefined') {\n          solutionPaths = !this.solutionPaths;\n        }\n\n        //Change?\n        if (solutionPaths !== this.solutionPaths) {\n          this.solutionPaths = solutionPaths;\n          this.broadcast('settingChange', 'solutionPaths');\n        }\n      },\n\n      /**\n       * Auto play next move\n       */\n      autoPlayNext: function(immediately) {\n\n        //Must have game and children\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\n          return;\n        }\n\n        //Init vars\n        var children = [];\n        var self = this;\n        var i;\n\n        //When picking a child node, we always prefer to pick a valid solution\n        for (i = 0; i < this.game.node.children.length; i++) {\n          if (this.game.node.children[i].solution) {\n            children.push(this.game.node.children[i]);\n          }\n        }\n\n        //No solution nodes? Just use all nodes then.\n        if (children.length === 0) {\n          children = this.game.node.children;\n        }\n\n        //Pick a random child node\n        i = Math.floor(Math.random() * children.length);\n\n        //No delay?\n        if (immediately || !this.solveAutoPlayDelay) {\n          this.next(children[i]);\n          return;\n        }\n\n        //Block navigation and run the timeout\n        this.solveNavigationBlocked = true;\n        $timeout(function() {\n\n          //Move to next move and unblock navigation\n          self.next(children[i]);\n          self.solveNavigationBlocked = false;\n\n        }, this.solveAutoPlayDelay);\n      },\n\n      /**\n       * Start solving from the current game node\n       */\n      solve: function() {\n\n        //Must have a game\n        if (!this.game || !this.game.isLoaded()) {\n          return false;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Remember problem start path\n        this.problemStartPath = this.game.getPath(true);\n\n        //Restrict start of navigation to the current node\n        this.restrictNode();\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      },\n\n      /**\n       * Restart the problem\n       */\n      restartProblem: function() {\n\n        //Must be in solve mode, must have game\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Go back to the start path\n        if (this.problemStartPath) {\n          this.goto(this.problemStartPath);\n        }\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeSolve = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.toggleSolutionPaths(this.config.solutionPaths);\n        this.setPlayerColor(this.config.playerColor);\n        this.setSolveAutoPlay(this.config.solveAutoPlay);\n        this.setSolveAutoPlayDelay(this.config.solveAutoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'solutionPaths') {\n          drawSolutionPaths.call(this, this.solutionPaths);\n        }\n\n        //Player color changed?\n        if (setting === 'playerColor') {\n\n          //Draw (or hide) solution paths\n          drawSolutionPaths.call(this, this.solutionPaths);\n\n          //Make an auto play move if it's not our turn\n          if (\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\n          ) {\n            this.autoPlayNext(true);\n          }\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this, event.x, event.y);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for keydown events\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //Right arrow\n          case KeyCodes.RIGHT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\n\n                //Go forward one move if solved\n                if (this.problemSolved) {\n                  this.next();\n                }\n              }\n            }\n            break;\n\n          //Left arrow\n          case KeyCodes.LEFT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked and not reached the start?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\n\n                //Go back one move\n                this.previous();\n\n                //Go back one more if this is not the player's turn and if\n                //the problem hasn't been solved yet\n                if (\n                  !this.problemSolved && this.solveAutoPlay &&\n                  this.game.getTurn() === -this.playerColor\n                ) {\n                  this.previous();\n                }\n              }\n            }\n            break;\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //A valid variation\n        if (this.game.isMoveVariation(event.x, event.y)) {\n\n          //Get the node\n          var i = this.game.getMoveVariation(event.x, event.y);\n\n          //Advance to the next position and get the next node\n          this.next(i);\n          var node = this.game.getNode();\n\n          //No children left? Check if we solved it or not\n          if (node.children.length === 0) {\n            if (node.solution === true) {\n              this.problemSolved = true;\n              this.broadcast('solutionFound', node);\n            }\n            else {\n              this.broadcast('solutionWrong', node);\n            }\n          }\n\n          //Auto-play next move?\n          else if (!this.problemSolved && this.solveAutoPlay) {\n            this.autoPlayNext();\n          }\n        }\n\n        //Unknown variation, try to play\n        else if (this.game.play(event.x, event.y)) {\n          this.problemOffPath = true;\n          this.processPosition();\n          this.broadcast('solutionOffPath', this.game.getNode());\n        }\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Draw solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Hide any solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, false);\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeSolve;\n  }];\n}]);\n\n})(window, window.angular);\n","/**\n * ng-go - v1.3.1 - 2-11-2015\n * https://github.com/adambuczynski/ngGo\n *\n * Copyright (c) 2015 Adam Buczynski <me@adambuczynski.com>\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n/**\n * ngGo\n *\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\n * refactored to fit the Angular framework, as well as having been linted, properly commented\n * and generally cleaned up.\n *\n * Copyright (c) 2013 Jan Prokop (WGo)\n * Copyright (c) 2014-2015 Adam Buczynski (ngGo)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo', [])\n\n/**\n * ngGo constants\n */\n.constant('ngGo', {\n  name: 'ngGo',\n  version: '1.3.1',\n  error: {\n\n    //Position errors\n    POSITION_OUT_OF_BOUNDS: 1,\n    POSITION_ALREADY_HAS_STONE: 2,\n    POSITION_IS_SUICIDE: 3,\n    POSITION_IS_REPEATING: 4,\n\n    //Data loading errors\n    NO_DATA: 5,\n    UNKNOWN_DATA: 6,\n    INVALID_SGF: 7,\n    INVALID_GIB: 8,\n    INVALID_JGF_JSON: 9,\n    INVALID_JGF_TREE_JSON: 10\n  }\n})\n\n/**\n * Stone colors\n */\n.constant('StoneColor', {\n  E: 0,\n  EMPTY: 0,\n  B: 1,\n  BLACK: 1,\n  W: -1,\n  WHITE: -1\n})\n\n/**\n * Markup types\n */\n.constant('MarkupTypes', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  LABEL: 'label',\n  LAST: 'last',\n  SAD: 'sad',\n  HAPPY: 'happy'\n})\n\n/**\n * Player modes\n */\n.constant('PlayerModes', {\n  PLAY: 'play',\n  REPLAY: 'replay',\n  EDIT: 'edit',\n  SOLVE: 'solve'\n})\n\n/**\n * Player tools\n */\n.constant('PlayerTools', {\n  NONE: 'none',\n  MOVE: 'move',\n  SCORE: 'score',\n  SETUP: 'setup',\n  MARKUP: 'markup'\n})\n\n/**\n * Key codes\n */\n.constant('KeyCodes', {\n  LEFT: 37,\n  RIGHT: 39,\n  UP: 38,\n  DOWN: 40,\n  ESC: 27,\n  ENTER: 13,\n  SPACE: 32,\n  TAB: 9,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  HOME: 36,\n  END: 35,\n  PAGEUP: 33,\n  PAGEDOWN: 34\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Directive', [\n  'ngGo.Board.Service'\n])\n\n/**\n * Directive definition\n */\n.directive('board', ['$window', 'Board', function($window, Board) {\n\n  //Get pixel ratio\n  var pixelRatio = window.pixelRatio || 1;\n\n  /**\n   * Helper to create a layer canvas\n   */\n  var createLayerCanvas = function(name) {\n\n    //Create canvas element and get context\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    //Scale context depending on pixel ratio\n    if (pixelRatio > 1) {\n      context.scale(pixelRatio, pixelRatio);\n    }\n\n    //Set class\n    canvas.className = name;\n\n    //Set initial canvas width/height based on our own size\n    canvas.width = this.clientWidth * pixelRatio;\n    canvas.height = this.clientHeight * pixelRatio;\n\n    //Append to element now and return context\n    this.appendChild(canvas);\n    return context;\n  };\n\n  /**\n   * Helper to determine draw size\n   */\n  var determineDrawSize = function(scope, availableWidth, availableHeight) {\n\n    //Init vars\n    var drawWidth, drawHeight, cellSize;\n\n    //Stretch available height to width if zero\n    if (availableHeight === 0 && availableWidth > 0) {\n      availableHeight = availableWidth;\n    }\n\n    //Grid size known?\n    if (scope.Board.width && scope.Board.height) {\n\n      //Determine smallest cell size\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\n\n      //Set draw size\n      drawWidth = Math.floor(cellSize * scope.Board.width);\n      drawHeight = Math.floor(cellSize * scope.Board.height);\n    }\n\n    //Otherwise, use the lesser of the available width/height\n    else {\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\n    }\n\n    //Broadcast new size if changed\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\n      scope.lastDrawWidth = drawWidth;\n      scope.lastDrawHeight = drawHeight;\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\n      return true;\n    }\n\n    //No change\n    return false;\n  };\n\n  /**\n   * Directive\n   */\n  return {\n    restrict: 'E',\n    scope: {\n      instance: '&'\n    },\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Init vars\n      var i, context, layer, playerElement;\n      var parent = element.parent();\n      var sizingElement = element[0];\n      var existingInstance = true;\n\n      //Remember last draw width/height\n      scope.lastDrawWidth = 0;\n      scope.lastDrawHeight = 0;\n\n      //Get board instance\n      scope.Board = scope.instance();\n\n      //Function given?\n      if (typeof scope.Board === 'function') {\n        scope.Board = scope.Board();\n      }\n\n      //Instantiate board if not present in scope\n      if (!scope.Board) {\n        existingInstance = false;\n        scope.Board = new Board();\n      }\n\n      //Link element\n      scope.Board.linkElement(element);\n\n      //Find player element\n      if (parent[0].tagName === 'PLAYER') {\n        playerElement = parent;\n        sizingElement = parent.parent()[0];\n      }\n\n      //Listen for board drawsize events\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\n\n        //First set the new dimensions on the canvas elements\n        var canvas = element.find('canvas');\n        for (i = 0; i < canvas.length; i++) {\n          canvas[i].width = width * pixelRatio;\n          canvas[i].height = height * pixelRatio;\n        }\n\n        //Set on the element if we're using a player element and if there is a size\n        if (playerElement || attrs.forceSize === 'true') {\n          element.css({width: width + 'px', height: height + 'px'});\n        }\n\n        //Next set it on the board itself\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\n      });\n\n      //Determine initial draw size\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n\n      //On window resize, determine the draw size again\n      angular.element($window).on('resize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On manual resize, determine draw size again\n      scope.$on('ngGo.board.determineDrawSize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On board grid resize, determine the draw size again\n      scope.$on('ngGo.board.resize', function(event, board) {\n\n        //Only relevent if this was our own board\n        if (board !== scope.Board) {\n          return;\n        }\n\n        //If the draw size didn't change, the draw size event won't be triggered.\n        //However, that means we should call the resized() method now manually because\n        //it won't be called with the setDrawSize() call.\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\n          scope.Board.resized();\n        }\n      });\n\n      //Static board\n      if (attrs.static && attrs.static === 'true') {\n\n        //Add static class and make the board static\n        element.addClass('static');\n        scope.Board.makeStatic();\n\n        //Create single canvas and link to all relevant layer service classes\n        context = createLayerCanvas.call(element[0], 'static');\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Dynamic board\n      else {\n\n        //Create individual layer canvasses and link the canvas context to the layer service class\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          context = createLayerCanvas.call(element[0], layer);\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Observe the board size attribute\n      attrs.$observe('size', function(size) {\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\n          size = size.split('x');\n          scope.Board.setSize(size[0], size[1]);\n        }\n        else {\n          scope.Board.setSize(size, size);\n        }\n      });\n\n      //Observe the coordinates attribute\n      attrs.$observe('coordinates', function(attr) {\n        scope.Board.toggleCoordinates(attr === 'true');\n      });\n\n      //Observe the cutoff attribute\n      attrs.$observe('cutoff', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.setCutoff(attr.split(','));\n        }\n      });\n\n      //Observe color multiplier\n      attrs.$observe('colorMultiplier', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.swapColors(attr);\n        }\n      });\n\n      //Link board to player if present in parent scope\n      if (scope.$parent.Player) {\n        scope.$parent.Player.setBoard(scope.Board);\n      }\n\n      //Redraw board if we had an existing instance (it might contain data)\n      if (existingInstance) {\n        scope.Board.redraw();\n      }\n    }\n  };\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\n * and is used for placing and removing objects on the board. The class has helpers to figure out\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\n * responsible for drawing all layers on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Service', [\n  'ngGo',\n  'ngGo.Board.Directive',\n  'ngGo.Board.Theme.Service',\n  'ngGo.Board.Layer.GridLayer.Service',\n  'ngGo.Board.Layer.ShadowLayer.Service',\n  'ngGo.Board.Layer.StonesLayer.Service',\n  'ngGo.Board.Layer.MarkupLayer.Service',\n  'ngGo.Board.Layer.ScoreLayer.Service',\n  'ngGo.Board.Layer.HoverLayer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.Stone.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Board', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Width and height\n    width: 0,\n    height: 0,\n\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\n    cutoff: [],\n\n    //Section of board to display\n    section: {top: 0, right: 0, bottom: 0, left: 0},\n\n    //Show coordinates?\n    coordinates: false,\n\n    //Color multiplier (use -1 to swap colors)\n    colorMultiplier: 1\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$injector', 'BoardTheme', function($rootScope, $injector, BoardTheme) {\n\n    /**\n     * Board constructor\n     */\n    var Board = function(config) {\n\n      //Initialize board\n      this.init();\n\n      //Parse config\n      this.parseConfig(config || {});\n    };\n\n    /**\n     * Initialize board\n     */\n    Board.prototype.init = function() {\n\n      //Remove everything\n      this.removeAll();\n\n      //Set board theme\n      this.theme = new BoardTheme();\n\n      //Initialize board draw dimensions in pixels\n      this.cellSize = 0;\n      this.drawWidth = 0;\n      this.drawHeight = 0;\n      this.drawMarginHor = 0;\n      this.drawMarginVer = 0;\n      this.gridDrawWidth = 0;\n      this.gridDrawHeight = 0;\n\n      //Set layer order\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\n\n      //Initialize layers\n      this.layers = {};\n      for (var l = 0; l < this.layerOrder.length; l++) {\n        var layer = this.layerOrder[l];\n        var layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\n        var LayerClass = $injector.get(layerClass);\n        this.layers[layer] = new LayerClass(this);\n      }\n\n      //Static board flag\n      this.static = false;\n\n      //Get margin from theme\n      this.margin = this.theme.get('board.margin');\n\n      //Color multiplier (to allow color swapping)\n      this.colorMultiplier = 1;\n\n      //Turn off coordinates\n      this.coordinates = false;\n      this.layers.grid.setCoordinates(false);\n\n      //Initialize grid size\n      this.width = 0;\n      this.height = 0;\n\n      //Initialize cutoff\n      this.cutoff = {\n        top: false,\n        left: false,\n        right: false,\n        bottom: false\n      };\n\n      //Initialize section\n      this.section = {\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    };\n\n    /**\n     * Link the board to a HTML element\n     */\n    Board.prototype.linkElement = function(element) {\n      this.element = element;\n    };\n\n    /**\n     * Make this board static (one canvas layer, only grid, stones and markup)\n     */\n    Board.prototype.makeStatic = function() {\n      this.static = true;\n      this.layerOrder = ['grid', 'stones', 'markup'];\n    };\n\n    /*****************************************************************************\n     * Configuration\n     ***/\n\n    /**\n     * Parse config instructions\n     */\n    Board.prototype.parseConfig = function(config) {\n\n      //Validate\n      if (typeof config !== 'object') {\n        return;\n      }\n\n      //Extend from default config\n      config = angular.extend({}, defaultConfig, config);\n\n      //Process settigns\n      this.toggleCoordinates(config.coordinates);\n      this.swapColors(config.colorMultiplier);\n      this.setCutoff(config.cutoff);\n      this.setSection(config.section);\n      this.setSize(config.width, config.height);\n    };\n\n    /**\n     * Set margin\n     */\n    Board.prototype.setMargin = function(margin) {\n\n      //Reset when not defined\n      if (typeof margin === 'undefined') {\n        margin = this.theme.get('board.margin');\n      }\n\n      //Set margin if changed\n      if (this.margin !== margin) {\n        this.margin = margin;\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set grid cut-off\n     */\n    Board.prototype.setCutoff = function(cutoff) {\n\n      //Nothing given? Reset cutoff\n      if (!cutoff || !angular.isArray(cutoff)) {\n        cutoff = [];\n      }\n\n      //Init\n      var changes = false;\n\n      //Check if there's a change\n      for (var side in this.cutoff) {\n        if (this.cutoff.hasOwnProperty(side)) {\n          if (cutoff.indexOf(side) !== -1) {\n            if (!this.cutoff[side]) {\n              this.cutoff[side] = true;\n              changes = true;\n            }\n          }\n          else {\n            if (this.cutoff[side]) {\n              this.cutoff[side] = false;\n              changes = true;\n            }\n          }\n        }\n      }\n\n      //Trigger resized if there were changes\n      if (changes) {\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set section of the board to be displayed\n     */\n    Board.prototype.setSection = function(section) {\n\n      //Nothing given?\n      if (!section || typeof section !== 'object') {\n        return this;\n      }\n\n      //Expand on default\n      section = angular.extend({\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      }, section);\n\n      //No changes?\n      if (\n        this.section.top === section.top && this.section.bottom === section.bottom &&\n        this.section.left === section.left && this.section.right === section.right\n      ) {\n        return this;\n      }\n\n      //Set section and call resized handler\n      this.section = section;\n      this.resized();\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set board size. This will clear the board objects.\n     */\n    Board.prototype.setSize = function(width, height) {\n\n      //Check what's given\n      width = parseInt(width || height || 0);\n      height = parseInt(height || width || 0);\n\n      //Invalid?\n      if (isNaN(width) || isNaN(height)) {\n        return;\n      }\n\n      //Changing?\n      if (width !== this.width || height !== this.height) {\n\n        //Remember size\n        this.width = width;\n        this.height = height;\n\n        //Set size in layers\n        for (var layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].setSize(width, height);\n          }\n        }\n\n        //Broadcast event (no call to resized, as that is handled in the directive)\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set new draw size\n     */\n    Board.prototype.setDrawSize = function(width, height) {\n      if (width !== this.drawWidth || height !== this.drawHeight) {\n        this.drawWidth = width;\n        this.drawHeight = height;\n        this.resized();\n      }\n    };\n\n    /**\n     * Toggle the coordinates\n     */\n    Board.prototype.toggleCoordinates = function(show) {\n\n      //Set or toggle\n      if (typeof show !== 'undefined') {\n        this.coordinates = show;\n      }\n      else {\n        this.coordinates = !this.coordinates;\n      }\n\n      //Set in grid layer\n      this.layers.grid.setCoordinates(this.coordinates);\n\n      //Set the proper board margin\n      if (this.coordinates) {\n        this.setMargin(this.theme.get('coordinates.margin'));\n      }\n      else {\n        this.setMargin(this.theme.get('board.margin'));\n      }\n    };\n\n    /**\n     * Swap colors on the board\n     */\n    Board.prototype.swapColors = function(multiplier) {\n\n      //Multiplier not given? Set to inverse of current value\n      if (typeof multiplier === 'undefined') {\n        multiplier = -this.colorMultiplier;\n      }\n      else {\n        multiplier = parseInt(multiplier);\n        if (isNaN(multiplier)) {\n          return;\n        }\n      }\n\n      //No change?\n      if (multiplier === this.colorMultiplier) {\n        return;\n      }\n\n      //Set new value\n      this.colorMultiplier = multiplier;\n\n      //For static board, redraw the whole thing\n      if (this.static) {\n        this.redraw();\n      }\n\n      //For a dynamic board, only these layers\n      else {\n        this.redraw('stones');\n        this.redraw('markup');\n      }\n    };\n\n    /*****************************************************************************\n     * Theme handling\n     ***/\n\n    /**\n     * Get the current theme object\n     */\n    Board.prototype.getTheme = function() {\n      return this.theme;\n    };\n\n    /**\n     * Set the theme object\n     */\n    Board.prototype.setTheme = function(theme) {\n      this.theme = theme;\n      return this;\n    };\n\n    /*****************************************************************************\n     * Object handling\n     ***/\n\n    /**\n     * Add an object to a board layer\n     */\n    Board.prototype.add = function(layer, x, y, value) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].add(x, y, value);\n      }\n    };\n\n    /**\n     * Remove an object from a board layer\n     */\n    Board.prototype.remove = function(layer, x, y) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].remove(x, y);\n      }\n    };\n\n    /**\n     * Get something from a board layer\n     */\n    Board.prototype.get = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].get(x, y));\n    };\n\n    /**\n     * Check if we have something at given coordinates for a given layer\n     */\n    Board.prototype.has = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].has(x, y));\n    };\n\n    /**\n     * Set all objects (grid) for a given layer\n     */\n    Board.prototype.setAll = function(layer, grid) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].setAll(grid);\n      }\n    };\n\n    /**\n     * Remove all objects from the board, optionally for a given layer\n     */\n    Board.prototype.removeAll = function(layer) {\n      if (layer) {\n        if (typeof this.layers[layer] !== 'undefined') {\n          this.layers[layer].removeAll();\n        }\n      }\n      else {\n        for (layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].removeAll();\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Position handling\n     ***/\n\n    /**\n     * Update the board with a new position\n     */\n    Board.prototype.updatePosition = function(position, pathChanged) {\n\n      //If we have no grid size yet, use what's in the position\n      if (!this.width || !this.height) {\n        this.setSize(position.width, position.height);\n      }\n\n      //Remove markup if path changed\n      if (pathChanged) {\n        this.removeAll('markup');\n      }\n\n      //Set new stones and markup grids\n      this.setAll('stones', position.stones);\n      this.setAll('markup', position.markup);\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state (list of objects per layer)\n     */\n    Board.prototype.getState = function(layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          return this.layers[layer].getAll();\n        }\n        return null;\n      }\n\n      //All layers\n      var state = {};\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          var grid = this.layers[layer].getAll();\n          if (grid && !grid.isEmpty()) {\n            state[layer] = grid;\n          }\n        }\n      }\n      return state;\n    };\n\n    /**\n     * Restore the board state from given state object\n     */\n    Board.prototype.restoreState = function(state, layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          this.layers[layer].setAll(state);\n        }\n        return;\n      }\n\n      //All layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].removeAll();\n          if (state[layer]) {\n            this.layers[layer].setAll(state[layer]);\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing control\n     ***/\n\n    /**\n     * Clear the whole board\n     */\n    Board.prototype.clear = function(layer) {\n\n      //Just clearing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Clear the layer\n        this.layers[layer].clear();\n        return;\n      }\n\n      //Static? One clear is enough\n      if (this.static) {\n        this.layers.stones.clear();\n        return;\n      }\n\n      //Clear all layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].clear();\n        }\n      }\n    };\n\n    /**\n     * Redraw everything or just a single layer\n     */\n    Board.prototype.redraw = function(layer) {\n\n      //The board can only be redrawn when there is a grid size and a draw size\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Just redrawing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Redraw the layer\n        this.layers[layer].redraw();\n        return;\n      }\n\n      //Clear the board first\n      this.clear();\n\n      //Now draw all layers again in the correct order\n      for (var i = 0; i < this.layerOrder.length; i++) {\n        layer = this.layerOrder[i];\n        this.layers[layer].draw();\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing helpers\n     ***/\n\n    /**\n     * Called after a board size change, draw size change, section change or margin change\n     */\n    Board.prototype.resized = function() {\n\n      //Determine the new grid\n      this.grid = {\n        xLeft: 0 + this.section.left,\n        xRight: this.width - 1 - this.section.right,\n        yTop: 0 + this.section.top,\n        yBot: this.height - 1 - this.section.bottom\n      };\n\n      //Only redraw when there is sensible data\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Determine number of cells horizontall and vertically\n      //The margin is a factor of the cell size, so let's add it to the number of cells\n      var noCellsHor = this.width + this.margin;\n      var noCellsVer = this.height + this.margin;\n\n      //Are we cutting off parts of the grid? Add half a cell of draw size\n      for (var side in this.cutoff) {\n        if (this.cutoff[side]) {\n          if (side === 'top' || side === 'bottom') {\n            noCellsVer += 0.5;\n          }\n          else {\n            noCellsHor += 0.5;\n          }\n        }\n      }\n\n      //Determine cell size now\n      this.cellSize = Math.floor(Math.min(\n        this.drawWidth / noCellsHor,\n        this.drawHeight / noCellsVer\n      ));\n\n      //Determine actual grid draw size (taking off the margin again)\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\n\n      //Determine draw margins\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\n\n      //Redraw\n      this.redraw();\n    };\n\n    /**\n     * Get the current cell size\n     */\n    Board.prototype.getCellSize = function() {\n      return this.cellSize;\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsX = function(gridX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsY = function(gridY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridX = function(absX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridY = function(absY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\n    };\n\n    /**\n     * Check if given grid coordinates are on board\n     */\n    Board.prototype.isOnBoard = function(gridX, gridY) {\n      return (\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\n      );\n    };\n\n    //Return object\n    return Board;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\n * a small rectangular area on the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('DefaultClearHandler', function() {\n\n  /**\n   * Clear handler definition\n   *\n   * All external handlers are called from the context of the layer that contains the object.\n   * First parameter is the canvas2d context, second parameter is the object itself.\n   */\n  return function(context, obj) {\n\n    //No context?\n    if (!context) {\n      return;\n    }\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(obj.x);\n    var y = this.board.getAbsY(obj.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Clear rectangle the size of the stone radius\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\n  };\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\n * stone color values for the game position class. It has built in validation of coordinates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Grid.Service', [\n  'ngGo',\n  'ngGo.Board.GridChanges.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGrid', ['BoardGridChanges', function(BoardGridChanges) {\n\n  /**\n   * Helper to convert a value at given coordinates to an object\n   */\n  var toObject = function(x, y, valueKey) {\n\n    //Create coordinates object\n    var obj = {\n      x: x,\n      y: y\n    };\n\n    //Already an object?\n    if (typeof this.grid[x][y] === 'object') {\n      return angular.extend(obj, this.grid[x][y]);\n    }\n\n    //Not an object, set value with given value key and return\n    obj[valueKey] = this.grid[x][y];\n    return obj;\n  };\n\n  /**\n   * Constructor\n   */\n  var BoardGrid = function(width, height, emptyValue) {\n\n    //Initialize size and grid array\n    this.width = 0;\n    this.height = 0;\n    this.grid = [];\n    this.emptyValue = null;\n\n    //Set empty value if given\n    if (typeof emptyValue !== 'undefined') {\n      this.emptyValue = emptyValue;\n    }\n\n    //Size given? Set it\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set a value\n   */\n  BoardGrid.prototype.set = function(x, y, value) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = value;\n    }\n  };\n\n  /**\n   * Unset a value\n   */\n  BoardGrid.prototype.unset = function(x, y) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = this.emptyValue;\n    }\n  };\n\n  /**\n   * Check if we have a non null value on the coordinates\n   */\n  BoardGrid.prototype.has = function(x, y) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\n  };\n\n  /**\n   * Check if we have a specific value on the coordinates\n   */\n  BoardGrid.prototype.is = function(x, y, value) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\n  };\n\n  /**\n   * Get a value, or an object with coordinates and the value in the given value key\n   */\n  BoardGrid.prototype.get = function(x, y, valueKey) {\n\n    //Validate\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\n      return this.emptyValue;\n    }\n\n    //Return as is?\n    if (!valueKey) {\n      return this.grid[x][y];\n    }\n\n    //Return as object\n    return toObject.call(this, x, y, valueKey);\n  };\n\n  /*****************************************************************************\n   * Mass operations\n   ***/\n\n  /**\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\n   * and the value in the given value key will be returned.\n   */\n  BoardGrid.prototype.all = function(valueKey) {\n\n    //Just get the grid?\n    if (!valueKey) {\n      return this.grid;\n    }\n\n    //Initialize objects list\n    var objects = [];\n\n    //Loop coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          objects.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return objects list\n    return objects;\n  };\n\n  /**\n   * Check if there is anything\n   */\n  BoardGrid.prototype.isEmpty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Populate the whole grid with a given value\n   */\n  BoardGrid.prototype.populate = function(value) {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = value;\n      }\n    }\n  };\n\n  /**\n   * Empty the grid\n   */\n  BoardGrid.prototype.empty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Clone ourselves\n   */\n  BoardGrid.prototype.clone = function() {\n\n    //Create new instance\n    var newGrid = new BoardGrid();\n\n    //Manually set vars for maximum efficiency\n    newGrid.grid = angular.copy(this.grid);\n    newGrid.emptyValue = this.emptyValue;\n    newGrid.width = this.width;\n    newGrid.height = this.height;\n\n    //Return\n    return newGrid;\n  };\n\n  /*****************************************************************************\n   * Comparison\n   ***/\n\n  /**\n   * Checks if a given grid is the same as the current grid\n   */\n  BoardGrid.prototype.isSameAs = function(grid) {\n\n    //Must have the same size\n    if (this.width !== grid.width || this.height !== grid.height) {\n      return false;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== grid[x][y]) {\n          return false;\n        }\n      }\n    }\n\n    //No differences found\n    return true;\n  };\n\n  /**\n   * Compares this position with another position and return change object\n   */\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\n\n    //Initialize board grid changes object\n    var changes = new BoardGridChanges();\n\n    //Must have the same size\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\n      console.warn('Trying to compare grids of a different size');\n      return changes;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n\n        //Something to add?\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\n        }\n\n        //Something to remove?\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.remove.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return changes grid\n    return changes;\n  };\n\n  /*****************************************************************************\n   * Helpers\n   ***/\n\n  /**\n   * Helper to validate coordinates (first param can be an object)\n   */\n  BoardGrid.prototype.isOnGrid = function(x, y) {\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\n  };\n\n  /**\n   * Helper to set the empty value\n   */\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\n    this.emptyValue = emptyValue;\n  };\n\n  /**\n   * Set the grid size\n   */\n  BoardGrid.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Create grid array\n    this.grid = [];\n    for (var x = 0; x < this.width; x++) {\n      this.grid[x] = [];\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Get the grid size object\n   */\n  BoardGrid.prototype.getSize = function() {\n    return {width: this.width, height: this.height};\n  };\n\n  //Return\n  return BoardGrid;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\n * grids. It simply keeps track of what was added and what was removed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.GridChanges.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGridChanges', function() {\n\n  /**\n   * Helper to subtract sets\n   */\n  var setSubtract = function(a, b) {\n    var n = [];\n    var q;\n    for (var i = 0; i < a.length; i++) {\n      q = true;\n      for (var j in b) {\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\n          q = false;\n          break;\n        }\n      }\n      if (q) {\n        n.push(a[i]);\n      }\n    }\n    return n;\n  };\n\n  /**\n   * Game position constructor\n   */\n  return function() {\n\n    /**\n     * Containers\n     */\n    this.add = [];\n    this.remove = [];\n\n    /**\n     * Concatenation helper\n     */\n    this.concat = function(newChanges) {\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\n    };\n\n    /**\n     * Check if there are changes\n     */\n    this.has = function() {\n      return !!(this.add.length || this.remove.length);\n    };\n  };\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\n * for drawing itself as well as its objects onto the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardLayer', ['BoardGrid', function(BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var BoardLayer = function(board, context) {\n\n    //Remember board reference and 2d canvas context\n    this.board = board;\n    this.context = context;\n\n    //Initialize grid for board objects\n    this.grid = new BoardGrid();\n  };\n\n  /*****************************************************************************\n   * Generic grid and object handling\n   ***/\n\n  /**\n   * Set grid size\n   */\n  BoardLayer.prototype.setSize = function(width, height) {\n\n    //Note: since this method is usually only called upon a global board resize,\n    //which also triggers the redraw method for layers, the layer is not cleared\n    //here, as it will happen anyway during the redraw cycle.\n\n    //Set it in the grid (removing all objects in the process)\n    this.grid.setSize(width, height);\n  };\n\n  /**\n   * Get all items\n   */\n  BoardLayer.prototype.getAll = function() {\n    return this.grid.clone();\n  };\n\n  /**\n   * Set all items at once\n   */\n  BoardLayer.prototype.setAll = function(grid) {\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  BoardLayer.prototype.removeAll = function() {\n    this.clear();\n    this.grid.empty();\n  };\n\n  /**\n   * Add a single item\n   */\n  BoardLayer.prototype.add = function(x, y, value) {\n    this.clearCell(x, y);\n    this.grid.set(x, y, value);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Remove a single item\n   */\n  BoardLayer.prototype.remove = function(x, y) {\n    this.clearCell(x, y);\n    this.grid.unset(x, y);\n  };\n\n  /**\n   * Get an item\n   */\n  BoardLayer.prototype.get = function(x, y) {\n    return this.grid.get(x, y);\n  };\n\n  /**\n   * Check if there is an item\n   */\n  BoardLayer.prototype.has = function(x, y) {\n    return this.grid.has(x, y);\n  };\n\n  /*****************************************************************************\n   * Generic drawing methods\n   ***/\n\n  /**\n   * Draw layer\n   */\n  BoardLayer.prototype.draw = function() {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\n   */\n  BoardLayer.prototype.clear = function() {\n    if (this.context) {\n      this.context.clearRect(\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\n      );\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  BoardLayer.prototype.redraw = function() {\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear cell\n   */\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\n    //Clearing method to be implemented in specific layer class\n  };\n\n  /**\n   * Redraw cell\n   */\n  BoardLayer.prototype.redrawCell = function(x, y) {\n    this.clearCell(x, y);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Set the canvas2d context\n   */\n  BoardLayer.prototype.setContext = function(context) {\n    this.context = context;\n  };\n\n  /**\n   * Get the canvas2d context\n   */\n  BoardLayer.prototype.getContext = function() {\n    return this.context;\n  };\n\n  //Return\n  return BoardLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardObject :: Base class for drawing board objects\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Service', [\n  'ngGo',\n  'ngGo.Board.DefaultClearHandler.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardObject', ['DefaultClearHandler', function(DefaultClearHandler) {\n\n  /**\n   * Constructor\n   */\n  var BoardObject = {\n\n    /**\n     * Draw method\n     */\n    draw: function(/*obj*/) {\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n    },\n\n    /**\n     * Clear method\n     */\n    clear: function(obj) {\n      DefaultClearHandler.call(this, this.context, obj);\n    }\n  };\n\n  //Return\n  return BoardObject;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.ShellPattern.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('ShellPattern', function() {\n\n  /**\n   * Helper to draw a shell line\n   */\n  var shellLine = function(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\n\n    //Initialize\n    ctx.shadowBlur = 2;\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = (radius / 30) * this.thickness;\n    ctx.beginPath();\n\n    //Lower radius\n    radius -= Math.max(1, ctx.lineWidth);\n\n    //Determine coordinates\n    var x1 = x + radius * Math.cos(startAngle * Math.PI);\n    var y1 = y + radius * Math.sin(startAngle * Math.PI);\n    var x2 = x + radius * Math.cos(endAngle * Math.PI);\n    var y2 = y + radius * Math.sin(endAngle * Math.PI);\n\n    //Math magic\n    var m, angle;\n    if (x2 > x1) {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m);\n    }\n    else if (x2 === x1) {\n      angle = Math.PI / 2;\n    }\n    else {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m) - Math.PI;\n    }\n\n    //Curvature factor\n    var c = this.factor * radius;\n    var dx = Math.sin(angle) * c;\n    var dy = Math.cos(angle) * c;\n\n    //Curvature coordinates\n    var bx1 = x1 + dx;\n    var by1 = y1 - dy;\n    var bx2 = x2 + dx;\n    var by2 = y2 - dy;\n\n    //Draw shell stroke\n    ctx.moveTo(x1, y1);\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\n    ctx.stroke();\n  };\n\n  /**\n   * Shell pattern drawer\n   */\n  return function(ctx, x, y, radius, angle, strokeStyle) {\n\n    //Initialize start and end angle\n    var startAngle = angle;\n    var endAngle = angle;\n\n    //Loop lines\n    for (var i = 0; i < this.lines.length; i++) {\n      startAngle += this.lines[i];\n      endAngle -= this.lines[i];\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\n    }\n  };\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\n * use static values or dynamic values depending on other properties, like the grid cell size.\n * Using the provider, the theme can be configured globally at application launch.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Theme.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.provider('BoardTheme', ['StoneColor', 'MarkupTypes', function(StoneColor, MarkupTypes) {\n\n  /**\n   * Default theme\n   */\n  var defaultTheme = {\n\n    //Board\n    board: {\n\n      //Board margin factor\n      margin: 0.25\n    },\n\n    //Stones\n    stone: {\n\n      //Stone style can be shell, glass, mono, or specify a custom handler service\n      style: 'shell',\n      shadow: true,\n      radius: function(cellSize) {\n        return Math.floor(cellSize / 2);\n      },\n\n      //Shell stones\n      shell: {\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#111';\n          }\n          return '#BFBFBA';\n        },\n        stroke: 'rgba(128,128,128,0.15)',\n        types: [\n          {\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\n            factor: 0.15,\n            thickness: 1.75\n          },\n          {\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\n            factor: 0.1,\n            thickness: 1.5\n          },\n          {\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\n            factor: 0.05,\n            thickness: 1.75\n          },\n          {\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\n            factor: 0.1,\n            thickness: 2\n          }\n        ]\n      },\n\n      //Mono stones\n      mono: {\n        lineWidth: 1,\n        lineColor: function() {\n          return '#000';\n        },\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#000';\n          }\n          return '#fff';\n        }\n      },\n\n      //Mini stones\n      mini: {\n        scale: 0.5,\n        alpha: 1\n      },\n\n      //Faded stones\n      faded: {\n        scale: 1,\n        alpha: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return 0.3;\n          }\n          return 0.4;\n        }\n      }\n    },\n\n    //Shadows\n    shadow: {\n\n      //Shadow gradient colors\n      color: 'rgba(40,30,20,0.5)',\n\n      //Shadow size\n      size: function(cellSize) {\n        return Math.floor(cellSize / 20);\n      },\n\n      //Shadow blur size\n      blur: function(cellSize) {\n        return cellSize / 20;\n      },\n\n      //Shadow offset\n      offsetX: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      },\n      offsetY: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      }\n    },\n\n    //Markup\n    markup: {\n\n      //Standard color\n      color: function(stoneColor) {\n        if (stoneColor === StoneColor.B) {\n          return 'rgba(255,255,255,0.9)';\n        }\n        return 'rgba(0,0,0,0.9)';\n      },\n\n      //Line width\n      lineWidth: function(cellSize) {\n        return Math.max(1, Math.floor(cellSize / 16));\n      },\n\n      //Triangle\n      triangle: {\n        scale: 0.85\n      },\n\n      //Square\n      square: {\n        scale: 0.85\n      },\n\n      //Cricle\n      circle: {\n        scale: 0.55\n      },\n\n      //Mark\n      mark: {\n        lineCap: 'square',\n        scale: 0.75\n      },\n\n      //Last\n      last: {\n        scale: 0.7\n      },\n\n      //Smiley\n      smiley: {\n        lineCap: 'round',\n        scale: 0.85\n      },\n\n      //Label\n      label: {\n        font: 'Arial'\n      },\n\n      //Variation markup\n      variation: {\n        type: MarkupTypes.LABEL,\n        text: function(i) {\n          return String.fromCharCode(65 + i);\n        },\n        color: 'rgba(86,114,30,0.9)'\n      },\n\n      //Solution paths markup\n      solution: {\n        valid: {\n          type: MarkupTypes.SELECT,\n          text: null,\n          color: 'rgba(86,114,30,1)',\n          scale: 0.5\n        },\n        invalid: {\n          type: MarkupTypes.MARK,\n          text: null,\n          color: 'rgba(237,9,15,1)',\n          scale: 0.3\n        }\n      }\n    },\n\n    //Grid\n    grid: {\n\n      //Line properties\n      lineColor: 'rgba(60,40,15,1)',\n      lineWidth: function(cellSize) {\n        if (cellSize > 60) {\n          return 2;\n        }\n        else if (cellSize > 50) {\n          return 1.5;\n        }\n        return 1;\n      },\n      lineCap: 'square',\n\n      //Star points\n      star: {\n\n        //Color and radius\n        color: 'rgba(60,40,15,1)',\n        radius: function(cellSize) {\n          if (cellSize > 50) {\n            return Math.floor((cellSize / 16) + 1);\n          }\n          else if (cellSize > 30) {\n            return 3;\n          }\n          else if (cellSize > 15) {\n            return 2;\n          }\n          else if (cellSize > 5) {\n            return 1.5;\n          }\n          return 1;\n        },\n\n        //Locations\n        points: function(width, height) {\n\n          //19x19\n          if (width === height && width === 19) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15,y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15,y: 9 },\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15,y: 15 }\n            ];\n          }\n\n          //13x13\n          if (width === height && width === 13) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }\n            ];\n          }\n\n          //9x9\n          if (width === height && width === 9) {\n            return [\n              { x: 4, y: 4}, { x: 2, y: 2},\n              { x: 2, y: 6}, { x: 6, y: 2},\n              { x: 6, y: 6}\n            ];\n          }\n\n          //No star points\n          return [];\n        }\n      }\n    },\n\n    //Coordinates\n    coordinates: {\n\n      //Color\n      color: 'rgba(101,69,37,0.5)',\n\n      //Board margin factor when showing coordinates\n      margin: 1.25,\n\n      //Vertical coordinates style\n      vertical: {\n        font: 'Arial',\n        style: 'numbers',\n        inverse: true,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      },\n\n      //Horizontal coordinates style\n      horizontal: {\n        font: 'Arial',\n        style: 'letters',\n        inverse: false,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      }\n    }\n  };\n\n  /**\n   * Set global default theme\n   */\n  this.setTheme = function(theme) {\n    if (theme) {\n      defaultTheme = angular.merge(defaultTheme, theme);\n    }\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function() {\n\n    /**\n     * Board theme constructor\n     */\n    var BoardTheme = function(theme) {\n\n      //Remember the given instance theme settings and (re)set the theme\n      this.instanceTheme = theme;\n      this.reset();\n    };\n\n    /**\n     * Reset the theme to defaults\n     */\n    BoardTheme.prototype.reset = function() {\n\n      //Use default theme as a base\n      this.theme = angular.copy(defaultTheme);\n\n      //Add any instance theme properties\n      if (this.instanceTheme) {\n        angular.merge(this.theme, this.instanceTheme);\n      }\n    };\n\n    /**\n     * Get a theme property\n     */\n    BoardTheme.prototype.get = function(property) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Can't find the property?\n        if (typeof prop[path[i]] === 'undefined') {\n          console.warn('Could not find theme property', property);\n          return null;\n        }\n\n        //Advance further in the object\n        prop = prop[path[i]];\n      }\n\n      //Found what we're looking for\n      if (typeof prop !== 'function') {\n        return prop;\n      }\n\n      //Prepare arguments\n      var args = [];\n      if (arguments.length > 1) {\n        for (var a = 1; a < arguments.length; a++) {\n          args.push(arguments[a]);\n        }\n      }\n\n      //Call function\n      return prop.apply(this, args);\n    };\n\n    /**\n     * Change a theme property dynamically (accepts handler function as value)\n     */\n    BoardTheme.prototype.set = function(property, value) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Time to set?\n        if ((i + 1) === path.length) {\n          prop[path[i]] = value;\n          break;\n        }\n\n        //Not set?\n        if (typeof prop[path[i]] === 'undefined') {\n          prop[path[i]] = {};\n        }\n\n        //Move on\n        prop = prop[path[i]];\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\n     */\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\n\n      //If no linewidth specified, use the grid line width as a reference\n      //to make sure stuff is aligned to the grid\n      if (typeof lineWidth === 'undefined') {\n        lineWidth = this.get('grid.lineWidth');\n      }\n\n      //Return a translation for uneven widths\n      return (lineWidth % 2) * 0.5;\n    };\n\n    //Return\n    return BoardTheme;\n  };\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidDataError :: Error class to handle invalid data.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidDataError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidDataError', ['ngGo', function(ngGo) {\n\n  /**\n   * Define error\n   */\n  var InvalidDataError = function(code) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidDataError';\n    this.message = 'Invalid data: ';\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.NO_DATA:\n        this.message += 'no data to process.';\n        break;\n      case ngGo.error.UNKNOWN_DATA:\n        this.message += 'unknown data format.';\n        break;\n      case ngGo.error.INVALID_GIB:\n        this.message += 'unable to parse GIB data.';\n        break;\n      case ngGo.error.INVALID_SGF:\n        this.message += 'unable to parse SGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_JSON:\n        this.message += 'unable to parse JGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_TREE_JSON:\n        this.message += 'unable to parse the JGF tree data.';\n        break;\n      default:\n        this.message += 'unable to parse the data.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidDataError.prototype = new Error();\n  InvalidDataError.prototype.constructor = InvalidDataError;\n\n  //Return object\n  return InvalidDataError;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidPositionError :: Error class to handle invalid moves.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidPositionError', ['ngGo', 'StoneColor', function(ngGo, StoneColor) {\n\n  /**\n   * Define error\n   */\n  var InvalidPositionError = function(code, x, y, color) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidPositionError';\n    this.message = 'Invalid position detected.';\n\n    //Add position data\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\n        ' stone on (' + x + ', ' + y + ')';\n    }\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\n        this.message += ', but these coordinates are not on the board.';\n        break;\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\n        this.message += ', but there is already a stone on those coordinates.';\n        break;\n      case ngGo.error.POSTITION_IS_SUICIDE:\n        this.message += ', but that would be suicide.';\n        break;\n      case ngGo.error.POSTITION_IS_REPEATING:\n        this.message += ', but this position already occured.';\n        break;\n      default:\n        this.message += '.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidPositionError.prototype = new Error();\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\n\n  //Return object\n  return InvalidPositionError;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Game :: This class represents a game record or a game that is being played/edited. The class\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\n * The class also keeps a stack of all board positions in memory and can validate moves to make\n * sure they are not repeating or suicide.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Service', [\n  'ngGo',\n  'ngGo.Game.Path.Service',\n  'ngGo.Game.Node.Service',\n  'ngGo.Game.Position.Service',\n  'ngGo.Kifu.Blank.Service',\n  'ngGo.Kifu.Parser.Service',\n  'ngGo.Errors.InvalidDataError.Service',\n  'ngGo.Errors.InvalidPositionError.Service'\n])\n\n/**\n * Factory definition\n */\n.provider('Game', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default size of board\n    defaultSize: 0,\n\n    //Default komi and handicap\n    defaultKomi: 0,\n    defaultHandicap: 0,\n\n    //Remember last selected variation when traversing nodes\n    rememberPath: true,\n\n    //Check for repeating positions? (KO / ALL / empty)\n    checkRepeat: 'KO',\n\n    //Allow suicide?\n    allowSuicide: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['ngGo', 'StoneColor', 'GamePath', 'GameNode', 'GamePosition', 'KifuParser', 'KifuBlank', 'InvalidDataError', 'InvalidPositionError', function(\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\n    KifuBlank, InvalidDataError, InvalidPositionError\n  ) {\n\n    /*****************************************************************************\n     * General helpers\n     ***/\n\n    /**\n     * Validate the info we have to make sure the properties exist\n     */\n    var validateInfo = function() {\n\n      //Set board info if not set\n      if (!this.info.board) {\n        this.info.board = {};\n      }\n\n      //Set game info if not set\n      if (!this.info.game) {\n        this.info.game = {};\n      }\n\n      //Set defaults\n      if (typeof this.info.board.width === 'undefined') {\n        this.info.board.width = this.config.defaultSize;\n      }\n      if (typeof this.info.board.height === 'undefined') {\n        this.info.board.height = this.config.defaultSize;\n      }\n      if (typeof this.info.game.komi === 'undefined') {\n        this.info.game.komi = this.config.defaultKomi;\n      }\n      if (typeof this.info.game.handicap === 'undefined') {\n        this.info.game.handicap = this.config.defaultHandicap;\n      }\n    };\n\n    /*****************************************************************************\n     * Node navigation helpers\n     ***/\n\n    /**\n     * Navigate to the next node\n     */\n    var nextNode = function(i) {\n\n      //Check if we have children\n      if (this.node.children.length === 0) {\n        return false;\n      }\n\n      //Remembered the path we took earlier?\n      if (i === undefined) {\n        i = this.node.rememberedPath;\n      }\n\n      //Determine which child node to process\n      i = i || 0;\n      if (i === -1) {\n        i = 0;\n      }\n\n      //Validate\n      if (i >= this.node.children.length || !this.node.children[i]) {\n        return false;\n      }\n\n      //Advance path\n      this.path.advance(i);\n\n      //Set pointer of current node\n      this.node = this.node.children[i];\n      return true;\n    };\n\n    /**\n     * Navigate to the previous node\n     */\n    var previousNode = function() {\n\n      //No parent node?\n      if (!this.node.parent) {\n        return false;\n      }\n\n      //Retreat path\n      this.path.retreat();\n\n      //Set pointer of current node\n      this.node = this.node.parent;\n      return true;\n    };\n\n    /**\n     * Navigate to the first node\n     */\n    var firstNode = function() {\n\n      //Reset path\n      this.path.reset();\n\n      //Set node pointer back to root\n      this.node = this.root;\n\n      //Set the initial turn depending on handicap\n      //Can be overwritten by game record instructions\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\n    };\n\n    /*****************************************************************************\n     * Position history helpers\n     ***/\n\n    /**\n     * Clear the position history and initialize with a blank position\n     */\n    var initializeHistory = function() {\n\n      //Already at beginning?\n      if (this.history.length === 1) {\n        return;\n      }\n\n      //Clear positions stack and create new blank position\n      this.history = [];\n      this.history.push(new GamePosition());\n\n      //Set board size if we have the info\n      if (this.info.board) {\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\n      }\n    };\n\n    /**\n     * Add position to stack. If position isn't specified current position is\n     * cloned and stacked. Pointer of actual position is moved to the new position.\n     */\n    var pushPosition = function(newPosition) {\n\n      //Position not given?\n      if (!newPosition) {\n        newPosition = this.position.clone();\n      }\n\n      //Push\n      this.history.push(newPosition);\n      return newPosition;\n    };\n\n    /**\n     * Remove current position from stack\n     */\n    var popPosition = function() {\n\n      //Nothing left?\n      if (this.history.length === 0) {\n        return null;\n      }\n\n      //Get old position\n      return this.history.pop();\n    };\n\n    /**\n     * Replace the current position in the stack\n     */\n    var replacePosition = function(newPosition) {\n      if (newPosition) {\n        this.history.pop();\n        this.history.push(newPosition);\n      }\n    };\n\n    /*****************************************************************************\n     * Execution helpers\n     ***/\n\n    /**\n     * Execute the current node\n     */\n    var executeNode = function() {\n\n      //Remember last selected node if we have a parent\n      if (this.node.parent) {\n        this.node.parent.rememberedPath = this.node.parent.children.indexOf(this.node);\n      }\n\n      //Initialize new position\n      var i;\n      var newPosition = this.position.clone();\n\n      //Handle moves\n      if (this.node.isMove()) {\n        if (this.node.move.pass) {\n          newPosition.setTurn(-this.node.move.color);\n        }\n        else {\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\n        }\n      }\n\n      //Handle turn instructions\n      if (this.node.turn) {\n        newPosition.setTurn(this.node.turn);\n      }\n\n      //Handle setup instructions\n      if (this.node.setup) {\n        for (i in this.node.setup) {\n          if (this.node.setup.hasOwnProperty(i)) {\n            newPosition.stones.set(\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\n            );\n          }\n        }\n      }\n\n      //Handle markup\n      if (this.node.markup) {\n        for (i in this.node.markup) {\n          if (this.node.markup.hasOwnProperty(i)) {\n            newPosition.markup.set(\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\n            );\n          }\n        }\n      }\n\n      //Push the new position into the history now\n      pushPosition.call(this, newPosition);\n    };\n\n    /*****************************************************************************\n     * Game class\n     ***/\n\n    /**\n     * Constructor\n     */\n    var Game = function(data, config) {\n\n      //Extend config\n      this.config = angular.extend({}, defaultConfig, config || {});\n\n      //Define property getter/setter for position\n      Object.defineProperty(this, 'position', {\n\n        //Getter returns the last position from the stack\n        get: function() {\n          return this.history[this.history.length - 1];\n        },\n\n        //Setter adds a new position to the stack\n        set: function(newPosition) {\n          this.history[this.history.length] = newPosition;\n        }\n      });\n\n      //Load data\n      if (data) {\n        this.load(data);\n      }\n      else {\n        this.init();\n      }\n    };\n\n    /**\n     * Initialize\n     */\n    Game.prototype.init = function() {\n\n      //Info properties\n      this.info = {};\n\n      //The rood node and pointer to the current node\n      this.root = null;\n      this.node = null;\n\n      //Game path\n      this.path = new GamePath();\n\n      //JGF record we loaded from\n      this.jgf = null;\n\n      //Positions history stack\n      this.history = [];\n    };\n\n    /**\n     * Load game record data\n     */\n    Game.prototype.load = function(data) {\n\n      //Initialize\n      this.init();\n\n      //Try to load game record data\n      try {\n        this.fromData(data);\n      }\n      catch (errorCode) {\n\n        //Just initialize our history with a blank position\n        initializeHistory.call(this);\n\n        //Wrap error code in error object\n        throw new InvalidDataError(errorCode);\n      }\n\n      //Go to the first move\n      this.first();\n    };\n\n    /**\n     * Reload game record\n     */\n    Game.prototype.reload = function() {\n      if (this.jgf) {\n        this.load(this.jgf);\n      }\n    };\n\n    /**\n     * Check if we managed to load a valid game record\n     */\n    Game.prototype.isLoaded = function() {\n      return this.root !== null;\n    };\n\n    /*****************************************************************************\n     * Game cloning and conversion\n     ***/\n\n    /**\n     * Clone this game\n     */\n    Game.prototype.clone = function() {\n\n      //Create new kifu object and get properties\n      var clone = new Game();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy all properties\n      for (var p = 0; p < props.length; p++) {\n        clone[p] = angular.copy(this[p]);\n      }\n\n      //Return clone\n      return clone;\n    };\n\n    /**\n     * Load from an unknown data source\n     */\n    Game.prototype.fromData = function(data) {\n\n      //No data, can't do much\n      if (!data) {\n        throw ngGo.error.NO_DATA;\n      }\n\n      //String given, could be stringified JGF, an SGF or GIB file\n      if (typeof data === 'string') {\n        var c = data.charAt(0);\n        if (c === '(') {\n          return this.fromSgf(data);\n        }\n        else if (c === '{' || c === '[') {\n          return this.fromJgf(data);\n        }\n        else if (c === '\\\\') {\n          return this.fromGib(data);\n        }\n        else {\n          throw ngGo.error.UNKNOWN_DATA;\n        }\n      }\n\n      //Object given? Probably a JGF object\n      else if (typeof data === 'object') {\n        this.fromJgf(data);\n      }\n\n      //Something else?\n      else {\n        throw ngGo.error.UNKNOWN_DATA;\n      }\n    };\n\n    /**\n     * Load from GIB data\n     */\n    Game.prototype.fromGib = function(gib) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.gib2jgf(gib);\n      if (!jgf) {\n        throw ngGo.error.INVALID_GIB;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from SGF data\n     */\n    Game.prototype.fromSgf = function(sgf) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.sgf2jgf(sgf);\n      if (!jgf) {\n        throw ngGo.error.INVALID_SGF;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from JGF data\n     */\n    Game.prototype.fromJgf = function(jgf) {\n\n      //Parse jgf string\n      if (typeof jgf === 'string') {\n        try {\n          jgf = angular.fromJson(jgf);\n        }\n        catch (error) {\n          throw ngGo.error.INVALID_JGF_JSON;\n        }\n      }\n\n      //If array given, convert to object with only tree\n      if (angular.isArray(jgf)) {\n        jgf = {\n          tree: jgf\n        };\n      }\n\n      //Parse tree string\n      if (typeof jgf.tree === 'string') {\n        if (jgf.tree.charAt(0) === '[') {\n          try {\n            jgf.tree = angular.fromJson(jgf.tree);\n          }\n          catch (error) {\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\n          }\n        }\n        else {\n          jgf.tree = [];\n        }\n      }\n\n      //Copy all properties except moves tree\n      for (var i in jgf) {\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\n          this.info[i] = angular.copy(jgf[i]);\n        }\n      }\n\n      //Validate info\n      validateInfo.call(this);\n\n      //Create root node\n      this.root = new GameNode();\n\n      //Tree given? Load all the moves\n      if (jgf.tree) {\n        this.root.fromJgf(jgf.tree);\n      }\n\n      //Remember JGF\n      this.jgf = jgf;\n    };\n\n    /**\n     * Convert to SGF\n     */\n    Game.prototype.toSgf = function() {\n      return KifuParser.jgf2sgf(this.toJgf());\n    };\n\n    /**\n     * Convert to JGF (optionally stringified)\n     */\n    Game.prototype.toJgf = function(stringify) {\n\n      //Initialize JGF and get properties\n      var jgf = KifuBlank.jgf();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy properties\n      for (var p = 0; p < props.length; p++) {\n\n        //Skip root\n        if (p === 'root') {\n          continue;\n        }\n\n        //Already present on JGF object? Extend\n        if (jgf[p]) {\n          jgf[p] = angular.extend(jgf[p], this[p]);\n        }\n\n        //Otherwise copy\n        else {\n          jgf[p] = angular.copy(this[p]);\n        }\n      }\n\n      //Build tree\n      jgf.tree = this.root.toJgf();\n\n      //Return\n      return stringify ? angular.toJson(jgf) : jgf;\n    };\n\n    /*****************************************************************************\n     * Getters\n     ***/\n\n    /**\n     * Get current node\n     */\n    Game.prototype.getNode = function() {\n      return this.node;\n    };\n\n    /**\n     * Get nodes array for currently remembered path\n     */\n    Game.prototype.getNodes = function() {\n\n      //Initialize node to process\n      var node = this.root;\n      var nodes = [node];\n\n      //Process children\n      while (node) {\n        node = node.getChild(node.rememberedPath);\n        if (node) {\n          nodes.push(node);\n        }\n      }\n\n      //Return nodes\n      return nodes;\n    };\n\n    /**\n     * Get node for a certain move\n     */\n    Game.prototype.getMoveNode = function(move) {\n      var nodes = this.getMoveNodes(move, move);\n      return nodes.length ? nodes[0] : null;\n    };\n\n    /**\n     * Get move nodes restricted by given move numbers\n     */\n    Game.prototype.getMoveNodes = function(fromMove, toMove) {\n\n      //Get all nodes for the current path\n      var nodes = this.getNodes();\n\n      //Use sensible defaults if no from/to moves given\n      fromMove = fromMove || 1;\n      toMove = toMove || nodes.length;\n\n      //Filter\n      return nodes.filter(function(node) {\n        if (node.isMove()) {\n          var move = node.getMoveNumber();\n          return (move >= fromMove && move <= toMove);\n        }\n        return false;\n      });\n    };\n\n    /**\n     * Get current move number\n     */\n    Game.prototype.getMove = function() {\n      if (this.node) {\n        return this.node.getMoveNumber();\n      }\n      return 0;\n    };\n\n    /**\n     * Get the number of moves in the main branch\n     */\n    Game.prototype.getMoveCount = function() {\n      var moveNodes = this.getMoveNodes();\n      return moveNodes.length;\n    };\n\n    /**\n     * Get the move variation for given coordinates\n     */\n    Game.prototype.getMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.getMoveVariation(x, y);\n      }\n      return -1;\n    };\n\n    /**\n     * Get the current game position\n     */\n    Game.prototype.getPosition = function() {\n      return this.position;\n    };\n\n    /**\n     * Get the game path\n     */\n    Game.prototype.getPath = function(clone) {\n      if (clone) {\n        return this.path.clone();\n      }\n      return this.path;\n    };\n\n    /**\n     * Clone the current game path\n     */\n    Game.prototype.clonePath = function() {\n      return this.path.clone();\n    };\n\n    /**\n     * Get the game path to a certain named node\n     */\n    Game.prototype.getPathToNode = function(nodeName) {\n      return GamePath.findNode(nodeName, this.root);\n    };\n\n    /**\n     * Get the game komi\n     */\n    Game.prototype.getKomi = function() {\n      var komi = this.get('game.komi', 0);\n      return parseFloat(komi);\n    };\n\n    /**\n     * Set the game komi\n     */\n    Game.prototype.setKomi = function(komi) {\n      if (typeof komi === 'undefined') {\n        komi = this.config.defaultKomi;\n      }\n      this.info.game.komi = parseFloat(komi);\n    };\n\n    /**\n     * Get the game name\n     */\n    Game.prototype.getName = function() {\n      return this.get('game.name', '');\n    };\n\n    /**\n     * Get the game result\n     */\n    Game.prototype.getResult = function() {\n      return this.get('game.result', '');\n    };\n\n    /**\n     * Get the player turn for this position\n     */\n    Game.prototype.getTurn = function() {\n\n      //Must have a position\n      if (!this.history.length) {\n        return StoneColor.B;\n      }\n\n      //Get from position\n      return this.position.getTurn();\n    };\n\n    /**\n     * Set the player turn for the current position\n     */\n    Game.prototype.setTurn = function(color) {\n\n      //Must have a position\n      if (!this.history.length) {\n        return;\n      }\n\n      //Set in position\n      this.position.setTurn(color);\n    };\n\n    /**\n     * Get the total capture count up to the current position\n     */\n    Game.prototype.getCaptureCount = function() {\n\n      //Initialize\n      var captures = {};\n      captures[StoneColor.B] = 0;\n      captures[StoneColor.W] = 0;\n\n      //Loop all positions and increment capture count\n      for (var i = 0; i < this.history.length; i++) {\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\n      }\n\n      //Return\n      return captures;\n    };\n\n    /**\n     * Get an info property\n     */\n    Game.prototype.get = function(property, defaultValue) {\n\n      //Must have a property\n      if (!property) {\n        return;\n      }\n\n      //The item's property in the object is given by dot separated strings\n      if (typeof property === 'string') {\n        property = property.split('.');\n      }\n\n      //Initialize object we're getting info from\n      var obj = this.info;\n      var key;\n\n      //Loop the properties\n      for (var p = 0; p < property.length; p++) {\n\n        //Get actual key\n        key = property[p];\n\n        //Last key reached? Done, get value\n        if ((p + 1) === property.length) {\n          if (typeof obj[key] === 'undefined') {\n            return defaultValue;\n          }\n          return obj[key];\n        }\n\n        //Must be object container\n        if (typeof obj[key] !== 'object') {\n          console.warn('Game info property', key, 'is not an object');\n          return defaultValue;\n        }\n\n        //Move up in tree\n        obj = obj[key];\n      }\n    };\n\n    /*****************************************************************************\n     * Checkers\n     ***/\n\n    /**\n     * Check if coordinates are on the board\n     */\n    Game.prototype.isOnBoard = function(x, y) {\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\n    };\n\n    /**\n     * Check if given coordinates are one of the next child node coordinates\n     */\n    Game.prototype.isMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.isMoveVariation(x, y);\n      }\n      return false;\n    };\n\n    /**\n     * Check if a given position is repeating within this game\n     */\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\n\n      //Init\n      var stop;\n\n      //Check for ko only? (Last two positions)\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\n        stop = this.history.length - 2;\n      }\n\n      //Check all history?\n      else if (this.checkRepeat === 'ALL') {\n        stop = 0;\n      }\n\n      //Not repeating\n      else {\n        return false;\n      }\n\n      //Loop history of positions to check\n      for (var i = this.history.length - 2; i >= stop; i--) {\n        if (checkPosition.isSameAs(this.history[i])) {\n          return true;\n        }\n      }\n\n      //Not repeating\n      return false;\n    };\n\n    /**\n     * Wrapper for validateMove() returning a boolean and catching any errors\n     */\n    Game.prototype.isValidMove = function(x, y, color) {\n      try {\n        this.validateMove(x, y, color);\n        return true;\n      }\n      catch (error) {\n        return false;\n      }\n    };\n\n    /**\n     * Check if a move is valid. If valid, the new game position object is returned.\n     * You can supply a pre-created position to use, or the current position is cloned.\n     */\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Something already here?\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\n      }\n\n      //Set color of move to make\n      color = color || this.position.getTurn();\n\n      //Determine position to use\n      newPosition = newPosition || this.position.clone();\n\n      //Place the stone\n      newPosition.stones.set(x, y, color);\n\n      //Capture adjacent stones if possible\n      var captures = newPosition.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created?\n        if (!newPosition.hasLiberties(x, y)) {\n\n          //Capture the group if it's allowed\n          if (this.allowSuicide) {\n            newPosition.captureGroup(x, y);\n          }\n\n          //Invalid move\n          else {\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\n          }\n        }\n      }\n\n      //Check history for repeating moves\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\n      }\n\n      //Set proper turn\n      newPosition.setTurn(-color);\n\n      //Move is valid\n      return newPosition;\n    };\n\n    /**\n     * Check if a stone (setup) placement is valid.\n     */\n    Game.prototype.validatePlacement = function(x, y, color, position) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Place the stone\n      position.stones.set(x, y, color);\n\n      //Empty spot? Don't need to check for captures\n      if (color === StoneColor.EMPTY) {\n        return;\n      }\n\n      //Capture adjacent stones if possible\n      var captures = position.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created? Capture it\n        if (!position.hasLiberties(x, y)) {\n          position.captureGroup(x, y);\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Stone and markup handling\n     ***/\n\n    /**\n     * Add a stone\n     */\n    Game.prototype.addStone = function(x, y, color) {\n\n      //Check if there's anything to do at all\n      if (this.position.stones.is(x, y, color)) {\n        return;\n      }\n\n      //Create temporary position\n      var tempPosition = this.position.clone();\n\n      //Validate placement on temp position\n      this.validatePlacement(x, y, color, tempPosition);\n\n      //No setup instructions container in this node?\n      if (typeof this.node.setup === 'undefined') {\n\n        //Is this a move node?\n        if (this.node.isMove()) {\n\n          //Clone our position\n          pushPosition.call(this);\n\n          //Create new node\n          var node = new GameNode();\n\n          //Append it to the current node and change the pointer\n          var i = node.appendTo(this.node);\n          this.node = node;\n\n          //Advance path to the added node index\n          this.path.advance(i);\n        }\n\n        //Create setup container in this node\n        this.node.setup = [];\n      }\n\n      //Replace current position\n      replacePosition.call(this, tempPosition);\n\n      //Add setup instructions to node\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\n    };\n\n    /**\n     * Add markup\n     */\n    Game.prototype.addMarkup = function(x, y, markup) {\n\n      //No markup instructions container in this node?\n      if (typeof this.node.markup === 'undefined') {\n        this.node.markup = [];\n      }\n\n      //Add markup to game position\n      this.position.markup.set(x, y, markup);\n\n      //Add markup instructions to node\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\n    };\n\n    /**\n     * Remove a stone\n     */\n    Game.prototype.removeStone = function(x, y) {\n\n      //Check if the stone is found in setup instructions\n      var foundInSetup = false;\n\n      //Remove from node setup instruction\n      if (typeof this.node.setup !== 'undefined') {\n        for (var i = 0; i < this.node.setup.length; i++) {\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\n\n            //Remove from node and unset in position\n            this.node.setup.splice(i, 1);\n            this.position.stones.unset(x, y);\n\n            //Mark as found\n            foundInSetup = true;\n            break;\n          }\n        }\n      }\n\n      //Not found in setup? Add as no stone color\n      if (!foundInSetup) {\n        this.addStone(x, y, StoneColor.EMPTY);\n      }\n    };\n\n    /**\n     * Remove markup\n     */\n    Game.prototype.removeMarkup = function(x, y) {\n\n      //Remove from node\n      if (typeof this.node.markup !== 'undefined') {\n        for (var i = 0; i < this.node.markup.length; i++) {\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\n            this.node.markup.splice(i, 1);\n            this.position.markup.unset(x, y);\n            break;\n          }\n        }\n      }\n    };\n\n    /**\n     * Check if there is a stone at the given coordinates for the current position\n     */\n    Game.prototype.hasStone = function(x, y, color) {\n      if (typeof color !== 'undefined') {\n        return this.position.stones.is(x, y, color);\n      }\n      return this.position.stones.has(x, y);\n    };\n\n    /**\n     * Check if there is markup at the given coordinate for the current position\n     */\n    Game.prototype.hasMarkup = function(x, y, type) {\n      if (typeof type !== 'undefined') {\n        return this.position.markup.is(x, y, type);\n      }\n      return this.position.markup.has(x, y);\n    };\n\n    /**\n     * Get stone on coordinates\n     */\n    Game.prototype.getStone = function(x, y) {\n      return this.position.stones.get(x, y);\n    };\n\n    /**\n     * Get markup on coordinates\n     */\n    Game.prototype.getMarkup = function(x, y) {\n      return this.position.markup.get(x, y);\n    };\n\n    /*****************************************************************************\n     * Move handling\n     ***/\n\n    /**\n     * Play move\n     */\n    Game.prototype.play = function(x, y, color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Validate move and get new position\n      var newPosition = this.validateMove(x, y, color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          x: x,\n          y: y,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node.rememberedPath = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n\n      //Valid move\n      return true;\n    };\n\n    /**\n     * Play pass\n     */\n    Game.prototype.pass = function(color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Initialize new position and switch the turn\n      var newPosition = this.position.clone();\n      newPosition.setTurn(-color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          pass: true,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node.rememberedPath = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n    };\n\n    /*****************************************************************************\n     * Game tree navigation\n     ***/\n\n    /**\n     * Go to the next position\n     */\n    Game.prototype.next = function(i) {\n\n      //Object (node) given as parameter? Find index\n      if (typeof i === 'object') {\n        i = this.node.children.indexOf(i);\n      }\n\n      //Go to the next node\n      if (nextNode.call(this, i)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n          return true;\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n\n      //Didn't go to next position\n      return false;\n    };\n\n    /**\n     * Go to the previous position\n     */\n    Game.prototype.previous = function() {\n\n      //Go to the previous node\n      if (previousNode.call(this)) {\n        popPosition.call(this);\n        return true;\n      }\n\n      //Didn't go to previous position\n      return false;\n    };\n\n    /**\n     * Go to the last position\n     */\n    Game.prototype.last = function() {\n\n      //Keep going to the next node until we reach the end\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the first position\n     */\n    Game.prototype.first = function() {\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      executeNode.call(this);\n    };\n\n    /**\n     * Go to position specified by a path object, a numeric move numer, or a node name string\n     */\n    Game.prototype.goto = function(target) {\n\n      //Must have a tree\n      if (this.root === null) {\n        return;\n      }\n\n      //Nothing given?\n      if (typeof target === 'undefined') {\n        return;\n      }\n\n      //Function given? Call now\n      if (typeof target === 'function') {\n        target = target.call(this);\n      }\n\n      //Initialize path\n      var path;\n\n      //Simple move number? Convert to path object\n      if (typeof target === 'number') {\n        path = this.path.clone();\n        path.setMove(target);\n      }\n\n      //String? Named node\n      else if (typeof target === 'string') {\n\n        //Already here?\n        if (this.node.name === target) {\n          return;\n        }\n\n        //Find path to node\n        path = this.getPathToNode(target);\n        if (path === null) {\n          return;\n        }\n      }\n\n      //Otherwise assume path object\n      else {\n        path = target;\n      }\n\n      //Already here?\n      if (this.path.compare(path)) {\n        return;\n      }\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      pushPosition.call(this);\n      executeNode.call(this);\n\n      //Loop path\n      var n = path.getMove();\n      for (var i = 0; i < n; i++) {\n\n        //Try going to the next node\n        if (!nextNode.call(this, path.nodeAt(i))) {\n          break;\n        }\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the next fork\n     */\n    Game.prototype.nextFork = function() {\n\n      //Keep going to the next node until we reach one with multiple children\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Have multiple children?\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous fork\n     */\n    Game.prototype.previousFork = function() {\n\n      //Loop until we find a node with more than one child\n      while (previousNode.call(this)) {\n        popPosition.call(this);\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the next move with comments\n     */\n    Game.prototype.nextComment = function() {\n\n      //Keep going to the next node until we find one with comments\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous move with comments\n     */\n    Game.prototype.previousComment = function() {\n\n      //Go back until we find a node with comments\n      while (previousNode.call(this)) {\n\n        //Pop the position\n        popPosition.call(this);\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state\n     */\n    Game.prototype.getState = function() {\n\n      //Can only create when we have a JGF and path\n      if (!this.jgf || !this.path) {\n        return null;\n      }\n\n      //Create state\n      var state = {\n        jgf: this.jgf,\n        path: this.path.clone()\n      };\n\n      //Return\n      return state;\n    };\n\n    /**\n     * Restore the game state\n     */\n    Game.prototype.restoreState = function(state) {\n\n      //Must have jgf and path\n      if (!state || !state.jgf || !state.path) {\n        return;\n      }\n\n      //Restore state\n      this.load(state.jgf);\n      this.goto(state.path);\n    };\n\n    //Return object\n    return Game;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GameNode :: This class represents a single node in the game moves tree. It contains\n * properties like the x and y grid coordinates, the move played, board setup instructions,\n * markup, player turn and comments. The moves tree in the game record is represented by a\n * string of GameNodes, each with pointers to their parent and children. Each node can have\n * multiple children (move variations), but only one parent.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Node.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameNode', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /**\n   * Helper to construct a coordinates base object\n   */\n  var coordinatesObject = function(coords, baseObject) {\n    baseObject = baseObject || {};\n    if (coords === '' || coords === 'pass') {\n      baseObject.pass = true;\n    }\n    else {\n\n      //Backwards compatibility with SGF string coordinates in JGF\n      if (typeof coords === 'string') {\n        coords = convertCoordinates(coords);\n      }\n\n      //Append coordinates\n      baseObject.x = coords[0] * 1;\n      baseObject.y = coords[1] * 1;\n    }\n    return baseObject;\n  };\n\n  /**\n   * Convert a numeric color value (color constant) to a string\n   */\n  var toStringColor = function(color) {\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\n  };\n\n  /**\n   * Convert a string color value to a numeric color constant\n   */\n  var toColorConstant = function(color) {\n    if (color === 'B') {\n      return StoneColor.B;\n    }\n    else if (color === 'W') {\n      return StoneColor.W;\n    }\n    return StoneColor.E;\n  };\n\n  /*****************************************************************************\n   * Helpers for conversion between JGF / KIFU format\n   ***/\n\n  /**\n   * Convert move object to JGF format\n   */\n  var convertMoveToJgf = function(move) {\n\n    //Initialize JGF move object and determine color\n    var jgfMove = angular.copy(move);\n    var color = toStringColor(move.color);\n\n    //No color?\n    if (color === '') {\n      return null;\n    }\n\n    //Pass move?\n    if (move.pass === true) {\n      jgfMove[color] = 'pass';\n    }\n\n    //Regular move\n    else {\n      jgfMove[color] = [move.x, move.y];\n    }\n\n    //Delete coordinates and color\n    delete jgfMove.x;\n    delete jgfMove.y;\n    delete jgfMove.color;\n\n    //Return move\n    return jgfMove;\n  };\n\n  /**\n   * Convert move from JGF format\n   */\n  var convertMoveFromJgf = function(move) {\n\n    //Prepare color, coordinates\n    var color, coords;\n\n    //Check whose move it was\n    if (move.W) {\n      color = 'W';\n      coords = move.W;\n    }\n    else if (move.B) {\n      color = 'B';\n      coords = move.B;\n    }\n\n    //No coordinates?\n    if (!coords) {\n      return null;\n    }\n\n    //Return coordinates object\n    return coordinatesObject(coords, {\n      color: toColorConstant(color)\n    });\n  };\n\n  /**\n   * Convert setup object to JGF format\n   */\n  var convertSetupToJgf = function(setup) {\n\n    //Initialize variables\n    var i, color;\n    var jgfSetup = {};\n\n    //Loop setup objects\n    for (i in setup) {\n      if (setup.hasOwnProperty(i)) {\n\n        //Get color\n        color = toStringColor(setup[i].color) || 'E';\n\n        //Initialize array\n        if (typeof jgfSetup[color] === 'undefined') {\n          jgfSetup[color] = [];\n        }\n\n        //Add coordinates\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\n      }\n    }\n\n    //Return\n    return jgfSetup;\n  };\n\n  /**\n   * Convert setup from JGF format\n   */\n  var convertSetupFromJgf = function(setup) {\n\n    //Initialize variables\n    var c, key, color;\n    var gameSetup = [];\n\n    //Loop setup\n    for (key in setup) {\n      if (setup.hasOwnProperty(key)) {\n\n        //Get color constant\n        color = toColorConstant(key);\n\n        //Loop coordinates\n        for (c in setup[key]) {\n          if (setup[key].hasOwnProperty(c)) {\n            gameSetup.push(coordinatesObject(setup[key][c], {\n              color: color\n            }));\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameSetup;\n  };\n\n  /**\n   * Convert markup object to JGF format\n   */\n  var convertMarkupToJgf = function(markup) {\n\n    //Initialize variables\n    var i, type;\n    var jgfMarkup = {};\n\n    //Loop setup objects\n    for (i in markup) {\n      if (markup.hasOwnProperty(i)) {\n\n        //Get type\n        type = markup[i].type;\n\n        //Initialize array\n        if (typeof jgfMarkup[type] === 'undefined') {\n          jgfMarkup[type] = [];\n        }\n\n        //Label?\n        if (type === 'label') {\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\n        }\n        else {\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\n        }\n      }\n    }\n\n    //Return\n    return jgfMarkup;\n  };\n\n  /**\n   * Convert markup from JGF format\n   */\n  var convertMarkupFromJgf = function(markup) {\n\n    //Initialize variables\n    var l, type;\n    var gameMarkup = [];\n\n    //Loop markup types\n    for (type in markup) {\n      if (markup.hasOwnProperty(type)) {\n\n        //Label?\n        if (type === 'label') {\n          for (l = 0; l < markup[type].length; l++) {\n\n            //Validate\n            if (!angular.isArray(markup[type][l])) {\n              continue;\n            }\n\n            //SGF type coordinates?\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\n              var text = markup[type][l][1];\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\n              markup[type][l].push(text);\n            }\n\n            //Validate length\n            if (markup[type][l].length < 3) {\n              continue;\n            }\n\n            //Add to stack\n            gameMarkup.push(coordinatesObject(markup[type][l], {\n              type: type,\n              text: markup[type][l][2]\n            }));\n          }\n        }\n        else {\n\n          //Loop coordinates\n          for (l in markup[type]) {\n            if (markup[type].hasOwnProperty(l)) {\n              gameMarkup.push(coordinatesObject(markup[type][l], {\n                type: type\n              }));\n            }\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameMarkup;\n  };\n\n  /**\n   * Convert turn object to JGF format\n   */\n  var convertTurnToJgf = function(turn) {\n    switch (turn) {\n      case StoneColor.W:\n        return 'W';\n      case StoneColor.B:\n        return 'B';\n      default:\n        return '';\n    }\n  };\n\n  /**\n   * Convert turn from JGF format\n   */\n  var convertTurnFromJgf = function(turn) {\n    switch (turn) {\n      case 'W':\n        return StoneColor.W;\n      case 'B':\n        return StoneColor.B;\n      default:\n        return StoneColor.EMPTY;\n    }\n  };\n\n  /**\n   * Conversions map\n   */\n  var conversionMap = {\n    toJgf: {\n      move: convertMoveToJgf,\n      setup: convertSetupToJgf,\n      markup: convertMarkupToJgf,\n      turn: convertTurnToJgf\n    },\n    fromJgf: {\n      move: convertMoveFromJgf,\n      setup: convertSetupFromJgf,\n      markup: convertMarkupFromJgf,\n      turn: convertTurnFromJgf\n    }\n  };\n\n  /**\n   * Constructor\n   */\n  var GameNode = function(properties, parent) {\n\n    //Set parent and children\n    this.parent = parent || null;\n    this.children = [];\n\n    //Save properties\n    if (properties) {\n      for (var key in properties) {\n        if (properties.hasOwnProperty(key)) {\n          this[key] = properties[key];\n        }\n      }\n    }\n  };\n\n  /**\n   * Get node's child specified by index or null if doesn't exist\n   */\n  GameNode.prototype.getChild = function(i) {\n    i = i || 0;\n    if (this.children[i]) {\n      return this.children[i];\n    }\n    return null;\n  };\n\n  /**\n   * Get all the children\n   */\n  GameNode.prototype.getChildren = function() {\n    return this.children;\n  };\n\n  /**\n   * Check if the node has any chilren\n   */\n  GameNode.prototype.hasChildren = function() {\n    return (this.children.length > 0);\n  };\n\n  /**\n   * Get parent node\n   */\n  GameNode.prototype.getParent = function() {\n    return this.parent;\n  };\n\n  /**\n   * Check if the node has more than one move variation\n   */\n  GameNode.prototype.hasMoveVariations = function() {\n\n    //Less than two child nodes?\n    if (this.children.length <= 1) {\n      return false;\n    }\n\n    //Loop children\n    var moveVariations = 0;\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].isMove()) {\n        moveVariations++;\n      }\n\n      //More than one move node present?\n      if (moveVariations > 1) {\n        return true;\n      }\n    }\n\n    //No move variations\n    return false;\n  };\n\n  /**\n   * Get all the move variation nodes\n   */\n  GameNode.prototype.getMoveVariations = function() {\n\n    //No child nodes?\n    if (this.children.length === 0) {\n      return false;\n    }\n\n    //Initialize\n    var moveVariations = [];\n\n    //Loop child nodes\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].isMove()) {\n        moveVariations.push(this.children[i]);\n      }\n    }\n\n    //Return\n    return moveVariations;\n  };\n\n  /**\n   * Get the move variation for given coordinates\n   */\n  GameNode.prototype.getMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return i;\n      }\n    }\n\n    //Not found\n    return -1;\n  };\n\n  /**\n   * Check if given coordinates are one of the next child node coordinates\n   */\n  GameNode.prototype.isMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return true;\n      }\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Check if we have comments\n   */\n  GameNode.prototype.hasComments = function() {\n    return (this.comments && this.comments.length > 0);\n  };\n\n  /**\n   * Check if this is a move node\n   */\n  GameNode.prototype.isMove = function() {\n    return !!this.move;\n  };\n\n  /**\n   * Get move number\n   */\n  GameNode.prototype.getMoveNumber = function() {\n\n    //Move node?\n    if (this.isMove()) {\n      if (this.parent) {\n        return this.parent.getMoveNumber() + 1;\n      }\n      return 1;\n    }\n\n    //Use parent move number if we have one\n    if (this.parent) {\n      return this.parent.getMoveNumber();\n    }\n\n    //No parent\n    return 0;\n  };\n\n  /*****************************************************************************\n   * Node manipulation\n   ***/\n\n  /**\n   * Remove this node from its parent\n   */\n  GameNode.prototype.remove = function() {\n\n    //Can't remove if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found remove it\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1) {\n      this.parent.children.splice(i, 1);\n    }\n\n    //Clear parent reference\n    this.parent = null;\n  };\n\n  /**\n   * Move the node up in the parent's child tree\n   */\n  GameNode.prototype.moveUp = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i > 0) {\n      var temp = this.parent.children[i - 1];\n      this.parent.children[i - 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Move the node down in the parent's child tree\n   */\n  GameNode.prototype.moveDown = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\n      var temp = this.parent.children[i + 1];\n      this.parent.children[i + 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Append this node to another node\n   */\n  GameNode.prototype.appendTo = function(node) {\n\n    //Remove from existing parent\n    this.remove();\n\n    //Set new parent\n    this.parent = node;\n    node.children.push(this);\n    return node.children.length - 1;\n  };\n\n  /**\n   * Append child node to this node.\n   */\n  GameNode.prototype.appendChild = function(node) {\n    node.parent = this;\n    this.children.push(node);\n    return this.children.length - 1;\n  };\n\n  /**\n   * Insert another node after this one\n   */\n  GameNode.prototype.insertNode = function(node) {\n\n    //Loop our children and change parent node\n    for (var i = 0; i < this.children.length; i++) {\n      this.children[i].parent = node;\n    }\n\n    //Merge children, set this node as the parent of given node\n    node.children = node.children.concat(this.children);\n    node.parent = this;\n\n    //Set given node as the child of this node\n    this.children = [node];\n  };\n\n  /*****************************************************************************\n   * JGF conversion\n   ***/\n\n  /**\n   * Build a Game Node from a given JGF tree\n   */\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\n\n    //Root JGF file given?\n    if (typeof jgf.tree !== 'undefined') {\n      return GameNode.fromJgf(jgf.tree, gameNode);\n    }\n\n    //Initialize helper vars\n    var variationNode, nextNode, i, j;\n\n    //Node to work with given? Otherwise, work with ourselves\n    gameNode = gameNode || this;\n\n    //Loop moves in the JGF tree\n    for (i = 0; i < jgf.length; i++) {\n\n      //Array? That means a variation branch\n      if (angular.isArray(jgf[i])) {\n\n        //Loop variation stacks\n        for (j = 0; j < jgf[i].length; j++) {\n\n          //Build the variation node\n          variationNode = new GameNode();\n          variationNode.fromJgf(jgf[i][j]);\n\n          //Append to working node\n          gameNode.appendChild(variationNode);\n        }\n      }\n\n      //Regular node\n      else {\n\n        //Get properties to copy\n        var properties = Object.getOwnPropertyNames(jgf[i]);\n\n        //Copy node properties\n        for (var key in properties) {\n          if (properties.hasOwnProperty(key)) {\n            var prop = properties[key];\n\n            //Conversion function present?\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\n            }\n            else if (typeof jgf[i][prop] === 'object') {\n              gameNode[prop] = angular.copy(jgf[i][prop]);\n            }\n            else {\n              gameNode[prop] = jgf[i][prop];\n            }\n          }\n        }\n      }\n\n      //Next element is a regular node? Prepare new working node\n      //Otherwise, if there are no more nodes or if the next element is\n      //an array (e.g. variations), we keep our working node as the current one\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\n        nextNode = new GameNode();\n        gameNode.appendChild(nextNode);\n        gameNode = nextNode;\n      }\n    }\n  };\n\n  /**\n   * Convert this node to a JGF node container\n   */\n  GameNode.prototype.toJgf = function(container) {\n\n    //Initialize container to add nodes to\n    container = container || [];\n\n    //Initialize node and get properties\n    var node = {};\n    var properties = Object.getOwnPropertyNames(this);\n\n    //Copy node properties\n    for (var key in properties) {\n      if (properties.hasOwnProperty(key)) {\n        var prop = properties[key];\n\n        //Skip some properties\n        if (prop === 'parent' || prop === 'children') {\n          continue;\n        }\n\n        //Conversion function present?\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\n        }\n        else if (typeof this[prop] === 'object') {\n          node[prop] = angular.copy(this[prop]);\n        }\n        else {\n          node[prop] = this[prop];\n        }\n      }\n    }\n\n    //Add node to container\n    container.push(node);\n\n    //Variations present?\n    if (this.children.length > 1) {\n\n      //Create variations container\n      var variationsContainer = [];\n      container.push(variationsContainer);\n\n      //Loop child (variation) nodes\n      for (var i = 0; i < this.children.length; i++) {\n\n        //Create container for this variation\n        var variationContainer = [];\n        variationsContainer.push(variationContainer);\n\n        //Call child node converter\n        this.children[i].toJgf(variationContainer);\n      }\n    }\n\n    //Just one child?\n    else if (this.children.length === 1) {\n      this.children[0].toJgf(container);\n    }\n\n    //Return container\n    return container;\n  };\n\n  //Return object\n  return GameNode;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePath :: A simple class that keeps track of a path taken in a game.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Path.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePath', function() {\n\n  /**\n   * Constructor\n   */\n  var GamePath = function() {\n    this.reset();\n  };\n\n  /**\n   * Reset\n   */\n  GamePath.prototype.reset = function() {\n    this.move = 0;\n    this.path = {};\n    this.branches = 0;\n    return this;\n  };\n\n  /**\n   * Advance a move\n   */\n  GamePath.prototype.advance = function(i) {\n\n    //Different child variation chosen? Remember\n    if (i > 0) {\n      this.path[this.move] = 1;\n      this.branches++;\n    }\n\n    //Increment move\n    this.move++;\n    return this;\n  };\n\n  /**\n   * Retreat a move\n   */\n  GamePath.prototype.retreat = function() {\n\n    //At start?\n    if (this.move === 0) {\n      return;\n    }\n\n    //Delete path choice\n    if (this.path[this.move]) {\n      delete this.path[this.move];\n      this.branches--;\n    }\n\n    //Decrement move\n    this.move--;\n    return this;\n  };\n\n  /**\n   * Go to a specific move number\n   */\n  GamePath.prototype.setMove = function(no) {\n\n    //Less than our current move? We need to erase any paths above the move number\n    if (no < this.move) {\n      for (var i in this.path) {\n        if (i > no) {\n          delete this.path[i];\n          this.branches--;\n        }\n      }\n    }\n\n    //Set move number\n    this.move = no;\n    return this;\n  };\n\n  /**\n   * Get the move number\n   */\n  GamePath.prototype.getMove = function() {\n    return this.move;\n  };\n\n  /**\n   * Get the node choice at a specific move number\n   */\n  GamePath.prototype.nodeAt = function(no) {\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\n  };\n\n  /**\n   * Compare to another path\n   */\n  GamePath.prototype.compare = function(otherPath) {\n\n    //Invalid object?\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\n      return;\n    }\n\n    //Different move number or path length?\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\n      return false;\n    }\n\n    //Check path\n    for (var i in this.path) {\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\n        return false;\n      }\n    }\n\n    //Same path!\n    return true;\n  };\n\n  /**\n   * Clone\n   */\n  GamePath.prototype.clone = function() {\n\n    //Create new instance\n    var newPath = new GamePath();\n\n    //Set vars\n    newPath.move = this.move;\n    newPath.branches = this.branches;\n    newPath.path = angular.copy(this.path);\n\n    //Return\n    return newPath;\n  };\n\n  /**\n   * Helper to find node name recursively\n   */\n  var findNodeName = function(node, nodeName, path) {\n\n    //Found in this node?\n    if (node.name && node.name === nodeName) {\n      return true;\n    }\n\n    //Loop children\n    for (var i = 0; i < node.children.length; i++) {\n\n      //Advance path\n      path.advance(i);\n\n      //Found in child node?\n      if (findNodeName(node.children[i], nodeName, path)) {\n        return true;\n      }\n\n      //Not found in this child node, retreat path\n      path.retreat();\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Static helper to create a path object to reach a certain node\n   */\n  GamePath.findNode = function(nodeName, rootNode) {\n\n    //Create new instance\n    var path = new GamePath();\n\n    //Find the node name\n    if (findNodeName(rootNode, nodeName, path)) {\n      return path;\n    }\n\n    //Not found\n    return null;\n  };\n\n  //Return\n  return GamePath;\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\n * markup on the board in this position, as well as any captures that were made and which player's\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\n * compare changes to other positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Position.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePosition', ['StoneColor', 'BoardGrid', function(StoneColor, BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var GamePosition = function(width, height) {\n\n    //Initialize\n    this.error = 0;\n    this.width = 0;\n    this.height = 0;\n    this.stones = new BoardGrid();\n    this.markup = new BoardGrid();\n    this.turn = StoneColor.B;\n\n    //Initialize captures\n    this.captures = {};\n    this.captures[StoneColor.B] = [];\n    this.captures[StoneColor.W] = [];\n\n    //Set empty value for stones grid\n    this.stones.whenEmpty(StoneColor.EMPTY);\n\n    //Set size\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set the grid size\n   */\n  GamePosition.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Set in grids\n    this.stones.setSize(width, height);\n    this.markup.setSize(width, height);\n\n    //Empty the position\n    this.empty();\n  };\n\n  /**\n   * Clear the whole position\n   */\n  GamePosition.prototype.empty = function() {\n    this.stones.empty();\n    this.markup.empty();\n  };\n\n  /**\n   * Sets stone color at given coordinates.\n   */\n  GamePosition.prototype.setStone = function(x, y, color) {\n    this.stones.set(x, y, color);\n  };\n\n  /**\n   * Sets markup type at given coordinates.\n   */\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\n    this.markup.set(x, y, markup);\n  };\n\n  /*****************************************************************************\n   * Liberties and capturing\n   ***/\n\n  /**\n   * Check if a group of given color has liberties, starting at the given coordinates\n   */\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\n\n    //Out of bounds? No liberties outside of the board\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Initialize tested grid if needed\n    tested = tested || new BoardGrid(this.width, this.height);\n\n    //See what color is present on the coordinates\n    var color = this.stones.get(x, y);\n\n    //If no group color was given, use what's on the position\n    groupColor = groupColor || color;\n\n    //Already tested, or enemy stone? Not giving any liberties\n    if (tested.get(x, y) === true || color === -groupColor) {\n      return false;\n    }\n\n    //Empty? That's a liberty\n    if (color === StoneColor.EMPTY) {\n      return true;\n    }\n\n    //Mark this position as tested now\n    tested.set(x, y, true);\n\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\n    //If we get at least one true, we have a liberty\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\n        this.hasLiberties(x + 1, y, groupColor, tested);\n  };\n\n  /**\n   * Helper to capture adjacent groups\n   */\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    friendlyColor = friendlyColor || this.stones.get(x, y);\n\n    //Can't capture empty spots\n    if (friendlyColor === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Flag to see if we captured stuff\n    var captured = false;\n\n    //Check adjacent positions now, capturing stones in the process if possible\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n\n    //Return\n    return captured;\n  };\n\n  /**\n   * Helper if we can capture a certain group\n   */\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\n\n    //Out of bounds? Nothing to capture\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Empty spot? Can't capture\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //We need to have a stone of matching group color in order to be able to capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //There is a capturable stone, let's see if it has any liberties left\n    if (this.hasLiberties(x, y, enemyColor)) {\n      return false;\n    }\n\n    //No liberties left, the group is capturable. Capture if we want to\n    if (doCapture) {\n      this.captureGroup(x, y, enemyColor);\n    }\n\n    //Capturable\n    return true;\n  };\n\n  /**\n   * Capture a group of certain color, starting at the given coordinates\n   */\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //If no group color was given, use what's on the position\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //Stone at position does not match the given group color? Can't capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //Capture the stone\n    this.captureStone(x, y);\n\n    //Capture the rest of the group\n    this.captureGroup(x, y - 1, enemyColor);\n    this.captureGroup(x, y + 1, enemyColor);\n    this.captureGroup(x - 1, y, enemyColor);\n    this.captureGroup(x + 1, y, enemyColor);\n\n    //At least one stone was captured\n    return true;\n  };\n\n  /**\n   * Capture a stone at given coordinates\n   */\n  GamePosition.prototype.captureStone = function(x, y) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Get color\n    var color = this.stones.get(x, y);\n\n    //Empty?\n    if (color === StoneColor.EMPTY) {\n      return;\n    }\n\n    //Ok, stone present, capture it\n    this.stones.set(x, y, StoneColor.EMPTY);\n    this.captures[color].push({x: x, y: y});\n  };\n\n  /**\n   * Set captures for a color (expects array with capture object coordinates)\n   */\n  GamePosition.prototype.setCaptures = function(color, captures) {\n    this.captures[color] = captures;\n  };\n\n  /**\n   * Get captures for a color\n   */\n  GamePosition.prototype.getCaptures = function(color) {\n    return this.captures[color] || [];\n  };\n\n  /**\n   * Get the capture count for a color (= the number of captures of the opposing color)\n   */\n  GamePosition.prototype.getCaptureCount = function(color) {\n    return this.captures[-color].length;\n  };\n\n  /*****************************************************************************\n   * Turn control\n   ***/\n\n  /**\n   * Set color for whose move it is at this position\n   */\n  GamePosition.prototype.setTurn = function(color) {\n    this.turn = color;\n  };\n\n  /**\n   * Get color for whose move it is at this position\n   */\n  GamePosition.prototype.getTurn = function() {\n    return this.turn;\n  };\n\n  /**\n   * Switch the player turn on this position\n   */\n  GamePosition.prototype.switchTurn = function() {\n    this.turn = -this.turn;\n  };\n\n  /*****************************************************************************\n   * Cloning and comparison\n   ***/\n\n  /**\n   * Clones the whole position except turn and captures\n   */\n  GamePosition.prototype.clone = function() {\n\n    //Create a new position\n    var newPosition = new GamePosition();\n\n    //Set vars manually for maximum efficiency\n    newPosition.turn = this.turn;\n    newPosition.width = this.width;\n    newPosition.height = this.height;\n    newPosition.stones = this.stones.clone();\n    newPosition.markup = new BoardGrid(this.width, this.height);\n\n    //Return\n    return newPosition;\n  };\n\n  /**\n   * Checks if a given position is the same as the current position\n   */\n  GamePosition.prototype.isSameAs = function(newPosition) {\n\n    //Must have the same size\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\n      return false;\n    }\n\n    //Compare the grids\n    return this.stones.isSameAs(newPosition.stones);\n  };\n\n  //Return\n  return GamePosition;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScore :: A simple class that contains a game score\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Score.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScore', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Helper to calculate the total points\n   */\n  var calcTotal = function() {\n    return parseInt(this.stones) + parseInt(this.territory) +\n      parseInt(this.captures) + parseInt(this.komi);\n  };\n\n  /**\n   * Constructor\n   */\n  var GameScore = function() {\n\n    //Get self\n    var self = this;\n\n    //Setup score containers\n    this.black = {};\n    this.white = {};\n\n    //Initialize\n    this.reset();\n\n    //Add total handlers\n    this.black.total = function() {\n      return calcTotal.call(self.black);\n    };\n    this.white.total = function() {\n      return calcTotal.call(self.white);\n    };\n  };\n\n  /**\n   * Reset the game score\n   */\n  GameScore.prototype.reset = function() {\n\n    //Get properties to loop\n    var props = ['stones', 'territory', 'captures', 'komi'];\n\n    //Score for black player\n    for (var i = 0; i < props.length; i++) {\n      this.black[props[i]] = 0;\n      this.white[props[i]] = 0;\n    }\n  };\n\n  /**\n   * Get the winner\n   */\n  GameScore.prototype.winner = function() {\n\n    //Get totals\n    var b = this.black.total();\n    var w = this.white.total();\n\n    //Determine winner\n    if (w > b) {\n      return StoneColor.W;\n    }\n    else if (b > w) {\n      return StoneColor.B;\n    }\n    return StoneColor.E;\n  };\n\n  //Return\n  return GameScore;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScorer :: This class is used to determine the score of a certain game position. It also\n * provides handling of manual adjustment of dead / living groups.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Scorer.Service', [\n  'ngGo',\n  'ngGo.Game.Score.Service',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScorer', ['GameScore', 'StoneColor', 'BoardGrid', function(GameScore, StoneColor, BoardGrid) {\n\n  /**\n   * Possible score states\n   */\n  var scoreState = {\n    UNKNOWN: StoneColor.EMPTY,\n    BLACK_STONE: StoneColor.B,\n    WHITE_STONE: StoneColor.W,\n    BLACK_CANDIDATE: StoneColor.B * 2,\n    WHITE_CANDIDATE: StoneColor.W * 2,\n    NEUTRAL: StoneColor.B * 3\n  };\n\n  /**\n   * Helper to set territory\n   */\n  var territorySet = function(x, y, candidateColor, boundaryColor) {\n\n    //Get color at given position\n    var posColor = this.stones.get(x, y);\n    var origColor = this.game.position.stones.get(x, y);\n\n    //If border reached, or a position which is already this color, or boundary color, can't set\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\n      return;\n    }\n\n    //Don't turn stones which are already this color into candidates, instead\n    //reset their color to what they were\n    if (origColor * 2 === candidateColor) {\n      this.stones.set(x, y, origColor);\n    }\n\n    //Otherwise, mark as candidate\n    else {\n      this.stones.set(x, y, candidateColor);\n    }\n\n    //Set adjacent squares\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\n  };\n\n  /**\n   * Helper to reset territory\n   */\n  var territoryReset = function(x, y) {\n\n    //Get original color from this position\n    var origColor = this.game.position.stones.get(x, y);\n\n    //Not on grid, or already this color?\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\n      return;\n    }\n\n    //Reset the color\n    this.stones.set(x, y, origColor);\n\n    //Set adjacent squares\n    territoryReset.call(this, x - 1, y);\n    territoryReset.call(this, x, y - 1);\n    territoryReset.call(this, x + 1, y);\n    territoryReset.call(this, x, y + 1);\n  };\n\n  /**\n   * Helper to determine score state\n   */\n  var determineScoreState = function() {\n\n    //Initialize vars\n    var change = true;\n    var curState, newState, adjacent, b, w, a, x, y;\n\n    //Loop while there is change\n    while (change) {\n\n      //Set to false\n      change = false;\n\n      //Go through the whole position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get current state at position\n          curState = this.stones.get(x, y);\n\n          //Unknown or candiates?\n          if (\n            curState === scoreState.UNKNOWN ||\n            curState === scoreState.BLACK_CANDIDATE ||\n            curState === scoreState.WHITE_CANDIDATE\n          ) {\n\n            //Get state in adjacent positions\n            adjacent = [\n              this.stones.get(x - 1, y),\n              this.stones.get(x, y - 1),\n              this.stones.get(x + 1, y),\n              this.stones.get(x, y + 1)\n            ];\n\n            //Reset\n            b = w = false;\n\n            //Loop adjacent squares\n            for (a = 0; a < 4; a++) {\n              if (\n                adjacent[a] === scoreState.BLACK_STONE ||\n                adjacent[a] === scoreState.BLACK_CANDIDATE\n              ) {\n                b = true;\n              }\n              else if (\n                adjacent[a] === scoreState.WHITE_STONE ||\n                adjacent[a] === scoreState.WHITE_CANDIDATE\n              ) {\n                w = true;\n              }\n              else if (adjacent[a] === scoreState.NEUTRAL) {\n                b = w = true;\n              }\n            }\n\n            //Determine new state\n            if (b && w) {\n              newState = scoreState.NEUTRAL;\n            }\n            else if (b) {\n              newState = scoreState.BLACK_CANDIDATE;\n            }\n            else if (w) {\n              newState = scoreState.WHITE_CANDIDATE;\n            }\n            else {\n              newState = false;\n            }\n\n            //Change?\n            if (newState !== false && newState !== curState) {\n              change = true;\n              this.stones.set(x, y, newState);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * this.game scorer class\n   */\n  var GameScorer = {\n\n    //Game to score\n    game: null,\n\n    //Score\n    score: null,\n\n    //Stones, captures and points grids\n    stones: null,\n    captures: null,\n    points: null,\n\n    /**\n     * Load a game to score\n     */\n    load: function(game) {\n\n      //Reset score\n      this.score = new GameScore();\n\n      //Remember\n      this.game = game;\n\n      //Clone position to work with\n      this.stones = this.game.position.stones.clone();\n\n      //Create grids\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n    },\n\n    /**\n     * Get the calculated score\n     */\n    getScore: function() {\n      return this.score;\n    },\n\n    /**\n     * Get the points grid\n     */\n    getPoints: function() {\n      return this.points;\n    },\n\n    /**\n     * Get the captures grid\n     */\n    getCaptures: function() {\n      return this.captures;\n    },\n\n    /**\n     * Run score calculation routine\n     */\n    calculate: function() {\n\n      //No game?\n      if (!this.game) {\n        console.warn('No game loaded in game scorer, can\\'t calutlate score.');\n        return;\n      }\n\n      //Empty grids\n      this.points.empty();\n      this.captures.empty();\n\n      //Determine score state\n      determineScoreState.call(this);\n\n      //Get komi and captures\n      var komi = this.game.get('game.komi');\n      var captures = this.game.getCaptureCount();\n\n      //Reset score\n      this.score.reset();\n\n      //Set captures and komi\n      this.score.black.captures = captures[StoneColor.B];\n      this.score.white.captures = captures[StoneColor.W];\n      this.score.black.komi = komi < 0 ? komi : 0;\n      this.score.white.komi = komi > 0 ? komi : 0;\n\n      //Init helper vars\n      var x, y, state, color;\n\n      //Loop position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get state and color on original position\n          state = this.stones.get(x, y);\n          color = this.game.position.stones.get(x, y);\n\n          //Black stone\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\n            this.score.black.stones++;\n            continue;\n          }\n\n          //White stone\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\n            this.score.white.stones++;\n            continue;\n          }\n\n          //Black candidate\n          if (state === scoreState.BLACK_CANDIDATE) {\n            this.score.black.territory++;\n            this.points.set(x, y, StoneColor.B);\n\n            //White stone underneath?\n            if (color === StoneColor.W) {\n              this.score.black.captures++;\n              this.captures.set(x, y, StoneColor.W);\n            }\n            continue;\n          }\n\n          //White candidate\n          if (state === scoreState.WHITE_CANDIDATE) {\n            this.score.white.territory++;\n            this.points.set(x, y, StoneColor.W);\n\n            //Black stone underneath?\n            if (color === StoneColor.B) {\n              this.score.white.captures++;\n              this.captures.set(x, y, StoneColor.B);\n            }\n            continue;\n          }\n        }\n      }\n    },\n\n    /**\n     * Mark stones dead or alive\n     */\n    mark: function(x, y) {\n\n      //Get color of original position and state of the count position\n      var color = this.game.position.stones.get(x, y);\n      var state = this.stones.get(x, y);\n\n      //White stone\n      if (color === StoneColor.W) {\n\n        //Was white, mark it and any territory it's in as black's\n        if (state === scoreState.WHITE_STONE) {\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\n        }\n\n        //Was marked as not white, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n\n      //Black stone\n      else if (color === StoneColor.B) {\n\n        //Was black, mark it and any territory it's in as white's\n        if (state === scoreState.BLACK_STONE) {\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\n        }\n\n        //Was marked as not black, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n    }\n  };\n\n  //Return\n  return GameScorer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Blank.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('KifuBlank', ['ngGo', function(ngGo) {\n\n  /**\n   * Blank JGF\n   */\n  var blankJgf = {\n    record: {\n      application: ngGo.name + ' v' + ngGo.version,\n      version: 1,\n      charset: 'UTF-8'\n    },\n    game: {\n      type: 'go',\n      players: [\n        {\n          color: 'black',\n          name: 'Black'\n        },\n        {\n          color: 'white',\n          name: 'White'\n        }\n      ]\n    },\n    board: {\n      width: 19,\n      height: 19\n    },\n    tree: []\n  };\n\n  /**\n   * Blank SGF\n   */\n  var blankSgf = {\n    AP: ngGo.name + ':' + ngGo.version,\n    CA: 'UTF-8',\n    FF: '4',\n    GM: '1',\n    SZ: '19',\n    PB: 'Black',\n    PW: 'White'\n  };\n\n  /**\n   * Blank JGF/SGF container\n   */\n  var KifuBlank = {\n\n    /**\n     * Get blank JGF\n     */\n    jgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankJgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    },\n\n    /**\n     * Get blank SGF\n     */\n    sgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankSgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = base[p];\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    }\n  };\n\n  //Return object\n  return KifuBlank;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\n * constants used by the parsers to aid conversion.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parser.Service', [\n  'ngGo',\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service'\n])\n\n/**\n * SGF/JGF aliases constant for conversion between the two formats\n * Note: not all properties can be translated directly, so some are\n * not present here in this constant\n */\n.constant('sgfAliases', {\n\n  //Record properties\n  'AP': 'record.application',\n  'CA': 'record.charset',\n  'CP': 'record.copyright',\n  'SO': 'record.source',\n  'US': 'record.transcriber',\n  'AN': 'record.annotator',\n\n  //Game properties\n  'GM': 'game.type',\n  'GN': 'game.name',\n  'KM': 'game.komi',\n  'HA': 'game.handicap',\n  'RE': 'game.result',\n  'RU': 'game.rules',\n  'TM': 'game.time.main',\n  'OT': 'game.time.overtime',\n  'DT': 'game.dates',\n  'PC': 'game.location',\n  'EV': 'game.event',\n  'RO': 'game.round',\n  'ON': 'game.opening',\n  'GC': 'game.comment',\n\n  //Player info properties\n  'PB': 'name',\n  'PW': 'name',\n  'BT': 'team',\n  'WT': 'team',\n  'BR': 'rank',\n  'WR': 'rank',\n\n  //Node annotation\n  'N': 'name',\n  'C': 'comments',\n  'CR': 'circle',\n  'TR': 'triangle',\n  'SQ': 'square',\n  'MA': 'mark',\n  'SL': 'select',\n  'LB': 'label'\n})\n\n/**\n * SGF game definitions\n */\n.constant('sgfGames', {\n  1: 'go',\n  2: 'othello',\n  3: 'chess',\n  4: 'renju',\n  6: 'backgammon',\n  7: 'chinese chess',\n  8: 'shogi'\n})\n\n/**\n * Factory definition\n */\n.factory('KifuParser', ['Gib2Jgf', 'Sgf2Jgf', 'Jgf2Sgf', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\n\n  /**\n   * Parser wrapper class\n   */\n  var KifuParser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    gib2jgf: function(gib, stringified) {\n      return Gib2Jgf.parse(gib, stringified);\n    },\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    sgf2jgf: function(sgf, stringified) {\n      return Sgf2Jgf.parse(sgf, stringified);\n    },\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    jgf2sgf: function(jgf) {\n      return Jgf2Sgf.parse(jgf);\n    }\n  };\n\n  //Return object\n  return KifuParser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Directive', [\n  'ngGo.Board.Directive'\n])\n\n/**\n * Directive definition\n */\n.directive('player', ['Player', function(Player) {\n  return {\n    restrict: 'E',\n\n    /**\n     * Controller\n     */\n    controller: ['$scope', function($scope) {\n\n      //Set player in scope\n      if (!$scope.Player) {\n        $scope.Player = Player;\n      }\n    }],\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Link the element\n      Player.linkElement(element);\n\n      //Observe mode and tool attributes\n      attrs.$observe('mode', function(mode) {\n        Player.switchMode(mode);\n      });\n      attrs.$observe('tool', function(tool) {\n        Player.switchTool(tool);\n      });\n\n      //Observe other settings attributes\n      attrs.$observe('variationMarkup', function(attr) {\n        Player.setVariationMarkup(attr === 'true');\n      });\n      attrs.$observe('solutionPaths', function(attr) {\n        Player.toggleSolutionPaths(attr === 'true');\n      });\n      attrs.$observe('lastMoveMarker', function(attr) {\n        Player.setLastMoveMarker(attr);\n      });\n    }\n  };\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Player :: This class brings the board to life and allows a user to interact with it. It\n * handles user input, controls objects going to the board, can load game records, and allows the\n * user to manipulate the board according to the current player mode.\n * Unless you want to display static positions, this is the class you'd use by default.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Service', [\n  'ngGo',\n  'ngGo.Player.Directive',\n  'ngGo.Player.Mode.Common.Service',\n  'ngGo.Board.Service',\n  'ngGo.Game.Service',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Player', ['PlayerModes', 'PlayerTools', 'MarkupTypes', function(PlayerModes, PlayerTools, MarkupTypes) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default mode/tool\n    mode: PlayerModes.REPLAY,\n    tool: PlayerTools.MOVE,\n\n    //Keys/scrollwheel navigation\n    arrowKeysNavigation: true,\n    scrollWheelNavigation: true,\n\n    //Last move marker, leave empty for none\n    lastMoveMarker: MarkupTypes.LAST,\n\n    //Indicate variations with markup on the board, and show\n    //successor node variations or current node variations\n    variationMarkup: true,\n    variationChildren: true,\n    variationSiblings: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$document', 'Game', 'GameScorer', 'Board', 'PlayerTools', function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\n\n    /**\n     * Helper to append board grid coordinatess to the broadcast event object\n     */\n    var processMouseEvent = function(broadcastEvent, mouseEvent) {\n\n      //Can only do this with a board and mouse event\n      if (!this.board || !mouseEvent) {\n        broadcastEvent.x = -1;\n        broadcastEvent.y = -1;\n        return;\n      }\n\n      //Init\n      var x = 0;\n      var y = 0;\n\n      //Set x\n      if (typeof mouseEvent.offsetX !== 'undefined') {\n        x = mouseEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.layerX;\n      }\n\n      //Set y\n      if (typeof mouseEvent.offsetY !== 'undefined') {\n        y = mouseEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.layerY;\n      }\n\n      //Apply pixel ratio factor\n      x *= (window.devicePixelRatio || 1);\n      y *= (window.devicePixelRatio || 1);\n\n      //Append coords\n      broadcastEvent.x = this.board.getGridX(x);\n      broadcastEvent.y = this.board.getGridY(y);\n\n      //Did we drag?\n      if (mouseEvent.drag) {\n        broadcastEvent.drag = mouseEvent.drag;\n      }\n    };\n\n    /**\n     * Player class\n     */\n    var Player = {\n\n      //Player configuration\n      config: {},\n\n      //Board and game instances\n      board: null,\n      game: null,\n\n      //Available modes and tools\n      modes: {},\n      tools: [],\n\n      //Player mode and active tool\n      mode: '',\n      tool: '',\n\n      //Current path\n      path: null,\n\n      /**\n       * Initialization\n       */\n      init: function() {\n\n        //Unlink board instance, create new game\n        this.board = null;\n        this.game = new Game();\n\n        //Reset path\n        this.path = null;\n\n        //Player mode and active tool\n        this.mode = '';\n        this.tool = '';\n\n        //Arrow keys / scroll wheel navigation\n        this.arrowKeysNavigation = false;\n        this.scrollWheelNavigation = false;\n\n        //Last move marker\n        this.lastMoveMarker = '';\n\n        //Variation markup\n        this.variationMarkup = false;\n        this.variationChildren = false;\n        this.variationSiblings = false;\n\n        //Restricted nodes\n        this.restrictNodeStart = null;\n        this.restrictNodeEnd = null;\n\n        //Parse config\n        this.parseConfig();\n      },\n\n      /**\n       * Link the player to a HTML element\n       */\n      linkElement: function(element) {\n\n        //Set element\n        this.element = element;\n\n        //Register document event\n        this.registerElementEvent('keydown', $document);\n\n        //Register element events\n        this.registerElementEvent('click');\n        this.registerElementEvent('mousedown');\n        this.registerElementEvent('mouseup');\n        this.registerElementEvent('mousemove');\n        this.registerElementEvent('mouseout');\n        this.registerElementEvent('mousewheel');\n        this.registerElementEvent('wheel');\n      },\n\n      /*****************************************************************************\n       * Configuration\n       ***/\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, defaultConfig, config || {});\n\n        //Process settings\n        this.switchMode(this.config.mode);\n        this.switchTool(this.config.tool);\n        this.setArrowKeysNavigation(this.config.arrowKeysNavigation);\n        this.setScrollWheelNavigation(this.config.scrollWheelNavigation);\n        this.setLastMoveMarker(this.config.lastMoveMarker);\n        this.setVariationMarkup(\n          this.config.variationMarkup,\n          this.config.variationChildren,\n          this.config.variationSiblings\n        );\n\n        //Let the modes parse their config\n        for (var mode in this.modes) {\n          if (this.modes[mode].parseConfig) {\n            this.modes[mode].parseConfig.call(this, this.config);\n          }\n        }\n      },\n\n      /**\n       * Set arrow keys navigation\n       */\n      setArrowKeysNavigation: function(arrowKeys) {\n        if (arrowKeys !== this.arrowKeysNavigation) {\n          this.arrowKeysNavigation = arrowKeys;\n          this.broadcast('settingChange', 'arrowKeysNavigation');\n        }\n      },\n\n      /**\n       * Set scroll wheel navigation\n       */\n      setScrollWheelNavigation: function(scrollWheel) {\n        if (scrollWheel !== this.scrollWheelNavigation) {\n          this.scrollWheelNavigation = scrollWheel;\n          this.broadcast('settingChange', 'scrollWheelNavigation');\n        }\n      },\n\n      /**\n       * Set the last move marker\n       */\n      setLastMoveMarker: function(lastMoveMarker) {\n        if (lastMoveMarker !== this.lastMoveMarker) {\n          this.lastMoveMarker = lastMoveMarker;\n          this.broadcast('settingChange', 'lastMoveMarker');\n        }\n      },\n\n      /**\n       * Set variation markup on the board\n       */\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\n\n        //One change event for these three settings\n        var change = false;\n\n        //Markup setting change?\n        if (variationMarkup !== this.variationMarkup) {\n          this.variationMarkup = variationMarkup;\n          change = true;\n        }\n\n        //Children setting change?\n        if (\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\n        ) {\n          this.variationChildren = variationChildren;\n          change = true;\n        }\n\n        //Siblings setting change?\n        if (\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\n        ) {\n          this.variationSiblings = variationSiblings;\n          change = true;\n        }\n\n        //Did anything change?\n        if (change) {\n          this.broadcast('settingChange', 'variationMarkup');\n        }\n      },\n\n      /*****************************************************************************\n       * Mode and tool handling\n       ***/\n\n      /**\n       * Register a player mode\n       */\n      registerMode: function(mode, PlayerMode) {\n\n        //Register the mode and let it parse the configuration\n        this.modes[mode] = PlayerMode;\n\n        //Parse config if we have a handler\n        if (this.modes[mode].parseConfig) {\n          this.modes[mode].parseConfig.call(this, this.config);\n        }\n\n        //Force switch the mode now, if it matches the initial mode\n        if (this.mode === mode) {\n          this.switchMode(this.mode, true);\n          this.switchTool(this.tool, true);\n        }\n      },\n\n      /**\n       * Set available tools\n       */\n      setTools: function(tools) {\n        this.tools = tools || [PlayerTools.NONE];\n      },\n\n      /**\n       * Check if we have a player mode\n       */\n      hasMode: function(mode) {\n        return this.modes[mode] ? true : false;\n      },\n\n      /**\n       * Check if we have a player tool\n       */\n      hasTool: function(tool) {\n        return (this.tools.indexOf(tool) !== -1);\n      },\n\n      /**\n       * Switch player mode\n       */\n      switchMode: function(mode, force) {\n\n        //No change?\n        if (!force && (!mode || this.mode === mode)) {\n          return false;\n        }\n\n        //Broadcast mode exit\n        if (this.mode) {\n          this.broadcast('modeExit', this.mode);\n        }\n\n        //Set mode, reset tools and active tool\n        this.mode = mode;\n        this.tools = [];\n        this.tool = PlayerTools.NONE;\n\n        //Broadcast mode entry\n        this.broadcast('modeEnter', this.mode);\n        return true;\n      },\n\n      /**\n       * Switch player tool\n       */\n      switchTool: function(tool, force) {\n\n        //No change?\n        if (!force && (!tool || this.tool === tool)) {\n          return false;\n        }\n\n        //Validate tool switch (only when there is a mode)\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\n          return false;\n        }\n\n        //Change tool\n        this.tool = tool;\n        this.broadcast('toolSwitch', this.tool);\n        return true;\n      },\n\n      /**\n       * Save the full player state\n       */\n      saveState: function() {\n\n        //Save player state\n        this.playerState = {\n          mode: this.mode,\n          tool: this.tool,\n          restrictNodeStart: this.restrictNodeStart,\n          restrictNodeEnd: this.restrictNodeEnd\n        };\n\n        //Save game state\n        this.saveGameState();\n      },\n\n      /**\n       * Restore to the saved player state\n       */\n      restoreState: function() {\n\n        //Must have player state\n        if (!this.playerState) {\n          return;\n        }\n\n        //Restore\n        this.switchMode(this.playerState.mode);\n        this.switchTool(this.playerState.tool);\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\n\n        //Restore game state\n        this.restoreGameState();\n      },\n\n      /*****************************************************************************\n       * Game record handling\n       ***/\n\n      /**\n       * Load game record\n       */\n      load: function(data, allowPlayerConfig) {\n\n        //Try to load the game record data\n        try {\n          this.game.load(data);\n        }\n        catch (error) {\n          throw error;\n        }\n\n        //Reset path\n        this.path = null;\n\n        //Parse configuration from JGF if allowed\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\n          this.parseConfig(this.game.get('settings'));\n        }\n\n        //Dispatch game loaded event\n        this.broadcast('gameLoaded', this.game);\n\n        //Board present?\n        if (this.board) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n\n        //Loaded ok\n        return true;\n      },\n\n      /**\n       * Reload the existing game record\n       */\n      reload: function() {\n\n        //Must have game\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reload game\n        this.game.reload();\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Save the current state\n       */\n      saveGameState: function() {\n        if (this.game && this.game.isLoaded()) {\n          this.gameState = this.game.getState();\n        }\n      },\n\n      /**\n       * Restore to the saved state\n       */\n      restoreGameState: function() {\n\n        //Must have game and saved state\n        if (!this.game || !this.gameState) {\n          return;\n        }\n\n        //Restore state\n        this.game.restoreState(this.gameState);\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /*****************************************************************************\n       * Navigation\n       ***/\n\n      /**\n       * Go to the next position\n       */\n      next: function(i) {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.next(i);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position\n       */\n      previous: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previous();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the last position\n       */\n      last: function() {\n        if (this.game) {\n          this.game.last();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the first position\n       */\n      first: function() {\n        if (this.game) {\n          this.game.first();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to a specific move number, tree path or named node\n       */\n      goto: function(target) {\n        if (this.game && target) {\n          this.game.goto(target);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the previous fork\n       */\n      previousFork: function() {\n        if (this.game) {\n          this.game.previousFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next fork\n       */\n      nextFork: function() {\n        if (this.game) {\n          this.game.nextFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next position with a comment\n       */\n      nextComment: function() {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.nextComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position with a comment\n       */\n      previousComment: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previousComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Restrict navigation to the current node\n       */\n      restrictNode: function(end) {\n\n        //Must have game and node\n        if (!this.game || !this.game.node) {\n          return;\n        }\n\n        //Restrict to current node\n        if (end) {\n          this.restrictNodeEnd = this.game.node;\n        }\n        else {\n          this.restrictNodeStart = this.game.node;\n        }\n      },\n\n      /**\n       * Process a new game position\n       */\n      processPosition: function() {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Get current node and game position\n        var node = this.game.getNode();\n        var path = this.game.getPath();\n        var position = this.game.getPosition();\n        var pathChanged = !path.compare(this.path);\n\n        //Update board\n        this.updateBoard(node, position, pathChanged);\n\n        //Path change?\n        if (pathChanged) {\n\n          //Copy new path and broadcast path change\n          this.path = path.clone();\n          this.broadcast('pathChange', node);\n\n          //Named node reached? Broadcast event\n          if (node.name) {\n            this.broadcast('reachedNode.' + node.name, node);\n          }\n        }\n\n        //Passed?\n        if (node.move && node.move.pass) {\n          this.broadcast('movePassed', node);\n        }\n      },\n\n      /**\n       * Show move numbers\n       */\n      showMoveNumbers: function(fromMove, toMove) {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Use sensible defaults if no from/to moves given\n        fromMove = fromMove || 1;\n        toMove = toMove || this.game.getMove();\n\n        //Get nodes for these moves\n        var nodes = this.game.getMoveNodes(fromMove, toMove);\n        var move = fromMove;\n\n        //Loop nodes\n        angular.forEach(nodes, function(node) {\n          this.board.add('markup', node.move.x, node.move.y, {\n            type: MarkupTypes.LABEL,\n            text: move++\n          });\n        }, this);\n\n        //Redraw board markup\n        this.board.redraw('markup');\n      },\n\n      /*****************************************************************************\n       * Game handling\n       ***/\n\n      /**\n       * Start a new game\n       */\n      newGame: function() {\n        this.game = new Game();\n        this.processPosition();\n      },\n\n      /**\n       * Score the current game position\n       */\n      scoreGame: function() {\n\n        //Calculate score\n        GameScorer.calculate();\n\n        //Get score, points and captures\n        var score = GameScorer.getScore();\n        var points = GameScorer.getPoints();\n        var captures = GameScorer.getCaptures();\n\n        //Remove all markup, and set captures and points\n        this.board.layers.markup.removeAll();\n        this.board.layers.score.setAll(points, captures);\n\n        //Broadcast score\n        this.broadcast('scoreCalculated', score);\n      },\n\n      /*****************************************************************************\n       * Board handling\n       ***/\n\n      /**\n       * Get the board\n       */\n      getBoard: function() {\n        return this.board;\n      },\n\n      /**\n       * Set the board\n       */\n      setBoard: function(Board) {\n\n        //Set the board\n        this.board = Board;\n\n        //Board ready\n        if (this.board) {\n          this.broadcast('boardReady', this.board);\n        }\n\n        //If a game has been loaded already, parse config and update the board\n        if (this.game && this.game.isLoaded()) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Update the board\n       */\n      updateBoard: function(node, position, pathChanged) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Update board with new position\n        this.board.updatePosition(position, pathChanged);\n\n        //Mark last move\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\n        }\n\n        //Broadcast board update event\n        this.broadcast('boardUpdate', node);\n      },\n\n      /*****************************************************************************\n       * Event handling\n       ***/\n\n      /**\n       * Register an element event\n       */\n      registerElementEvent: function(event, element) {\n\n        //Which element to use\n        if (typeof element === 'undefined' || !element.on) {\n          element = this.element;\n        }\n\n        //Remove any existing event listener and apply new one\n        //TODO: Namespacing events doesn't work with Angular's jqLite\n        element.off(event/* + '.ngGo.player'*/);\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\n      },\n\n      /**\n       * Event listener\n       */\n      on: function(type, listener, mode, $scope) {\n\n        //Must have valid listener\n        if (typeof listener !== 'function') {\n          console.warn('Listener is not a function:', listener);\n          return;\n        }\n\n        //Scope given as 3rd parameter?\n        if (mode && mode.$parent) {\n          $scope = mode;\n          mode = '';\n        }\n\n        //Multiple events?\n        if (type.indexOf(' ') !== -1) {\n          var types = type.split(' ');\n          for (var t = 0; t < types.length; t++) {\n            this.on(types[t], listener, mode, $scope);\n          }\n          return;\n        }\n\n        //Get self and determine scope to use\n        var self = this;\n        var scope = $scope || $rootScope;\n\n        //Create listener and return de-registration function\n        return scope.$on('ngGo.player.' + type, function() {\n\n          //Filter on mode\n          if (mode) {\n            if (\n              (typeof mode === 'string' && mode !== self.mode) ||\n              mode.indexOf(self.mode) === -1\n            ) {\n              return;\n            }\n          }\n\n          //Inside a text field?\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\n            return;\n          }\n\n          //Append grid coordinates for mouse events\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\n            processMouseEvent.call(self, arguments[0], arguments[1]);\n          }\n\n          //Dragging? Prevent click events from firing\n          if (self.preventClickEvent && type === 'click') {\n            delete self.preventClickEvent;\n            return;\n          }\n          else if (type === 'mousedrag') {\n            self.preventClickEvent = true;\n          }\n\n          //Call listener\n          listener.apply(self, arguments);\n        });\n      },\n\n      /**\n       * Event broadcaster\n       */\n      broadcast: function(type, args) {\n\n        //Must have type\n        if (!type) {\n          return;\n        }\n\n        //Make sure we are in a digest cycle\n        if (!$rootScope.$$phase) {\n          $rootScope.$apply(function() {\n            $rootScope.$broadcast('ngGo.player.' + type, args);\n          });\n        }\n        else {\n          $rootScope.$broadcast('ngGo.player.' + type, args);\n        }\n      }\n    };\n\n    //Initialize\n    Player.init();\n\n    //Return object\n    return Player;\n  }];\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\n * gridlines, starpoints and coordinates via the Coordinates class.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Coordinates.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GridLayer', ['BoardLayer', 'Coordinates', function(BoardLayer, Coordinates) {\n\n  /**\n   * Helper for drawing starpoints\n   */\n  var drawStarPoint = function(gridX, gridY, starRadius, starColor) {\n\n    //Don't draw if it falls outsize of the board grid\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\n      return;\n    }\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\n      return;\n    }\n\n    //Get absolute coordinates and star point radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n\n    //Draw star point\n    this.context.beginPath();\n    this.context.fillStyle = starColor;\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\n    this.context.fill();\n  };\n\n  /**\n   * Constructor\n   */\n  var GridLayer = function(board, context) {\n\n    //Set coordinates setting\n    this.coordinates = false;\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Show or hide the coordinates.\n   */\n  GridLayer.prototype.setCoordinates = function(show) {\n    this.coordinates = show;\n  };\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Get all has nothing to return\n   */\n  GridLayer.prototype.getAll = function() {\n    return null;\n  };\n\n  /**\n   * Set all has nothing to set\n   */\n  GridLayer.prototype.setAll = function(/*grid*/) {\n    return;\n  };\n\n  /**\n   * Remove all has nothing to remove\n   */\n  GridLayer.prototype.removeAll = function() {\n    return;\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw method\n   */\n  GridLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Determine top x and y margin\n    var tx = this.board.drawMarginHor;\n    var ty = this.board.drawMarginVer;\n\n    //Get theme properties\n    var cellSize = this.board.getCellSize();\n    var lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\n    var lineCap = this.board.theme.get('grid.lineCap');\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', cellSize);\n    var starColor = this.board.theme.get('grid.star.color');\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n    this.context.strokeStyle = strokeStyle;\n\n    //Helper vars\n    var i, x, y;\n\n    //Draw vertical lines\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\n      x = this.board.getAbsX(i);\n      this.context.moveTo(x, ty);\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\n    }\n\n    //Draw horizontal lines\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\n      y = this.board.getAbsY(i);\n      this.context.moveTo(tx, y);\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\n    }\n\n    //Draw grid lines\n    this.context.stroke();\n\n    //Star points defined?\n    for (i = 0; i < starPoints.length; i++) {\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n\n    //Draw coordinates\n    if (this.coordinates) {\n      Coordinates.draw.call(this);\n    }\n  };\n\n  /**\n   * Clear a square cell area on the grid\n   */\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Clear rectangle\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Redraw a square cell area on the grid\n   */\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', s);\n    var starColor = this.board.theme.get('grid.star.color');\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n\n    //Determine draw coordinates\n    var x1 = (gridX === 0) ? x : x - r;\n    var x2 = (gridX === this.board.width - 1) ? x : x + r;\n    var y1 = (gridY === 0) ? y : y - r;\n    var y2 = (gridY === this.board.height - 1) ? y : y + r;\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Patch up grid lines\n    this.context.moveTo(x1, y);\n    this.context.lineTo(x2, y);\n    this.context.moveTo(x, y1);\n    this.context.lineTo(x, y2);\n    this.context.stroke();\n\n    //Check if we need to draw a star point here\n    for (var i in starPoints) {\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\n      }\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  //Return\n  return GridLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('HoverLayer', ['BoardLayer', 'Markup', 'StoneFaded', function(BoardLayer, Markup, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var HoverLayer = function(board, context) {\n\n    //Container for items to restore\n    this.restore = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add hover item\n   */\n  HoverLayer.prototype.add = function(x, y, hover) {\n\n    //Validate coordinates\n    if (!this.grid.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Remove any previous item at this position\n    this.remove(x, y);\n\n    //Create hover object\n    hover.object = {\n      x: x,\n      y: y\n    };\n\n    //Stones\n    if (hover.type === 'stones') {\n      hover.objectClass = StoneFaded;\n      hover.object.color = hover.value;\n    }\n\n    //Markup\n    else if (hover.type === 'markup') {\n      hover.objectClass = Markup;\n      if (typeof hover.value === 'object') {\n        hover.object = angular.extend(hover.object, hover.value);\n      }\n      else {\n        hover.object.type = hover.value;\n      }\n    }\n\n    //Unknown\n    else {\n      console.warn('Unknown hover type', hover.type);\n      return;\n    }\n\n    //Check if we need to hide something on layers underneath\n    if (this.board.has(hover.type, x, y)) {\n      this.restore.push({\n        x: x,\n        y: y,\n        layer: hover.type,\n        value: this.board.get(hover.type, x, y)\n      });\n      this.board.remove(hover.type, x, y);\n    }\n\n    //Add to stack\n    this.grid.set(x, y, hover);\n\n    //Draw item\n    if (hover.objectClass && hover.objectClass.draw) {\n      hover.objectClass.draw.call(this, hover.object);\n    }\n  };\n\n  /**\n   * Remove the hover object\n   */\n  HoverLayer.prototype.remove = function(x, y) {\n\n    //Validate coordinates\n    if (!this.grid.has(x, y)) {\n      return;\n    }\n\n    //Get object and clear it\n    var hover = this.grid.get(x, y);\n    if (hover.objectClass && hover.objectClass.clear) {\n      hover.objectClass.clear.call(this, hover.object);\n    }\n\n    //Other objects to restore?\n    for (var i = 0; i < this.restore.length; i++) {\n      if (this.restore[i].x === x && this.restore[i].y === y) {\n        this.board.add(\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n        );\n        this.restore.splice(i, 1);\n      }\n    }\n  };\n\n  /**\n   * Remove all hover objects\n   */\n  HoverLayer.prototype.removeAll = function() {\n\n    //Anything to do?\n    if (this.grid.isEmpty()) {\n      return;\n    }\n\n    //Get all item as objects\n    var i;\n    var hover = this.grid.all('layer');\n\n    //Clear them\n    for (i = 0; i < hover.length; i++) {\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\n        hover[i].objectClass.clear.call(this, hover[i].object);\n      }\n    }\n\n    //Clear layer and empty grid\n    this.clear();\n    this.grid.empty();\n\n    //Restore objects on other layers\n    for (i = 0; i < this.restore.length; i++) {\n      this.board.add(\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n      );\n    }\n\n    //Clear restore array\n    this.restore = [];\n  };\n\n  /**\n   * Draw layer\n   */\n  HoverLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Loop objects and clear them\n    var hover = this.grid.all('hover');\n    for (var i = 0; i < hover.length; i++) {\n      if (hover.objectClass && hover.objectClass.draw) {\n        hover.objectClass.draw.call(this, hover.object);\n      }\n    }\n  };\n\n  //Return\n  return HoverLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('MarkupLayer', ['BoardLayer', 'Markup', function(BoardLayer, Markup) {\n\n  /**\n   * Constructor\n   */\n  var MarkupLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all markup at once\n   */\n  MarkupLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'type');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Markup.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Markup.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  MarkupLayer.prototype.removeAll = function() {\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Clear them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.clear.call(this, markup[i]);\n    }\n\n    //Empty the grid now\n    this.grid.empty();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  MarkupLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Draw them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.draw.call(this, markup[i]);\n    }\n  };\n\n  /**\n   * Draw cell\n   */\n  MarkupLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  MarkupLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  //Return\n  return MarkupLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ScoreLayer', ['BoardLayer', 'StoneMini', 'StoneFaded', function(BoardLayer, StoneMini, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var ScoreLayer = function(board, context) {\n\n    //Points and captures\n    this.points = [];\n    this.captures = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set points and captures\n   */\n  ScoreLayer.prototype.setAll = function(points, captures) {\n\n    //Remove all existing stuff first\n    this.removeAll();\n\n    //Set new stuff\n    this.points = points.all('color');\n    this.captures = captures.all('color');\n\n    //Draw\n    this.draw();\n  };\n\n  /**\n   * Remove all scoring\n   */\n  ScoreLayer.prototype.removeAll = function() {\n\n    //If there are captures, draw them back onto the stones layer\n    for (var i = 0; i < this.captures.length; i++) {\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\n    }\n\n    //Clear the layer\n    this.clear();\n\n    //Remove all stuff\n    this.points = [];\n    this.captures = [];\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  ScoreLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Init\n    var i;\n\n    //Draw captures first (removing stones from the stones layer)\n    for (i = 0; i < this.captures.length; i++) {\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\n      StoneFaded.draw.call(this, this.captures[i]);\n    }\n\n    //Draw points on top of it\n    for (i = 0; i < this.points.length; i++) {\n      StoneMini.draw.call(this, this.points[i]);\n    }\n  };\n\n  //Return\n  return ScoreLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneShadow.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ShadowLayer', ['BoardLayer', 'StoneShadow', function(BoardLayer, StoneShadow) {\n\n  /**\n   * Constructor\n   */\n  var ShadowLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add a stone\n   */\n  ShadowLayer.prototype.add = function(stone) {\n\n    //Don't add if no shadow\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\n      return;\n    }\n\n    //Already have a stone here?\n    if (this.grid.has(stone.x, stone.y)) {\n      return;\n    }\n\n    //Add to grid\n    this.grid.set(stone.x, stone.y, stone.color);\n\n    //Draw it if there is a context\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\n      StoneShadow.draw.call(this, stone);\n    }\n  };\n\n  /**\n   * Remove a stone\n   */\n  ShadowLayer.prototype.remove = function(stone) {\n\n    //Remove from grid\n    this.grid.unset(stone.x, stone.y);\n\n    //Redraw whole layer\n    this.redraw();\n  };\n\n  /**\n   * Draw layer\n   */\n  ShadowLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get shadowsize from theme\n    var shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\n\n    //Apply shadow transformation\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      StoneShadow.draw.call(this, stones[i]);\n    }\n  };\n\n  //Return\n  return ShadowLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StonesLayer', ['BoardLayer', 'Stone', 'StoneColor', function(BoardLayer, Stone, StoneColor) {\n\n  /**\n   * Constructor\n   */\n  var StonesLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n\n    //Set empty value for grid\n    this.grid.whenEmpty(StoneColor.EMPTY);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all stones at once\n   */\n  StonesLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'color');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Stone.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Stone.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  StonesLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      Stone.draw.call(this, stones[i]);\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  StonesLayer.prototype.redraw = function() {\n\n    //Clear shadows layer\n    this.board.removeAll('shadow');\n\n    //Redraw ourselves\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  StonesLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  StonesLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  //Return\n  return StonesLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Coordinates :: This class is used for drawing board coordinates\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Coordinates.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('Coordinates', function() {\n\n  //Kanji\n  var kanji = [\n    '一', '二', '三', '四', '五', '六', '七', '八', '九', '十',\n    '十一', '十二', '十三', '十四', '十五', '十六', '十七', '十八', '十九', '二十',\n    '二十一', '二十二', '二十三', '二十四', '二十五', '二十六', '二十七', '二十八', '二十九', '三十',\n    '三十一', '三十二', '三十三', '三十四', '三十五', '三十六', '三十七', '三十八', '三十九', '四十'\n  ];\n\n  //Character codes\n  var aChar = 'A'.charCodeAt(0);\n  var aCharLc = 'a'.charCodeAt(0);\n\n  /**\n   * Coordinate generators\n   */\n  var coordinates = {\n\n    //Kanji coordinates\n    kanji: function(i) {\n      return kanji[i] || '';\n    },\n\n    //Numbers from 1\n    numbers: function(i) {\n      return i + 1;\n    },\n\n    //Capital letters from A\n    letters: function(i) {\n\n      //Initialize\n      var ch = '';\n\n      //Beyond Z? Prepend with A\n      if (i >= 25) {\n        ch = 'A';\n        i -= 25;\n      }\n\n      //The letter I is ommitted\n      if (i >= 8) {\n        i++;\n      }\n\n      //Return\n      return ch + String.fromCharCode(aChar + i);\n    },\n\n    //JGF coordinates (e.g. 0, 1, ...)\n    jgf: function(i) {\n      return i;\n    },\n\n    //SGF coordinates (e.g. a, b, ...)\n    sgf: function(i) {\n      var ch;\n      if (i < 26) {\n        ch = aCharLc + i;\n      }\n      else {\n        ch = aChar + i;\n      }\n      return String.fromCharCode(ch);\n    }\n  };\n\n  /**\n   * Coordinates object\n   */\n  var Coordinates = {\n\n    /**\n     * Draw\n     */\n    draw: function() {\n\n      //Can only draw when we have context and dimensions\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Get cell size\n      var cellSize = this.board.getCellSize();\n\n      //Get boundary coordinates\n      var xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\n      var xr = this.board.drawWidth - xl;\n      var yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\n      var yb = this.board.drawHeight - yt;\n\n      //Get theme properties\n      var fillStyle = this.board.theme.get('coordinates.color');\n      var vertical = {\n        font: this.board.theme.get('coordinates.vertical.font'),\n        size: this.board.theme.get('coordinates.vertical.size'),\n        style: this.board.theme.get('coordinates.vertical.style'),\n        inverse: this.board.theme.get('coordinates.vertical.inverse')\n      };\n      var horizontal = {\n        font: this.board.theme.get('coordinates.horizontal.font'),\n        size: this.board.theme.get('coordinates.horizontal.size'),\n        style: this.board.theme.get('coordinates.horizontal.style'),\n        inverse: this.board.theme.get('coordinates.horizontal.inverse')\n      };\n\n      //Configure context\n      this.context.fillStyle = fillStyle;\n      this.context.textBaseline = 'middle';\n      this.context.textAlign = 'center';\n\n      //Helper vars\n      var i, j, x, y, ch;\n\n      //Draw vertical coordinates\n      for (i = 0; i < this.board.height; i++) {\n\n        //Inverse?\n        j = i;\n        if (vertical.inverse) {\n          j = this.board.height - i - 1;\n        }\n\n        //Get character\n        if (typeof vertical.style === 'function') {\n          ch = vertical.style.call(this, j);\n        }\n        else if (coordinates[vertical.style]) {\n          ch = coordinates[vertical.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        y = this.board.getAbsY(i);\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\n        this.context.fillText(ch, xl, y);\n        this.context.fillText(ch, xr, y);\n      }\n\n      //Draw horizontal coordinates\n      for (i = 0; i < this.board.width; i++) {\n\n        //Inverse?\n        j = i;\n        if (horizontal.inverse) {\n          j = this.board.width - i - 1;\n        }\n\n        //Get character\n        if (typeof horizontal.style === 'function') {\n          ch = horizontal.style.call(this, j);\n        }\n        else if (coordinates[horizontal.style]) {\n          ch = coordinates[horizontal.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        x = this.board.getAbsX(i);\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\n        this.context.fillText(ch, x, yt);\n        this.context.fillText(ch, x, yb);\n      }\n    }\n  };\n\n  //Return\n  return Coordinates;\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Markup :: This class is used for drawing markup\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Markup.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Markup', ['MarkupTypes', 'BoardObject', function(MarkupTypes, BoardObject) {\n\n  /**\n   * Math constants\n   */\n  var cosPi4 = Math.cos(Math.PI / 4);\n  var cosPi6 = Math.cos(Math.PI / 6);\n\n  /**\n   * Triangle draw handler\n   */\n  var drawTriangle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y - r);\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.closePath();\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Square draw handler\n   */\n  var drawSquare = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw circle handler\n   */\n  var drawCircle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw mark handler\n   */\n  var drawMark = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x - rcos, y - rcos);\n    this.context.lineTo(x + rcos, y + rcos);\n    this.context.moveTo(x + rcos, y - rcos);\n    this.context.lineTo(x - rcos, y + rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw select handler\n   */\n  var drawSelect = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Last move draw handler\n   */\n  var drawLast = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(s);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y);\n    this.context.lineTo(x + r, y);\n    this.context.lineTo(x, y + r);\n    this.context.closePath();\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw happy smiley handler\n   */\n  var drawHappySmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 8);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw sad smiley handler\n   */\n  var drawSadSmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw label\n   */\n  var drawLabel = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var font = markup.font || this.board.theme.get('markup.label.font') || '';\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //First, clear grid square below for clarity\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.clearCell(markup.x, markup.y);\n    }\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.textBaseline = 'middle';\n    this.context.textAlign = 'center';\n\n    //Convert to text\n    if (typeof markup.text === 'number') {\n      markup.text = markup.text.toString();\n    }\n\n    //Determine font size\n    if (markup.text.length === 1) {\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\n    }\n    else if (markup.text.length === 2) {\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\n    }\n    else {\n      this.context.font = r + 'px ' + font;\n    }\n\n    //Draw element\n    this.context.beginPath();\n    this.context.fillText(markup.text, x, y, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Clear label\n   */\n  var clearLabel = function(markup) {\n\n    //No stone on location? Redraw the grid square, if we cleared it\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\n    }\n  };\n\n  /**\n   * Markup class\n   */\n  var Markup = {\n\n    /**\n     * Draw\n     */\n    draw: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Drawing depends on type\n      switch (markup.type) {\n\n        //Triangle\n        case MarkupTypes.TRIANGLE:\n          drawTriangle.call(this, markup);\n          break;\n\n        //Square\n        case MarkupTypes.SQUARE:\n          drawSquare.call(this, markup);\n          break;\n\n        //Circle\n        case MarkupTypes.CIRCLE:\n          drawCircle.call(this, markup);\n          break;\n\n        //Mark\n        case MarkupTypes.MARK:\n          drawMark.call(this, markup);\n          break;\n\n        //Select\n        case MarkupTypes.SELECT:\n          drawSelect.call(this, markup);\n          break;\n\n        //happy\n        case MarkupTypes.HAPPY:\n          drawHappySmiley.call(this, markup);\n          break;\n\n        //Sad\n        case MarkupTypes.SAD:\n          drawSadSmiley.call(this, markup);\n          break;\n\n        //Last move marker\n        case MarkupTypes.LAST:\n          drawLast.call(this, markup);\n          break;\n\n        //Label\n        case MarkupTypes.LABEL:\n          markup.text = markup.text || '';\n          drawLabel.call(this, markup);\n          break;\n      }\n    },\n\n    /**\n     * Clear\n     */\n    clear: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, markup);\n\n      //Special handling for label\n      if (markup.type === MarkupTypes.LABEL) {\n        clearLabel.call(this, markup);\n      }\n    }\n  };\n\n  //Return\n  return Markup;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Stone :: This class is used for drawing stones on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Stone.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n  'ngGo.Board.ShellPattern.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Stone', ['$injector', 'BoardObject', 'StoneColor', 'ShellPattern', function($injector, BoardObject, StoneColor, ShellPattern) {\n\n  /**\n   * Shell random seed\n   */\n  var shellSeed;\n\n  /**\n   * Mono colored stones\n   */\n  var drawMono = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Don't draw shadow\n    stone.shadow = false;\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\n    var fillStyle = this.board.theme.get('stone.mono.color', color);\n    var strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Configure context\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Draw outline\n    this.context.stroke();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Glass stones\n   */\n  var drawGlass = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Begin path\n    this.context.beginPath();\n\n    //Determine stone texture\n    if (color === StoneColor.W) {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#fff');\n      this.context.fillStyle.addColorStop(1, '#aaa');\n    }\n    else {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#666');\n      this.context.fillStyle.addColorStop(1, '#111');\n    }\n\n    //Complete drawing\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Slate and shell stones\n   */\n  var drawSlateShell = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Get random seed\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var shellTypes = this.board.theme.get('stone.shell.types');\n    var fillStyle = this.board.theme.get('stone.shell.color', color);\n    var strokeStyle = this.board.theme.get('stone.shell.stroke');\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fillStyle = fillStyle;\n    this.context.fill();\n\n    //Shell stones\n    if (color === StoneColor.W) {\n\n      //Get random shell type\n      var type =\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\n\n      //Determine random angle\n      var z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\n      var angle = (2 / z) * (shellSeed % z);\n\n      //Draw shell pattern\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Slate stones\n    else {\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Constructor\n   */\n  var Stone = {\n\n    /**\n     * Draw a stone\n     */\n    draw: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Determine style of stone\n      var style = this.board.theme.get('stone.style');\n\n      //Draw using the appropriate handler\n      switch (style) {\n\n        //Slate and shell\n        case 'shell':\n          drawSlateShell.call(this, stone);\n          break;\n\n        //Glass stones\n        case 'glass':\n          drawGlass.call(this, stone);\n          break;\n\n        //Mono stones\n        case 'mono':\n          drawMono.call(this, stone);\n          break;\n\n        //Custom type\n        default:\n          var handler = $injector.get(style);\n          if (handler) {\n            handler.call(this, stone);\n          }\n      }\n\n      //Add shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.add(stone);\n      }\n    },\n\n    /**\n     * Clear a stone\n     */\n    clear: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, stone);\n\n      //Remove shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.remove(stone);\n      }\n    }\n  };\n\n  //Return\n  return Stone;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneFaded', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneFaded = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.faded.scale');\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneFaded;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\n * (for scoring).\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneMini.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneMini', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneMini = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.mini.scale');\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneMini;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneShadow :: This class is used for drawing stone shadows on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneShadow', function() {\n\n  /**\n   * Constructor\n   */\n  var StoneShadow = {\n\n    /**\n     * Draw a stone shadow\n     */\n    draw: function(stone) {\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\n\n      //Apply scaling factor?\n      if (stone.scale) {\n        r = Math.round(r * stone.scale);\n      }\n\n      //Get theme properties\n      var blur = this.board.theme.get('shadow.blur', s);\n      var offsetX = this.board.theme.get('shadow.offsetX', s);\n      var offsetY = this.board.theme.get('shadow.offsetY', s);\n      var shadowColor = this.board.theme.get('shadow.color');\n\n      //Configure context\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\n      );\n      this.context.fillStyle.addColorStop(0, shadowColor);\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n\n      //Draw shadow\n      this.context.beginPath();\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\n      this.context.fill();\n    },\n\n    /**\n     * Clear a stone shadow\n     */\n    clear: function(stone) {\n\n      //Note: this method is currently not in use due to the overlapping shadows\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\n      //appropriate either, so for now we will leave it at this.\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = this.board.theme.get('stone.radius', s);\n\n      //Clear a generous rectangle\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\n    }\n  };\n\n  //Return\n  return StoneShadow;\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Gib2Jgf', ['ngGo', 'KifuBlank', function(ngGo, KifuBlank) {\n\n  /**\n   * Regular expressions\n   */\n  var regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\n  var regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\n  var regKomi = /GAMEGONGJE=([0-9]+)/gi;\n  var regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\n  var regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\n  var regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\n\n  /**\n   * Player parser function\n   */\n  var parsePlayer = function(jgf, match) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\n\n    //Create player object\n    var player = {\n      color: color,\n      name: match[2],\n      rank: match[3].toLowerCase()\n    };\n\n    //Check if player of this color already exists, if so, overwrite\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p] = player;\n        return;\n      }\n    }\n\n    //Player of this color not found, push\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, match) {\n    jgf.game.komi = parseFloat(match[1] / 10);\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, match) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Push date\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\n  };\n\n  /**\n   * Result parser function\n   */\n  var parseResult = function(jgf, match) {\n\n    //Winner color\n    var result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\n    result += '+';\n\n    //Win condition\n    if (match[2].match(/res/i)) {\n      result += 'R';\n    }\n    else if (match[2].match(/time/i)) {\n      result += 'T';\n    }\n    else {\n      result += match[2];\n    }\n\n    //Set in JGF\n    jgf.game.result = result;\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, match) {\n\n    //Determine player color\n    var color = match[2];\n    if (color === 1) {\n      color = 'B';\n    }\n    else if (color === 2) {\n      color = 'W';\n    }\n    else {\n      return;\n    }\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (false) {\n\n    }\n\n    //Regular move\n    else {\n      node.move[color] = [match[3] * 1, match[4] * 1];\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    parse: function(gib, stringified) {\n\n      //Get new JGF object\n      var jgf = KifuBlank.jgf();\n\n      //Initialize\n      var match;\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find player information\n      while ((match = regPlayer.exec(gib))) {\n        parsePlayer(jgf, match);\n      }\n\n      //Find komi\n      if ((match = regKomi.exec(gib))) {\n        parseKomi(jgf, match);\n      }\n\n      //Find game date\n      if ((match = regDate.exec(gib))) {\n        parseDate(jgf, match);\n      }\n\n      //Find game result\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\n        parseResult(jgf, match);\n      }\n\n      //Find moves\n      while ((match = regMove.exec(gib))) {\n\n        //Create new node\n        node = {};\n\n        //Parse move\n        parseMove(jgf, node, match);\n\n        //Push node to container\n        container.push(node);\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Jgf2Sgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Flip SGF alias map and create JGF alias map\n   */\n  var jgfAliases = {};\n  for (var sgfProp in sgfAliases) {\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\n    }\n  }\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert to SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Helper to escape SGF info\n   */\n  var escapeSgf = function(text) {\n    if (typeof text === 'string') {\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\n    }\n    return text;\n  };\n\n  /**\n   * Helper to write an SGF group\n   */\n  var writeGroup = function(prop, values, output, escape) {\n    if (values.length) {\n      output.sgf += prop;\n      for (var i = 0; i < values.length; i++) {\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\n      }\n    }\n  };\n\n  /**\n   * Move parser\n   */\n  var parseMove = function(move, output) {\n\n    //Determine and validate color\n    var color = move.B ? 'B' : (move.W ? 'W' : '');\n    if (color === '') {\n      return;\n    }\n\n    //Determine move\n    var coords = (move[color] === 'pass') ? '' : move[color];\n\n    //Append to SGF\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\n  };\n\n  /**\n   * Setup parser\n   */\n  var parseSetup = function(setup, output) {\n\n    //Loop colors\n    for (var color in setup) {\n      if (setup.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < setup[color].length; i++) {\n          setup[color][i] = convertCoordinates(setup[color][i]);\n        }\n\n        //Write as group\n        writeGroup('A' + color, setup[color], output);\n      }\n    }\n  };\n\n  /**\n   * Score parser\n   */\n  var parseScore = function(score, output) {\n\n    //Loop colors\n    for (var color in score) {\n      if (score.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < score[color].length; i++) {\n          score[color][i] = convertCoordinates(score[color][i]);\n        }\n\n        //Write as group\n        writeGroup('T' + color, score[color], output);\n      }\n    }\n  };\n\n  /**\n   * Markup parser\n   */\n  var parseMarkup = function(markup, output) {\n\n    //Loop markup types\n    for (var type in markup) {\n      if (markup.hasOwnProperty(type)) {\n        var i;\n\n        //Label type has the label text appended to the coords\n        if (type === 'label') {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\n          }\n        }\n        else {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]);\n          }\n        }\n\n        //Convert type\n        if (typeof jgfAliases[type] !== 'undefined') {\n          type = jgfAliases[type];\n        }\n\n        //Write as group\n        writeGroup(type, markup[type], output);\n      }\n    }\n  };\n\n  /**\n   * Turn parser\n   */\n  var parseTurn = function(turn, output) {\n    output.sgf += 'PL[' + turn + ']';\n  };\n\n  /**\n   * Comments parser\n   */\n  var parseComments = function(comments, output) {\n\n    //Determine key\n    var key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\n\n    //Flatten comment objects\n    var flatComments = [];\n    for (var c = 0; c < comments.length; c++) {\n      if (typeof comments[c] === 'string') {\n        flatComments.push(comments[c]);\n      }\n      else if (comments[c].comment) {\n        flatComments.push(comments[c].comment);\n      }\n    }\n\n    //Write as group\n    writeGroup(key, flatComments, output, true);\n  };\n\n  /**\n   * Node name parser\n   */\n  var parseNodeName = function(nodeName, output) {\n    var key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\n  };\n\n  /**\n   * Game parser\n   */\n  var parseGame = function(game) {\n\n    //Loop SGF game definitions\n    for (var i in sgfGames) {\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\n        return i;\n      }\n    }\n\n    //Not found\n    return 0;\n  };\n\n  /**\n   * Application parser\n   */\n  var parseApplication = function(application) {\n    var parts = application.split(' v');\n    if (parts.length > 1) {\n      return parts[0] + ':' + parts[1];\n    }\n    return application;\n  };\n\n  /**\n   * Player instructions parser\n   */\n  var parsePlayer = function(player, rootProperties) {\n\n    //Variation handling\n    var st = 0;\n    if (!player.variationMarkup) {\n      st += 2;\n    }\n    if (player.variationSiblings) {\n      st += 1;\n    }\n\n    //Set in root properties\n    rootProperties.ST = st;\n  };\n\n  /**\n   * Board parser\n   */\n  var parseBoard = function(board, rootProperties) {\n\n    //Both width and height should be given\n    if (board.width && board.height) {\n\n      //Same dimensions?\n      if (board.width === board.height) {\n        rootProperties.SZ = board.width;\n      }\n\n      //Different dimensions are not supported by SGF, but OGS uses the\n      //format w:h, so we will stick with that for anyone who supports it.\n      else {\n        rootProperties.SZ = board.width + ':' + board.height;\n      }\n    }\n\n    //Otherwise, check if only width or height were given at least\n    else if (board.width) {\n      rootProperties.SZ = board.width;\n    }\n    else if (board.height) {\n      rootProperties.SZ = board.height;\n    }\n\n    //Can't determine size\n    else {\n      rootProperties.SZ = '';\n    }\n  };\n\n  /**\n   * Players parser\n   */\n  var parsePlayers = function(players, rootProperties) {\n\n    //Loop players\n    for (var p = 0; p < players.length; p++) {\n\n      //Validate color\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\n        continue;\n      }\n\n      //Get SGF color\n      var color = (players[p].color === 'black') ? 'B' : 'W';\n\n      //Name given?\n      if (players[p].name) {\n        rootProperties['P' + color] = players[p].name;\n      }\n\n      //Rank given?\n      if (players[p].rank) {\n        rootProperties[color + 'R'] = players[p].rank;\n      }\n\n      //Team given?\n      if (players[p].team) {\n        rootProperties[color + 'T'] = players[p].team;\n      }\n    }\n  };\n\n  /**\n   * Parse function to property mapper\n   */\n  var parsingMap = {\n\n    //Node properties\n    'move': parseMove,\n    'setup': parseSetup,\n    'score': parseScore,\n    'markup': parseMarkup,\n    'turn': parseTurn,\n    'comments': parseComments,\n    'name': parseNodeName,\n\n    //Info properties\n    'record.application': parseApplication,\n    'player': parsePlayer,\n    'board': parseBoard,\n    'game.type': parseGame,\n    'game.players': parsePlayers\n  };\n\n  /*****************************************************************************\n   * Parser functions\n   ***/\n\n  /**\n   * Helper to write a JGF tree to SGF\n   */\n  var writeTree = function(tree, output) {\n\n    //Loop nodes in the tree\n    for (var i = 0; i < tree.length; i++) {\n      var node = tree[i];\n\n      //Array? That means a variation\n      if (angular.isArray(node)) {\n        for (var j = 0; j < node.length; j++) {\n          output.sgf += '(\\n;';\n          writeTree(node[j], output);\n          output.sgf += '\\n)';\n        }\n\n        //Continue\n        continue;\n      }\n\n      //Loop node properties\n      for (var key in node) {\n        if (node.hasOwnProperty(key)) {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[key] !== 'undefined') {\n            parsingMap[key](node[key], output);\n            continue;\n          }\n\n          //Other object, can't handle it\n          if (typeof node[key] === 'object') {\n            continue;\n          }\n\n          //Anything else, append it\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\n        }\n      }\n\n      //More to come?\n      if ((i + 1) < tree.length) {\n        output.sgf += '\\n;';\n      }\n    }\n  };\n\n  /**\n   * Helper to extract all SGF root properties from a JGF object\n   */\n  var extractRootProperties = function(jgf, rootProperties, key) {\n\n    //Initialize key\n    if (typeof key === 'undefined') {\n      key = '';\n    }\n\n    //Loop properties of jgf node\n    for (var subKey in jgf) {\n      if (jgf.hasOwnProperty(subKey)) {\n\n        //Skip SGF signature (as we keep our own)\n        if (subKey === 'sgf') {\n          continue;\n        }\n\n        //Build jgf key\n        var jgfKey = (key === '') ? subKey : key + '.' + subKey;\n\n        //If the item is an object, handle separately\n        if (typeof jgf[subKey] === 'object') {\n\n          //Handler for this object present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\n          }\n\n          //Otherwise, just flatten and call this function recursively\n          else {\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\n          }\n          continue;\n        }\n\n        //Check if it's a known key, if so, append the value to the root\n        var value;\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            value = parsingMap[jgfKey](jgf[subKey]);\n          }\n          else {\n            value = escapeSgf(jgf[subKey]);\n          }\n\n          //Set in root properties\n          rootProperties[jgfAliases[jgfKey]] = value;\n        }\n      }\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    parse: function(jgf) {\n\n      //String given?\n      if (typeof jgf === 'string') {\n        jgf = angular.fromJson(jgf);\n      }\n\n      //Must have moves tree\n      if (!jgf.tree) {\n        console.error('No moves tree in JGF object');\n        return;\n      }\n\n      //Initialize output (as object, so it remains a reference) and root properties container\n      var output = {sgf: '(\\n;'};\n      var root = angular.copy(jgf);\n      var rootProperties = KifuBlank.sgf();\n\n      //The first node of the JGF tree is the root node, and it can contain comments,\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\n      //and attach it to the root\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\n        root = angular.extend(root, jgf.tree[0]);\n        delete root.root;\n        delete jgf.tree[0];\n      }\n\n      //Set root properties\n      delete root.tree;\n      extractRootProperties(root, rootProperties);\n\n      //Write root properties\n      for (var key in rootProperties) {\n        if (rootProperties[key]) {\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\n        }\n      }\n\n      //Write game tree\n      writeTree(jgf.tree, output);\n\n      //Close SGF and return\n      output.sgf += ')';\n      return output.sgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Sgf2Jgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Regular expressions for SGF data\n   */\n  var regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\n  var regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\n  var regProperty = /[A-Z]+/;\n  var regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Application parser function (doesn't overwrite existing signature)\n   */\n  var parseApp = function(jgf, node, key, value) {\n    if (!jgf.record.application) {\n      var app = value[0].split(':');\n      if (app.length > 1) {\n        jgf.record.application = app[0] + ' v' + app[1];\n      }\n      else {\n        jgf.record.application = app[0];\n      }\n    }\n  };\n\n  /**\n   * SGF format parser\n   */\n  var parseSgfFormat = function() {\n    return;\n  };\n\n  /**\n   * Game type parser function\n   */\n  var parseGame = function(jgf, node, key, value) {\n    var game = value[0];\n    if (typeof sgfGames[game] !== 'undefined') {\n      jgf.game.type = sgfGames[game];\n    }\n    else {\n      jgf.game.type = value[0];\n    }\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, key, value) {\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\n      node.move[key] = 'pass';\n    }\n\n    //Regular move\n    else {\n      node.move[key] = convertCoordinates(value[0]);\n    }\n  };\n\n  /**\n   * Comment parser function\n   */\n  var parseComment = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Node name parser function\n   */\n  var parseNodeName = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value[0];\n  };\n\n  /**\n   * Board setup parser function\n   */\n  var parseSetup = function(jgf, node, key, value) {\n\n    //Initialize setup container on node\n    if (typeof node.setup === 'undefined') {\n      node.setup = {};\n    }\n\n    //Remove \"A\" from setup key\n    key = key.charAt(1);\n\n    //Initialize setup container of this type\n    if (typeof node.setup[key] === 'undefined') {\n      node.setup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.setup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Scoring parser function\n   */\n  var parseScore = function(jgf, node, key, value) {\n\n    //Initialize score container on node\n    if (typeof node.score === 'undefined') {\n      node.score = {\n        B: [],\n        W: []\n      };\n    }\n\n    //Remove \"T\" from setup key\n    key = key.charAt(1);\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.score[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Turn parser function\n   */\n  var parseTurn = function(jgf, node, key, value) {\n    node.turn = value[0];\n  };\n\n  /**\n   * Label parser function\n   */\n  var parseLabel = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n\n      //Split off coordinates and add label contents\n      var coords = convertCoordinates(value[i].substr(0, 2));\n      coords.push(value[i].substr(3));\n\n      //Add to node\n      node.markup[key].push(coords);\n    }\n  };\n\n  /**\n   * Markup parser function\n   */\n  var parseMarkup = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.markup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Size parser function\n   */\n  var parseSize = function(jgf, node, key, value) {\n\n    //Initialize board container\n    if (typeof jgf.board === 'undefined') {\n      jgf.board = {};\n    }\n\n    //Add size property (can be width:height or just a single size)\n    var size = value[0].split(':');\n    if (size.length > 1) {\n      jgf.board.width = parseInt(size[0]);\n      jgf.board.height = parseInt(size[1]);\n    }\n    else {\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\n    }\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, node, key, value) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Explode dates\n    var dates = value[0].split(',');\n    for (var d = 0; d < dates.length; d++) {\n      jgf.game.dates.push(dates[d]);\n    }\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, node, key, value) {\n    jgf.game.komi = parseFloat(value[0]);\n  };\n\n  /**\n   * Variations handling parser function\n   */\n  var parseVariations = function(jgf, node, key, value) {\n\n    //Initialize display property\n    if (typeof jgf.player === 'undefined') {\n      jgf.player = {};\n    }\n\n    //Initialize variation display settings\n    jgf.player.variationMarkup = false;\n    jgf.player.variationChildren = false;\n    jgf.player.variationSiblings = false;\n\n    //Parse as integer\n    var st = parseInt(value[0]);\n\n    //Determine what we want (see SGF specs for details)\n    switch (st) {\n      case 0:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationChildren = true;\n        break;\n      case 1:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationSiblings = true;\n        break;\n      case 2:\n        jgf.player.variationChildren = true;\n        break;\n      case 3:\n        jgf.player.variationSiblings = true;\n        break;\n    }\n  };\n\n  /**\n   * Player info parser function\n   */\n  var parsePlayer = function(jgf, node, key, value) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Check if player of this color already exists\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p][key] = value[0];\n        return;\n      }\n    }\n\n    //Player of this color not found, initialize\n    var player = {color: color};\n    player[key] = value[0];\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Parsing function to property mapper\n   */\n  var parsingMap = {\n\n    //Application, game type, board size, komi, date\n    'AP': parseApp,\n    'FF': parseSgfFormat,\n    'GM': parseGame,\n    'SZ': parseSize,\n    'KM': parseKomi,\n    'DT': parseDate,\n\n    //Variations handling\n    'ST': parseVariations,\n\n    //Player info handling\n    'PB': parsePlayer,\n    'PW': parsePlayer,\n    'BT': parsePlayer,\n    'WT': parsePlayer,\n    'BR': parsePlayer,\n    'WR': parsePlayer,\n\n    //Moves\n    'B': parseMove,\n    'W': parseMove,\n\n    //Node annotation\n    'C': parseComment,\n    'N': parseNodeName,\n\n    //Board setup\n    'AB': parseSetup,\n    'AW': parseSetup,\n    'AE': parseSetup,\n    'PL': parseTurn,\n    'TW': parseScore,\n    'TB': parseScore,\n\n    //Markup\n    'CR': parseMarkup,\n    'SQ': parseMarkup,\n    'TR': parseMarkup,\n    'MA': parseMarkup,\n    'SL': parseMarkup,\n    'LB': parseLabel\n  };\n\n  /**\n   * These properties need a node object\n   */\n  var needsNode = [\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB'\n  ];\n\n  /*****************************************************************************\n   * Parser helpers\n   ***/\n\n  /**\n   * Set info in the JGF tree at a certain position\n   */\n  var setInfo = function(jgf, position, value) {\n\n    //Position given must be an array\n    if (typeof position !== 'object') {\n      return;\n    }\n\n    //Initialize node to attach value to\n    var node = jgf;\n    var key;\n\n    //Loop the position\n    for (var p = 0; p < position.length; p++) {\n\n      //Get key\n      key = position[p];\n\n      //Last key reached? Done\n      if ((p + 1) === position.length) {\n        break;\n      }\n\n      //Create container if not set\n      if (typeof node[key] !== 'object') {\n        node[key] = {};\n      }\n\n      //Move up in tree\n      node = node[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    parse: function(sgf, stringified) {\n\n      //Get new JGF object (with SGF node as a base)\n      var jgf = KifuBlank.jgf({record: {sgf: {}}});\n\n      //Initialize\n      var stack = [];\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find sequence of elements\n      var sequence = sgf.match(regSequence);\n\n      //Loop sequence items\n      for (var i = 0; i < sequence.length; i++) {\n\n        //Push stack if new variation found\n        if (sequence[i] === '(') {\n\n          //First encounter, this defines the main tree branch, so skip\n          if (i === 0 || i === '0') {\n            continue;\n          }\n\n          //Push the current container to the stack\n          stack.push(container);\n\n          //Create variation container if it doesn't exist yet\n          if (!angular.isArray(container[container.length - 1])) {\n            container.push([]);\n          }\n\n          //Use variation container\n          container = container[container.length - 1];\n\n          //Now create moves container\n          container.push([]);\n          container = container[container.length - 1];\n          continue;\n        }\n\n        //Grab last container from stack if end of variation reached\n        else if (sequence[i] === ')') {\n          if (stack.length) {\n            container = stack.pop();\n          }\n          continue;\n        }\n\n        //Make array of properties within this sequence\n        var properties = sequence[i].match(regNode) || [];\n\n        //Loop them\n        for (var j = 0; j < properties.length; j++) {\n\n          //Get property's key and separate values\n          var key = regProperty.exec(properties[j])[0].toUpperCase();\n          var values = properties[j].match(regValues);\n\n          //Remove additional braces [ and ]\n          for (var k = 0; k < values.length; k++) {\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\n          }\n\n          //SGF parser present for this key? Call it, and we're done\n          if (typeof parsingMap[key] !== 'undefined') {\n\n            //Does this type of property need a node?\n            if (needsNode.indexOf(key) !== -1) {\n\n              //If no node object present, create a new node\n              //For moves, always a new node is created\n              if (!node || key === 'B' || key === 'W') {\n                node = {};\n                container.push(node);\n              }\n            }\n\n            //Apply parsing function on node\n            parsingMap[key](jgf, node, key, values);\n            continue;\n          }\n\n          //No SGF parser present, we continue with regular property handling\n\n          //If there is only one value, simplify array\n          if (values.length === 1) {\n            values = values[0];\n          }\n\n          //SGF alias known? Then this is an info element and we handle it accordingly\n          if (typeof sgfAliases[key] !== 'undefined') {\n\n            //The position in the JGF object is represented by dot separated strings\n            //in the sgfAliases array. Split the position and use the setInfo helper\n            //to set the info on the JGF object\n            setInfo(jgf, sgfAliases[key].split('.'), values);\n            continue;\n          }\n\n          //No SGF alias present either, just append the data\n\n          //Save in node\n          if (node) {\n            node[key] = values;\n          }\n\n          //Save in root\n          else {\n            jgf[key] = values;\n          }\n        }\n\n        //Reset node, unless this was the root node\n        if (node && !node.root) {\n          node = null;\n        }\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeCommon :: This class governs common event handling of the player shared by\n * various player modes. It's basically an abstract player mode and it can't be actively set.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Common.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Run block\n */\n.run(['Player', 'PlayerModes', 'PlayerModeCommon', function(Player, PlayerModes, PlayerModeCommon) {\n\n  /**\n   * Register common event handlers\n   */\n  Player.on('keydown', PlayerModeCommon.keyDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n}])\n\n/**\n * Factory definition\n */\n.factory('PlayerModeCommon', ['Player', 'PlayerTools', 'GameScorer', 'KeyCodes', function(Player, PlayerTools, GameScorer, KeyCodes) {\n\n  /**\n   * Helper to build drag object\n   */\n  var dragObject = function(event) {\n\n    //Initialize drag object\n    var drag = {\n      start: {\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y\n      },\n      stop: {\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y\n      }\n    };\n\n    //Fix boundaries\n    if (drag.start.x < 0) {\n      drag.start.x = 0;\n    }\n    if (drag.start.y < 0) {\n      drag.start.y = 0;\n    }\n    if (drag.stop.x > this.board.width - 1) {\n      drag.stop.x = this.board.width - 1;\n    }\n    if (drag.stop.y > this.board.height - 1) {\n      drag.stop.y = this.board.height - 1;\n    }\n\n    //Return\n    return drag;\n  };\n\n  /**\n   * Normalize the mousewheel event helper\n   */\n  function normalizeMousewheelEvent(event) {\n\n    //Initialize vars\n    var deltaX = 0;\n    var deltaY = 0;\n\n    //Old school scrollwheel delta\n    if ('detail' in event) {\n      deltaY = event.detail * -1;\n    }\n    if ('wheelDelta' in event) {\n      deltaY = event.wheelDelta;\n    }\n    if ('wheelDeltaY' in event) {\n      deltaY = event.wheelDeltaY;\n    }\n    if ('wheelDeltaX' in event) {\n      deltaX = event.wheelDeltaX * -1;\n    }\n\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\n      deltaX = deltaY * -1;\n      deltaY = 0;\n    }\n\n    //New type wheel delta (WheelEvent)\n    if ('deltaY' in event) {\n      deltaY = event.deltaY * -1;\n    }\n    if ('deltaX' in event) {\n      deltaX = event.deltaX;\n    }\n\n    //Set in event (have to use different property name because of strict mode)\n    event.mouseWheelX = deltaX;\n    event.mouseWheelY = deltaY;\n\n    //Return\n    return event;\n  }\n\n  /**\n   * Player extension\n   */\n  angular.extend(Player, {\n\n    /**\n     * Mouse coordinate helper vars\n     */\n    mouse: {\n\n      //Drag start\n      dragStart: null,\n\n      //Last grid coordinates\n      lastX: -1,\n      lastY: -1\n    }\n  });\n\n  /**\n   * Player mode definition\n   */\n  var PlayerMode = {\n\n    /**\n     * Handler for keydown events\n     */\n    keyDown: function(event, keyboardEvent) {\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Switch key code\n      switch (keyboardEvent.keyCode) {\n\n        //ESC\n        case KeyCodes.ESC:\n\n          //Cancel drag event, and prevent click event as well\n          this.mouse.dragStart = null;\n          this.preventClickEvent = true;\n          break;\n\n        //Right arrow\n        case KeyCodes.RIGHT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Advance to the next move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\n              this.next();\n            }\n          }\n          break;\n\n        //Left arrow\n        case KeyCodes.LEFT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Go to the previous move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\n              this.previous();\n            }\n          }\n          break;\n\n        //Up arrow\n        case KeyCodes.UP:\n          break;\n\n        //Down arrow\n        case KeyCodes.DOWN:\n          break;\n      }\n    },\n\n    /**\n     * Handler for mousewheel events\n     */\n    mouseWheel: function(event, mouseEvent) {\n\n      //Disabled or not using move tool?\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\n        return true;\n      }\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return true;\n      }\n\n      //Normalize mousewheel event\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\n\n      //Find delta\n      var delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\n\n      //Next move\n      if (delta < 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.next();\n      }\n\n      //Previous move\n      else if (delta > 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.previous();\n      }\n\n      //Don't scroll the window\n      if (delta !== 0) {\n        mouseEvent.preventDefault();\n      }\n    },\n\n    /**\n     * Mouse out handler\n     */\n    mouseOut: function() {\n      if (this.board) {\n        this.board.removeAll('hover');\n      }\n    },\n\n    /**\n     * Mouse move handler\n     */\n    mouseMove: function(event, mouseEvent) {\n\n      //Attach drag object to events\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n      }\n\n      //Nothing else to do?\n      if (!this.board || !this.board.layers.hover) {\n        return;\n      }\n\n      //Last coordinates are the same?\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\n        return;\n      }\n\n      //Remember last coordinates\n      this.mouse.lastX = event.x;\n      this.mouse.lastY = event.y;\n\n      //Broadcast hover event\n      this.broadcast('hover', mouseEvent);\n    },\n\n    /**\n     * Mouse down handler\n     */\n    mouseDown: function(event) {\n      this.mouse.dragStart = {\n        x: event.x,\n        y: event.y\n      };\n    },\n\n    /**\n     * Mouse up handler\n     */\n    mouseUp: function(event, mouseEvent) {\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n        this.broadcast('mousedrag', mouseEvent);\n      }\n      this.mouse.dragStart = null;\n    }\n  };\n\n  //Return\n  return PlayerMode;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\n * a game record and its board positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Edit.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Setup tools\n */\n.constant('SetupTools', {\n  BLACK: 'black',\n  WHITE: 'white',\n  CLEAR: 'clear'\n})\n\n/**\n * Markup tools\n */\n.constant('MarkupTools', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  SAD: 'sad',\n  HAPPY: 'happy',\n  TEXT: 'text',\n  NUMBER: 'number',\n  CLEAR: 'clear'\n})\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeEdit', function(Player, PlayerModes, PlayerModeEdit) {\n\n  //Register event handlers\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\n\n  //Register mode\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeEdit', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['Player', 'PlayerTools', 'SetupTools', 'MarkupTools', 'MarkupTypes', 'GameScorer', 'StoneColor', function(\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\n  ) {\n\n    //Character codes\n    var aChar = 'A'.charCodeAt(0);\n    var aCharLc = 'a'.charCodeAt(0);\n\n    /**\n     * Update hover mark at specific coordinates\n     */\n    var updateHoverMark = function(x, y, isDrag) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Setup tool\n        case PlayerTools.SETUP:\n\n          //Clear tool\n          if (this.setupTool === SetupTools.CLEAR) {\n\n            //Stone present? Can remove it\n            if (this.game.hasStone(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Stone color tool\n          else {\n\n            //Add or overwrite stone if no stone present of the given color\n            if (!this.game.hasStone(x, y, this.setupToolColor())) {\n              this.board.add('hover', x, y, {\n                type: 'stones',\n                value: this.setupToolColor()\n              });\n            }\n\n            //Stone present of same color? Can remove it if we're not dragging\n            else if (!isDrag) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n          break;\n\n        //Markup tool\n        case PlayerTools.MARKUP:\n\n          //Clear tool, or already markup in place?\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\n            if (this.game.hasMarkup(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Text or number\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: {\n                type: MarkupTypes.LABEL,\n                text: this.markupLabel\n              }\n            });\n          }\n\n          //Other markup\n          else {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: this.markupTool\n            });\n          }\n          break;\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to set markup\n     */\n    var setMarkup = function(x, y) {\n\n      //Already markup in place? Remove it first\n      if (this.game.hasMarkup(x, y)) {\n\n        //Check what markup there is\n        var markup = this.game.getMarkup(x, y);\n\n        //Label? Also remove from our labels list\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\n          var i = this.markupLabels.indexOf(markup.text);\n          if (i !== -1) {\n            this.markupLabels.splice(i, 1);\n          }\n        }\n\n        //Remove from game\n        this.game.removeMarkup(x, y);\n        return;\n      }\n\n      //Clear tool used? Done\n      if (this.markupTool === MarkupTools.CLEAR) {\n        return;\n      }\n\n      //Text\n      else if (this.markupTool === MarkupTools.TEXT) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next text label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Number\n      else if (this.markupTool === MarkupTools.NUMBER) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next number label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Other markup\n      else {\n        this.game.addMarkup(x, y, this.markupTool);\n      }\n    };\n\n    /**\n     * Helper to set a stone\n     */\n    var setStone = function(x, y, isDrag) {\n\n      //Get the stone color\n      var color = this.setupToolColor();\n\n      //Trying to remove a stone\n      if (color === StoneColor.EMPTY) {\n        this.game.removeStone(x, y);\n      }\n\n      //Adding a stone\n      else {\n\n        //A stone there already of the same color? Just remove if not dragging\n        if (!isDrag && this.game.hasStone(x, y, color)) {\n          this.game.removeStone(x, y);\n          return;\n        }\n\n        //Any stone present?\n        else if (this.game.hasStone(x, y)) {\n          this.game.removeStone(x, y);\n        }\n\n        //Add stone now\n        this.game.addStone(x, y, color);\n      }\n\n      //Redraw markup\n      this.board.layers.markup.redrawCell(x, y);\n    };\n\n    /**\n     * Find all markup labels in current position\n     */\n    var findAllMarkupLabels = function() {\n\n      //Clear\n      this.markupLabels = [];\n\n      //Must have game\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get all markup from position\n      var markup = this.game.position.markup.all('type');\n      for (var i = 0; i < markup.length; i++) {\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\n          this.markupLabels.push(markup[i].text);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Active setup tool and markup tool\n      setupTool: SetupTools.BLACK,\n      markupTool: MarkupTools.TRIANGLE,\n\n      //Current markup labels on the board and current markup label\n      markupLabels: [],\n      markupLabel: '',\n\n      /**\n       * Set the setup tool\n       */\n      switchSetupTool: function(tool) {\n        this.setupTool = tool;\n      },\n\n      /**\n       * Set the markup tool\n       */\n      switchMarkupTool: function(tool) {\n        this.markupTool = tool;\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          this.determineMarkupLabel();\n        }\n      },\n\n      /**\n       * Conversion of setup tool to stone color\n       */\n      setupToolColor: function() {\n        switch (this.setupTool) {\n          case SetupTools.BLACK:\n            return StoneColor.B;\n          case SetupTools.WHITE:\n            return StoneColor.W;\n          default:\n            return StoneColor.EMPTY;\n        }\n      },\n\n      /**\n       * Set the new text markup label\n       */\n      setMarkupLabel: function(label) {\n        if (label) {\n          this.markupLabel = label;\n        }\n      },\n\n      /**\n       * Determine the new text markup label\n       */\n      determineMarkupLabel: function() {\n\n        //Clear\n        this.markupLabel = '';\n\n        //Check what tool we're using\n        switch (this.markupTool) {\n\n          //Text tool?\n          case MarkupTools.TEXT:\n            var i = 0;\n\n            //Loop while the label is present\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n\n              //A-Z\n              if (i < 26) {\n                this.markupLabel = String.fromCharCode(aChar + i);\n              }\n\n              //a-z\n              else if (i < 52) {\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\n              }\n\n              //AA, AB, AC, etc.\n              else {\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\n                  String.fromCharCode(aChar + (i % 26));\n              }\n\n              //Keep going\n              i++;\n            }\n            break;\n\n          //Number tool?\n          case MarkupTools.NUMBER:\n            this.markupLabel = 0;\n\n            //Loop while the label is present\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n              this.markupLabel++;\n            }\n            break;\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeEdit = {\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Remove all hover items\n        this.board.removeAll('hover');\n\n        //Single coordinate?\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //No dragging for labels\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //Loop area\n        for (var x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n          for (var y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n            updateHoverMark.call(this, x, y, true);\n          }\n        }\n      },\n\n      /**\n       * Keydown handler\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //TODO: tool switching via keyboard input\n        }\n      },\n\n      /**\n       * Click handler\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        this.board.removeAll('hover');\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Try to play the move\n            if (!this.game.play(event.x, event.y)) {\n              return;\n            }\n            this.processPosition();\n            break;\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Set stone and update board\n            setStone.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Set markup and update board\n            setMarkup.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Mouse drag handler\n       */\n      mouseDrag: function(event) {\n\n        //Initialize vars\n        var x, y;\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setStone.call(this, x, y, true);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Don't do this for labels\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n              break;\n            }\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setMarkup.call(this, x, y);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Path change\n       */\n      pathChange: function() {\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SETUP,\n          PlayerTools.MARKUP,\n          PlayerTools.SCORE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Find all markup labels in the current game position\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeEdit;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\n * through an existing game record without the ability to deviate from the tree or its variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Replay.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeReplay', function(Player, PlayerModes, PlayerModeReplay) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\n\n  //Register the mode\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeReplay', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Auto play delay\n    autoPlayDelay: 1000\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$interval', 'Player', 'PlayerModes', 'PlayerTools', 'MarkupTypes', 'GameScorer', function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show move variations on the board\n     */\n    var showMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n\n        //Auto variation markup should never overwrite existing markup\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\n          continue;\n        }\n\n        //Add to board\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n          type: this.board.theme.get('markup.variation.type'),\n          text: this.board.theme.get('markup.variation.text', i),\n          color: this.board.theme.get('markup.variation.color')\n        });\n      }\n    };\n\n    /**\n     * Helper to hide move variations from the board\n     */\n    var hideMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) move variations on the board\n     */\n    var drawMoveVariations = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get the current node\n      var node = this.game.getNode();\n      var variations;\n      if (!node) {\n        return;\n      }\n\n      //Child variations?\n      if (this.variationChildren && node.hasMoveVariations()) {\n        variations = node.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n\n      //Sibling variations?\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\n        variations = node.parent.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Auto play vars\n      autoPlaying: false,\n      autoPlayDelay: 1000,\n      autoPlayPromise: null,\n\n      /**\n       * Set auto play delay\n       */\n      setAutoPlayDelay: function(delay) {\n        if (this.autoPlayDelay !== delay) {\n          this.autoPlayDelay = delay;\n          this.broadcast('settingChange', 'autoPlayDelay');\n        }\n      },\n\n      /**\n       * Start auto play with a given delay\n       */\n      start: function(delay) {\n\n        //Not in replay mode or already auto playing?\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\n          return;\n        }\n\n        //Already auto playing, no game or no move children?\n        if (!this.game || !this.game.node.hasChildren()) {\n          return;\n        }\n\n        //Get self\n        var self = this;\n\n        //Determine delay\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\n\n        //Switch tool\n        this.switchTool(PlayerTools.NONE);\n\n        //Create interval\n        this.autoPlaying = true;\n        this.autoPlayPromise = $interval(function() {\n\n          //Advance to the next node\n          self.next(0, true);\n\n          //Ran out of children?\n          if (!self.game.node.hasChildren()) {\n            self.stop();\n          }\n        }, delay);\n\n        //Broadcast event\n        this.broadcast('autoPlayStarted', this.game.node);\n      },\n\n      /**\n       * Stop auto play\n       */\n      stop: function() {\n\n        //Not in replay mode or not auto playing?\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\n          return;\n        }\n\n        //Cancel interval\n        if (this.autoPlayPromise) {\n          $interval.cancel(this.autoPlayPromise);\n        }\n\n        //Clear flags\n        this.autoPlayPromise = null;\n        this.autoPlaying = false;\n\n        //Broadcast event\n        this.broadcast('autoPlayStopped', this.game.node);\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeReplay = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.setAutoPlayDelay(this.config.autoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'variationMarkup') {\n          drawMoveVariations.call(this, this.variationMarkup);\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Check if we clicked a move variation, advance to the next position if so\n            if (this.game.isMoveVariation(event.x, event.y)) {\n              this.next(this.game.getMoveVariation(event.x, event.y));\n            }\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeReplay.hover.call(this, event);\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SCORE,\n          PlayerTools.NONE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Stop auto playing\n        if (this.autoPlaying) {\n          this.stop();\n        }\n\n        //Hide move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, false);\n        }\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeReplay;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\n * go problems and finding the right move or variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Solve.Service', [\n  'ngGo'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeSolve', function(Player, PlayerModes, PlayerModeSolve) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\n\n  //Register mode\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeSolve', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Player color\n    playerColor: StoneColor.B,\n\n    //Show solution paths\n    solutionPaths: false,\n\n    //Auto play settings\n    solveAutoPlay: true,\n    solveAutoPlayDelay: 500\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$timeout', 'Player', 'PlayerModes', 'PlayerTools', 'KeyCodes', function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\n\n    /**\n     * Check if we can make a move\n     */\n    var canMakeMove = function() {\n\n      //We can make a move when...\n\n      //...there is no auto play going on\n      if (!this.solveAutoPlay) {\n        return true;\n      }\n\n      //...we solved the puzzle already\n      if (this.problemSolved) {\n        return true;\n      }\n\n      //...we are off path\n      if (this.problemOffPath) {\n        return true;\n      }\n\n      //...it's our turn\n      if (this.game.getTurn() === this.playerColor) {\n        return true;\n      }\n\n      //Otherwise, we can't make a move\n      return false;\n    };\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show solution paths\n     */\n    var showSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        if (variations[i].solution === true) {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.valid.type'),\n            text: this.board.theme.get('markup.solution.valid.text', i),\n            scale: this.board.theme.get('markup.solution.valid.scale'),\n            color: this.board.theme.get('markup.solution.valid.color')\n          });\n        }\n        else {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.invalid.type'),\n            text: this.board.theme.get('markup.solution.invalid.text', i),\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\n            color: this.board.theme.get('markup.solution.invalid.color')\n          });\n        }\n      }\n    };\n\n    /**\n     * Helper to hide solution paths\n     */\n    var hideSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) solution paths\n     */\n    var drawSolutionPaths = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get node and variations\n      var node = this.game.getNode();\n      var variations = node.getMoveVariations();\n\n      //When showing, make sure it's not during the auto solver's move\n      if (show && !this.problemSolved && this.solveAutoPlay) {\n        if (this.game.getTurn() !== this.playerColor) {\n          hideSolutionPaths.call(this, variations);\n          return;\n        }\n      }\n\n      //Call helper\n      if (show) {\n        showSolutionPaths.call(this, variations);\n      }\n      else {\n        hideSolutionPaths.call(this, variations);\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Solved and off-path flags\n      problemSolved: false,\n      problemOffPath: false,\n\n      //Problem start path\n      problemStartPath: null,\n\n      //The player color\n      playerColor: 0,\n\n      //Solution paths\n      solutionPaths: false,\n\n      //Auto play vars\n      solveAutoPlay: true,\n      solveAutoPlayDelay: 500,\n\n      //Navigation blocked flag\n      solveNavigationBlocked: false,\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlay: function(autoPlay) {\n        if (this.solveAutoPlay !== autoPlay) {\n          this.solveAutoPlay = autoPlay;\n          this.broadcast('settingChange', 'solveAutoPlay');\n        }\n      },\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlayDelay: function(delay) {\n        if (this.solveAutoPlayDelay !== delay) {\n          this.solveAutoPlayDelay = delay;\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\n        }\n      },\n\n      /**\n       * Set player color\n       */\n      setPlayerColor: function(color) {\n        if (this.playerColor !== color) {\n          this.playerColor = color;\n          this.broadcast('settingChange', 'playerColor');\n        }\n      },\n\n      /**\n       * Get player color\n       */\n      getPlayerColor: function(asOnBoard) {\n        if (asOnBoard && this.board) {\n          return this.board.colorMultiplier * this.playerColor;\n        }\n        return this.playerColor;\n      },\n\n      /**\n       * Toggle solution paths\n       */\n      toggleSolutionPaths: function(solutionPaths) {\n\n        //Toggle if not given\n        if (typeof solutionPaths === 'undefined') {\n          solutionPaths = !this.solutionPaths;\n        }\n\n        //Change?\n        if (solutionPaths !== this.solutionPaths) {\n          this.solutionPaths = solutionPaths;\n          this.broadcast('settingChange', 'solutionPaths');\n        }\n      },\n\n      /**\n       * Auto play next move\n       */\n      autoPlayNext: function(immediately) {\n\n        //Must have game and children\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\n          return;\n        }\n\n        //Init vars\n        var children = [];\n        var self = this;\n        var i;\n\n        //When picking a child node, we always prefer to pick a valid solution\n        for (i = 0; i < this.game.node.children.length; i++) {\n          if (this.game.node.children[i].solution) {\n            children.push(this.game.node.children[i]);\n          }\n        }\n\n        //No solution nodes? Just use all nodes then.\n        if (children.length === 0) {\n          children = this.game.node.children;\n        }\n\n        //Pick a random child node\n        i = Math.floor(Math.random() * children.length);\n\n        //No delay?\n        if (immediately || !this.solveAutoPlayDelay) {\n          this.next(children[i]);\n          return;\n        }\n\n        //Block navigation and run the timeout\n        this.solveNavigationBlocked = true;\n        $timeout(function() {\n\n          //Move to next move and unblock navigation\n          self.next(children[i]);\n          self.solveNavigationBlocked = false;\n\n        }, this.solveAutoPlayDelay);\n      },\n\n      /**\n       * Start solving from the current game node\n       */\n      solve: function() {\n\n        //Must have a game\n        if (!this.game || !this.game.isLoaded()) {\n          return false;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Remember problem start path\n        this.problemStartPath = this.game.getPath(true);\n\n        //Restrict start of navigation to the current node\n        this.restrictNode();\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      },\n\n      /**\n       * Restart the problem\n       */\n      restartProblem: function() {\n\n        //Must be in solve mode, must have game\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Go back to the start path\n        if (this.problemStartPath) {\n          this.goto(this.problemStartPath);\n        }\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeSolve = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.toggleSolutionPaths(this.config.solutionPaths);\n        this.setPlayerColor(this.config.playerColor);\n        this.setSolveAutoPlay(this.config.solveAutoPlay);\n        this.setSolveAutoPlayDelay(this.config.solveAutoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'solutionPaths') {\n          drawSolutionPaths.call(this, this.solutionPaths);\n        }\n\n        //Player color changed?\n        if (setting === 'playerColor') {\n\n          //Draw (or hide) solution paths\n          drawSolutionPaths.call(this, this.solutionPaths);\n\n          //Make an auto play move if it's not our turn\n          if (\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\n          ) {\n            this.autoPlayNext(true);\n          }\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this, event.x, event.y);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for keydown events\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //Right arrow\n          case KeyCodes.RIGHT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\n\n                //Go forward one move if solved\n                if (this.problemSolved) {\n                  this.next();\n                }\n              }\n            }\n            break;\n\n          //Left arrow\n          case KeyCodes.LEFT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked and not reached the start?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\n\n                //Go back one move\n                this.previous();\n\n                //Go back one more if this is not the player's turn and if\n                //the problem hasn't been solved yet\n                if (\n                  !this.problemSolved && this.solveAutoPlay &&\n                  this.game.getTurn() === -this.playerColor\n                ) {\n                  this.previous();\n                }\n              }\n            }\n            break;\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //A valid variation\n        if (this.game.isMoveVariation(event.x, event.y)) {\n\n          //Get the node\n          var i = this.game.getMoveVariation(event.x, event.y);\n\n          //Advance to the next position and get the next node\n          this.next(i);\n          var node = this.game.getNode();\n\n          //No children left? Check if we solved it or not\n          if (node.children.length === 0) {\n            if (node.solution === true) {\n              this.problemSolved = true;\n              this.broadcast('solutionFound', node);\n            }\n            else {\n              this.broadcast('solutionWrong', node);\n            }\n          }\n\n          //Auto-play next move?\n          else if (!this.problemSolved && this.solveAutoPlay) {\n            this.autoPlayNext();\n          }\n        }\n\n        //Unknown variation, try to play\n        else if (this.game.play(event.x, event.y)) {\n          this.problemOffPath = true;\n          this.processPosition();\n          this.broadcast('solutionOffPath', this.game.getNode());\n        }\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Draw solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Hide any solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, false);\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeSolve;\n  }];\n}]);\n\n})(window, window.angular);\n"],"sourceRoot":"/source/"}