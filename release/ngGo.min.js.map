{"version":3,"sources":["ngGo.js","board/board.directive.js","board/board.service.js","board/defaultClearHandler.service.js","board/grid.service.js","board/gridChanges.service.js","board/layer.service.js","board/object.service.js","board/shellPattern.service.js","board/theme.service.js","errors/invalidDataError.service.js","errors/invalidPositionError.service.js","game/game.service.js","game/node.service.js","game/path.service.js","game/position.service.js","game/score.service.js","game/scorer.service.js","kifu/blank.service.js","kifu/parser.service.js","player/player.directive.js","player/player.service.js","board/layer/gridLayer.service.js","board/layer/hoverLayer.service.js","board/layer/markupLayer.service.js","board/layer/scoreLayer.service.js","board/layer/shadowLayer.service.js","board/layer/stonesLayer.service.js","board/object/coordinates.service.js","board/object/markup.service.js","board/object/stone.service.js","board/object/stoneFaded.service.js","board/object/stoneMini.service.js","board/object/stoneShadow.service.js","kifu/parsers/gib2jgf.service.js","kifu/parsers/jgf2sgf.service.js","kifu/parsers/sgf2jgf.service.js","player/mode/common.service.js","player/mode/edit.service.js","player/mode/replay.service.js","player/mode/solve.service.js"],"names":["window","angular","undefined","constant","name","POSITION_OUT_OF_BOUNDS","POSITION_ALREADY_HAS_STONE","NO_DATA","UNKNOWN_DATA","INVALID_SGF","INVALID_GIB","E","EMPTY","B","BLACK","TRIANGLE","CIRCLE","SQUARE","MARK","SELECT","LABEL","LAST","PLAY","REPLAY","NONE","MOVE","SCORE","LEFT","RIGHT","UP","DOWN","ESC","ENTER","SPACE","TAB","SHIFT","CTRL","ALT","HOME","END","cellSize","scope","lastDrawHeight","drawHeight","$broadcast","drawWidth","instance","layer","playerElement","parent","sizingElement","element","existingInstance","Board","canvas","width","i","height","pixelRatio","layerOrder","layers","setContext","context","createLayerCanvas","size","setSize","toLowerCase","indexOf","split","setCutoff","attr","this","drawMarginHor","drawMarginVer","gridDrawWidth","gridDrawHeight","layerClass","toUpperCase","LayerClass","$injector","get","substr","left","right","bottom","prototype","cutoff","setSection","config","section","resized","side","changes","extend","show","coordinates","setMargin","theme","multiplier","parseInt","setTheme","y","value","remove","setAll","grid","removeAll","getAll","state","static","draw","xRight","yTop","top","yBot","noCellsVer","noCellsHor","round","absX","absY","s","board","getCellSize","r","clearRect","x","emptyValue","objects","push","toObject","newGrid","q","n","j","b","a","length","concat","setSubtract","empty","drawCell","ctx","lineWidth","radius","beginPath","x2","Math","cos","endAngle","PI","y2","sin","m","y1","angle","x1","dy","bx2","dx","by2","stroke","lines","shellLine","call","stoneColor","thickness","color","offsetY","ceil","MarkupTypes","fromCharCode","String","scale","invalid","floor","inverse","defaultTheme","args","arguments","path","BoardTheme","message","code","ngGo","error","INVALID_JGF_JSON","INVALID_JGF_TREE_JSON","POSTITION_OUT_OF_BOUNDS","POSTITION_ALREADY_HAS_STONE","POSTITION_IS_SUICIDE","POSTITION_IS_REPEATING","info","defaultSize","komi","game","handicap","history","pop","newPosition","node","move","pass","validateMove","stones","markup","init","reload","jgf","c","data","charAt","fromSgf","fromJgf","fromGib","fromJson","tree","nodes","getMoveNumber","fromMove","toMove","getMove","moveNodes","getMoveVariation","getPath","clone","parseFloat","setKomi","defaultKomi","captures","StoneColor","W","p","defaultValue","obj","isMoveVariation","stop","splice","position","unset","hasStone","has","hasMarkup","type","GameNode","previousNode","executeNode","target","setMove","getPathToNode","children","Game","coords","baseObject","toColorConstant","jgfMove","jgfSetup","gameSetup","jgfMarkup","gameMarkup","convertCoordinates","l","text","turn","convertTurnFromJgf","properties","key","convertTurnToJgf","isMove","temp","prop","conversionMap","gameNode","_typeof","appendChild","nextNode","toJgf","reset","branches","no","newPath","captured","canCapture","captureGroup","enemyColor","BoardGrid","white","self","black","props","territorySet","candidateColor","boundaryColor","territoryReset","newState","adjacent","w","scoreState","WHITE_STONE","NEUTRAL","WHITE_CANDIDATE","BLACK_CANDIDATE","set","BLACK_STONE","points","score","application","charset","version","CA","FF","GM","SZ","PB","PW","base","blank","AP","CP","SO","GN","KM","HA","RE","RU","TM","OT","DT","PC","EV","RO","BT","WT","N","C","CR","TR","SQ","MA","1","2","3","4","6","restrict","Player","attrs","$observe","mode","variationSiblings","broadcastEvent","originalEvent","mouseEvent","layerX","layerY","registerElementEvent","setArrowKeysNavigation","setScrollWheelNavigation","setLastMoveMarker","lastMoveMarker","setVariationMarkup","variationMarkup","modes","parseConfig","arrowKeysNavigation","arrowKeys","scrollWheelNavigation","scrollWheel","change","variationChildren","switchTool","tool","PlayerTools","restrictNodeStart","restrictNodeEnd","playerState","processPosition","gameState","previousFork","previousComment","pathChanged","GameScorer","isLoaded","$parent","types","preventClickEvent","t","listener","on","$scope","$rootScope","arc","fill","lineCap","strokeStyle","starRadius","starColor","starPoints","canvasTranslate","moveTo","ty","lineTo","tx","gridY","drawStarPoint","hover","object","objectClass","clear","add","restore","clearCell","StoneFaded","ch","aCharLc","aChar","yt","yb","font","style","horizontal","textAlign","fillStyle","vertical","fillText","xr","getAbsY","closePath","rcos","bezierCurveTo","HAPPY","SAD","drawLabel","addColorStop","createRadialGradient","handler","stone","max","shadowColor","offsetX","blur","rank","match","players","player","result","regKomi","regDate","regResultMargin","regResultOther","escapeSgf","replace","output","values","sgf","flatComments","comments","comment","nodeName","parts","st","rootProperties","writeTree","parsingMap","extractRootProperties","subKey","jgfKey","jgfAliases","sgfAliases","parseMove","setup","parseSetup","parseTurn","parseMarkup","parseNodeName","record.application","parseBoard","parsePlayer","root","app","record","parseGame","sgfGames","dates","regProperty","regValues","parseSize","parseKomi","parseDate","AB","AW","AE","parseScore","PL","parseLabel","container","stack","PlayerModeCommon","mouseMove","PlayerModes","mouseOut","mouseDown","EDIT","SOLVE","mouseUp","mouse","dragStart","event","drag","start","deltaY","detail","wheelDelta","wheelDeltaY","axis","HORIZONTAL_AXIS","delta","next","previous","dragObject","broadcast","CLEAR","TEXT","NUMBER","PlayerModeEdit","modeEnter","mouseDrag","keyDown","click","lastY","setupToolColor","MarkupTools","markupTool","isValidMove","getTurn","markupLabels","addMarkup","markupLabel","isDrag","determineMarkupLabel","SetupTools","WHITE","label","SETUP","MARKUP","updateHoverMark","setStone","setMarkup","mark","statePreScoring","PlayerModeReplay","pathChange","toolSwitch","modeExit","variations","getNode","hasMoveVariations","showMoveVariations","hideMoveVariations","autoPlayPromise","autoPlayDelay","delay","PlayerModeSolve","solution","hideSolutionPaths","playerColor","solveAutoPlay","autoPlay","solveAutoPlayDelay","asOnBoard","solutionPaths","immediately","setSolveAutoPlay","setSolveAutoPlayDelay","problemSolved"],"mappings":"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","file":"ngGo.min.js","sourcesContent":["/**\n * ngGo\n *\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\n * refactored to fit the Angular framework, as well as having been linted, properly commented\n * and generally cleaned up.\n *\n * Copyright (c) 2013 Jan Prokop (WGo)\n * Copyright (c) 2014-2015 Adam Reis (ngGo)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo', [])\n\n/**\n * ngGo constants\n */\n.constant('ngGo', {\n  name: 'ngGo',\n  version: '1.3.1',\n  error: {\n\n    //Position errors\n    POSITION_OUT_OF_BOUNDS: 1,\n    POSITION_ALREADY_HAS_STONE: 2,\n    POSITION_IS_SUICIDE: 3,\n    POSITION_IS_REPEATING: 4,\n\n    //Data loading errors\n    NO_DATA: 5,\n    UNKNOWN_DATA: 6,\n    INVALID_SGF: 7,\n    INVALID_GIB: 8,\n    INVALID_JGF_JSON: 9,\n    INVALID_JGF_TREE_JSON: 10,\n  },\n})\n\n/**\n * Stone colors\n */\n.constant('StoneColor', {\n  E: 0,\n  EMPTY: 0,\n  B: 1,\n  BLACK: 1,\n  W: -1,\n  WHITE: -1,\n})\n\n/**\n * Markup types\n */\n.constant('MarkupTypes', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  LABEL: 'label',\n  LAST: 'last',\n  SAD: 'sad',\n  HAPPY: 'happy',\n})\n\n/**\n * Player modes\n */\n.constant('PlayerModes', {\n  PLAY: 'play',\n  REPLAY: 'replay',\n  EDIT: 'edit',\n  SOLVE: 'solve',\n})\n\n/**\n * Player tools\n */\n.constant('PlayerTools', {\n  NONE: 'none',\n  MOVE: 'move',\n  SCORE: 'score',\n  SETUP: 'setup',\n  MARKUP: 'markup',\n})\n\n/**\n * Key codes\n */\n.constant('KeyCodes', {\n  LEFT: 37,\n  RIGHT: 39,\n  UP: 38,\n  DOWN: 40,\n  ESC: 27,\n  ENTER: 13,\n  SPACE: 32,\n  TAB: 9,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  HOME: 36,\n  END: 35,\n  PAGEUP: 33,\n  PAGEDOWN: 34,\n});\n","/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Directive', [\n  'ngGo.Board.Service',\n])\n\n/**\n * Directive definition\n */\n.directive('board', function($window, Board) {\n\n  //Get pixel ratio\n  let pixelRatio = window.devicePixelRatio || 1;\n\n  /**\n   * Helper to create a layer canvas\n   */\n  function createLayerCanvas(name) {\n\n    //Create canvas element and get context\n    let canvas = document.createElement('canvas');\n    let context = canvas.getContext('2d');\n\n    //Scale context depending on pixel ratio\n    if (pixelRatio > 1) {\n      context.scale(pixelRatio, pixelRatio);\n    }\n\n    //Set class\n    canvas.className = name;\n\n    //Set initial canvas width/height based on our own size\n    canvas.width = this.clientWidth * pixelRatio;\n    canvas.height = this.clientHeight * pixelRatio;\n\n    //Append to element now and return context\n    this.appendChild(canvas);\n    return context;\n  }\n\n  /**\n   * Helper to determine draw size\n   */\n  function determineDrawSize(scope, availableWidth, availableHeight) {\n\n    //Init vars\n    let drawWidth, drawHeight, cellSize;\n\n    //Stretch available height to width if zero\n    if (availableHeight === 0 && availableWidth > 0) {\n      availableHeight = availableWidth;\n    }\n\n    //Grid size known?\n    if (scope.Board.width && scope.Board.height) {\n\n      //Determine smallest cell size\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\n\n      //Set draw size\n      drawWidth = Math.floor(cellSize * scope.Board.width);\n      drawHeight = Math.floor(cellSize * scope.Board.height);\n    }\n\n    //Otherwise, use the lesser of the available width/height\n    else {\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\n    }\n\n    //Broadcast new size if changed\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\n      scope.lastDrawWidth = drawWidth;\n      scope.lastDrawHeight = drawHeight;\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\n      return true;\n    }\n\n    //No change\n    return false;\n  }\n\n  /**\n   * Directive\n   */\n  return {\n    restrict: 'E',\n    scope: {\n      instance: '&',\n    },\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Init vars\n      let i, context, layer, playerElement;\n      let parent = element.parent();\n      let sizingElement = element[0];\n      let existingInstance = true;\n\n      //Remember last draw width/height\n      scope.lastDrawWidth = 0;\n      scope.lastDrawHeight = 0;\n\n      //Get board instance\n      scope.Board = scope.instance();\n\n      //Function given?\n      if (typeof scope.Board === 'function') {\n        scope.Board = scope.Board();\n      }\n\n      //Instantiate board if not present in scope\n      if (!scope.Board) {\n        existingInstance = false;\n        scope.Board = new Board();\n      }\n\n      //Link element\n      scope.Board.linkElement(element);\n\n      //Find player element\n      if (parent[0].tagName === 'PLAYER') {\n        playerElement = parent;\n        sizingElement = parent.parent()[0];\n      }\n\n      //Listen for board drawsize events\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\n\n        //First set the new dimensions on the canvas elements\n        let canvas = element.find('canvas');\n        for (i = 0; i < canvas.length; i++) {\n          canvas[i].width = width * pixelRatio;\n          canvas[i].height = height * pixelRatio;\n        }\n\n        //Set on the element if we're using a player element and if there is a size\n        if (playerElement || attrs.forceSize === 'true') {\n          element.css({width: width + 'px', height: height + 'px'});\n        }\n\n        //Next set it on the board itself\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\n      });\n\n      //Determine initial draw size\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n\n      //On window resize, determine the draw size again\n      angular.element($window).on('resize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On manual resize, determine draw size again\n      scope.$on('ngGo.board.determineDrawSize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On board grid resize, determine the draw size again\n      scope.$on('ngGo.board.resize', function(event, board) {\n\n        //Only relevent if this was our own board\n        if (board !== scope.Board) {\n          return;\n        }\n\n        //If the draw size didn't change, the draw size event won't be triggered.\n        //However, that means we should call the resized() method now manually because\n        //it won't be called with the setDrawSize() call.\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\n          scope.Board.resized();\n        }\n      });\n\n      //Static board\n      if (attrs.static && attrs.static === 'true') {\n\n        //Add static class and make the board static\n        element.addClass('static');\n        scope.Board.makeStatic();\n\n        //Create single canvas and link to all relevant layer service classes\n        context = createLayerCanvas.call(element[0], 'static');\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Dynamic board\n      else {\n\n        //Create individual layer canvasses and link the canvas context to the layer service class\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          context = createLayerCanvas.call(element[0], layer);\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Observe the board size attribute\n      attrs.$observe('size', function(size) {\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\n          size = size.split('x');\n          scope.Board.setSize(size[0], size[1]);\n        }\n        else {\n          scope.Board.setSize(size, size);\n        }\n      });\n\n      //Observe the coordinates attribute\n      attrs.$observe('coordinates', function(attr) {\n        scope.Board.toggleCoordinates(attr === 'true');\n      });\n\n      //Observe the cutoff attribute\n      attrs.$observe('cutoff', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.setCutoff(attr.split(','));\n        }\n      });\n\n      //Observe color multiplier\n      attrs.$observe('colorMultiplier', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.swapColors(attr);\n        }\n      });\n\n      //Link board to player if present in parent scope\n      if (scope.$parent.Player) {\n        scope.$parent.Player.setBoard(scope.Board);\n      }\n\n      //Redraw board if we had an existing instance (it might contain data)\n      if (existingInstance) {\n        scope.Board.redraw();\n      }\n    },\n  };\n});\n","\n/**\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\n * and is used for placing and removing objects on the board. The class has helpers to figure out\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\n * responsible for drawing all layers on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Service', [\n  'ngGo',\n  'ngGo.Board.Directive',\n  'ngGo.Board.Theme.Service',\n  'ngGo.Board.Layer.GridLayer.Service',\n  'ngGo.Board.Layer.ShadowLayer.Service',\n  'ngGo.Board.Layer.StonesLayer.Service',\n  'ngGo.Board.Layer.MarkupLayer.Service',\n  'ngGo.Board.Layer.ScoreLayer.Service',\n  'ngGo.Board.Layer.HoverLayer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.Stone.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service',\n])\n\n/**\n * Provider definition\n */\n.provider('Board', function() {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n    //Width and height\n    width: 0,\n    height: 0,\n\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\n    cutoff: [],\n\n    //Section of board to display\n    section: {top: 0, right: 0, bottom: 0, left: 0},\n\n    //Show coordinates?\n    coordinates: false,\n\n    //Color multiplier (use -1 to swap colors)\n    colorMultiplier: 1,\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function($rootScope, $injector, BoardTheme) {\n\n    /**\n     * Board constructor\n     */\n    function Board(config) {\n\n      //Initialize board\n      this.init();\n\n      //Parse config\n      this.parseConfig(config || {});\n    }\n\n    /**\n     * Initialize board\n     */\n    Board.prototype.init = function() {\n\n      //Remove everything\n      this.removeAll();\n\n      //Set board theme\n      this.theme = new BoardTheme();\n\n      //Initialize board draw dimensions in pixels\n      this.cellSize = 0;\n      this.drawWidth = 0;\n      this.drawHeight = 0;\n      this.drawMarginHor = 0;\n      this.drawMarginVer = 0;\n      this.gridDrawWidth = 0;\n      this.gridDrawHeight = 0;\n\n      //Set layer order\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\n\n      //Initialize layers\n      this.layers = {};\n      for (let l = 0; l < this.layerOrder.length; l++) {\n        let layer = this.layerOrder[l];\n        let layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\n        let LayerClass = $injector.get(layerClass);\n        this.layers[layer] = new LayerClass(this);\n      }\n\n      //Static board flag\n      this.static = false;\n\n      //Get margin from theme\n      this.margin = this.theme.get('board.margin');\n\n      //Color multiplier (to allow color swapping)\n      this.colorMultiplier = 1;\n\n      //Turn off coordinates\n      this.coordinates = false;\n      this.layers.grid.setCoordinates(false);\n\n      //Initialize grid size\n      this.width = 0;\n      this.height = 0;\n\n      //Initialize cutoff\n      this.cutoff = {\n        top: false,\n        left: false,\n        right: false,\n        bottom: false,\n      };\n\n      //Initialize section\n      this.section = {\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n      };\n    };\n\n    /**\n     * Link the board to a HTML element\n     */\n    Board.prototype.linkElement = function(element) {\n      this.element = element;\n    };\n\n    /**\n     * Make this board static (one canvas layer, only grid, stones and markup)\n     */\n    Board.prototype.makeStatic = function() {\n      this.static = true;\n      this.layerOrder = ['grid', 'stones', 'markup'];\n    };\n\n    /*****************************************************************************\n     * Configuration\n     ***/\n\n    /**\n     * Parse config instructions\n     */\n    Board.prototype.parseConfig = function(config) {\n\n      //Validate\n      if (typeof config !== 'object') {\n        return;\n      }\n\n      //Extend from default config\n      config = angular.extend({}, defaultConfig, config);\n\n      //Process settigns\n      this.toggleCoordinates(config.coordinates);\n      this.swapColors(config.colorMultiplier);\n      this.setCutoff(config.cutoff);\n      this.setSection(config.section);\n      this.setSize(config.width, config.height);\n    };\n\n    /**\n     * Set margin\n     */\n    Board.prototype.setMargin = function(margin) {\n\n      //Reset when not defined\n      if (typeof margin === 'undefined') {\n        margin = this.theme.get('board.margin');\n      }\n\n      //Set margin if changed\n      if (this.margin !== margin) {\n        this.margin = margin;\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set grid cut-off\n     */\n    Board.prototype.setCutoff = function(cutoff) {\n\n      //Nothing given? Reset cutoff\n      if (!cutoff || !angular.isArray(cutoff)) {\n        cutoff = [];\n      }\n\n      //Init\n      let changes = false;\n\n      //Check if there's a change\n      for (let side in this.cutoff) {\n        if (this.cutoff.hasOwnProperty(side)) {\n          if (cutoff.indexOf(side) !== -1) {\n            if (!this.cutoff[side]) {\n              this.cutoff[side] = true;\n              changes = true;\n            }\n          }\n          else if (this.cutoff[side]) {\n            this.cutoff[side] = false;\n            changes = true;\n          }\n        }\n      }\n\n      //Trigger resized if there were changes\n      if (changes) {\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set section of the board to be displayed\n     */\n    Board.prototype.setSection = function(section) {\n\n      //Nothing given?\n      if (!section || typeof section !== 'object') {\n        return this;\n      }\n\n      //Expand on default\n      section = angular.extend({\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n      }, section);\n\n      //No changes?\n      if (\n        this.section.top === section.top && this.section.bottom === section.bottom &&\n        this.section.left === section.left && this.section.right === section.right\n      ) {\n        return this;\n      }\n\n      //Set section and call resized handler\n      this.section = section;\n      this.resized();\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set board size. This will clear the board objects.\n     */\n    Board.prototype.setSize = function(width, height) {\n\n      //Check what's given\n      width = parseInt(width || height || 0);\n      height = parseInt(height || width || 0);\n\n      //Invalid?\n      if (isNaN(width) || isNaN(height)) {\n        return;\n      }\n\n      //Changing?\n      if (width !== this.width || height !== this.height) {\n\n        //Remember size\n        this.width = width;\n        this.height = height;\n\n        //Set size in layers\n        for (let layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].setSize(width, height);\n          }\n        }\n\n        //Broadcast event (no call to resized, as that is handled in the directive)\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set new draw size\n     */\n    Board.prototype.setDrawSize = function(width, height) {\n      if (width !== this.drawWidth || height !== this.drawHeight) {\n        this.drawWidth = width;\n        this.drawHeight = height;\n        this.resized();\n      }\n    };\n\n    /**\n     * Toggle the coordinates\n     */\n    Board.prototype.toggleCoordinates = function(show) {\n\n      //Set or toggle\n      if (typeof show !== 'undefined') {\n        this.coordinates = show;\n      }\n      else {\n        this.coordinates = !this.coordinates;\n      }\n\n      //Set in grid layer\n      this.layers.grid.setCoordinates(this.coordinates);\n\n      //Set the proper board margin\n      if (this.coordinates) {\n        this.setMargin(this.theme.get('coordinates.margin'));\n      }\n      else {\n        this.setMargin(this.theme.get('board.margin'));\n      }\n    };\n\n    /**\n     * Swap colors on the board\n     */\n    Board.prototype.swapColors = function(multiplier) {\n\n      //Multiplier not given? Set to inverse of current value\n      if (typeof multiplier === 'undefined') {\n        multiplier = -this.colorMultiplier;\n      }\n      else {\n        multiplier = parseInt(multiplier);\n        if (isNaN(multiplier)) {\n          return;\n        }\n      }\n\n      //No change?\n      if (multiplier === this.colorMultiplier) {\n        return;\n      }\n\n      //Set new value\n      this.colorMultiplier = multiplier;\n\n      //For static board, redraw the whole thing\n      if (this.static) {\n        this.redraw();\n      }\n\n      //For a dynamic board, only these layers\n      else {\n        this.redraw('stones');\n        this.redraw('markup');\n      }\n    };\n\n    /*****************************************************************************\n     * Theme handling\n     ***/\n\n    /**\n     * Get the current theme object\n     */\n    Board.prototype.getTheme = function() {\n      return this.theme;\n    };\n\n    /**\n     * Set the theme object\n     */\n    Board.prototype.setTheme = function(theme) {\n      this.theme = theme;\n      return this;\n    };\n\n    /*****************************************************************************\n     * Object handling\n     ***/\n\n    /**\n     * Add an object to a board layer\n     */\n    Board.prototype.add = function(layer, x, y, value) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].add(x, y, value);\n      }\n    };\n\n    /**\n     * Remove an object from a board layer\n     */\n    Board.prototype.remove = function(layer, x, y) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].remove(x, y);\n      }\n    };\n\n    /**\n     * Get something from a board layer\n     */\n    Board.prototype.get = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].get(x, y));\n    };\n\n    /**\n     * Check if we have something at given coordinates for a given layer\n     */\n    Board.prototype.has = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].has(x, y));\n    };\n\n    /**\n     * Set all objects (grid) for a given layer\n     */\n    Board.prototype.setAll = function(layer, grid) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].setAll(grid);\n      }\n    };\n\n    /**\n     * Remove all objects from the board, optionally for a given layer\n     */\n    Board.prototype.removeAll = function(layer) {\n      if (layer) {\n        if (typeof this.layers[layer] !== 'undefined') {\n          this.layers[layer].removeAll();\n        }\n      }\n      else {\n        for (layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].removeAll();\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Position handling\n     ***/\n\n    /**\n     * Update the board with a new position\n     */\n    Board.prototype.updatePosition = function(position, pathChanged) {\n\n      //If we have no grid size yet, use what's in the position\n      if (!this.width || !this.height) {\n        this.setSize(position.width, position.height);\n      }\n\n      //Remove markup if path changed\n      if (pathChanged) {\n        this.removeAll('markup');\n      }\n\n      //Set new stones and markup grids\n      this.setAll('stones', position.stones);\n      this.setAll('markup', position.markup);\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state (list of objects per layer)\n     */\n    Board.prototype.getState = function(layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          return this.layers[layer].getAll();\n        }\n        return null;\n      }\n\n      //All layers\n      let state = {};\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          let grid = this.layers[layer].getAll();\n          if (grid && !grid.isEmpty()) {\n            state[layer] = grid;\n          }\n        }\n      }\n      return state;\n    };\n\n    /**\n     * Restore the board state from given state object\n     */\n    Board.prototype.restoreState = function(state, layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          this.layers[layer].setAll(state);\n        }\n        return;\n      }\n\n      //All layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].removeAll();\n          if (state[layer]) {\n            this.layers[layer].setAll(state[layer]);\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing control\n     ***/\n\n    /**\n     * Clear the whole board\n     */\n    Board.prototype.clear = function(layer) {\n\n      //Just clearing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Clear the layer\n        this.layers[layer].clear();\n        return;\n      }\n\n      //Static? One clear is enough\n      if (this.static) {\n        this.layers.stones.clear();\n        return;\n      }\n\n      //Clear all layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].clear();\n        }\n      }\n    };\n\n    /**\n     * Redraw everything or just a single layer\n     */\n    Board.prototype.redraw = function(layer) {\n\n      //The board can only be redrawn when there is a grid size and a draw size\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Just redrawing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Redraw the layer\n        this.layers[layer].redraw();\n        return;\n      }\n\n      //Clear the board first\n      this.clear();\n\n      //Now draw all layers again in the correct order\n      for (let i = 0; i < this.layerOrder.length; i++) {\n        layer = this.layerOrder[i];\n        this.layers[layer].draw();\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing helpers\n     ***/\n\n    /**\n     * Called after a board size change, draw size change, section change or margin change\n     */\n    Board.prototype.resized = function() {\n\n      //Determine the new grid\n      this.grid = {\n        xLeft: 0 + this.section.left,\n        xRight: this.width - 1 - this.section.right,\n        yTop: 0 + this.section.top,\n        yBot: this.height - 1 - this.section.bottom,\n      };\n\n      //Only redraw when there is sensible data\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Determine number of cells horizontall and vertically\n      //The margin is a factor of the cell size, so let's add it to the number of cells\n      let noCellsHor = this.width + this.margin;\n      let noCellsVer = this.height + this.margin;\n\n      //Are we cutting off parts of the grid? Add half a cell of draw size\n      for (let side in this.cutoff) {\n        if (this.cutoff[side]) {\n          if (side === 'top' || side === 'bottom') {\n            noCellsVer += 0.5;\n          }\n          else {\n            noCellsHor += 0.5;\n          }\n        }\n      }\n\n      //Determine cell size now\n      this.cellSize = Math.floor(Math.min(\n        this.drawWidth / noCellsHor,\n        this.drawHeight / noCellsVer\n      ));\n\n      //Determine actual grid draw size (taking off the margin again)\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\n\n      //Determine draw margins\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\n\n      //Redraw\n      this.redraw();\n    };\n\n    /**\n     * Get the current cell size\n     */\n    Board.prototype.getCellSize = function() {\n      return this.cellSize;\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsX = function(gridX) {\n      let offset = this.cutoff.left ? 0.5 : 0;\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsY = function(gridY) {\n      let offset = this.cutoff.top ? 0.5 : 0;\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridX = function(absX) {\n      let offset = this.cutoff.left ? 0.5 : 0;\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridY = function(absY) {\n      let offset = this.cutoff.top ? 0.5 : 0;\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\n    };\n\n    /**\n     * Check if given grid coordinates are on board\n     */\n    Board.prototype.isOnBoard = function(gridX, gridY) {\n      return (\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\n      );\n    };\n\n    //Return object\n    return Board;\n  };\n});\n","\n/**\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\n * a small rectangular area on the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('DefaultClearHandler', function() {\n\n  /**\n   * Clear handler definition\n   *\n   * All external handlers are called from the context of the layer that contains the object.\n   * First parameter is the canvas2d context, second parameter is the object itself.\n   */\n  return function(context, obj) {\n\n    //No context?\n    if (!context) {\n      return;\n    }\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(obj.x);\n    let y = this.board.getAbsY(obj.y);\n    let s = this.board.getCellSize();\n    let r = this.board.theme.get('stone.radius', s);\n\n    //Clear rectangle the size of the stone radius\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\n  };\n});\n","\n/**\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\n * stone color values for the game position class. It has built in validation of coordinates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Grid.Service', [\n  'ngGo',\n  'ngGo.Board.GridChanges.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGrid', function(BoardGridChanges) {\n\n  /**\n   * Helper to convert a value at given coordinates to an object\n   */\n  function toObject(x, y, valueKey) {\n\n    //Create coordinates object\n    let obj = {x, y};\n\n    //Already an object?\n    if (typeof this.grid[x][y] === 'object') {\n      return angular.extend(obj, this.grid[x][y]);\n    }\n\n    //Not an object, set value with given value key and return\n    obj[valueKey] = this.grid[x][y];\n    return obj;\n  }\n\n  /**\n   * Constructor\n   */\n  function BoardGrid(width, height, emptyValue) {\n\n    //Initialize size and grid array\n    this.width = 0;\n    this.height = 0;\n    this.grid = [];\n    this.emptyValue = null;\n\n    //Set empty value if given\n    if (typeof emptyValue !== 'undefined') {\n      this.emptyValue = emptyValue;\n    }\n\n    //Size given? Set it\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  }\n\n  /**\n   * Set a value\n   */\n  BoardGrid.prototype.set = function(x, y, value) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = value;\n    }\n  };\n\n  /**\n   * Unset a value\n   */\n  BoardGrid.prototype.unset = function(x, y) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = this.emptyValue;\n    }\n  };\n\n  /**\n   * Check if we have a non null value on the coordinates\n   */\n  BoardGrid.prototype.has = function(x, y) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\n  };\n\n  /**\n   * Check if we have a specific value on the coordinates\n   */\n  BoardGrid.prototype.is = function(x, y, value) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\n  };\n\n  /**\n   * Get a value, or an object with coordinates and the value in the given value key\n   */\n  BoardGrid.prototype.get = function(x, y, valueKey) {\n\n    //Validate\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\n      return this.emptyValue;\n    }\n\n    //Return as is?\n    if (!valueKey) {\n      return this.grid[x][y];\n    }\n\n    //Return as object\n    return toObject.call(this, x, y, valueKey);\n  };\n\n  /*****************************************************************************\n   * Mass operations\n   ***/\n\n  /**\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\n   * and the value in the given value key will be returned.\n   */\n  BoardGrid.prototype.all = function(valueKey) {\n\n    //Just get the grid?\n    if (!valueKey) {\n      return this.grid;\n    }\n\n    //Initialize objects list\n    let objects = [];\n\n    //Loop coordinates\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          objects.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return objects list\n    return objects;\n  };\n\n  /**\n   * Check if there is anything\n   */\n  BoardGrid.prototype.isEmpty = function() {\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Populate the whole grid with a given value\n   */\n  BoardGrid.prototype.populate = function(value) {\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        this.grid[x][y] = value;\n      }\n    }\n  };\n\n  /**\n   * Empty the grid\n   */\n  BoardGrid.prototype.empty = function() {\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Clone ourselves\n   */\n  BoardGrid.prototype.clone = function() {\n\n    //Create new instance\n    let newGrid = new BoardGrid();\n\n    //Manually set vars for maximum efficiency\n    newGrid.grid = angular.copy(this.grid);\n    newGrid.emptyValue = this.emptyValue;\n    newGrid.width = this.width;\n    newGrid.height = this.height;\n\n    //Return\n    return newGrid;\n  };\n\n  /*****************************************************************************\n   * Comparison\n   ***/\n\n  /**\n   * Checks if a given grid is the same as the current grid\n   */\n  BoardGrid.prototype.isSameAs = function(grid) {\n\n    //Must have the same size\n    if (this.width !== grid.width || this.height !== grid.height) {\n      return false;\n    }\n\n    //Loop all coordinates\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== grid[x][y]) {\n          return false;\n        }\n      }\n    }\n\n    //No differences found\n    return true;\n  };\n\n  /**\n   * Compares this position with another position and return change object\n   */\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\n\n    //Initialize board grid changes object\n    let changes = new BoardGridChanges();\n\n    //Must have the same size\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\n      throw new Error('Trying to compare grids of a different size');\n    }\n\n    //Loop all coordinates\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n\n        //Something to add?\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\n        }\n\n        //Something to remove?\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.remove.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return changes grid\n    return changes;\n  };\n\n  /*****************************************************************************\n   * Helpers\n   ***/\n\n  /**\n   * Helper to validate coordinates (first param can be an object)\n   */\n  BoardGrid.prototype.isOnGrid = function(x, y) {\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\n  };\n\n  /**\n   * Helper to set the empty value\n   */\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\n    this.emptyValue = emptyValue;\n  };\n\n  /**\n   * Set the grid size\n   */\n  BoardGrid.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Create grid array\n    this.grid = [];\n    for (let x = 0; x < this.width; x++) {\n      this.grid[x] = [];\n      for (let y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Get the grid size object\n   */\n  BoardGrid.prototype.getSize = function() {\n    return {width: this.width, height: this.height};\n  };\n\n  //Return\n  return BoardGrid;\n});\n","\n/**\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\n * grids. It simply keeps track of what was added and what was removed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.GridChanges.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGridChanges', function() {\n\n  /**\n   * Helper to subtract sets\n   */\n  function setSubtract(a, b) {\n    let n = [];\n    let q;\n    for (let i = 0; i < a.length; i++) {\n      q = true;\n      for (let j in b) {\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\n          q = false;\n          break;\n        }\n      }\n      if (q) {\n        n.push(a[i]);\n      }\n    }\n    return n;\n  }\n\n  /**\n   * Grid changes constructor\n   */\n  return function() {\n\n    /**\n     * Containers\n     */\n    this.add = [];\n    this.remove = [];\n\n    /**\n     * Concatenation helper\n     */\n    this.concat = function(newChanges) {\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\n    };\n\n    /**\n     * Check if there are changes\n     */\n    this.has = function() {\n      return !!(this.add.length || this.remove.length);\n    };\n  };\n});\n","\n/**\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\n * for drawing itself as well as its objects onto the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('BoardLayer', function(BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  function BoardLayer(board, context) {\n\n    //Remember board reference and 2d canvas context\n    this.board = board;\n    this.context = context;\n\n    //Initialize grid for board objects\n    this.grid = new BoardGrid();\n  }\n\n  /*****************************************************************************\n   * Generic grid and object handling\n   ***/\n\n  /**\n   * Set grid size\n   */\n  BoardLayer.prototype.setSize = function(width, height) {\n\n    //Note: since this method is usually only called upon a global board resize,\n    //which also triggers the redraw method for layers, the layer is not cleared\n    //here, as it will happen anyway during the redraw cycle.\n\n    //Set it in the grid (removing all objects in the process)\n    this.grid.setSize(width, height);\n  };\n\n  /**\n   * Get all items\n   */\n  BoardLayer.prototype.getAll = function() {\n    return this.grid.clone();\n  };\n\n  /**\n   * Set all items at once\n   */\n  BoardLayer.prototype.setAll = function(grid) {\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  BoardLayer.prototype.removeAll = function() {\n    this.clear();\n    this.grid.empty();\n  };\n\n  /**\n   * Add a single item\n   */\n  BoardLayer.prototype.add = function(x, y, value) {\n    this.clearCell(x, y);\n    this.grid.set(x, y, value);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Remove a single item\n   */\n  BoardLayer.prototype.remove = function(x, y) {\n    this.clearCell(x, y);\n    this.grid.unset(x, y);\n  };\n\n  /**\n   * Get an item\n   */\n  BoardLayer.prototype.get = function(x, y) {\n    return this.grid.get(x, y);\n  };\n\n  /**\n   * Check if there is an item\n   */\n  BoardLayer.prototype.has = function(x, y) {\n    return this.grid.has(x, y);\n  };\n\n  /*****************************************************************************\n   * Generic drawing methods\n   ***/\n\n  /**\n   * Draw layer\n   */\n  BoardLayer.prototype.draw = function() {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\n   */\n  BoardLayer.prototype.clear = function() {\n    if (this.context) {\n      this.context.clearRect(\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\n      );\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  BoardLayer.prototype.redraw = function() {\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear cell\n   */\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\n    //Clearing method to be implemented in specific layer class\n  };\n\n  /**\n   * Redraw cell\n   */\n  BoardLayer.prototype.redrawCell = function(x, y) {\n    this.clearCell(x, y);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Set the canvas2d context\n   */\n  BoardLayer.prototype.setContext = function(context) {\n    this.context = context;\n  };\n\n  /**\n   * Get the canvas2d context\n   */\n  BoardLayer.prototype.getContext = function() {\n    return this.context;\n  };\n\n  //Return\n  return BoardLayer;\n});\n","\n/**\n * BoardObject :: Base class for drawing board objects\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Service', [\n  'ngGo',\n  'ngGo.Board.DefaultClearHandler.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('BoardObject', function(DefaultClearHandler) {\n\n  /**\n   * Constructor\n   */\n  let BoardObject = {\n\n    /**\n     * Draw method\n     */\n    draw: function(/*obj*/) {\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n    },\n\n    /**\n     * Clear method\n     */\n    clear: function(obj) {\n      DefaultClearHandler.call(this, this.context, obj);\n    },\n  };\n\n  //Return\n  return BoardObject;\n});\n","\n/**\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.ShellPattern.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('ShellPattern', function() {\n\n  /**\n   * Helper to draw a shell line\n   */\n  function shellLine(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\n\n    //Initialize\n    ctx.shadowBlur = 2;\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = (radius / 30) * this.thickness;\n    ctx.beginPath();\n\n    //Lower radius\n    radius -= Math.max(1, ctx.lineWidth);\n\n    //Determine coordinates\n    let x1 = x + radius * Math.cos(startAngle * Math.PI);\n    let y1 = y + radius * Math.sin(startAngle * Math.PI);\n    let x2 = x + radius * Math.cos(endAngle * Math.PI);\n    let y2 = y + radius * Math.sin(endAngle * Math.PI);\n\n    //Math magic\n    let m, angle;\n    if (x2 > x1) {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m);\n    }\n    else if (x2 === x1) {\n      angle = Math.PI / 2;\n    }\n    else {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m) - Math.PI;\n    }\n\n    //Curvature factor\n    let c = this.factor * radius;\n    let dx = Math.sin(angle) * c;\n    let dy = Math.cos(angle) * c;\n\n    //Curvature coordinates\n    let bx1 = x1 + dx;\n    let by1 = y1 - dy;\n    let bx2 = x2 + dx;\n    let by2 = y2 - dy;\n\n    //Draw shell stroke\n    ctx.moveTo(x1, y1);\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\n    ctx.stroke();\n  }\n\n  /**\n   * Shell pattern drawer\n   */\n  return function(ctx, x, y, radius, angle, strokeStyle) {\n\n    //Initialize start and end angle\n    let startAngle = angle;\n    let endAngle = angle;\n\n    //Loop lines\n    for (let i = 0; i < this.lines.length; i++) {\n      startAngle += this.lines[i];\n      endAngle -= this.lines[i];\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\n    }\n  };\n});\n","\n/**\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\n * use static values or dynamic values depending on other properties, like the grid cell size.\n * Using the provider, the theme can be configured globally at application launch.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Theme.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.provider('BoardTheme', function(StoneColor, MarkupTypes) {\n\n  /**\n   * Default theme\n   */\n  let defaultTheme = {\n\n    //Board\n    board: {\n\n      //Board margin factor\n      margin: 0.25,\n    },\n\n    //Stones\n    stone: {\n\n      //Stone style can be shell, glass, mono, or specify a custom handler service\n      style: 'shell',\n      shadow: true,\n      radius: function(cellSize) {\n        return Math.floor(cellSize / 2);\n      },\n\n      //Shell stones\n      shell: {\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#111';\n          }\n          return '#BFBFBA';\n        },\n        stroke: 'rgba(128,128,128,0.15)',\n        types: [\n          {\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\n            factor: 0.15,\n            thickness: 1.75,\n          },\n          {\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\n            factor: 0.1,\n            thickness: 1.5,\n          },\n          {\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\n            factor: 0.05,\n            thickness: 1.75,\n          },\n          {\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\n            factor: 0.1,\n            thickness: 2,\n          },\n        ],\n      },\n\n      //Mono stones\n      mono: {\n        lineWidth: 1,\n        lineColor: function() {\n          return '#000';\n        },\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#000';\n          }\n          return '#fff';\n        },\n      },\n\n      //Mini stones\n      mini: {\n        scale: 0.5,\n        alpha: 1,\n      },\n\n      //Faded stones\n      faded: {\n        scale: 1,\n        alpha: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return 0.3;\n          }\n          return 0.4;\n        },\n      },\n    },\n\n    //Shadows\n    shadow: {\n\n      //Shadow gradient colors\n      color: 'rgba(40,30,20,0.5)',\n\n      //Shadow size\n      size: function(cellSize) {\n        return Math.floor(cellSize / 20);\n      },\n\n      //Shadow blur size\n      blur: function(cellSize) {\n        return cellSize / 20;\n      },\n\n      //Shadow offset\n      offsetX: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      },\n      offsetY: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      },\n    },\n\n    //Markup\n    markup: {\n\n      //Standard color\n      color: function(stoneColor) {\n        if (stoneColor === StoneColor.B) {\n          return 'rgba(255,255,255,0.9)';\n        }\n        return 'rgba(0,0,0,0.9)';\n      },\n\n      //Line width\n      lineWidth: function(cellSize) {\n        return Math.max(1, Math.floor(cellSize / 16));\n      },\n\n      //Triangle\n      triangle: {\n        scale: 0.85,\n      },\n\n      //Square\n      square: {\n        scale: 0.85,\n      },\n\n      //Cricle\n      circle: {\n        scale: 0.55,\n      },\n\n      //Mark\n      mark: {\n        lineCap: 'square',\n        scale: 0.75,\n      },\n\n      //Last\n      last: {\n        scale: 0.7,\n      },\n\n      //Smiley\n      smiley: {\n        lineCap: 'round',\n        scale: 0.85,\n      },\n\n      //Label\n      label: {\n        font: 'Arial',\n      },\n\n      //Variation markup\n      variation: {\n        type: MarkupTypes.LABEL,\n        text: function(i) {\n          return String.fromCharCode(65 + i);\n        },\n        color: 'rgba(86,114,30,0.9)',\n      },\n\n      //Solution paths markup\n      solution: {\n        valid: {\n          type: MarkupTypes.SELECT,\n          text: null,\n          color: 'rgba(86,114,30,1)',\n          scale: 0.5,\n        },\n        invalid: {\n          type: MarkupTypes.MARK,\n          text: null,\n          color: 'rgba(237,9,15,1)',\n          scale: 0.3,\n        },\n      },\n    },\n\n    //Grid\n    grid: {\n\n      //Line properties\n      lineColor: 'rgba(60,40,15,1)',\n      lineWidth: function(cellSize) {\n        if (cellSize > 60) {\n          return 2;\n        }\n        else if (cellSize > 50) {\n          return 1.5;\n        }\n        return 1;\n      },\n      lineCap: 'square',\n\n      //Star points\n      star: {\n\n        //Color and radius\n        color: 'rgba(60,40,15,1)',\n        radius: function(cellSize) {\n          if (cellSize > 50) {\n            return Math.floor((cellSize / 16) + 1);\n          }\n          else if (cellSize > 30) {\n            return 3;\n          }\n          else if (cellSize > 15) {\n            return 2;\n          }\n          else if (cellSize > 5) {\n            return 1.5;\n          }\n          return 1;\n        },\n\n        //Locations\n        points: function(width, height) {\n\n          //19x19\n          if (width === height && width === 19) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15, y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15, y: 9 },\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15, y: 15 },\n            ];\n          }\n\n          //13x13\n          if (width === height && width === 13) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 },\n            ];\n          }\n\n          //9x9\n          if (width === height && width === 9) {\n            return [\n              { x: 4, y: 4}, { x: 2, y: 2},\n              { x: 2, y: 6}, { x: 6, y: 2},\n              { x: 6, y: 6},\n            ];\n          }\n\n          //No star points\n          return [];\n        },\n      },\n    },\n\n    //Coordinates\n    coordinates: {\n\n      //Color\n      color: 'rgba(101,69,37,0.5)',\n\n      //Board margin factor when showing coordinates\n      margin: 1.25,\n\n      //Vertical coordinates style\n      vertical: {\n        font: 'Arial',\n        style: 'numbers',\n        inverse: true,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        },\n      },\n\n      //Horizontal coordinates style\n      horizontal: {\n        font: 'Arial',\n        style: 'letters',\n        inverse: false,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        },\n      },\n    },\n  };\n\n  /**\n   * Set global default theme\n   */\n  this.setTheme = function(theme) {\n    if (theme) {\n      defaultTheme = angular.merge(defaultTheme, theme);\n    }\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function() {\n\n    /**\n     * Board theme constructor\n     */\n    function BoardTheme(theme) {\n\n      //Remember the given instance theme settings and (re)set the theme\n      this.instanceTheme = theme;\n      this.reset();\n    }\n\n    /**\n     * Reset the theme to defaults\n     */\n    BoardTheme.prototype.reset = function() {\n\n      //Use default theme as a base\n      this.theme = angular.copy(defaultTheme);\n\n      //Add any instance theme properties\n      if (this.instanceTheme) {\n        angular.merge(this.theme, this.instanceTheme);\n      }\n    };\n\n    /**\n     * Get a theme property\n     */\n    BoardTheme.prototype.get = function(property) {\n\n      //Determine path to the property\n      let path = property.split('.');\n      let prop = this.theme;\n\n      //Loop path\n      for (let i = 0; i < path.length; i++) {\n\n        //Can't find the property?\n        if (typeof prop[path[i]] === 'undefined') {\n          throw new Error('Could not find theme property ' + property);\n        }\n\n        //Advance further in the object\n        prop = prop[path[i]];\n      }\n\n      //Found what we're looking for\n      if (typeof prop !== 'function') {\n        return prop;\n      }\n\n      //Prepare arguments\n      let args = [];\n      if (arguments.length > 1) {\n        for (let a = 1; a < arguments.length; a++) {\n          args.push(arguments[a]);\n        }\n      }\n\n      //Call function\n      return prop.apply(this, args);\n    };\n\n    /**\n     * Change a theme property dynamically (accepts handler function as value)\n     */\n    BoardTheme.prototype.set = function(property, value) {\n\n      //Determine path to the property\n      let path = property.split('.');\n      let prop = this.theme;\n\n      //Loop path\n      for (let i = 0; i < path.length; i++) {\n\n        //Time to set?\n        if ((i + 1) === path.length) {\n          prop[path[i]] = value;\n          break;\n        }\n\n        //Not set?\n        if (typeof prop[path[i]] === 'undefined') {\n          prop[path[i]] = {};\n        }\n\n        //Move on\n        prop = prop[path[i]];\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\n     */\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\n\n      //If no linewidth specified, use the grid line width as a reference\n      //to make sure stuff is aligned to the grid\n      if (typeof lineWidth === 'undefined') {\n        lineWidth = this.get('grid.lineWidth');\n      }\n\n      //Return a translation for uneven widths\n      return (lineWidth % 2) * 0.5;\n    };\n\n    //Return\n    return BoardTheme;\n  };\n});\n","\n/**\n * InvalidDataError :: Error class to handle invalid data.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidDataError.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidDataError', function(ngGo) {\n\n  /**\n   * Define error\n   */\n  function InvalidDataError(code) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidDataError';\n    this.message = 'Invalid data: ';\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.NO_DATA:\n        this.message += 'no data to process.';\n        break;\n      case ngGo.error.UNKNOWN_DATA:\n        this.message += 'unknown data format.';\n        break;\n      case ngGo.error.INVALID_GIB:\n        this.message += 'unable to parse GIB data.';\n        break;\n      case ngGo.error.INVALID_SGF:\n        this.message += 'unable to parse SGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_JSON:\n        this.message += 'unable to parse JGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_TREE_JSON:\n        this.message += 'unable to parse the JGF tree data.';\n        break;\n      default:\n        this.message += 'unable to parse the data.';\n    }\n  }\n\n  /**\n   * Extend from error class\n   */\n  InvalidDataError.prototype = new Error();\n  InvalidDataError.prototype.constructor = InvalidDataError;\n\n  //Return object\n  return InvalidDataError;\n});\n","\n/**\n * InvalidPositionError :: Error class to handle invalid moves.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidPositionError', function(ngGo, StoneColor) {\n\n  /**\n   * Define error\n   */\n  function InvalidPositionError(code, x, y, color) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidPositionError';\n    this.message = 'Invalid position detected.';\n\n    //Add position data\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\n        ' stone on (' + x + ', ' + y + ')';\n    }\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\n        this.message += ', but these coordinates are not on the board.';\n        break;\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\n        this.message += ', but there is already a stone on those coordinates.';\n        break;\n      case ngGo.error.POSTITION_IS_SUICIDE:\n        this.message += ', but that would be suicide.';\n        break;\n      case ngGo.error.POSTITION_IS_REPEATING:\n        this.message += ', but this position already occured.';\n        break;\n      default:\n        this.message += '.';\n    }\n  }\n\n  /**\n   * Extend from error class\n   */\n  InvalidPositionError.prototype = new Error();\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\n\n  //Return object\n  return InvalidPositionError;\n});\n","\n/**\n * Game :: This class represents a game record or a game that is being played/edited. The class\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\n * The class also keeps a stack of all board positions in memory and can validate moves to make\n * sure they are not repeating or suicide.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Service', [\n  'ngGo',\n  'ngGo.Game.Path.Service',\n  'ngGo.Game.Node.Service',\n  'ngGo.Game.Position.Service',\n  'ngGo.Kifu.Blank.Service',\n  'ngGo.Kifu.Parser.Service',\n  'ngGo.Errors.InvalidDataError.Service',\n  'ngGo.Errors.InvalidPositionError.Service',\n])\n\n/**\n * Factory definition\n */\n.provider('Game', function() {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n    //Default size of board\n    defaultSize: 0,\n\n    //Default komi and handicap\n    defaultKomi: 0,\n    defaultHandicap: 0,\n\n    //Remember last selected variation when traversing nodes\n    rememberPath: true,\n\n    //Check for repeating positions? (KO / ALL / empty)\n    checkRepeat: 'KO',\n\n    //Allow suicide?\n    allowSuicide: false,\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function(\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\n    KifuBlank, InvalidDataError, InvalidPositionError\n  ) {\n\n    /*****************************************************************************\n     * General helpers\n     ***/\n\n    /**\n     * Validate the info we have to make sure the properties exist\n     */\n    function validateInfo() {\n\n      //Set board info if not set\n      if (!this.info.board) {\n        this.info.board = {};\n      }\n\n      //Set game info if not set\n      if (!this.info.game) {\n        this.info.game = {};\n      }\n\n      //Set defaults\n      if (typeof this.info.board.width === 'undefined') {\n        this.info.board.width = this.config.defaultSize;\n      }\n      if (typeof this.info.board.height === 'undefined') {\n        this.info.board.height = this.config.defaultSize;\n      }\n      if (typeof this.info.game.komi === 'undefined') {\n        this.info.game.komi = this.config.defaultKomi;\n      }\n      if (typeof this.info.game.handicap === 'undefined') {\n        this.info.game.handicap = this.config.defaultHandicap;\n      }\n    }\n\n    /*****************************************************************************\n     * Node navigation helpers\n     ***/\n\n    /**\n     * Navigate to the next node\n     */\n    function nextNode(i) {\n\n      //Check if we have children\n      if (this.node.children.length === 0) {\n        return false;\n      }\n\n      //Remembered the path we took earlier?\n      if (i === undefined) {\n        i = this.node.rememberedPath;\n      }\n\n      //Determine which child node to process\n      i = i || 0;\n      if (i === -1) {\n        i = 0;\n      }\n\n      //Validate\n      if (i >= this.node.children.length || !this.node.children[i]) {\n        return false;\n      }\n\n      //Advance path\n      this.path.advance(i);\n\n      //Set pointer of current node\n      this.node = this.node.children[i];\n      return true;\n    }\n\n    /**\n     * Navigate to the previous node\n     */\n    function previousNode() {\n\n      //No parent node?\n      if (!this.node.parent) {\n        return false;\n      }\n\n      //Retreat path\n      this.path.retreat();\n\n      //Set pointer of current node\n      this.node = this.node.parent;\n      return true;\n    }\n\n    /**\n     * Navigate to the first node\n     */\n    function firstNode() {\n\n      //Reset path\n      this.path.reset();\n\n      //Set node pointer back to root\n      this.node = this.root;\n\n      //Set the initial turn depending on handicap\n      //Can be overwritten by game record instructions\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\n    }\n\n    /*****************************************************************************\n     * Position history helpers\n     ***/\n\n    /**\n     * Clear the position history and initialize with a blank position\n     */\n    function initializeHistory() {\n\n      //Already at beginning?\n      if (this.history.length === 1) {\n        return;\n      }\n\n      //Clear positions stack and create new blank position\n      this.history = [];\n      this.history.push(new GamePosition());\n\n      //Set board size if we have the info\n      if (this.info.board) {\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\n      }\n    }\n\n    /**\n     * Add position to stack. If position isn't specified current position is\n     * cloned and stacked. Pointer of actual position is moved to the new position.\n     */\n    function pushPosition(newPosition) {\n\n      //Position not given?\n      if (!newPosition) {\n        newPosition = this.position.clone();\n      }\n\n      //Push\n      this.history.push(newPosition);\n      return newPosition;\n    }\n\n    /**\n     * Remove current position from stack\n     */\n    function popPosition() {\n\n      //Nothing left?\n      if (this.history.length === 0) {\n        return null;\n      }\n\n      //Get old position\n      return this.history.pop();\n    }\n\n    /**\n     * Replace the current position in the stack\n     */\n    function replacePosition(newPosition) {\n      if (newPosition) {\n        this.history.pop();\n        this.history.push(newPosition);\n      }\n    }\n\n    /*****************************************************************************\n     * Execution helpers\n     ***/\n\n    /**\n     * Execute the current node\n     */\n    function executeNode() {\n\n      //Remember last selected node if we have a parent\n      if (this.node.parent) {\n        this.node.parent.rememberedPath = this.node.parent.children.indexOf(this.node);\n      }\n\n      //Initialize new position\n      let i;\n      let newPosition = this.position.clone();\n\n      //Handle moves\n      if (this.node.isMove()) {\n        if (this.node.move.pass) {\n          newPosition.setTurn(-this.node.move.color);\n        }\n        else {\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\n        }\n      }\n\n      //Handle turn instructions\n      if (this.node.turn) {\n        newPosition.setTurn(this.node.turn);\n      }\n\n      //Handle setup instructions\n      if (this.node.setup) {\n        for (i in this.node.setup) {\n          if (this.node.setup.hasOwnProperty(i)) {\n            newPosition.stones.set(\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\n            );\n          }\n        }\n      }\n\n      //Handle markup\n      if (this.node.markup) {\n        for (i in this.node.markup) {\n          if (this.node.markup.hasOwnProperty(i)) {\n            newPosition.markup.set(\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\n            );\n          }\n        }\n      }\n\n      //Push the new position into the history now\n      pushPosition.call(this, newPosition);\n    }\n\n    /*****************************************************************************\n     * Game class\n     ***/\n\n    /**\n     * Constructor\n     */\n    function Game(data, config) {\n\n      //Extend config\n      this.config = angular.extend({}, defaultConfig, config || {});\n\n      //Define property getter/setter for position\n      Object.defineProperty(this, 'position', {\n\n        //Getter returns the last position from the stack\n        get: function() {\n          return this.history[this.history.length - 1];\n        },\n\n        //Setter adds a new position to the stack\n        set: function(newPosition) {\n          this.history[this.history.length] = newPosition;\n        },\n      });\n\n      //Load data\n      if (data) {\n        this.load(data);\n      }\n      else {\n        this.init();\n      }\n    }\n\n    /**\n     * Initialize\n     */\n    Game.prototype.init = function() {\n\n      //Info properties\n      this.info = {};\n\n      //The rood node and pointer to the current node\n      this.root = null;\n      this.node = null;\n\n      //Game path\n      this.path = new GamePath();\n\n      //JGF record we loaded from\n      this.jgf = null;\n\n      //Positions history stack\n      this.history = [];\n    };\n\n    /**\n     * Load game record data\n     */\n    Game.prototype.load = function(data) {\n\n      //Initialize\n      this.init();\n\n      //Try to load game record data\n      try {\n        this.fromData(data);\n      }\n      catch (errorCode) {\n\n        //Just initialize our history with a blank position\n        initializeHistory.call(this);\n\n        //Wrap error code in error object\n        throw new InvalidDataError(errorCode);\n      }\n\n      //Go to the first move\n      this.first();\n    };\n\n    /**\n     * Reload game record\n     */\n    Game.prototype.reload = function() {\n      if (this.jgf) {\n        this.load(this.jgf);\n      }\n    };\n\n    /**\n     * Check if we managed to load a valid game record\n     */\n    Game.prototype.isLoaded = function() {\n      return this.root !== null;\n    };\n\n    /*****************************************************************************\n     * Game cloning and conversion\n     ***/\n\n    /**\n     * Clone this game\n     */\n    Game.prototype.clone = function() {\n\n      //Create new kifu object and get properties\n      let clone = new Game();\n      let props = Object.getOwnPropertyNames(this);\n\n      //Copy all properties\n      for (let p = 0; p < props.length; p++) {\n        clone[p] = angular.copy(this[p]);\n      }\n\n      //Return clone\n      return clone;\n    };\n\n    /**\n     * Load from an unknown data source\n     */\n    Game.prototype.fromData = function(data) {\n\n      //No data, can't do much\n      if (!data) {\n        throw ngGo.error.NO_DATA;\n      }\n\n      //String given, could be stringified JGF, an SGF or GIB file\n      if (typeof data === 'string') {\n        let c = data.charAt(0);\n        if (c === '(') {\n          return this.fromSgf(data);\n        }\n        else if (c === '{' || c === '[') {\n          return this.fromJgf(data);\n        }\n        else if (c === '\\\\') {\n          return this.fromGib(data);\n        }\n        else {\n          throw ngGo.error.UNKNOWN_DATA;\n        }\n      }\n\n      //Object given? Probably a JGF object\n      else if (typeof data === 'object') {\n        this.fromJgf(data);\n      }\n\n      //Something else?\n      else {\n        throw ngGo.error.UNKNOWN_DATA;\n      }\n    };\n\n    /**\n     * Load from GIB data\n     */\n    Game.prototype.fromGib = function(gib) {\n\n      //Use the kifu parser\n      let jgf = KifuParser.gib2jgf(gib);\n      if (!jgf) {\n        throw ngGo.error.INVALID_GIB;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from SGF data\n     */\n    Game.prototype.fromSgf = function(sgf) {\n\n      //Use the kifu parser\n      let jgf = KifuParser.sgf2jgf(sgf);\n      if (!jgf) {\n        throw ngGo.error.INVALID_SGF;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from JGF data\n     */\n    Game.prototype.fromJgf = function(jgf) {\n\n      //Parse jgf string\n      if (typeof jgf === 'string') {\n        try {\n          jgf = angular.fromJson(jgf);\n        }\n        catch (error) {\n          throw ngGo.error.INVALID_JGF_JSON;\n        }\n      }\n\n      //If array given, convert to object with only tree\n      if (angular.isArray(jgf)) {\n        jgf = {\n          tree: jgf,\n        };\n      }\n\n      //Parse tree string\n      if (typeof jgf.tree === 'string') {\n        if (jgf.tree.charAt(0) === '[') {\n          try {\n            jgf.tree = angular.fromJson(jgf.tree);\n          }\n          catch (error) {\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\n          }\n        }\n        else {\n          jgf.tree = [];\n        }\n      }\n\n      //Copy all properties except moves tree\n      for (let i in jgf) {\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\n          this.info[i] = angular.copy(jgf[i]);\n        }\n      }\n\n      //Validate info\n      validateInfo.call(this);\n\n      //Create root node\n      this.root = new GameNode();\n\n      //Tree given? Load all the moves\n      if (jgf.tree) {\n        this.root.fromJgf(jgf.tree);\n      }\n\n      //Remember JGF\n      this.jgf = jgf;\n    };\n\n    /**\n     * Convert to SGF\n     */\n    Game.prototype.toSgf = function() {\n      return KifuParser.jgf2sgf(this.toJgf());\n    };\n\n    /**\n     * Convert to JGF (optionally stringified)\n     */\n    Game.prototype.toJgf = function(stringify) {\n\n      //Initialize JGF and get properties\n      let jgf = KifuBlank.jgf();\n      let props = Object.getOwnPropertyNames(this);\n\n      //Copy properties\n      for (let p = 0; p < props.length; p++) {\n\n        //Skip root\n        if (p === 'root') {\n          continue;\n        }\n\n        //Already present on JGF object? Extend\n        if (jgf[p]) {\n          jgf[p] = angular.extend(jgf[p], this[p]);\n        }\n\n        //Otherwise copy\n        else {\n          jgf[p] = angular.copy(this[p]);\n        }\n      }\n\n      //Build tree\n      jgf.tree = this.root.toJgf();\n\n      //Return\n      return stringify ? angular.toJson(jgf) : jgf;\n    };\n\n    /*****************************************************************************\n     * Getters\n     ***/\n\n    /**\n     * Get current node\n     */\n    Game.prototype.getNode = function() {\n      return this.node;\n    };\n\n    /**\n     * Get nodes array for currently remembered path\n     */\n    Game.prototype.getNodes = function() {\n\n      //Initialize node to process\n      let node = this.root;\n      let nodes = [node];\n\n      //Process children\n      while (node) {\n        node = node.getChild(node.rememberedPath);\n        if (node) {\n          nodes.push(node);\n        }\n      }\n\n      //Return nodes\n      return nodes;\n    };\n\n    /**\n     * Get node for a certain move\n     */\n    Game.prototype.getMoveNode = function(move) {\n      let nodes = this.getMoveNodes(move, move);\n      return nodes.length ? nodes[0] : null;\n    };\n\n    /**\n     * Get move nodes restricted by given move numbers\n     */\n    Game.prototype.getMoveNodes = function(fromMove, toMove) {\n\n      //Get all nodes for the current path\n      let nodes = this.getNodes();\n\n      //Use sensible defaults if no from/to moves given\n      fromMove = fromMove || 1;\n      toMove = toMove || nodes.length;\n\n      //Filter\n      return nodes.filter(function(node) {\n        if (node.isMove()) {\n          let move = node.getMoveNumber();\n          return (move >= fromMove && move <= toMove);\n        }\n        return false;\n      });\n    };\n\n    /**\n     * Get current move number\n     */\n    Game.prototype.getMove = function() {\n      if (this.node) {\n        return this.node.getMoveNumber();\n      }\n      return 0;\n    };\n\n    /**\n     * Get the number of moves in the main branch\n     */\n    Game.prototype.getMoveCount = function() {\n      let moveNodes = this.getMoveNodes();\n      return moveNodes.length;\n    };\n\n    /**\n     * Get the move variation for given coordinates\n     */\n    Game.prototype.getMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.getMoveVariation(x, y);\n      }\n      return -1;\n    };\n\n    /**\n     * Get the current game position\n     */\n    Game.prototype.getPosition = function() {\n      return this.position;\n    };\n\n    /**\n     * Get the game path\n     */\n    Game.prototype.getPath = function(clone) {\n      if (clone) {\n        return this.path.clone();\n      }\n      return this.path;\n    };\n\n    /**\n     * Clone the current game path\n     */\n    Game.prototype.clonePath = function() {\n      return this.path.clone();\n    };\n\n    /**\n     * Get the game path to a certain named node\n     */\n    Game.prototype.getPathToNode = function(nodeName) {\n      return GamePath.findNode(nodeName, this.root);\n    };\n\n    /**\n     * Get the game komi\n     */\n    Game.prototype.getKomi = function() {\n      let komi = this.get('game.komi', 0);\n      return parseFloat(komi);\n    };\n\n    /**\n     * Set the game komi\n     */\n    Game.prototype.setKomi = function(komi) {\n      if (typeof komi === 'undefined') {\n        komi = this.config.defaultKomi;\n      }\n      this.info.game.komi = parseFloat(komi);\n    };\n\n    /**\n     * Get the game name\n     */\n    Game.prototype.getName = function() {\n      return this.get('game.name', '');\n    };\n\n    /**\n     * Get the game result\n     */\n    Game.prototype.getResult = function() {\n      return this.get('game.result', '');\n    };\n\n    /**\n     * Get the player turn for this position\n     */\n    Game.prototype.getTurn = function() {\n\n      //Must have a position\n      if (!this.history.length) {\n        return StoneColor.B;\n      }\n\n      //Get from position\n      return this.position.getTurn();\n    };\n\n    /**\n     * Set the player turn for the current position\n     */\n    Game.prototype.setTurn = function(color) {\n\n      //Must have a position\n      if (!this.history.length) {\n        return;\n      }\n\n      //Set in position\n      this.position.setTurn(color);\n    };\n\n    /**\n     * Get the total capture count up to the current position\n     */\n    Game.prototype.getCaptureCount = function() {\n\n      //Initialize\n      let captures = {};\n      captures[StoneColor.B] = 0;\n      captures[StoneColor.W] = 0;\n\n      //Loop all positions and increment capture count\n      for (let i = 0; i < this.history.length; i++) {\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\n      }\n\n      //Return\n      return captures;\n    };\n\n    /**\n     * Get an info property\n     */\n    Game.prototype.get = function(property, defaultValue) {\n\n      //Must have a property\n      if (!property) {\n        return;\n      }\n\n      //The item's property in the object is given by dot separated strings\n      if (typeof property === 'string') {\n        property = property.split('.');\n      }\n\n      //Initialize object we're getting info from\n      let obj = this.info;\n      let key;\n\n      //Loop the properties\n      for (let p = 0; p < property.length; p++) {\n\n        //Get actual key\n        key = property[p];\n\n        //Last key reached? Done, get value\n        if ((p + 1) === property.length) {\n          if (typeof obj[key] === 'undefined') {\n            return defaultValue;\n          }\n          return obj[key];\n        }\n\n        //Must be object container\n        if (typeof obj[key] !== 'object') {\n          throw new Error('Game info property ' + key + ' is not an object');\n        }\n\n        //Move up in tree\n        obj = obj[key];\n      }\n    };\n\n    /*****************************************************************************\n     * Checkers\n     ***/\n\n    /**\n     * Check if coordinates are on the board\n     */\n    Game.prototype.isOnBoard = function(x, y) {\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\n    };\n\n    /**\n     * Check if given coordinates are one of the next child node coordinates\n     */\n    Game.prototype.isMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.isMoveVariation(x, y);\n      }\n      return false;\n    };\n\n    /**\n     * Check if a given position is repeating within this game\n     */\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\n\n      //Init\n      let stop;\n\n      //Check for ko only? (Last two positions)\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\n        stop = this.history.length - 2;\n      }\n\n      //Check all history?\n      else if (this.checkRepeat === 'ALL') {\n        stop = 0;\n      }\n\n      //Not repeating\n      else {\n        return false;\n      }\n\n      //Loop history of positions to check\n      for (let i = this.history.length - 2; i >= stop; i--) {\n        if (checkPosition.isSameAs(this.history[i])) {\n          return true;\n        }\n      }\n\n      //Not repeating\n      return false;\n    };\n\n    /**\n     * Wrapper for validateMove() returning a boolean and catching any errors\n     */\n    Game.prototype.isValidMove = function(x, y, color) {\n      try {\n        this.validateMove(x, y, color);\n        return true;\n      }\n      catch (error) {\n        return false;\n      }\n    };\n\n    /**\n     * Check if a move is valid. If valid, the new game position object is returned.\n     * You can supply a pre-created position to use, or the current position is cloned.\n     */\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Something already here?\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\n      }\n\n      //Set color of move to make\n      color = color || this.position.getTurn();\n\n      //Determine position to use\n      newPosition = newPosition || this.position.clone();\n\n      //Place the stone\n      newPosition.stones.set(x, y, color);\n\n      //Capture adjacent stones if possible\n      let captures = newPosition.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created?\n        if (!newPosition.hasLiberties(x, y)) {\n\n          //Capture the group if it's allowed\n          if (this.allowSuicide) {\n            newPosition.captureGroup(x, y);\n          }\n\n          //Invalid move\n          else {\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\n          }\n        }\n      }\n\n      //Check history for repeating moves\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\n      }\n\n      //Set proper turn\n      newPosition.setTurn(-color);\n\n      //Move is valid\n      return newPosition;\n    };\n\n    /**\n     * Check if a stone (setup) placement is valid.\n     */\n    Game.prototype.validatePlacement = function(x, y, color, position) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Place the stone\n      position.stones.set(x, y, color);\n\n      //Empty spot? Don't need to check for captures\n      if (color === StoneColor.EMPTY) {\n        return;\n      }\n\n      //Capture adjacent stones if possible\n      let captures = position.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created? Capture it\n        if (!position.hasLiberties(x, y)) {\n          position.captureGroup(x, y);\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Stone and markup handling\n     ***/\n\n    /**\n     * Add a stone\n     */\n    Game.prototype.addStone = function(x, y, color) {\n\n      //Check if there's anything to do at all\n      if (this.position.stones.is(x, y, color)) {\n        return;\n      }\n\n      //Create temporary position\n      let tempPosition = this.position.clone();\n\n      //Validate placement on temp position\n      this.validatePlacement(x, y, color, tempPosition);\n\n      //No setup instructions container in this node?\n      if (typeof this.node.setup === 'undefined') {\n\n        //Is this a move node?\n        if (this.node.isMove()) {\n\n          //Clone our position\n          pushPosition.call(this);\n\n          //Create new node\n          let node = new GameNode();\n\n          //Append it to the current node and change the pointer\n          let i = node.appendTo(this.node);\n          this.node = node;\n\n          //Advance path to the added node index\n          this.path.advance(i);\n        }\n\n        //Create setup container in this node\n        this.node.setup = [];\n      }\n\n      //Replace current position\n      replacePosition.call(this, tempPosition);\n\n      //Add setup instructions to node\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\n    };\n\n    /**\n     * Add markup\n     */\n    Game.prototype.addMarkup = function(x, y, markup) {\n\n      //No markup instructions container in this node?\n      if (typeof this.node.markup === 'undefined') {\n        this.node.markup = [];\n      }\n\n      //Add markup to game position\n      this.position.markup.set(x, y, markup);\n\n      //Add markup instructions to node\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\n    };\n\n    /**\n     * Remove a stone\n     */\n    Game.prototype.removeStone = function(x, y) {\n\n      //Check if the stone is found in setup instructions\n      let foundInSetup = false;\n\n      //Remove from node setup instruction\n      if (typeof this.node.setup !== 'undefined') {\n        for (let i = 0; i < this.node.setup.length; i++) {\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\n\n            //Remove from node and unset in position\n            this.node.setup.splice(i, 1);\n            this.position.stones.unset(x, y);\n\n            //Mark as found\n            foundInSetup = true;\n            break;\n          }\n        }\n      }\n\n      //Not found in setup? Add as no stone color\n      if (!foundInSetup) {\n        this.addStone(x, y, StoneColor.EMPTY);\n      }\n    };\n\n    /**\n     * Remove markup\n     */\n    Game.prototype.removeMarkup = function(x, y) {\n\n      //Remove from node\n      if (typeof this.node.markup !== 'undefined') {\n        for (let i = 0; i < this.node.markup.length; i++) {\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\n            this.node.markup.splice(i, 1);\n            this.position.markup.unset(x, y);\n            break;\n          }\n        }\n      }\n    };\n\n    /**\n     * Check if there is a stone at the given coordinates for the current position\n     */\n    Game.prototype.hasStone = function(x, y, color) {\n      if (typeof color !== 'undefined') {\n        return this.position.stones.is(x, y, color);\n      }\n      return this.position.stones.has(x, y);\n    };\n\n    /**\n     * Check if there is markup at the given coordinate for the current position\n     */\n    Game.prototype.hasMarkup = function(x, y, type) {\n      if (typeof type !== 'undefined') {\n        return this.position.markup.is(x, y, type);\n      }\n      return this.position.markup.has(x, y);\n    };\n\n    /**\n     * Get stone on coordinates\n     */\n    Game.prototype.getStone = function(x, y) {\n      return this.position.stones.get(x, y);\n    };\n\n    /**\n     * Get markup on coordinates\n     */\n    Game.prototype.getMarkup = function(x, y) {\n      return this.position.markup.get(x, y);\n    };\n\n    /*****************************************************************************\n     * Move handling\n     ***/\n\n    /**\n     * Play move\n     */\n    Game.prototype.play = function(x, y, color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Validate move and get new position\n      let newPosition = this.validateMove(x, y, color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      let node = new GameNode({\n        move: {\n          x: x,\n          y: y,\n          color: color,\n        },\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      let i = node.appendTo(this.node);\n      this.node.rememberedPath = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n\n      //Valid move\n      return true;\n    };\n\n    /**\n     * Play pass\n     */\n    Game.prototype.pass = function(color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Initialize new position and switch the turn\n      let newPosition = this.position.clone();\n      newPosition.setTurn(-color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      let node = new GameNode({\n        move: {\n          pass: true,\n          color: color,\n        },\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      let i = node.appendTo(this.node);\n      this.node.rememberedPath = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n    };\n\n    /*****************************************************************************\n     * Game tree navigation\n     ***/\n\n    /**\n     * Go to the next position\n     */\n    Game.prototype.next = function(i) {\n\n      //Object (node) given as parameter? Find index\n      if (typeof i === 'object') {\n        i = this.node.children.indexOf(i);\n      }\n\n      //Go to the next node\n      if (nextNode.call(this, i)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n          return true;\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n\n      //Didn't go to next position\n      return false;\n    };\n\n    /**\n     * Go to the previous position\n     */\n    Game.prototype.previous = function() {\n\n      //Go to the previous node\n      if (previousNode.call(this)) {\n        popPosition.call(this);\n        return true;\n      }\n\n      //Didn't go to previous position\n      return false;\n    };\n\n    /**\n     * Go to the last position\n     */\n    Game.prototype.last = function() {\n\n      //Keep going to the next node until we reach the end\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the first position\n     */\n    Game.prototype.first = function() {\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      executeNode.call(this);\n    };\n\n    /**\n     * Go to position specified by a path object, a numeric move numer, or a node name string\n     */\n    Game.prototype.goto = function(target) {\n\n      //Must have a tree\n      if (this.root === null) {\n        return;\n      }\n\n      //Nothing given?\n      if (typeof target === 'undefined') {\n        return;\n      }\n\n      //Function given? Call now\n      if (typeof target === 'function') {\n        target = target.call(this);\n      }\n\n      //Initialize path\n      let path;\n\n      //Simple move number? Convert to path object\n      if (typeof target === 'number') {\n        path = this.path.clone();\n        path.setMove(target);\n      }\n\n      //String? Named node\n      else if (typeof target === 'string') {\n\n        //Already here?\n        if (this.node.name === target) {\n          return;\n        }\n\n        //Find path to node\n        path = this.getPathToNode(target);\n        if (path === null) {\n          return;\n        }\n      }\n\n      //Otherwise assume path object\n      else {\n        path = target;\n      }\n\n      //Already here?\n      if (this.path.compare(path)) {\n        return;\n      }\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      pushPosition.call(this);\n      executeNode.call(this);\n\n      //Loop path\n      let n = path.getMove();\n      for (let i = 0; i < n; i++) {\n\n        //Try going to the next node\n        if (!nextNode.call(this, path.nodeAt(i))) {\n          break;\n        }\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the next fork\n     */\n    Game.prototype.nextFork = function() {\n\n      //Keep going to the next node until we reach one with multiple children\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Have multiple children?\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous fork\n     */\n    Game.prototype.previousFork = function() {\n\n      //Loop until we find a node with more than one child\n      while (previousNode.call(this)) {\n        popPosition.call(this);\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the next move with comments\n     */\n    Game.prototype.nextComment = function() {\n\n      //Keep going to the next node until we find one with comments\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous move with comments\n     */\n    Game.prototype.previousComment = function() {\n\n      //Go back until we find a node with comments\n      while (previousNode.call(this)) {\n\n        //Pop the position\n        popPosition.call(this);\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state\n     */\n    Game.prototype.getState = function() {\n\n      //Can only create when we have a JGF and path\n      if (!this.jgf || !this.path) {\n        return null;\n      }\n\n      //Create state\n      let state = {\n        jgf: this.jgf,\n        path: this.path.clone(),\n      };\n\n      //Return\n      return state;\n    };\n\n    /**\n     * Restore the game state\n     */\n    Game.prototype.restoreState = function(state) {\n\n      //Must have jgf and path\n      if (!state || !state.jgf || !state.path) {\n        return;\n      }\n\n      //Restore state\n      this.load(state.jgf);\n      this.goto(state.path);\n    };\n\n    //Return object\n    return Game;\n  };\n});\n","\n/**\n * GameNode :: This class represents a single node in the game moves tree. It contains\n * properties like the x and y grid coordinates, the move played, board setup instructions,\n * markup, player turn and comments. The moves tree in the game record is represented by a\n * string of GameNodes, each with pointers to their parent and children. Each node can have\n * multiple children (move variations), but only one parent.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Node.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('GameNode', function(StoneColor) {\n\n  /**\n   * Character index of \"a\"\n   */\n  let aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  function convertCoordinates(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  }\n\n  /**\n   * Helper to construct a coordinates base object\n   */\n  function coordinatesObject(coords, baseObject) {\n    baseObject = baseObject || {};\n    if (coords === '' || coords === 'pass') {\n      baseObject.pass = true;\n    }\n    else {\n\n      //Backwards compatibility with SGF string coordinates in JGF\n      if (typeof coords === 'string') {\n        coords = convertCoordinates(coords);\n      }\n\n      //Append coordinates\n      baseObject.x = Number(coords[0]);\n      baseObject.y = Number(coords[1]);\n    }\n    return baseObject;\n  }\n\n  /**\n   * Convert a numeric color value (color constant) to a string\n   */\n  function toStringColor(color) {\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\n  }\n\n  /**\n   * Convert a string color value to a numeric color constant\n   */\n  function toColorConstant(color) {\n    if (color === 'B') {\n      return StoneColor.B;\n    }\n    else if (color === 'W') {\n      return StoneColor.W;\n    }\n    return StoneColor.E;\n  }\n\n  /*****************************************************************************\n   * Helpers for conversion between JGF / KIFU format\n   ***/\n\n  /**\n   * Convert move object to JGF format\n   */\n  function convertMoveToJgf(move) {\n\n    //Initialize JGF move object and determine color\n    let jgfMove = angular.copy(move);\n    let color = toStringColor(move.color);\n\n    //No color?\n    if (color === '') {\n      return null;\n    }\n\n    //Pass move?\n    if (move.pass === true) {\n      jgfMove[color] = 'pass';\n    }\n\n    //Regular move\n    else {\n      jgfMove[color] = [move.x, move.y];\n    }\n\n    //Delete coordinates and color\n    delete jgfMove.x;\n    delete jgfMove.y;\n    delete jgfMove.color;\n\n    //Return move\n    return jgfMove;\n  }\n\n  /**\n   * Convert move from JGF format\n   */\n  function convertMoveFromJgf(move) {\n\n    //Prepare color, coordinates\n    let color, coords;\n\n    //Check whose move it was\n    if (move.W) {\n      color = 'W';\n      coords = move.W;\n    }\n    else if (move.B) {\n      color = 'B';\n      coords = move.B;\n    }\n\n    //No coordinates?\n    if (!coords) {\n      return null;\n    }\n\n    //Return coordinates object\n    return coordinatesObject(coords, {\n      color: toColorConstant(color),\n    });\n  }\n\n  /**\n   * Convert setup object to JGF format\n   */\n  function convertSetupToJgf(setup) {\n\n    //Initialize variables\n    let i, color;\n    let jgfSetup = {};\n\n    //Loop setup objects\n    for (i in setup) {\n      if (setup.hasOwnProperty(i)) {\n\n        //Get color\n        color = toStringColor(setup[i].color) || 'E';\n\n        //Initialize array\n        if (typeof jgfSetup[color] === 'undefined') {\n          jgfSetup[color] = [];\n        }\n\n        //Add coordinates\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\n      }\n    }\n\n    //Return\n    return jgfSetup;\n  }\n\n  /**\n   * Convert setup from JGF format\n   */\n  function convertSetupFromJgf(setup) {\n\n    //Initialize variables\n    let c, key, color;\n    let gameSetup = [];\n\n    //Loop setup\n    for (key in setup) {\n      if (setup.hasOwnProperty(key)) {\n\n        //Get color constant\n        color = toColorConstant(key);\n\n        //Loop coordinates\n        for (c in setup[key]) {\n          if (setup[key].hasOwnProperty(c)) {\n            gameSetup.push(coordinatesObject(setup[key][c], {\n              color: color,\n            }));\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameSetup;\n  }\n\n  /**\n   * Convert markup object to JGF format\n   */\n  function convertMarkupToJgf(markup) {\n\n    //Initialize variables\n    let i, type;\n    let jgfMarkup = {};\n\n    //Loop setup objects\n    for (i in markup) {\n      if (markup.hasOwnProperty(i)) {\n\n        //Get type\n        type = markup[i].type;\n\n        //Initialize array\n        if (typeof jgfMarkup[type] === 'undefined') {\n          jgfMarkup[type] = [];\n        }\n\n        //Label?\n        if (type === 'label') {\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\n        }\n        else {\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\n        }\n      }\n    }\n\n    //Return\n    return jgfMarkup;\n  }\n\n  /**\n   * Convert markup from JGF format\n   */\n  function convertMarkupFromJgf(markup) {\n\n    //Initialize variables\n    let l, type;\n    let gameMarkup = [];\n\n    //Loop markup types\n    for (type in markup) {\n      if (markup.hasOwnProperty(type)) {\n\n        //Label?\n        if (type === 'label') {\n          for (l = 0; l < markup[type].length; l++) {\n\n            //Validate\n            if (!angular.isArray(markup[type][l])) {\n              continue;\n            }\n\n            //SGF type coordinates?\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\n              let text = markup[type][l][1];\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\n              markup[type][l].push(text);\n            }\n\n            //Validate length\n            if (markup[type][l].length < 3) {\n              continue;\n            }\n\n            //Add to stack\n            gameMarkup.push(coordinatesObject(markup[type][l], {\n              type: type,\n              text: markup[type][l][2],\n            }));\n          }\n        }\n        else {\n\n          //Loop coordinates\n          for (l in markup[type]) {\n            if (markup[type].hasOwnProperty(l)) {\n              gameMarkup.push(coordinatesObject(markup[type][l], {\n                type: type,\n              }));\n            }\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameMarkup;\n  }\n\n  /**\n   * Convert turn object to JGF format\n   */\n  function convertTurnToJgf(turn) {\n    switch (turn) {\n      case StoneColor.W:\n        return 'W';\n      case StoneColor.B:\n        return 'B';\n      default:\n        return '';\n    }\n  }\n\n  /**\n   * Convert turn from JGF format\n   */\n  function convertTurnFromJgf(turn) {\n    switch (turn) {\n      case 'W':\n        return StoneColor.W;\n      case 'B':\n        return StoneColor.B;\n      default:\n        return StoneColor.EMPTY;\n    }\n  }\n\n  /**\n   * Conversions map\n   */\n  let conversionMap = {\n    toJgf: {\n      move: convertMoveToJgf,\n      setup: convertSetupToJgf,\n      markup: convertMarkupToJgf,\n      turn: convertTurnToJgf,\n    },\n    fromJgf: {\n      move: convertMoveFromJgf,\n      setup: convertSetupFromJgf,\n      markup: convertMarkupFromJgf,\n      turn: convertTurnFromJgf,\n    },\n  };\n\n  /**\n   * Constructor\n   */\n  function GameNode(properties, parent) {\n\n    //Set parent and children\n    this.parent = parent || null;\n    this.children = [];\n\n    //Save properties\n    if (properties) {\n      for (let key in properties) {\n        if (properties.hasOwnProperty(key)) {\n          this[key] = properties[key];\n        }\n      }\n    }\n  }\n\n  /**\n   * Get node's child specified by index or null if doesn't exist\n   */\n  GameNode.prototype.getChild = function(i) {\n    i = i || 0;\n    if (this.children[i]) {\n      return this.children[i];\n    }\n    return null;\n  };\n\n  /**\n   * Get all the children\n   */\n  GameNode.prototype.getChildren = function() {\n    return this.children;\n  };\n\n  /**\n   * Check if the node has any chilren\n   */\n  GameNode.prototype.hasChildren = function() {\n    return (this.children.length > 0);\n  };\n\n  /**\n   * Get parent node\n   */\n  GameNode.prototype.getParent = function() {\n    return this.parent;\n  };\n\n  /**\n   * Check if the node has more than one move variation\n   */\n  GameNode.prototype.hasMoveVariations = function() {\n\n    //Less than two child nodes?\n    if (this.children.length <= 1) {\n      return false;\n    }\n\n    //Loop children\n    let moveVariations = 0;\n    for (let i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].isMove()) {\n        moveVariations++;\n      }\n\n      //More than one move node present?\n      if (moveVariations > 1) {\n        return true;\n      }\n    }\n\n    //No move variations\n    return false;\n  };\n\n  /**\n   * Get all the move variation nodes\n   */\n  GameNode.prototype.getMoveVariations = function() {\n\n    //No child nodes?\n    if (this.children.length === 0) {\n      return false;\n    }\n\n    //Initialize\n    let moveVariations = [];\n\n    //Loop child nodes\n    for (let i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].isMove()) {\n        moveVariations.push(this.children[i]);\n      }\n    }\n\n    //Return\n    return moveVariations;\n  };\n\n  /**\n   * Get the move variation for given coordinates\n   */\n  GameNode.prototype.getMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (let i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return i;\n      }\n    }\n\n    //Not found\n    return -1;\n  };\n\n  /**\n   * Check if given coordinates are one of the next child node coordinates\n   */\n  GameNode.prototype.isMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (let i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return true;\n      }\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Check if we have comments\n   */\n  GameNode.prototype.hasComments = function() {\n    return (this.comments && this.comments.length > 0);\n  };\n\n  /**\n   * Check if this is a move node\n   */\n  GameNode.prototype.isMove = function() {\n    return !!this.move;\n  };\n\n  /**\n   * Get move number\n   */\n  GameNode.prototype.getMoveNumber = function() {\n\n    //Move node?\n    if (this.isMove()) {\n      if (this.parent) {\n        return this.parent.getMoveNumber() + 1;\n      }\n      return 1;\n    }\n\n    //Use parent move number if we have one\n    if (this.parent) {\n      return this.parent.getMoveNumber();\n    }\n\n    //No parent\n    return 0;\n  };\n\n  /*****************************************************************************\n   * Node manipulation\n   ***/\n\n  /**\n   * Remove this node from its parent\n   */\n  GameNode.prototype.remove = function() {\n\n    //Can't remove if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found remove it\n    let i = this.parent.children.indexOf(this);\n    if (i !== -1) {\n      this.parent.children.splice(i, 1);\n    }\n\n    //Clear parent reference\n    this.parent = null;\n  };\n\n  /**\n   * Move the node up in the parent's child tree\n   */\n  GameNode.prototype.moveUp = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    let i = this.parent.children.indexOf(this);\n    if (i > 0) {\n      let temp = this.parent.children[i - 1];\n      this.parent.children[i - 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Move the node down in the parent's child tree\n   */\n  GameNode.prototype.moveDown = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    let i = this.parent.children.indexOf(this);\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\n      let temp = this.parent.children[i + 1];\n      this.parent.children[i + 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Append this node to another node\n   */\n  GameNode.prototype.appendTo = function(node) {\n\n    //Remove from existing parent\n    this.remove();\n\n    //Set new parent\n    this.parent = node;\n    node.children.push(this);\n    return node.children.length - 1;\n  };\n\n  /**\n   * Append child node to this node.\n   */\n  GameNode.prototype.appendChild = function(node) {\n    node.parent = this;\n    this.children.push(node);\n    return this.children.length - 1;\n  };\n\n  /**\n   * Insert another node after this one\n   */\n  GameNode.prototype.insertNode = function(node) {\n\n    //Loop our children and change parent node\n    for (let i = 0; i < this.children.length; i++) {\n      this.children[i].parent = node;\n    }\n\n    //Merge children, set this node as the parent of given node\n    node.children = node.children.concat(this.children);\n    node.parent = this;\n\n    //Set given node as the child of this node\n    this.children = [node];\n  };\n\n  /*****************************************************************************\n   * JGF conversion\n   ***/\n\n  /**\n   * Build a Game Node from a given JGF tree\n   */\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\n\n    //Root JGF file given?\n    if (typeof jgf.tree !== 'undefined') {\n      return GameNode.fromJgf(jgf.tree, gameNode);\n    }\n\n    //Initialize helper vars\n    let variationNode, nextNode, i, j;\n\n    //Node to work with given? Otherwise, work with ourselves\n    gameNode = gameNode || this;\n\n    //Loop moves in the JGF tree\n    for (i = 0; i < jgf.length; i++) {\n\n      //Array? That means a variation branch\n      if (angular.isArray(jgf[i])) {\n\n        //Loop variation stacks\n        for (j = 0; j < jgf[i].length; j++) {\n\n          //Build the variation node\n          variationNode = new GameNode();\n          variationNode.fromJgf(jgf[i][j]);\n\n          //Append to working node\n          gameNode.appendChild(variationNode);\n        }\n      }\n\n      //Regular node\n      else {\n\n        //Get properties to copy\n        let properties = Object.getOwnPropertyNames(jgf[i]);\n\n        //Copy node properties\n        for (let key in properties) {\n          if (properties.hasOwnProperty(key)) {\n            let prop = properties[key];\n\n            //Conversion function present?\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\n            }\n            else if (typeof jgf[i][prop] === 'object') {\n              gameNode[prop] = angular.copy(jgf[i][prop]);\n            }\n            else {\n              gameNode[prop] = jgf[i][prop];\n            }\n          }\n        }\n      }\n\n      //Next element is a regular node? Prepare new working node\n      //Otherwise, if there are no more nodes or if the next element is\n      //an array (e.g. variations), we keep our working node as the current one\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\n        nextNode = new GameNode();\n        gameNode.appendChild(nextNode);\n        gameNode = nextNode;\n      }\n    }\n  };\n\n  /**\n   * Convert this node to a JGF node container\n   */\n  GameNode.prototype.toJgf = function(container) {\n\n    //Initialize container to add nodes to\n    container = container || [];\n\n    //Initialize node and get properties\n    let node = {};\n    let properties = Object.getOwnPropertyNames(this);\n\n    //Copy node properties\n    for (let key in properties) {\n      if (properties.hasOwnProperty(key)) {\n        let prop = properties[key];\n\n        //Skip some properties\n        if (prop === 'parent' || prop === 'children') {\n          continue;\n        }\n\n        //Conversion function present?\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\n        }\n        else if (typeof this[prop] === 'object') {\n          node[prop] = angular.copy(this[prop]);\n        }\n        else {\n          node[prop] = this[prop];\n        }\n      }\n    }\n\n    //Add node to container\n    container.push(node);\n\n    //Variations present?\n    if (this.children.length > 1) {\n\n      //Create variations container\n      let variationsContainer = [];\n      container.push(variationsContainer);\n\n      //Loop child (variation) nodes\n      for (let i = 0; i < this.children.length; i++) {\n\n        //Create container for this variation\n        let variationContainer = [];\n        variationsContainer.push(variationContainer);\n\n        //Call child node converter\n        this.children[i].toJgf(variationContainer);\n      }\n    }\n\n    //Just one child?\n    else if (this.children.length === 1) {\n      this.children[0].toJgf(container);\n    }\n\n    //Return container\n    return container;\n  };\n\n  //Return object\n  return GameNode;\n});\n","\n/**\n * GamePath :: A simple class that keeps track of a path taken in a game.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Path.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('GamePath', function() {\n\n  /**\n   * Constructor\n   */\n  function GamePath() {\n    this.reset();\n  }\n\n  /**\n   * Reset\n   */\n  GamePath.prototype.reset = function() {\n    this.move = 0;\n    this.path = {};\n    this.branches = 0;\n    return this;\n  };\n\n  /**\n   * Advance a move\n   */\n  GamePath.prototype.advance = function(i) {\n\n    //Different child variation chosen? Remember\n    if (i > 0) {\n      this.path[this.move] = 1;\n      this.branches++;\n    }\n\n    //Increment move\n    this.move++;\n    return this;\n  };\n\n  /**\n   * Retreat a move\n   */\n  GamePath.prototype.retreat = function() {\n\n    //At start?\n    if (this.move === 0) {\n      return;\n    }\n\n    //Delete path choice\n    if (this.path[this.move]) {\n      delete this.path[this.move];\n      this.branches--;\n    }\n\n    //Decrement move\n    this.move--;\n    return this;\n  };\n\n  /**\n   * Go to a specific move number\n   */\n  GamePath.prototype.setMove = function(no) {\n\n    //Less than our current move? We need to erase any paths above the move number\n    if (no < this.move) {\n      for (let i in this.path) {\n        if (i > no) {\n          delete this.path[i];\n          this.branches--;\n        }\n      }\n    }\n\n    //Set move number\n    this.move = no;\n    return this;\n  };\n\n  /**\n   * Get the move number\n   */\n  GamePath.prototype.getMove = function() {\n    return this.move;\n  };\n\n  /**\n   * Get the node choice at a specific move number\n   */\n  GamePath.prototype.nodeAt = function(no) {\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\n  };\n\n  /**\n   * Compare to another path\n   */\n  GamePath.prototype.compare = function(otherPath) {\n\n    //Invalid object?\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\n      return;\n    }\n\n    //Different move number or path length?\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\n      return false;\n    }\n\n    //Check path\n    for (let i in this.path) {\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\n        return false;\n      }\n    }\n\n    //Same path!\n    return true;\n  };\n\n  /**\n   * Clone\n   */\n  GamePath.prototype.clone = function() {\n\n    //Create new instance\n    let newPath = new GamePath();\n\n    //Set vars\n    newPath.move = this.move;\n    newPath.branches = this.branches;\n    newPath.path = angular.copy(this.path);\n\n    //Return\n    return newPath;\n  };\n\n  /**\n   * Helper to find node name recursively\n   */\n  function findNodeName(node, nodeName, path) {\n\n    //Found in this node?\n    if (node.name && node.name === nodeName) {\n      return true;\n    }\n\n    //Loop children\n    for (let i = 0; i < node.children.length; i++) {\n\n      //Advance path\n      path.advance(i);\n\n      //Found in child node?\n      if (findNodeName(node.children[i], nodeName, path)) {\n        return true;\n      }\n\n      //Not found in this child node, retreat path\n      path.retreat();\n    }\n\n    //Not found\n    return false;\n  }\n\n  /**\n   * Static helper to create a path object to reach a certain node\n   */\n  GamePath.findNode = function(nodeName, rootNode) {\n\n    //Create new instance\n    let path = new GamePath();\n\n    //Find the node name\n    if (findNodeName(rootNode, nodeName, path)) {\n      return path;\n    }\n\n    //Not found\n    return null;\n  };\n\n  //Return\n  return GamePath;\n});\n","\n/**\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\n * markup on the board in this position, as well as any captures that were made and which player's\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\n * compare changes to other positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Position.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('GamePosition', function(StoneColor, BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  function GamePosition(width, height) {\n\n    //Initialize\n    this.error = 0;\n    this.width = 0;\n    this.height = 0;\n    this.stones = new BoardGrid();\n    this.markup = new BoardGrid();\n    this.turn = StoneColor.B;\n\n    //Initialize captures\n    this.captures = {};\n    this.captures[StoneColor.B] = [];\n    this.captures[StoneColor.W] = [];\n\n    //Set empty value for stones grid\n    this.stones.whenEmpty(StoneColor.EMPTY);\n\n    //Set size\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  }\n\n  /**\n   * Set the grid size\n   */\n  GamePosition.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Set in grids\n    this.stones.setSize(width, height);\n    this.markup.setSize(width, height);\n\n    //Empty the position\n    this.empty();\n  };\n\n  /**\n   * Clear the whole position\n   */\n  GamePosition.prototype.empty = function() {\n    this.stones.empty();\n    this.markup.empty();\n  };\n\n  /**\n   * Sets stone color at given coordinates.\n   */\n  GamePosition.prototype.setStone = function(x, y, color) {\n    this.stones.set(x, y, color);\n  };\n\n  /**\n   * Sets markup type at given coordinates.\n   */\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\n    this.markup.set(x, y, markup);\n  };\n\n  /*****************************************************************************\n   * Liberties and capturing\n   ***/\n\n  /**\n   * Check if a group of given color has liberties, starting at the given coordinates\n   */\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\n\n    //Out of bounds? No liberties outside of the board\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Initialize tested grid if needed\n    tested = tested || new BoardGrid(this.width, this.height);\n\n    //See what color is present on the coordinates\n    let color = this.stones.get(x, y);\n\n    //If no group color was given, use what's on the position\n    groupColor = groupColor || color;\n\n    //Already tested, or enemy stone? Not giving any liberties\n    if (tested.get(x, y) === true || color === -groupColor) {\n      return false;\n    }\n\n    //Empty? That's a liberty\n    if (color === StoneColor.EMPTY) {\n      return true;\n    }\n\n    //Mark this position as tested now\n    tested.set(x, y, true);\n\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\n    //If we get at least one true, we have a liberty\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\n        this.hasLiberties(x + 1, y, groupColor, tested);\n  };\n\n  /**\n   * Helper to capture adjacent groups\n   */\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    friendlyColor = friendlyColor || this.stones.get(x, y);\n\n    //Can't capture empty spots\n    if (friendlyColor === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Flag to see if we captured stuff\n    let captured = false;\n\n    //Check adjacent positions now, capturing stones in the process if possible\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n\n    //Return\n    return captured;\n  };\n\n  /**\n   * Helper if we can capture a certain group\n   */\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\n\n    //Out of bounds? Nothing to capture\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Empty spot? Can't capture\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //We need to have a stone of matching group color in order to be able to capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //There is a capturable stone, let's see if it has any liberties left\n    if (this.hasLiberties(x, y, enemyColor)) {\n      return false;\n    }\n\n    //No liberties left, the group is capturable. Capture if we want to\n    if (doCapture) {\n      this.captureGroup(x, y, enemyColor);\n    }\n\n    //Capturable\n    return true;\n  };\n\n  /**\n   * Capture a group of certain color, starting at the given coordinates\n   */\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //If no group color was given, use what's on the position\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //Stone at position does not match the given group color? Can't capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //Capture the stone\n    this.captureStone(x, y);\n\n    //Capture the rest of the group\n    this.captureGroup(x, y - 1, enemyColor);\n    this.captureGroup(x, y + 1, enemyColor);\n    this.captureGroup(x - 1, y, enemyColor);\n    this.captureGroup(x + 1, y, enemyColor);\n\n    //At least one stone was captured\n    return true;\n  };\n\n  /**\n   * Capture a stone at given coordinates\n   */\n  GamePosition.prototype.captureStone = function(x, y) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Get color\n    let color = this.stones.get(x, y);\n\n    //Empty?\n    if (color === StoneColor.EMPTY) {\n      return;\n    }\n\n    //Ok, stone present, capture it\n    this.stones.set(x, y, StoneColor.EMPTY);\n    this.captures[color].push({x: x, y: y});\n  };\n\n  /**\n   * Set captures for a color (expects array with capture object coordinates)\n   */\n  GamePosition.prototype.setCaptures = function(color, captures) {\n    this.captures[color] = captures;\n  };\n\n  /**\n   * Get captures for a color\n   */\n  GamePosition.prototype.getCaptures = function(color) {\n    return this.captures[color] || [];\n  };\n\n  /**\n   * Get the capture count for a color (= the number of captures of the opposing color)\n   */\n  GamePosition.prototype.getCaptureCount = function(color) {\n    return this.captures[-color].length;\n  };\n\n  /*****************************************************************************\n   * Turn control\n   ***/\n\n  /**\n   * Set color for whose move it is at this position\n   */\n  GamePosition.prototype.setTurn = function(color) {\n    this.turn = color;\n  };\n\n  /**\n   * Get color for whose move it is at this position\n   */\n  GamePosition.prototype.getTurn = function() {\n    return this.turn;\n  };\n\n  /**\n   * Switch the player turn on this position\n   */\n  GamePosition.prototype.switchTurn = function() {\n    this.turn = -this.turn;\n  };\n\n  /*****************************************************************************\n   * Cloning and comparison\n   ***/\n\n  /**\n   * Clones the whole position except turn and captures\n   */\n  GamePosition.prototype.clone = function() {\n\n    //Create a new position\n    let newPosition = new GamePosition();\n\n    //Set vars manually for maximum efficiency\n    newPosition.turn = this.turn;\n    newPosition.width = this.width;\n    newPosition.height = this.height;\n    newPosition.stones = this.stones.clone();\n    newPosition.markup = new BoardGrid(this.width, this.height);\n\n    //Return\n    return newPosition;\n  };\n\n  /**\n   * Checks if a given position is the same as the current position\n   */\n  GamePosition.prototype.isSameAs = function(newPosition) {\n\n    //Must have the same size\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\n      return false;\n    }\n\n    //Compare the grids\n    return this.stones.isSameAs(newPosition.stones);\n  };\n\n  //Return\n  return GamePosition;\n});\n","\n/**\n * GameScore :: A simple class that contains a game score\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Score.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('GameScore', function(StoneColor) {\n\n  /**\n   * Helper to calculate the total points\n   */\n  function calcTotal() {\n    return parseInt(this.stones) + parseInt(this.territory) +\n      parseInt(this.captures) + parseInt(this.komi);\n  }\n\n  /**\n   * Constructor\n   */\n  function GameScore() {\n\n    //Get self\n    let self = this;\n\n    //Setup score containers\n    this.black = {};\n    this.white = {};\n\n    //Initialize\n    this.reset();\n\n    //Add total handlers\n    this.black.total = function() {\n      return calcTotal.call(self.black);\n    };\n    this.white.total = function() {\n      return calcTotal.call(self.white);\n    };\n  }\n\n  /**\n   * Reset the game score\n   */\n  GameScore.prototype.reset = function() {\n\n    //Get properties to loop\n    let props = ['stones', 'territory', 'captures', 'komi'];\n\n    //Score for black player\n    for (let i = 0; i < props.length; i++) {\n      this.black[props[i]] = 0;\n      this.white[props[i]] = 0;\n    }\n  };\n\n  /**\n   * Get the winner\n   */\n  GameScore.prototype.winner = function() {\n\n    //Get totals\n    let b = this.black.total();\n    let w = this.white.total();\n\n    //Determine winner\n    if (w > b) {\n      return StoneColor.W;\n    }\n    else if (b > w) {\n      return StoneColor.B;\n    }\n    return StoneColor.E;\n  };\n\n  //Return\n  return GameScore;\n});\n","\n/**\n * GameScorer :: This class is used to determine the score of a certain game position. It also\n * provides handling of manual adjustment of dead / living groups.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Scorer.Service', [\n  'ngGo',\n  'ngGo.Game.Score.Service',\n  'ngGo.Board.Grid.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('GameScorer', function(GameScore, StoneColor, BoardGrid) {\n\n  /**\n   * Possible score states\n   */\n  let scoreState = {\n    UNKNOWN: StoneColor.EMPTY,\n    BLACK_STONE: StoneColor.B,\n    WHITE_STONE: StoneColor.W,\n    BLACK_CANDIDATE: StoneColor.B * 2,\n    WHITE_CANDIDATE: StoneColor.W * 2,\n    NEUTRAL: StoneColor.B * 3,\n  };\n\n  /**\n   * Helper to set territory\n   */\n  function territorySet(x, y, candidateColor, boundaryColor) {\n\n    //Get color at given position\n    let posColor = this.stones.get(x, y);\n    let origColor = this.game.position.stones.get(x, y);\n\n    //If border reached, or a position which is already this color, or boundary color, can't set\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\n      return;\n    }\n\n    //Don't turn stones which are already this color into candidates, instead\n    //reset their color to what they were\n    if (origColor * 2 === candidateColor) {\n      this.stones.set(x, y, origColor);\n    }\n\n    //Otherwise, mark as candidate\n    else {\n      this.stones.set(x, y, candidateColor);\n    }\n\n    //Set adjacent squares\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\n  }\n\n  /**\n   * Helper to reset territory\n   */\n  function territoryReset(x, y) {\n\n    //Get original color from this position\n    let origColor = this.game.position.stones.get(x, y);\n\n    //Not on grid, or already this color?\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\n      return;\n    }\n\n    //Reset the color\n    this.stones.set(x, y, origColor);\n\n    //Set adjacent squares\n    territoryReset.call(this, x - 1, y);\n    territoryReset.call(this, x, y - 1);\n    territoryReset.call(this, x + 1, y);\n    territoryReset.call(this, x, y + 1);\n  }\n\n  /**\n   * Helper to determine score state\n   */\n  function determineScoreState() {\n\n    //Initialize vars\n    let change = true;\n    let curState, newState, adjacent, b, w, a, x, y;\n\n    //Loop while there is change\n    while (change) {\n\n      //Set to false\n      change = false;\n\n      //Go through the whole position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get current state at position\n          curState = this.stones.get(x, y);\n\n          //Unknown or candiates?\n          if (\n            curState === scoreState.UNKNOWN ||\n            curState === scoreState.BLACK_CANDIDATE ||\n            curState === scoreState.WHITE_CANDIDATE\n          ) {\n\n            //Get state in adjacent positions\n            adjacent = [\n              this.stones.get(x - 1, y),\n              this.stones.get(x, y - 1),\n              this.stones.get(x + 1, y),\n              this.stones.get(x, y + 1),\n            ];\n\n            //Reset\n            b = w = false;\n\n            //Loop adjacent squares\n            for (a = 0; a < 4; a++) {\n              if (\n                adjacent[a] === scoreState.BLACK_STONE ||\n                adjacent[a] === scoreState.BLACK_CANDIDATE\n              ) {\n                b = true;\n              }\n              else if (\n                adjacent[a] === scoreState.WHITE_STONE ||\n                adjacent[a] === scoreState.WHITE_CANDIDATE\n              ) {\n                w = true;\n              }\n              else if (adjacent[a] === scoreState.NEUTRAL) {\n                b = w = true;\n              }\n            }\n\n            //Determine new state\n            if (b && w) {\n              newState = scoreState.NEUTRAL;\n            }\n            else if (b) {\n              newState = scoreState.BLACK_CANDIDATE;\n            }\n            else if (w) {\n              newState = scoreState.WHITE_CANDIDATE;\n            }\n            else {\n              newState = false;\n            }\n\n            //Change?\n            if (newState !== false && newState !== curState) {\n              change = true;\n              this.stones.set(x, y, newState);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * this.game scorer class\n   */\n  let GameScorer = {\n\n    //Game to score\n    game: null,\n\n    //Score\n    score: null,\n\n    //Stones, captures and points grids\n    stones: null,\n    captures: null,\n    points: null,\n\n    /**\n     * Load a game to score\n     */\n    load: function(game) {\n\n      //Reset score\n      this.score = new GameScore();\n\n      //Remember\n      this.game = game;\n\n      //Clone position to work with\n      this.stones = this.game.position.stones.clone();\n\n      //Create grids\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n    },\n\n    /**\n     * Get the calculated score\n     */\n    getScore: function() {\n      return this.score;\n    },\n\n    /**\n     * Get the points grid\n     */\n    getPoints: function() {\n      return this.points;\n    },\n\n    /**\n     * Get the captures grid\n     */\n    getCaptures: function() {\n      return this.captures;\n    },\n\n    /**\n     * Run score calculation routine\n     */\n    calculate: function() {\n\n      //No game?\n      if (!this.game) {\n        throw new Error(\n          'No game loaded in game scorer, can\\'t calculate score.'\n        );\n      }\n\n      //Empty grids\n      this.points.empty();\n      this.captures.empty();\n\n      //Determine score state\n      determineScoreState.call(this);\n\n      //Get komi and captures\n      let komi = this.game.get('game.komi');\n      let captures = this.game.getCaptureCount();\n\n      //Reset score\n      this.score.reset();\n\n      //Set captures and komi\n      this.score.black.captures = captures[StoneColor.B];\n      this.score.white.captures = captures[StoneColor.W];\n      this.score.black.komi = komi < 0 ? komi : 0;\n      this.score.white.komi = komi > 0 ? komi : 0;\n\n      //Init helper vars\n      let x, y, state, color;\n\n      //Loop position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get state and color on original position\n          state = this.stones.get(x, y);\n          color = this.game.position.stones.get(x, y);\n\n          //Black stone\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\n            this.score.black.stones++;\n            continue;\n          }\n\n          //White stone\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\n            this.score.white.stones++;\n            continue;\n          }\n\n          //Black candidate\n          if (state === scoreState.BLACK_CANDIDATE) {\n            this.score.black.territory++;\n            this.points.set(x, y, StoneColor.B);\n\n            //White stone underneath?\n            if (color === StoneColor.W) {\n              this.score.black.captures++;\n              this.captures.set(x, y, StoneColor.W);\n            }\n            continue;\n          }\n\n          //White candidate\n          if (state === scoreState.WHITE_CANDIDATE) {\n            this.score.white.territory++;\n            this.points.set(x, y, StoneColor.W);\n\n            //Black stone underneath?\n            if (color === StoneColor.B) {\n              this.score.white.captures++;\n              this.captures.set(x, y, StoneColor.B);\n            }\n            continue;\n          }\n        }\n      }\n    },\n\n    /**\n     * Mark stones dead or alive\n     */\n    mark: function(x, y) {\n\n      //Get color of original position and state of the count position\n      let color = this.game.position.stones.get(x, y);\n      let state = this.stones.get(x, y);\n\n      //White stone\n      if (color === StoneColor.W) {\n\n        //Was white, mark it and any territory it's in as black's\n        if (state === scoreState.WHITE_STONE) {\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\n        }\n\n        //Was marked as not white, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n\n      //Black stone\n      else if (color === StoneColor.B) {\n\n        //Was black, mark it and any territory it's in as white's\n        if (state === scoreState.BLACK_STONE) {\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\n        }\n\n        //Was marked as not black, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n    },\n  };\n\n  //Return\n  return GameScorer;\n});\n","\n/**\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Blank.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('KifuBlank', function(ngGo) {\n\n  /**\n   * Blank JGF\n   */\n  let blankJgf = {\n    record: {\n      application: ngGo.name + ' v' + ngGo.version,\n      version: 1,\n      charset: 'UTF-8',\n    },\n    game: {\n      type: 'go',\n      players: [\n        {\n          color: 'black',\n          name: 'Black',\n        },\n        {\n          color: 'white',\n          name: 'White',\n        },\n      ],\n    },\n    board: {\n      width: 19,\n      height: 19,\n    },\n    tree: [],\n  };\n\n  /**\n   * Blank SGF\n   */\n  let blankSgf = {\n    AP: ngGo.name + ':' + ngGo.version,\n    CA: 'UTF-8',\n    FF: '4',\n    GM: '1',\n    SZ: '19',\n    PB: 'Black',\n    PW: 'White',\n  };\n\n  /**\n   * Blank JGF/SGF container\n   */\n  let KifuBlank = {\n\n    /**\n     * Get blank JGF\n     */\n    jgf: function(base) {\n\n      //Initialize blank\n      let blank = angular.copy(blankJgf);\n\n      //Base given?\n      if (base) {\n        for (let p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    },\n\n    /**\n     * Get blank SGF\n     */\n    sgf: function(base) {\n\n      //Initialize blank\n      let blank = angular.copy(blankSgf);\n\n      //Base given?\n      if (base) {\n        for (let p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = base[p];\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    },\n  };\n\n  //Return object\n  return KifuBlank;\n});\n","\n/**\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\n * constants used by the parsers to aid conversion.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parser.Service', [\n  'ngGo',\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service',\n])\n\n/**\n * SGF/JGF aliases constant for conversion between the two formats\n * Note: not all properties can be translated directly, so some are\n * not present here in this constant\n */\n.constant('sgfAliases', {\n\n  //Record properties\n  'AP': 'record.application',\n  'CA': 'record.charset',\n  'CP': 'record.copyright',\n  'SO': 'record.source',\n  'US': 'record.transcriber',\n  'AN': 'record.annotator',\n\n  //Game properties\n  'GM': 'game.type',\n  'GN': 'game.name',\n  'KM': 'game.komi',\n  'HA': 'game.handicap',\n  'RE': 'game.result',\n  'RU': 'game.rules',\n  'TM': 'game.time.main',\n  'OT': 'game.time.overtime',\n  'DT': 'game.dates',\n  'PC': 'game.location',\n  'EV': 'game.event',\n  'RO': 'game.round',\n  'ON': 'game.opening',\n  'GC': 'game.comment',\n\n  //Player info properties\n  'PB': 'name',\n  'PW': 'name',\n  'BT': 'team',\n  'WT': 'team',\n  'BR': 'rank',\n  'WR': 'rank',\n\n  //Node annotation\n  'N': 'name',\n  'C': 'comments',\n  'CR': 'circle',\n  'TR': 'triangle',\n  'SQ': 'square',\n  'MA': 'mark',\n  'SL': 'select',\n  'LB': 'label',\n})\n\n/**\n * SGF game definitions\n */\n.constant('sgfGames', {\n  1: 'go',\n  2: 'othello',\n  3: 'chess',\n  4: 'renju',\n  6: 'backgammon',\n  7: 'chinese chess',\n  8: 'shogi',\n})\n\n/**\n * Factory definition\n */\n.factory('KifuParser', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\n\n  /**\n   * Parser wrapper class\n   */\n  let KifuParser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    gib2jgf: function(gib, stringified) {\n      return Gib2Jgf.parse(gib, stringified);\n    },\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    sgf2jgf: function(sgf, stringified) {\n      return Sgf2Jgf.parse(sgf, stringified);\n    },\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    jgf2sgf: function(jgf) {\n      return Jgf2Sgf.parse(jgf);\n    },\n  };\n\n  //Return object\n  return KifuParser;\n});\n","/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Directive', [\n  'ngGo.Board.Directive',\n])\n\n/**\n * Directive definition\n */\n.directive('player', function(Player) {\n  return {\n    restrict: 'E',\n\n    /**\n     * Controller\n     */\n    controller: function($scope) {\n\n      //Set player in scope\n      if (!$scope.Player) {\n        $scope.Player = Player;\n      }\n    },\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Link the element\n      Player.linkElement(element);\n\n      //Observe mode and tool attributes\n      attrs.$observe('mode', function(mode) {\n        Player.switchMode(mode);\n      });\n      attrs.$observe('tool', function(tool) {\n        Player.switchTool(tool);\n      });\n\n      //Observe other settings attributes\n      attrs.$observe('variationMarkup', function(attr) {\n        Player.setVariationMarkup(attr === 'true');\n      });\n      attrs.$observe('solutionPaths', function(attr) {\n        Player.toggleSolutionPaths(attr === 'true');\n      });\n      attrs.$observe('lastMoveMarker', function(attr) {\n        Player.setLastMoveMarker(attr);\n      });\n    },\n  };\n});\n","\n/**\n * Player :: This class brings the board to life and allows a user to interact with it. It\n * handles user input, controls objects going to the board, can load game records, and allows the\n * user to manipulate the board according to the current player mode.\n * Unless you want to display static positions, this is the class you'd use by default.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Service', [\n  'ngGo',\n  'ngGo.Player.Directive',\n  'ngGo.Player.Mode.Common.Service',\n  'ngGo.Board.Service',\n  'ngGo.Game.Service',\n  'ngGo.Game.Scorer.Service',\n])\n\n/**\n * Provider definition\n */\n.provider('Player', function(PlayerModes, PlayerTools, MarkupTypes) {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n    //Default mode/tool\n    mode: PlayerModes.REPLAY,\n    tool: PlayerTools.MOVE,\n\n    //Keys/scrollwheel navigation\n    arrowKeysNavigation: true,\n    scrollWheelNavigation: true,\n\n    //Last move marker, leave empty for none\n    lastMoveMarker: MarkupTypes.LAST,\n\n    //Indicate variations with markup on the board, and show\n    //successor node variations or current node variations\n    variationMarkup: true,\n    variationChildren: true,\n    variationSiblings: false,\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\n\n    /**\n     * Helper to append board grid coordinatess to the broadcast event object\n     */\n    function processMouseEvent(broadcastEvent, mouseEvent) {\n\n      //Can only do this with a board and mouse event\n      if (!this.board || !mouseEvent) {\n        broadcastEvent.x = -1;\n        broadcastEvent.y = -1;\n        return;\n      }\n\n      //Init\n      let x = 0;\n      let y = 0;\n\n      //Set x\n      if (typeof mouseEvent.offsetX !== 'undefined') {\n        x = mouseEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.layerX;\n      }\n\n      //Set y\n      if (typeof mouseEvent.offsetY !== 'undefined') {\n        y = mouseEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.layerY;\n      }\n\n      //Apply pixel ratio factor\n      x *= (window.devicePixelRatio || 1);\n      y *= (window.devicePixelRatio || 1);\n\n      //Append coords\n      broadcastEvent.x = this.board.getGridX(x);\n      broadcastEvent.y = this.board.getGridY(y);\n\n      //Did we drag?\n      if (mouseEvent.drag) {\n        broadcastEvent.drag = mouseEvent.drag;\n      }\n    }\n\n    /**\n     * Player class\n     */\n    let Player = {\n\n      //Player configuration\n      config: {},\n\n      //Board and game instances\n      board: null,\n      game: null,\n\n      //Available modes and tools\n      modes: {},\n      tools: [],\n\n      //Player mode and active tool\n      mode: '',\n      tool: '',\n\n      //Current path\n      path: null,\n\n      /**\n       * Initialization\n       */\n      init: function() {\n\n        //Unlink board instance, create new game\n        this.board = null;\n        this.game = new Game();\n\n        //Reset path\n        this.path = null;\n\n        //Player mode and active tool\n        this.mode = '';\n        this.tool = '';\n\n        //Arrow keys / scroll wheel navigation\n        this.arrowKeysNavigation = false;\n        this.scrollWheelNavigation = false;\n\n        //Last move marker\n        this.lastMoveMarker = '';\n\n        //Variation markup\n        this.variationMarkup = false;\n        this.variationChildren = false;\n        this.variationSiblings = false;\n\n        //Restricted nodes\n        this.restrictNodeStart = null;\n        this.restrictNodeEnd = null;\n\n        //Parse config\n        this.parseConfig();\n      },\n\n      /**\n       * Link the player to a HTML element\n       */\n      linkElement: function(element) {\n\n        //Set element\n        this.element = element;\n\n        //Register document event\n        this.registerElementEvent('keydown', $document);\n\n        //Register element events\n        this.registerElementEvent('click');\n        this.registerElementEvent('mousedown');\n        this.registerElementEvent('mouseup');\n        this.registerElementEvent('mousemove');\n        this.registerElementEvent('mouseout');\n        this.registerElementEvent('mousewheel');\n        this.registerElementEvent('wheel');\n      },\n\n      /*****************************************************************************\n       * Configuration\n       ***/\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, defaultConfig, config || {});\n\n        //Process settings\n        this.switchMode(this.config.mode);\n        this.switchTool(this.config.tool);\n        this.setArrowKeysNavigation(this.config.arrowKeysNavigation);\n        this.setScrollWheelNavigation(this.config.scrollWheelNavigation);\n        this.setLastMoveMarker(this.config.lastMoveMarker);\n        this.setVariationMarkup(\n          this.config.variationMarkup,\n          this.config.variationChildren,\n          this.config.variationSiblings\n        );\n\n        //Let the modes parse their config\n        for (let mode in this.modes) {\n          if (this.modes[mode].parseConfig) {\n            this.modes[mode].parseConfig.call(this, this.config);\n          }\n        }\n      },\n\n      /**\n       * Set arrow keys navigation\n       */\n      setArrowKeysNavigation: function(arrowKeys) {\n        if (arrowKeys !== this.arrowKeysNavigation) {\n          this.arrowKeysNavigation = arrowKeys;\n          this.broadcast('settingChange', 'arrowKeysNavigation');\n        }\n      },\n\n      /**\n       * Set scroll wheel navigation\n       */\n      setScrollWheelNavigation: function(scrollWheel) {\n        if (scrollWheel !== this.scrollWheelNavigation) {\n          this.scrollWheelNavigation = scrollWheel;\n          this.broadcast('settingChange', 'scrollWheelNavigation');\n        }\n      },\n\n      /**\n       * Set the last move marker\n       */\n      setLastMoveMarker: function(lastMoveMarker) {\n        if (lastMoveMarker !== this.lastMoveMarker) {\n          this.lastMoveMarker = lastMoveMarker;\n          this.broadcast('settingChange', 'lastMoveMarker');\n        }\n      },\n\n      /**\n       * Set variation markup on the board\n       */\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\n\n        //One change event for these three settings\n        let change = false;\n\n        //Markup setting change?\n        if (variationMarkup !== this.variationMarkup) {\n          this.variationMarkup = variationMarkup;\n          change = true;\n        }\n\n        //Children setting change?\n        if (\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\n        ) {\n          this.variationChildren = variationChildren;\n          change = true;\n        }\n\n        //Siblings setting change?\n        if (\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\n        ) {\n          this.variationSiblings = variationSiblings;\n          change = true;\n        }\n\n        //Did anything change?\n        if (change) {\n          this.broadcast('settingChange', 'variationMarkup');\n        }\n      },\n\n      /*****************************************************************************\n       * Mode and tool handling\n       ***/\n\n      /**\n       * Register a player mode\n       */\n      registerMode: function(mode, PlayerMode) {\n\n        //Register the mode and let it parse the configuration\n        this.modes[mode] = PlayerMode;\n\n        //Parse config if we have a handler\n        if (this.modes[mode].parseConfig) {\n          this.modes[mode].parseConfig.call(this, this.config);\n        }\n\n        //Force switch the mode now, if it matches the initial mode\n        if (this.mode === mode) {\n          this.switchMode(this.mode, true);\n          this.switchTool(this.tool, true);\n        }\n      },\n\n      /**\n       * Set available tools\n       */\n      setTools: function(tools) {\n        this.tools = tools || [PlayerTools.NONE];\n      },\n\n      /**\n       * Check if we have a player mode\n       */\n      hasMode: function(mode) {\n        return this.modes[mode] ? true : false;\n      },\n\n      /**\n       * Check if we have a player tool\n       */\n      hasTool: function(tool) {\n        return (this.tools.indexOf(tool) !== -1);\n      },\n\n      /**\n       * Switch player mode\n       */\n      switchMode: function(mode, force) {\n\n        //No change?\n        if (!force && (!mode || this.mode === mode)) {\n          return false;\n        }\n\n        //Broadcast mode exit\n        if (this.mode) {\n          this.broadcast('modeExit', this.mode);\n        }\n\n        //Set mode, reset tools and active tool\n        this.mode = mode;\n        this.tools = [];\n        this.tool = PlayerTools.NONE;\n\n        //Broadcast mode entry\n        this.broadcast('modeEnter', this.mode);\n        return true;\n      },\n\n      /**\n       * Switch player tool\n       */\n      switchTool: function(tool, force) {\n\n        //No change?\n        if (!force && (!tool || this.tool === tool)) {\n          return false;\n        }\n\n        //Validate tool switch (only when there is a mode)\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\n          return false;\n        }\n\n        //Change tool\n        this.tool = tool;\n        this.broadcast('toolSwitch', this.tool);\n        return true;\n      },\n\n      /**\n       * Save the full player state\n       */\n      saveState: function() {\n\n        //Save player state\n        this.playerState = {\n          mode: this.mode,\n          tool: this.tool,\n          restrictNodeStart: this.restrictNodeStart,\n          restrictNodeEnd: this.restrictNodeEnd,\n        };\n\n        //Save game state\n        this.saveGameState();\n      },\n\n      /**\n       * Restore to the saved player state\n       */\n      restoreState: function() {\n\n        //Must have player state\n        if (!this.playerState) {\n          return;\n        }\n\n        //Restore\n        this.switchMode(this.playerState.mode);\n        this.switchTool(this.playerState.tool);\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\n\n        //Restore game state\n        this.restoreGameState();\n      },\n\n      /*****************************************************************************\n       * Game record handling\n       ***/\n\n      /**\n       * Load game record\n       */\n      load: function(data, allowPlayerConfig) {\n\n        //Try to load the game record data\n        try {\n          this.game.load(data);\n        }\n        catch (error) {\n          throw error;\n        }\n\n        //Reset path\n        this.path = null;\n\n        //Parse configuration from JGF if allowed\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\n          this.parseConfig(this.game.get('settings'));\n        }\n\n        //Dispatch game loaded event\n        this.broadcast('gameLoaded', this.game);\n\n        //Board present?\n        if (this.board) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n\n        //Loaded ok\n        return true;\n      },\n\n      /**\n       * Reload the existing game record\n       */\n      reload: function() {\n\n        //Must have game\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reload game\n        this.game.reload();\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Save the current state\n       */\n      saveGameState: function() {\n        if (this.game && this.game.isLoaded()) {\n          this.gameState = this.game.getState();\n        }\n      },\n\n      /**\n       * Restore to the saved state\n       */\n      restoreGameState: function() {\n\n        //Must have game and saved state\n        if (!this.game || !this.gameState) {\n          return;\n        }\n\n        //Restore state\n        this.game.restoreState(this.gameState);\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /*****************************************************************************\n       * Navigation\n       ***/\n\n      /**\n       * Go to the next position\n       */\n      next: function(i) {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.next(i);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position\n       */\n      previous: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previous();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the last position\n       */\n      last: function() {\n        if (this.game) {\n          this.game.last();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the first position\n       */\n      first: function() {\n        if (this.game) {\n          this.game.first();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to a specific move number, tree path or named node\n       */\n      goto: function(target) {\n        if (this.game && target) {\n          this.game.goto(target);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the previous fork\n       */\n      previousFork: function() {\n        if (this.game) {\n          this.game.previousFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next fork\n       */\n      nextFork: function() {\n        if (this.game) {\n          this.game.nextFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next position with a comment\n       */\n      nextComment: function() {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.nextComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position with a comment\n       */\n      previousComment: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previousComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Restrict navigation to the current node\n       */\n      restrictNode: function(end) {\n\n        //Must have game and node\n        if (!this.game || !this.game.node) {\n          return;\n        }\n\n        //Restrict to current node\n        if (end) {\n          this.restrictNodeEnd = this.game.node;\n        }\n        else {\n          this.restrictNodeStart = this.game.node;\n        }\n      },\n\n      /**\n       * Process a new game position\n       */\n      processPosition: function() {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Get current node and game position\n        let node = this.game.getNode();\n        let path = this.game.getPath();\n        let position = this.game.getPosition();\n        let pathChanged = !path.compare(this.path);\n\n        //Update board\n        this.updateBoard(node, position, pathChanged);\n\n        //Path change?\n        if (pathChanged) {\n\n          //Copy new path and broadcast path change\n          this.path = path.clone();\n          this.broadcast('pathChange', node);\n\n          //Named node reached? Broadcast event\n          if (node.name) {\n            this.broadcast('reachedNode.' + node.name, node);\n          }\n        }\n\n        //Passed?\n        if (node.move && node.move.pass) {\n          this.broadcast('movePassed', node);\n        }\n      },\n\n      /**\n       * Show move numbers\n       */\n      showMoveNumbers: function(fromMove, toMove) {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Use sensible defaults if no from/to moves given\n        fromMove = fromMove || 1;\n        toMove = toMove || this.game.getMove();\n\n        //Get nodes for these moves\n        let nodes = this.game.getMoveNodes(fromMove, toMove);\n        let move = fromMove;\n\n        //Loop nodes\n        angular.forEach(nodes, function(node) {\n          this.board.add('markup', node.move.x, node.move.y, {\n            type: MarkupTypes.LABEL,\n            text: move++,\n          });\n        }, this);\n\n        //Redraw board markup\n        this.board.redraw('markup');\n      },\n\n      /*****************************************************************************\n       * Game handling\n       ***/\n\n      /**\n       * Start a new game\n       */\n      newGame: function() {\n        this.game = new Game();\n        this.processPosition();\n      },\n\n      /**\n       * Score the current game position\n       */\n      scoreGame: function() {\n\n        //Calculate score\n        GameScorer.calculate();\n\n        //Get score, points and captures\n        let score = GameScorer.getScore();\n        let points = GameScorer.getPoints();\n        let captures = GameScorer.getCaptures();\n\n        //Remove all markup, and set captures and points\n        this.board.layers.markup.removeAll();\n        this.board.layers.score.setAll(points, captures);\n\n        //Broadcast score\n        this.broadcast('scoreCalculated', score);\n      },\n\n      /*****************************************************************************\n       * Board handling\n       ***/\n\n      /**\n       * Get the board\n       */\n      getBoard: function() {\n        return this.board;\n      },\n\n      /**\n       * Set the board\n       */\n      setBoard: function(Board) {\n\n        //Set the board\n        this.board = Board;\n\n        //Board ready\n        if (this.board) {\n          this.broadcast('boardReady', this.board);\n        }\n\n        //If a game has been loaded already, parse config and update the board\n        if (this.game && this.game.isLoaded()) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Update the board\n       */\n      updateBoard: function(node, position, pathChanged) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Update board with new position\n        this.board.updatePosition(position, pathChanged);\n\n        //Mark last move\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\n        }\n\n        //Broadcast board update event\n        this.broadcast('boardUpdate', node);\n      },\n\n      /*****************************************************************************\n       * Event handling\n       ***/\n\n      /**\n       * Register an element event\n       */\n      registerElementEvent: function(event, element) {\n\n        //Which element to use\n        if (typeof element === 'undefined' || !element.on) {\n          element = this.element;\n        }\n\n        //Remove any existing event listener and apply new one\n        //TODO: Namespacing events doesn't work with Angular's jqLite\n        element.off(event/* + '.ngGo.player'*/);\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\n      },\n\n      /**\n       * Event listener\n       */\n      on: function(type, listener, mode, $scope) {\n\n        //Must have valid listener\n        if (typeof listener !== 'function') {\n          throw new Error('Listener is not a function: ' + listener);\n        }\n\n        //Scope given as 3rd parameter?\n        if (mode && mode.$parent) {\n          $scope = mode;\n          mode = '';\n        }\n\n        //Multiple events?\n        if (type.indexOf(' ') !== -1) {\n          let types = type.split(' ');\n          for (let t = 0; t < types.length; t++) {\n            this.on(types[t], listener, mode, $scope);\n          }\n          return;\n        }\n\n        //Get self and determine scope to use\n        let self = this;\n        let scope = $scope || $rootScope;\n\n        //Create listener and return de-registration function\n        return scope.$on('ngGo.player.' + type, function() {\n\n          //Filter on mode\n          if (mode) {\n            if (\n              (typeof mode === 'string' && mode !== self.mode) ||\n              mode.indexOf(self.mode) === -1\n            ) {\n              return;\n            }\n          }\n\n          //Inside a text field?\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\n            return;\n          }\n\n          //Append grid coordinates for mouse events\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\n            processMouseEvent.call(self, arguments[0], arguments[1]);\n          }\n\n          //Dragging? Prevent click events from firing\n          if (self.preventClickEvent && type === 'click') {\n            delete self.preventClickEvent;\n            return;\n          }\n          else if (type === 'mousedrag') {\n            self.preventClickEvent = true;\n          }\n\n          //Call listener\n          listener.apply(self, arguments);\n        });\n      },\n\n      /**\n       * Event broadcaster\n       */\n      broadcast: function(type, args) {\n\n        //Must have type\n        if (!type) {\n          return;\n        }\n\n        //Make sure we are in a digest cycle\n        if (!$rootScope.$$phase) {\n          $rootScope.$apply(function() {\n            $rootScope.$broadcast('ngGo.player.' + type, args);\n          });\n        }\n        else {\n          $rootScope.$broadcast('ngGo.player.' + type, args);\n        }\n      },\n    };\n\n    //Initialize\n    Player.init();\n\n    //Return object\n    return Player;\n  };\n});\n","\n/**\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\n * gridlines, starpoints and coordinates via the Coordinates class.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Coordinates.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('GridLayer', function(BoardLayer, Coordinates) {\n\n  /**\n   * Helper for drawing starpoints\n   */\n  function drawStarPoint(gridX, gridY, starRadius, starColor) {\n\n    //Don't draw if it falls outsize of the board grid\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\n      return;\n    }\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\n      return;\n    }\n\n    //Get absolute coordinates and star point radius\n    let x = this.board.getAbsX(gridX);\n    let y = this.board.getAbsY(gridY);\n\n    //Draw star point\n    this.context.beginPath();\n    this.context.fillStyle = starColor;\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\n    this.context.fill();\n  }\n\n  /**\n   * Constructor\n   */\n  function GridLayer(board, context) {\n\n    //Set coordinates setting\n    this.coordinates = false;\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Show or hide the coordinates.\n   */\n  GridLayer.prototype.setCoordinates = function(show) {\n    this.coordinates = show;\n  };\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Get all has nothing to return\n   */\n  GridLayer.prototype.getAll = function() {\n    return null;\n  };\n\n  /**\n   * Set all has nothing to set\n   */\n  GridLayer.prototype.setAll = function(/*grid*/) {\n    return;\n  };\n\n  /**\n   * Remove all has nothing to remove\n   */\n  GridLayer.prototype.removeAll = function() {\n    return;\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw method\n   */\n  GridLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Determine top x and y margin\n    let tx = this.board.drawMarginHor;\n    let ty = this.board.drawMarginVer;\n\n    //Get theme properties\n    let cellSize = this.board.getCellSize();\n    let lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\n    let lineCap = this.board.theme.get('grid.lineCap');\n    let strokeStyle = this.board.theme.get('grid.lineColor');\n    let starRadius = this.board.theme.get('grid.star.radius', cellSize);\n    let starColor = this.board.theme.get('grid.star.color');\n    let starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n    let canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n    this.context.strokeStyle = strokeStyle;\n\n    //Helper vars\n    let i, x, y;\n\n    //Draw vertical lines\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\n      x = this.board.getAbsX(i);\n      this.context.moveTo(x, ty);\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\n    }\n\n    //Draw horizontal lines\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\n      y = this.board.getAbsY(i);\n      this.context.moveTo(tx, y);\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\n    }\n\n    //Draw grid lines\n    this.context.stroke();\n\n    //Star points defined?\n    for (i = 0; i < starPoints.length; i++) {\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n\n    //Draw coordinates\n    if (this.coordinates) {\n      Coordinates.draw.call(this);\n    }\n  };\n\n  /**\n   * Clear a square cell area on the grid\n   */\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    let x = this.board.getAbsX(gridX);\n    let y = this.board.getAbsY(gridY);\n    let s = this.board.getCellSize();\n    let r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    let lineWidth = this.board.theme.get('grid.lineWidth', s);\n    let canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Clear rectangle\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Redraw a square cell area on the grid\n   */\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    let x = this.board.getAbsX(gridX);\n    let y = this.board.getAbsY(gridY);\n    let s = this.board.getCellSize();\n    let r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    let lineWidth = this.board.theme.get('grid.lineWidth', s);\n    let strokeStyle = this.board.theme.get('grid.lineColor');\n    let starRadius = this.board.theme.get('grid.star.radius', s);\n    let starColor = this.board.theme.get('grid.star.color');\n    let canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n    let starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n\n    //Determine draw coordinates\n    let x1 = (gridX === 0) ? x : x - r;\n    let x2 = (gridX === this.board.width - 1) ? x : x + r;\n    let y1 = (gridY === 0) ? y : y - r;\n    let y2 = (gridY === this.board.height - 1) ? y : y + r;\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Patch up grid lines\n    this.context.moveTo(x1, y);\n    this.context.lineTo(x2, y);\n    this.context.moveTo(x, y1);\n    this.context.lineTo(x, y2);\n    this.context.stroke();\n\n    //Check if we need to draw a star point here\n    for (let i in starPoints) {\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\n      }\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  //Return\n  return GridLayer;\n});\n","\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.StoneFaded.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('HoverLayer', function(BoardLayer, Markup, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  function HoverLayer(board, context) {\n\n    //Container for items to restore\n    this.restore = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add hover item\n   */\n  HoverLayer.prototype.add = function(x, y, hover) {\n\n    //Validate coordinates\n    if (!this.grid.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Remove any previous item at this position\n    this.remove(x, y);\n\n    //Create hover object\n    hover.object = {\n      x: x,\n      y: y,\n    };\n\n    //Stones\n    if (hover.type === 'stones') {\n      hover.objectClass = StoneFaded;\n      hover.object.color = hover.value;\n    }\n\n    //Markup\n    else if (hover.type === 'markup') {\n      hover.objectClass = Markup;\n      if (typeof hover.value === 'object') {\n        hover.object = angular.extend(hover.object, hover.value);\n      }\n      else {\n        hover.object.type = hover.value;\n      }\n    }\n\n    //Unknown\n    else {\n      throw new Error('Unknown hover type ' + hover.type);\n    }\n\n    //Check if we need to hide something on layers underneath\n    if (this.board.has(hover.type, x, y)) {\n      this.restore.push({\n        x: x,\n        y: y,\n        layer: hover.type,\n        value: this.board.get(hover.type, x, y),\n      });\n      this.board.remove(hover.type, x, y);\n    }\n\n    //Add to stack\n    this.grid.set(x, y, hover);\n\n    //Draw item\n    if (hover.objectClass && hover.objectClass.draw) {\n      hover.objectClass.draw.call(this, hover.object);\n    }\n  };\n\n  /**\n   * Remove the hover object\n   */\n  HoverLayer.prototype.remove = function(x, y) {\n\n    //Validate coordinates\n    if (!this.grid.has(x, y)) {\n      return;\n    }\n\n    //Get object and clear it\n    let hover = this.grid.get(x, y);\n    if (hover.objectClass && hover.objectClass.clear) {\n      hover.objectClass.clear.call(this, hover.object);\n    }\n\n    //Other objects to restore?\n    for (let i = 0; i < this.restore.length; i++) {\n      if (this.restore[i].x === x && this.restore[i].y === y) {\n        this.board.add(\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n        );\n        this.restore.splice(i, 1);\n      }\n    }\n  };\n\n  /**\n   * Remove all hover objects\n   */\n  HoverLayer.prototype.removeAll = function() {\n\n    //Anything to do?\n    if (this.grid.isEmpty()) {\n      return;\n    }\n\n    //Get all item as objects\n    let i;\n    let hover = this.grid.all('layer');\n\n    //Clear them\n    for (i = 0; i < hover.length; i++) {\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\n        hover[i].objectClass.clear.call(this, hover[i].object);\n      }\n    }\n\n    //Clear layer and empty grid\n    this.clear();\n    this.grid.empty();\n\n    //Restore objects on other layers\n    for (i = 0; i < this.restore.length; i++) {\n      this.board.add(\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n      );\n    }\n\n    //Clear restore array\n    this.restore = [];\n  };\n\n  /**\n   * Draw layer\n   */\n  HoverLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Loop objects and clear them\n    let hover = this.grid.all('hover');\n    for (let i = 0; i < hover.length; i++) {\n      if (hover.objectClass && hover.objectClass.draw) {\n        hover.objectClass.draw.call(this, hover.object);\n      }\n    }\n  };\n\n  //Return\n  return HoverLayer;\n});\n","\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('MarkupLayer', function(BoardLayer, Markup) {\n\n  /**\n   * Constructor\n   */\n  function MarkupLayer(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all markup at once\n   */\n  MarkupLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    let i;\n    let changes = this.grid.compare(grid, 'type');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Markup.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Markup.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  MarkupLayer.prototype.removeAll = function() {\n\n    //Get all markup as objects\n    let markup = this.grid.all('type');\n\n    //Clear them\n    for (let i = 0; i < markup.length; i++) {\n      Markup.clear.call(this, markup[i]);\n    }\n\n    //Empty the grid now\n    this.grid.empty();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  MarkupLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all markup as objects\n    let markup = this.grid.all('type');\n\n    //Draw them\n    for (let i = 0; i < markup.length; i++) {\n      Markup.draw.call(this, markup[i]);\n    }\n  };\n\n  /**\n   * Draw cell\n   */\n  MarkupLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  MarkupLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  //Return\n  return MarkupLayer;\n});\n","\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('ScoreLayer', function(BoardLayer, StoneMini, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  function ScoreLayer(board, context) {\n\n    //Points and captures\n    this.points = [];\n    this.captures = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set points and captures\n   */\n  ScoreLayer.prototype.setAll = function(points, captures) {\n\n    //Remove all existing stuff first\n    this.removeAll();\n\n    //Set new stuff\n    this.points = points.all('color');\n    this.captures = captures.all('color');\n\n    //Draw\n    this.draw();\n  };\n\n  /**\n   * Remove all scoring\n   */\n  ScoreLayer.prototype.removeAll = function() {\n\n    //If there are captures, draw them back onto the stones layer\n    for (let i = 0; i < this.captures.length; i++) {\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\n    }\n\n    //Clear the layer\n    this.clear();\n\n    //Remove all stuff\n    this.points = [];\n    this.captures = [];\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  ScoreLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Init\n    let i;\n\n    //Draw captures first (removing stones from the stones layer)\n    for (i = 0; i < this.captures.length; i++) {\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\n      StoneFaded.draw.call(this, this.captures[i]);\n    }\n\n    //Draw points on top of it\n    for (i = 0; i < this.points.length; i++) {\n      StoneMini.draw.call(this, this.points[i]);\n    }\n  };\n\n  //Return\n  return ScoreLayer;\n});\n","\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneShadow.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('ShadowLayer', function(BoardLayer, StoneShadow) {\n\n  /**\n   * Constructor\n   */\n  function ShadowLayer(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add a stone\n   */\n  ShadowLayer.prototype.add = function(stone) {\n\n    //Don't add if no shadow\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\n      return;\n    }\n\n    //Already have a stone here?\n    if (this.grid.has(stone.x, stone.y)) {\n      return;\n    }\n\n    //Add to grid\n    this.grid.set(stone.x, stone.y, stone.color);\n\n    //Draw it if there is a context\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\n      StoneShadow.draw.call(this, stone);\n    }\n  };\n\n  /**\n   * Remove a stone\n   */\n  ShadowLayer.prototype.remove = function(stone) {\n\n    //Remove from grid\n    this.grid.unset(stone.x, stone.y);\n\n    //Redraw whole layer\n    this.redraw();\n  };\n\n  /**\n   * Draw layer\n   */\n  ShadowLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get shadowsize from theme\n    let shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\n\n    //Apply shadow transformation\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\n\n    //Get all stones as objects\n    let stones = this.grid.all('color');\n\n    //Draw them\n    for (let i = 0; i < stones.length; i++) {\n      StoneShadow.draw.call(this, stones[i]);\n    }\n  };\n\n  //Return\n  return ShadowLayer;\n});\n","\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Stone.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('StonesLayer', function(BoardLayer, Stone, StoneColor) {\n\n  /**\n   * Constructor\n   */\n  function StonesLayer(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n\n    //Set empty value for grid\n    this.grid.whenEmpty(StoneColor.EMPTY);\n  }\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all stones at once\n   */\n  StonesLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    let i;\n    let changes = this.grid.compare(grid, 'color');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Stone.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Stone.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  StonesLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all stones as objects\n    let stones = this.grid.all('color');\n\n    //Draw them\n    for (let i = 0; i < stones.length; i++) {\n      Stone.draw.call(this, stones[i]);\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  StonesLayer.prototype.redraw = function() {\n\n    //Clear shadows layer\n    this.board.removeAll('shadow');\n\n    //Redraw ourselves\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  StonesLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  StonesLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  //Return\n  return StonesLayer;\n});\n","\n/**\n * Coordinates :: This class is used for drawing board coordinates\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Coordinates.Service', [\n  'ngGo',\n])\n\n/**\n * Factory definition\n */\n.factory('Coordinates', function() {\n\n  //Kanji\n  let kanji = [\n    '一', '二', '三', '四', '五', '六', '七', '八', '九', '十',\n    '十一', '十二', '十三', '十四', '十五', '十六', '十七', '十八', '十九', '二十',\n    '二十一', '二十二', '二十三', '二十四', '二十五', '二十六', '二十七', '二十八', '二十九', '三十',\n    '三十一', '三十二', '三十三', '三十四', '三十五', '三十六', '三十七', '三十八', '三十九', '四十',\n  ];\n\n  //Character codes\n  let aChar = 'A'.charCodeAt(0);\n  let aCharLc = 'a'.charCodeAt(0);\n\n  /**\n   * Coordinate generators\n   */\n  let coordinates = {\n\n    //Kanji coordinates\n    kanji: function(i) {\n      return kanji[i] || '';\n    },\n\n    //Numbers from 1\n    numbers: function(i) {\n      return i + 1;\n    },\n\n    //Capital letters from A\n    letters: function(i) {\n\n      //Initialize\n      let ch = '';\n\n      //Beyond Z? Prepend with A\n      if (i >= 25) {\n        ch = 'A';\n        i -= 25;\n      }\n\n      //The letter I is ommitted\n      if (i >= 8) {\n        i++;\n      }\n\n      //Return\n      return ch + String.fromCharCode(aChar + i);\n    },\n\n    //JGF coordinates (e.g. 0, 1, ...)\n    jgf: function(i) {\n      return i;\n    },\n\n    //SGF coordinates (e.g. a, b, ...)\n    sgf: function(i) {\n      let ch;\n      if (i < 26) {\n        ch = aCharLc + i;\n      }\n      else {\n        ch = aChar + i;\n      }\n      return String.fromCharCode(ch);\n    },\n  };\n\n  /**\n   * Coordinates object\n   */\n  let Coordinates = {\n\n    /**\n     * Draw\n     */\n    draw: function() {\n\n      //Can only draw when we have context and dimensions\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Get cell size\n      let cellSize = this.board.getCellSize();\n\n      //Get boundary coordinates\n      let xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\n      let xr = this.board.drawWidth - xl;\n      let yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\n      let yb = this.board.drawHeight - yt;\n\n      //Get theme properties\n      let fillStyle = this.board.theme.get('coordinates.color');\n      let vertical = {\n        font: this.board.theme.get('coordinates.vertical.font'),\n        size: this.board.theme.get('coordinates.vertical.size'),\n        style: this.board.theme.get('coordinates.vertical.style'),\n        inverse: this.board.theme.get('coordinates.vertical.inverse'),\n      };\n      let horizontal = {\n        font: this.board.theme.get('coordinates.horizontal.font'),\n        size: this.board.theme.get('coordinates.horizontal.size'),\n        style: this.board.theme.get('coordinates.horizontal.style'),\n        inverse: this.board.theme.get('coordinates.horizontal.inverse'),\n      };\n\n      //Configure context\n      this.context.fillStyle = fillStyle;\n      this.context.textBaseline = 'middle';\n      this.context.textAlign = 'center';\n\n      //Helper vars\n      let i, j, x, y, ch;\n\n      //Draw vertical coordinates\n      for (i = 0; i < this.board.height; i++) {\n\n        //Inverse?\n        j = i;\n        if (vertical.inverse) {\n          j = this.board.height - i - 1;\n        }\n\n        //Get character\n        if (typeof vertical.style === 'function') {\n          ch = vertical.style.call(this, j);\n        }\n        else if (coordinates[vertical.style]) {\n          ch = coordinates[vertical.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        y = this.board.getAbsY(i);\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\n        this.context.fillText(ch, xl, y);\n        this.context.fillText(ch, xr, y);\n      }\n\n      //Draw horizontal coordinates\n      for (i = 0; i < this.board.width; i++) {\n\n        //Inverse?\n        j = i;\n        if (horizontal.inverse) {\n          j = this.board.width - i - 1;\n        }\n\n        //Get character\n        if (typeof horizontal.style === 'function') {\n          ch = horizontal.style.call(this, j);\n        }\n        else if (coordinates[horizontal.style]) {\n          ch = coordinates[horizontal.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        x = this.board.getAbsX(i);\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\n        this.context.fillText(ch, x, yt);\n        this.context.fillText(ch, x, yb);\n      }\n    },\n  };\n\n  //Return\n  return Coordinates;\n});\n","\n/**\n * Markup :: This class is used for drawing markup\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Markup.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('Markup', function(MarkupTypes, BoardObject) {\n\n  /**\n   * Math constants\n   */\n  let cosPi4 = Math.cos(Math.PI / 4);\n  let cosPi6 = Math.cos(Math.PI / 6);\n\n  /**\n   * Triangle draw handler\n   */\n  function drawTriangle(markup) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(markup.x);\n    let y = this.board.getAbsY(markup.y);\n    let s = this.board.getCellSize();\n    let r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    let stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    let lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    let strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    let canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y - r);\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.closePath();\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Square draw handler\n   */\n  function drawSquare(markup) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(markup.x);\n    let y = this.board.getAbsY(markup.y);\n    let s = this.board.getCellSize();\n    let r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    let rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    let stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    let lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    let strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    let canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw circle handler\n   */\n  function drawCircle(markup) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(markup.x);\n    let y = this.board.getAbsY(markup.y);\n    let s = this.board.getCellSize();\n    let r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    let stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    let lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    let strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    let canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw mark handler\n   */\n  function drawMark(markup) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(markup.x);\n    let y = this.board.getAbsY(markup.y);\n    let s = this.board.getCellSize();\n    let r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    let rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    let stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    let lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    let lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\n    let strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    let canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x - rcos, y - rcos);\n    this.context.lineTo(x + rcos, y + rcos);\n    this.context.moveTo(x + rcos, y - rcos);\n    this.context.lineTo(x - rcos, y + rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw select handler\n   */\n  function drawSelect(markup) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(markup.x);\n    let y = this.board.getAbsY(markup.y);\n    let s = this.board.getCellSize();\n    let r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    let stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    let lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    let fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    let canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Last move draw handler\n   */\n  function drawLast(markup) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(markup.x);\n    let y = this.board.getAbsY(markup.y);\n    let s = this.board.getCellSize();\n    let r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    let stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    let fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    let canvasTranslate = this.board.theme.canvasTranslate(s);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y);\n    this.context.lineTo(x + r, y);\n    this.context.lineTo(x, y + r);\n    this.context.closePath();\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw happy smiley handler\n   */\n  function drawHappySmiley(markup) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(markup.x);\n    let y = this.board.getAbsY(markup.y);\n    let s = this.board.getCellSize();\n    let r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    let stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    let lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    let lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    let strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    let canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 8);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw sad smiley handler\n   */\n  function drawSadSmiley(markup) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(markup.x);\n    let y = this.board.getAbsY(markup.y);\n    let s = this.board.getCellSize();\n    let r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    let stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    let lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    let lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    let strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    let canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Draw label\n   */\n  function drawLabel(markup) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(markup.x);\n    let y = this.board.getAbsY(markup.y);\n    let s = this.board.getCellSize();\n    let r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    let stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    let font = markup.font || this.board.theme.get('markup.label.font') || '';\n    let fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    let canvasTranslate = this.board.theme.canvasTranslate();\n\n    //First, clear grid square below for clarity\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.clearCell(markup.x, markup.y);\n    }\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.textBaseline = 'middle';\n    this.context.textAlign = 'center';\n\n    //Convert to text\n    if (typeof markup.text === 'number') {\n      markup.text = markup.text.toString();\n    }\n\n    //Determine font size\n    if (markup.text.length === 1) {\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\n    }\n    else if (markup.text.length === 2) {\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\n    }\n    else {\n      this.context.font = r + 'px ' + font;\n    }\n\n    //Draw element\n    this.context.beginPath();\n    this.context.fillText(markup.text, x, y, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Clear label\n   */\n  function clearLabel(markup) {\n\n    //No stone on location? Redraw the grid square, if we cleared it\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\n    }\n  }\n\n  /**\n   * Markup class\n   */\n  let Markup = {\n\n    /**\n     * Draw\n     */\n    draw: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Drawing depends on type\n      switch (markup.type) {\n\n        //Triangle\n        case MarkupTypes.TRIANGLE:\n          drawTriangle.call(this, markup);\n          break;\n\n        //Square\n        case MarkupTypes.SQUARE:\n          drawSquare.call(this, markup);\n          break;\n\n        //Circle\n        case MarkupTypes.CIRCLE:\n          drawCircle.call(this, markup);\n          break;\n\n        //Mark\n        case MarkupTypes.MARK:\n          drawMark.call(this, markup);\n          break;\n\n        //Select\n        case MarkupTypes.SELECT:\n          drawSelect.call(this, markup);\n          break;\n\n        //happy\n        case MarkupTypes.HAPPY:\n          drawHappySmiley.call(this, markup);\n          break;\n\n        //Sad\n        case MarkupTypes.SAD:\n          drawSadSmiley.call(this, markup);\n          break;\n\n        //Last move marker\n        case MarkupTypes.LAST:\n          drawLast.call(this, markup);\n          break;\n\n        //Label\n        case MarkupTypes.LABEL:\n          markup.text = markup.text || '';\n          drawLabel.call(this, markup);\n          break;\n      }\n    },\n\n    /**\n     * Clear\n     */\n    clear: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, markup);\n\n      //Special handling for label\n      if (markup.type === MarkupTypes.LABEL) {\n        clearLabel.call(this, markup);\n      }\n    },\n  };\n\n  //Return\n  return Markup;\n});\n","\n/**\n * Stone :: This class is used for drawing stones on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Stone.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n  'ngGo.Board.ShellPattern.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('Stone', function($injector, BoardObject, StoneColor, ShellPattern) {\n\n  /**\n   * Shell random seed\n   */\n  let shellSeed;\n\n  /**\n   * Mono colored stones\n   */\n  function drawMono(stone) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(stone.x);\n    let y = this.board.getAbsY(stone.y);\n    let s = this.board.getCellSize();\n    let r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Don't draw shadow\n    stone.shadow = false;\n\n    //Apply color multiplier\n    let color = stone.color * this.board.colorMultiplier;\n\n    //Get theme properties\n    let lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\n    let fillStyle = this.board.theme.get('stone.mono.color', color);\n    let strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\n    let canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Configure context\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Draw outline\n    this.context.stroke();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Glass stones\n   */\n  function drawGlass(stone) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(stone.x);\n    let y = this.board.getAbsY(stone.y);\n    let s = this.board.getCellSize();\n    let r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Apply color multiplier\n    let color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    let canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Begin path\n    this.context.beginPath();\n\n    //Determine stone texture\n    if (color === StoneColor.W) {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#fff');\n      this.context.fillStyle.addColorStop(1, '#aaa');\n    }\n    else {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#666');\n      this.context.fillStyle.addColorStop(1, '#111');\n    }\n\n    //Complete drawing\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Slate and shell stones\n   */\n  function drawSlateShell(stone) {\n\n    //Get coordinates and stone radius\n    let x = this.board.getAbsX(stone.x);\n    let y = this.board.getAbsY(stone.y);\n    let s = this.board.getCellSize();\n    let r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Get random seed\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\n\n    //Apply color multiplier\n    let color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    let shellTypes = this.board.theme.get('stone.shell.types');\n    let fillStyle = this.board.theme.get('stone.shell.color', color);\n    let strokeStyle = this.board.theme.get('stone.shell.stroke');\n    let canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fillStyle = fillStyle;\n    this.context.fill();\n\n    //Shell stones\n    if (color === StoneColor.W) {\n\n      //Get random shell type\n      let type =\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\n\n      //Determine random angle\n      let z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\n      let angle = (2 / z) * (shellSeed % z);\n\n      //Draw shell pattern\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Slate stones\n    else {\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  }\n\n  /**\n   * Constructor\n   */\n  let Stone = {\n\n    /**\n     * Draw a stone\n     */\n    draw: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Determine style of stone\n      let style = this.board.theme.get('stone.style');\n\n      //Draw using the appropriate handler\n      switch (style) {\n\n        //Slate and shell\n        case 'shell':\n          drawSlateShell.call(this, stone);\n          break;\n\n        //Glass stones\n        case 'glass':\n          drawGlass.call(this, stone);\n          break;\n\n        //Mono stones\n        case 'mono':\n          drawMono.call(this, stone);\n          break;\n\n        //Custom type\n        default:\n          let handler = $injector.get(style);\n          if (handler) {\n            handler.call(this, stone);\n          }\n      }\n\n      //Add shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.add(stone);\n      }\n    },\n\n    /**\n     * Clear a stone\n     */\n    clear: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, stone);\n\n      //Remove shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.remove(stone);\n      }\n    },\n  };\n\n  //Return\n  return Stone;\n});\n","\n/**\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('StoneFaded', function(Stone) {\n\n  /**\n   * Class\n   */\n  let StoneFaded = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.faded.scale');\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    },\n  };\n\n  //Return\n  return StoneFaded;\n});\n","\n/**\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\n * (for scoring).\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneMini.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('StoneMini', function(Stone) {\n\n  /**\n   * Class\n   */\n  let StoneMini = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.mini.scale');\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    },\n  };\n\n  //Return\n  return StoneMini;\n});\n","\n/**\n * StoneShadow :: This class is used for drawing stone shadows on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('StoneShadow', function() {\n\n  /**\n   * Constructor\n   */\n  let StoneShadow = {\n\n    /**\n     * Draw a stone shadow\n     */\n    draw: function(stone) {\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      let x = this.board.getAbsX(stone.x);\n      let y = this.board.getAbsY(stone.y);\n      let s = this.board.getCellSize();\n      let r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\n\n      //Apply scaling factor?\n      if (stone.scale) {\n        r = Math.round(r * stone.scale);\n      }\n\n      //Get theme properties\n      let blur = this.board.theme.get('shadow.blur', s);\n      let offsetX = this.board.theme.get('shadow.offsetX', s);\n      let offsetY = this.board.theme.get('shadow.offsetY', s);\n      let shadowColor = this.board.theme.get('shadow.color');\n\n      //Configure context\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\n      );\n      this.context.fillStyle.addColorStop(0, shadowColor);\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n\n      //Draw shadow\n      this.context.beginPath();\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\n      this.context.fill();\n    },\n\n    /**\n     * Clear a stone shadow\n     */\n    clear: function(stone) {\n\n      //Note: this method is currently not in use due to the overlapping shadows\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\n      //appropriate either, so for now we will leave it at this.\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      let x = this.board.getAbsX(stone.x);\n      let y = this.board.getAbsY(stone.y);\n      let s = this.board.getCellSize();\n      let r = this.board.theme.get('stone.radius', s);\n\n      //Clear a generous rectangle\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\n    },\n  };\n\n  //Return\n  return StoneShadow;\n});\n","\n/**\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('Gib2Jgf', function(ngGo, KifuBlank) {\n\n  /**\n   * Regular expressions\n   */\n  let regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\n  let regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\n  let regKomi = /GAMEGONGJE=([0-9]+)/gi;\n  let regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\n  let regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\n  let regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\n\n  /**\n   * Player parser function\n   */\n  function parsePlayer(jgf, match) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    let color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\n\n    //Create player object\n    let player = {\n      color: color,\n      name: match[2],\n      rank: match[3].toLowerCase(),\n    };\n\n    //Check if player of this color already exists, if so, overwrite\n    for (let p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p] = player;\n        return;\n      }\n    }\n\n    //Player of this color not found, push\n    jgf.game.players.push(player);\n  }\n\n  /**\n   * Komi parser function\n   */\n  function parseKomi(jgf, match) {\n    jgf.game.komi = parseFloat(match[1] / 10);\n  }\n\n  /**\n   * Date parser function\n   */\n  function parseDate(jgf, match) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Push date\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\n  }\n\n  /**\n   * Result parser function\n   */\n  function parseResult(jgf, match) {\n\n    //Winner color\n    let result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\n    result += '+';\n\n    //Win condition\n    if (match[2].match(/res/i)) {\n      result += 'R';\n    }\n    else if (match[2].match(/time/i)) {\n      result += 'T';\n    }\n    else {\n      result += match[2];\n    }\n\n    //Set in JGF\n    jgf.game.result = result;\n  }\n\n  /**\n   * Move parser function\n   */\n  function parseMove(jgf, node, match) {\n\n    //Determine player color\n    let color = match[2];\n    if (color === 1) {\n      color = 'B';\n    }\n    else if (color === 2) {\n      color = 'W';\n    }\n    else {\n      return;\n    }\n\n    //Create move container\n    node.move = {};\n    node.move[color] = [Number(match[3]), Number(match[4])];\n  }\n\n  /**\n   * Parser class\n   */\n  let Parser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    parse: function(gib, stringified) {\n\n      //Get new JGF object\n      let jgf = KifuBlank.jgf();\n\n      //Initialize\n      let match;\n      let container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      let node = {root: true};\n      container.push(node);\n\n      //Find player information\n      while ((match = regPlayer.exec(gib))) {\n        parsePlayer(jgf, match);\n      }\n\n      //Find komi\n      if ((match = regKomi.exec(gib))) {\n        parseKomi(jgf, match);\n      }\n\n      //Find game date\n      if ((match = regDate.exec(gib))) {\n        parseDate(jgf, match);\n      }\n\n      //Find game result\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\n        parseResult(jgf, match);\n      }\n\n      //Find moves\n      while ((match = regMove.exec(gib))) {\n\n        //Create new node\n        node = {};\n\n        //Parse move\n        parseMove(jgf, node, match);\n\n        //Push node to container\n        container.push(node);\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    },\n  };\n\n  //Return object\n  return Parser;\n});\n","\n/**\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('Jgf2Sgf', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Flip SGF alias map and create JGF alias map\n   */\n  let jgfAliases = {};\n  for (let sgfProp in sgfAliases) {\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\n    }\n  }\n\n  /**\n   * Character index of \"a\"\n   */\n  let aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert to SGF coordinates\n   */\n  function convertCoordinates(coords) {\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\n  }\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Helper to escape SGF info\n   */\n  function escapeSgf(text) {\n    if (typeof text === 'string') {\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\n    }\n    return text;\n  }\n\n  /**\n   * Helper to write an SGF group\n   */\n  function writeGroup(prop, values, output, escape) {\n    if (values.length) {\n      output.sgf += prop;\n      for (let i = 0; i < values.length; i++) {\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\n      }\n    }\n  }\n\n  /**\n   * Move parser\n   */\n  function parseMove(move, output) {\n\n    //Determine and validate color\n    let color = move.B ? 'B' : (move.W ? 'W' : '');\n    if (color === '') {\n      return;\n    }\n\n    //Determine move\n    let coords = (move[color] === 'pass') ? '' : move[color];\n\n    //Append to SGF\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\n  }\n\n  /**\n   * Setup parser\n   */\n  function parseSetup(setup, output) {\n\n    //Loop colors\n    for (let color in setup) {\n      if (setup.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (let i = 0; i < setup[color].length; i++) {\n          setup[color][i] = convertCoordinates(setup[color][i]);\n        }\n\n        //Write as group\n        writeGroup('A' + color, setup[color], output);\n      }\n    }\n  }\n\n  /**\n   * Score parser\n   */\n  function parseScore(score, output) {\n\n    //Loop colors\n    for (let color in score) {\n      if (score.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (let i = 0; i < score[color].length; i++) {\n          score[color][i] = convertCoordinates(score[color][i]);\n        }\n\n        //Write as group\n        writeGroup('T' + color, score[color], output);\n      }\n    }\n  }\n\n  /**\n   * Markup parser\n   */\n  function parseMarkup(markup, output) {\n\n    //Loop markup types\n    for (let type in markup) {\n      if (markup.hasOwnProperty(type)) {\n        let i;\n\n        //Label type has the label text appended to the coords\n        if (type === 'label') {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\n          }\n        }\n        else {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]);\n          }\n        }\n\n        //Convert type\n        if (typeof jgfAliases[type] !== 'undefined') {\n          type = jgfAliases[type];\n        }\n\n        //Write as group\n        writeGroup(type, markup[type], output);\n      }\n    }\n  }\n\n  /**\n   * Turn parser\n   */\n  function parseTurn(turn, output) {\n    output.sgf += 'PL[' + turn + ']';\n  }\n\n  /**\n   * Comments parser\n   */\n  function parseComments(comments, output) {\n\n    //Determine key\n    let key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\n\n    //Flatten comment objects\n    let flatComments = [];\n    for (let c = 0; c < comments.length; c++) {\n      if (typeof comments[c] === 'string') {\n        flatComments.push(comments[c]);\n      }\n      else if (comments[c].comment) {\n        flatComments.push(comments[c].comment);\n      }\n    }\n\n    //Write as group\n    writeGroup(key, flatComments, output, true);\n  }\n\n  /**\n   * Node name parser\n   */\n  function parseNodeName(nodeName, output) {\n    let key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\n  }\n\n  /**\n   * Game parser\n   */\n  function parseGame(game) {\n\n    //Loop SGF game definitions\n    for (let i in sgfGames) {\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\n        return i;\n      }\n    }\n\n    //Not found\n    return 0;\n  }\n\n  /**\n   * Application parser\n   */\n  function parseApplication(application) {\n    let parts = application.split(' v');\n    if (parts.length > 1) {\n      return parts[0] + ':' + parts[1];\n    }\n    return application;\n  }\n\n  /**\n   * Player instructions parser\n   */\n  function parsePlayer(player, rootProperties) {\n\n    //Variation handling\n    let st = 0;\n    if (!player.variationMarkup) {\n      st += 2;\n    }\n    if (player.variationSiblings) {\n      st += 1;\n    }\n\n    //Set in root properties\n    rootProperties.ST = st;\n  }\n\n  /**\n   * Board parser\n   */\n  function parseBoard(board, rootProperties) {\n\n    //Both width and height should be given\n    if (board.width && board.height) {\n\n      //Same dimensions?\n      if (board.width === board.height) {\n        rootProperties.SZ = board.width;\n      }\n\n      //Different dimensions are not supported by SGF, but OGS uses the\n      //format w:h, so we will stick with that for anyone who supports it.\n      else {\n        rootProperties.SZ = board.width + ':' + board.height;\n      }\n    }\n\n    //Otherwise, check if only width or height were given at least\n    else if (board.width) {\n      rootProperties.SZ = board.width;\n    }\n    else if (board.height) {\n      rootProperties.SZ = board.height;\n    }\n\n    //Can't determine size\n    else {\n      rootProperties.SZ = '';\n    }\n  }\n\n  /**\n   * Players parser\n   */\n  function parsePlayers(players, rootProperties) {\n\n    //Loop players\n    for (let p = 0; p < players.length; p++) {\n\n      //Validate color\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\n        continue;\n      }\n\n      //Get SGF color\n      let color = (players[p].color === 'black') ? 'B' : 'W';\n\n      //Name given?\n      if (players[p].name) {\n        rootProperties['P' + color] = players[p].name;\n      }\n\n      //Rank given?\n      if (players[p].rank) {\n        rootProperties[color + 'R'] = players[p].rank;\n      }\n\n      //Team given?\n      if (players[p].team) {\n        rootProperties[color + 'T'] = players[p].team;\n      }\n    }\n  }\n\n  /**\n   * Parse function to property mapper\n   */\n  let parsingMap = {\n\n    //Node properties\n    'move': parseMove,\n    'setup': parseSetup,\n    'score': parseScore,\n    'markup': parseMarkup,\n    'turn': parseTurn,\n    'comments': parseComments,\n    'name': parseNodeName,\n\n    //Info properties\n    'record.application': parseApplication,\n    'player': parsePlayer,\n    'board': parseBoard,\n    'game.type': parseGame,\n    'game.players': parsePlayers,\n  };\n\n  /*****************************************************************************\n   * Parser functions\n   ***/\n\n  /**\n   * Helper to write a JGF tree to SGF\n   */\n  function writeTree(tree, output) {\n\n    //Loop nodes in the tree\n    for (let i = 0; i < tree.length; i++) {\n      let node = tree[i];\n\n      //Array? That means a variation\n      if (angular.isArray(node)) {\n        for (let j = 0; j < node.length; j++) {\n          output.sgf += '(\\n;';\n          writeTree(node[j], output);\n          output.sgf += '\\n)';\n        }\n\n        //Continue\n        continue;\n      }\n\n      //Loop node properties\n      for (let key in node) {\n        if (node.hasOwnProperty(key)) {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[key] !== 'undefined') {\n            parsingMap[key](node[key], output);\n            continue;\n          }\n\n          //Other object, can't handle it\n          if (typeof node[key] === 'object') {\n            continue;\n          }\n\n          //Anything else, append it\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\n        }\n      }\n\n      //More to come?\n      if ((i + 1) < tree.length) {\n        output.sgf += '\\n;';\n      }\n    }\n  }\n\n  /**\n   * Helper to extract all SGF root properties from a JGF object\n   */\n  function extractRootProperties(jgf, rootProperties, key) {\n\n    //Initialize key\n    if (typeof key === 'undefined') {\n      key = '';\n    }\n\n    //Loop properties of jgf node\n    for (let subKey in jgf) {\n      if (jgf.hasOwnProperty(subKey)) {\n\n        //Skip SGF signature (as we keep our own)\n        if (subKey === 'sgf') {\n          continue;\n        }\n\n        //Build jgf key\n        let jgfKey = (key === '') ? subKey : key + '.' + subKey;\n\n        //If the item is an object, handle separately\n        if (typeof jgf[subKey] === 'object') {\n\n          //Handler for this object present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\n          }\n\n          //Otherwise, just flatten and call this function recursively\n          else {\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\n          }\n          continue;\n        }\n\n        //Check if it's a known key, if so, append the value to the root\n        let value;\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            value = parsingMap[jgfKey](jgf[subKey]);\n          }\n          else {\n            value = escapeSgf(jgf[subKey]);\n          }\n\n          //Set in root properties\n          rootProperties[jgfAliases[jgfKey]] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Parser class\n   */\n  let Parser = {\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    parse: function(jgf) {\n\n      //String given?\n      if (typeof jgf === 'string') {\n        jgf = angular.fromJson(jgf);\n      }\n\n      //Must have moves tree\n      if (!jgf.tree) {\n        throw new Error('No moves tree in JGF object');\n      }\n\n      //Initialize output (as object, so it remains a reference) and root properties container\n      let output = {sgf: '(\\n;'};\n      let root = angular.copy(jgf);\n      let rootProperties = KifuBlank.sgf();\n\n      //The first node of the JGF tree is the root node, and it can contain comments,\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\n      //and attach it to the root\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\n        root = angular.extend(root, jgf.tree[0]);\n        delete root.root;\n        delete jgf.tree[0];\n      }\n\n      //Set root properties\n      delete root.tree;\n      extractRootProperties(root, rootProperties);\n\n      //Write root properties\n      for (let key in rootProperties) {\n        if (rootProperties[key]) {\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\n        }\n      }\n\n      //Write game tree\n      writeTree(jgf.tree, output);\n\n      //Close SGF and return\n      output.sgf += ')';\n      return output.sgf;\n    },\n  };\n\n  //Return object\n  return Parser;\n});\n","\n/**\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('Sgf2Jgf', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Regular expressions for SGF data\n   */\n  let regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\n  let regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\n  let regProperty = /[A-Z]+/;\n  let regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\n\n  /**\n   * Character index of \"a\"\n   */\n  let aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  function convertCoordinates(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  }\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Application parser function (doesn't overwrite existing signature)\n   */\n  function parseApp(jgf, node, key, value) {\n    if (!jgf.record.application) {\n      let app = value[0].split(':');\n      if (app.length > 1) {\n        jgf.record.application = app[0] + ' v' + app[1];\n      }\n      else {\n        jgf.record.application = app[0];\n      }\n    }\n  }\n\n  /**\n   * SGF format parser\n   */\n  function parseSgfFormat() {\n    return;\n  }\n\n  /**\n   * Game type parser function\n   */\n  function parseGame(jgf, node, key, value) {\n    let game = value[0];\n    if (typeof sgfGames[game] !== 'undefined') {\n      jgf.game.type = sgfGames[game];\n    }\n    else {\n      jgf.game.type = value[0];\n    }\n  }\n\n  /**\n   * Move parser function\n   */\n  function parseMove(jgf, node, key, value) {\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\n      node.move[key] = 'pass';\n    }\n\n    //Regular move\n    else {\n      node.move[key] = convertCoordinates(value[0]);\n    }\n  }\n\n  /**\n   * Comment parser function\n   */\n  function parseComment(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value;\n  }\n\n  /**\n   * Node name parser function\n   */\n  function parseNodeName(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value[0];\n  }\n\n  /**\n   * Board setup parser function\n   */\n  function parseSetup(jgf, node, key, value) {\n\n    //Initialize setup container on node\n    if (typeof node.setup === 'undefined') {\n      node.setup = {};\n    }\n\n    //Remove \"A\" from setup key\n    key = key.charAt(1);\n\n    //Initialize setup container of this type\n    if (typeof node.setup[key] === 'undefined') {\n      node.setup[key] = [];\n    }\n\n    //Add values\n    for (let i = 0; i < value.length; i++) {\n      node.setup[key].push(convertCoordinates(value[i]));\n    }\n  }\n\n  /**\n   * Scoring parser function\n   */\n  function parseScore(jgf, node, key, value) {\n\n    //Initialize score container on node\n    if (typeof node.score === 'undefined') {\n      node.score = {\n        B: [],\n        W: [],\n      };\n    }\n\n    //Remove \"T\" from setup key\n    key = key.charAt(1);\n\n    //Add values\n    for (let i = 0; i < value.length; i++) {\n      node.score[key].push(convertCoordinates(value[i]));\n    }\n  }\n\n  /**\n   * Turn parser function\n   */\n  function parseTurn(jgf, node, key, value) {\n    node.turn = value[0];\n  }\n\n  /**\n   * Label parser function\n   */\n  function parseLabel(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (let i = 0; i < value.length; i++) {\n\n      //Split off coordinates and add label contents\n      let coords = convertCoordinates(value[i].substr(0, 2));\n      coords.push(value[i].substr(3));\n\n      //Add to node\n      node.markup[key].push(coords);\n    }\n  }\n\n  /**\n   * Markup parser function\n   */\n  function parseMarkup(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (let i = 0; i < value.length; i++) {\n      node.markup[key].push(convertCoordinates(value[i]));\n    }\n  }\n\n  /**\n   * Size parser function\n   */\n  function parseSize(jgf, node, key, value) {\n\n    //Initialize board container\n    if (typeof jgf.board === 'undefined') {\n      jgf.board = {};\n    }\n\n    //Add size property (can be width:height or just a single size)\n    let size = value[0].split(':');\n    if (size.length > 1) {\n      jgf.board.width = parseInt(size[0]);\n      jgf.board.height = parseInt(size[1]);\n    }\n    else {\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\n    }\n  }\n\n  /**\n   * Date parser function\n   */\n  function parseDate(jgf, node, key, value) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Explode dates\n    let dates = value[0].split(',');\n    for (let d = 0; d < dates.length; d++) {\n      jgf.game.dates.push(dates[d]);\n    }\n  }\n\n  /**\n   * Komi parser function\n   */\n  function parseKomi(jgf, node, key, value) {\n    jgf.game.komi = parseFloat(value[0]);\n  }\n\n  /**\n   * Variations handling parser function\n   */\n  function parseVariations(jgf, node, key, value) {\n\n    //Initialize display property\n    if (typeof jgf.player === 'undefined') {\n      jgf.player = {};\n    }\n\n    //Initialize variation display settings\n    jgf.player.variationMarkup = false;\n    jgf.player.variationChildren = false;\n    jgf.player.variationSiblings = false;\n\n    //Parse as integer\n    let st = parseInt(value[0]);\n\n    //Determine what we want (see SGF specs for details)\n    switch (st) {\n      case 0:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationChildren = true;\n        break;\n      case 1:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationSiblings = true;\n        break;\n      case 2:\n        jgf.player.variationChildren = true;\n        break;\n      case 3:\n        jgf.player.variationSiblings = true;\n        break;\n    }\n  }\n\n  /**\n   * Player info parser function\n   */\n  function parsePlayer(jgf, node, key, value) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    let color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Check if player of this color already exists\n    for (let p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p][key] = value[0];\n        return;\n      }\n    }\n\n    //Player of this color not found, initialize\n    let player = {color: color};\n    player[key] = value[0];\n    jgf.game.players.push(player);\n  }\n\n  /**\n   * Parsing function to property mapper\n   */\n  let parsingMap = {\n\n    //Application, game type, board size, komi, date\n    'AP': parseApp,\n    'FF': parseSgfFormat,\n    'GM': parseGame,\n    'SZ': parseSize,\n    'KM': parseKomi,\n    'DT': parseDate,\n\n    //Variations handling\n    'ST': parseVariations,\n\n    //Player info handling\n    'PB': parsePlayer,\n    'PW': parsePlayer,\n    'BT': parsePlayer,\n    'WT': parsePlayer,\n    'BR': parsePlayer,\n    'WR': parsePlayer,\n\n    //Moves\n    'B': parseMove,\n    'W': parseMove,\n\n    //Node annotation\n    'C': parseComment,\n    'N': parseNodeName,\n\n    //Board setup\n    'AB': parseSetup,\n    'AW': parseSetup,\n    'AE': parseSetup,\n    'PL': parseTurn,\n    'TW': parseScore,\n    'TB': parseScore,\n\n    //Markup\n    'CR': parseMarkup,\n    'SQ': parseMarkup,\n    'TR': parseMarkup,\n    'MA': parseMarkup,\n    'SL': parseMarkup,\n    'LB': parseLabel,\n  };\n\n  /**\n   * These properties need a node object\n   */\n  let needsNode = [\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB',\n  ];\n\n  /*****************************************************************************\n   * Parser helpers\n   ***/\n\n  /**\n   * Set info in the JGF tree at a certain position\n   */\n  function setInfo(jgf, position, value) {\n\n    //Position given must be an array\n    if (typeof position !== 'object') {\n      return;\n    }\n\n    //Initialize node to attach value to\n    let node = jgf;\n    let key;\n\n    //Loop the position\n    for (let p = 0; p < position.length; p++) {\n\n      //Get key\n      key = position[p];\n\n      //Last key reached? Done\n      if ((p + 1) === position.length) {\n        break;\n      }\n\n      //Create container if not set\n      if (typeof node[key] !== 'object') {\n        node[key] = {};\n      }\n\n      //Move up in tree\n      node = node[key];\n    }\n\n    //Set value\n    node[key] = value;\n  }\n\n  /**\n   * Parser class\n   */\n  let Parser = {\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    parse: function(sgf, stringified) {\n\n      //Get new JGF object (with SGF node as a base)\n      let jgf = KifuBlank.jgf({record: {sgf: {}}});\n\n      //Initialize\n      let stack = [];\n      let container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      let node = {root: true};\n      container.push(node);\n\n      //Find sequence of elements\n      let sequence = sgf.match(regSequence);\n\n      //Loop sequence items\n      for (let i = 0; i < sequence.length; i++) {\n\n        //Push stack if new variation found\n        if (sequence[i] === '(') {\n\n          //First encounter, this defines the main tree branch, so skip\n          if (i === 0 || i === '0') {\n            continue;\n          }\n\n          //Push the current container to the stack\n          stack.push(container);\n\n          //Create variation container if it doesn't exist yet\n          if (!angular.isArray(container[container.length - 1])) {\n            container.push([]);\n          }\n\n          //Use variation container\n          container = container[container.length - 1];\n\n          //Now create moves container\n          container.push([]);\n          container = container[container.length - 1];\n          continue;\n        }\n\n        //Grab last container from stack if end of variation reached\n        else if (sequence[i] === ')') {\n          if (stack.length) {\n            container = stack.pop();\n          }\n          continue;\n        }\n\n        //Make array of properties within this sequence\n        let properties = sequence[i].match(regNode) || [];\n\n        //Loop them\n        for (let j = 0; j < properties.length; j++) {\n\n          //Get property's key and separate values\n          let key = regProperty.exec(properties[j])[0].toUpperCase();\n          let values = properties[j].match(regValues);\n\n          //Remove additional braces [ and ]\n          for (let k = 0; k < values.length; k++) {\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\n          }\n\n          //SGF parser present for this key? Call it, and we're done\n          if (typeof parsingMap[key] !== 'undefined') {\n\n            //Does this type of property need a node?\n            if (needsNode.indexOf(key) !== -1) {\n\n              //If no node object present, create a new node\n              //For moves, always a new node is created\n              if (!node || key === 'B' || key === 'W') {\n                node = {};\n                container.push(node);\n              }\n            }\n\n            //Apply parsing function on node\n            parsingMap[key](jgf, node, key, values);\n            continue;\n          }\n\n          //No SGF parser present, we continue with regular property handling\n\n          //If there is only one value, simplify array\n          if (values.length === 1) {\n            values = values[0];\n          }\n\n          //SGF alias known? Then this is an info element and we handle it accordingly\n          if (typeof sgfAliases[key] !== 'undefined') {\n\n            //The position in the JGF object is represented by dot separated strings\n            //in the sgfAliases array. Split the position and use the setInfo helper\n            //to set the info on the JGF object\n            setInfo(jgf, sgfAliases[key].split('.'), values);\n            continue;\n          }\n\n          //No SGF alias present either, just append the data\n\n          //Save in node\n          if (node) {\n            node[key] = values;\n          }\n\n          //Save in root\n          else {\n            jgf[key] = values;\n          }\n        }\n\n        //Reset node, unless this was the root node\n        if (node && !node.root) {\n          node = null;\n        }\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    },\n  };\n\n  //Return object\n  return Parser;\n});\n","\n/**\n * PlayerModeCommon :: This class governs common event handling of the player shared by\n * various player modes. It's basically an abstract player mode and it can't be actively set.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Common.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service',\n])\n\n/**\n * Run block\n */\n.run(function(Player, PlayerModes, PlayerModeCommon) {\n\n  /**\n   * Register common event handlers\n   */\n  Player.on('keydown', PlayerModeCommon.keyDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT,\n  ]);\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\n    PlayerModes.REPLAY, PlayerModes.EDIT,\n  ]);\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE,\n  ]);\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE,\n  ]);\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE,\n  ]);\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE,\n  ]);\n})\n\n/**\n * Factory definition\n */\n.factory('PlayerModeCommon', function(Player, PlayerTools, GameScorer, KeyCodes) {\n\n  /**\n   * Helper to build drag object\n   */\n  function dragObject(event) {\n\n    //Initialize drag object\n    let drag = {\n      start: {\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y,\n      },\n      stop: {\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y,\n      },\n    };\n\n    //Fix boundaries\n    if (drag.start.x < 0) {\n      drag.start.x = 0;\n    }\n    if (drag.start.y < 0) {\n      drag.start.y = 0;\n    }\n    if (drag.stop.x > this.board.width - 1) {\n      drag.stop.x = this.board.width - 1;\n    }\n    if (drag.stop.y > this.board.height - 1) {\n      drag.stop.y = this.board.height - 1;\n    }\n\n    //Return\n    return drag;\n  }\n\n  /**\n   * Normalize the mousewheel event helper\n   */\n  function normalizeMousewheelEvent(event) {\n\n    //Initialize vars\n    let deltaX = 0;\n    let deltaY = 0;\n\n    //Old school scrollwheel delta\n    if ('detail' in event) {\n      deltaY = event.detail * -1;\n    }\n    if ('wheelDelta' in event) {\n      deltaY = event.wheelDelta;\n    }\n    if ('wheelDeltaY' in event) {\n      deltaY = event.wheelDeltaY;\n    }\n    if ('wheelDeltaX' in event) {\n      deltaX = event.wheelDeltaX * -1;\n    }\n\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\n      deltaX = deltaY * -1;\n      deltaY = 0;\n    }\n\n    //New type wheel delta (WheelEvent)\n    if ('deltaY' in event) {\n      deltaY = event.deltaY * -1;\n    }\n    if ('deltaX' in event) {\n      deltaX = event.deltaX;\n    }\n\n    //Set in event (have to use different property name because of strict mode)\n    event.mouseWheelX = deltaX;\n    event.mouseWheelY = deltaY;\n\n    //Return\n    return event;\n  }\n\n  /**\n   * Player extension\n   */\n  angular.extend(Player, {\n\n    /**\n     * Mouse coordinate helper vars\n     */\n    mouse: {\n\n      //Drag start\n      dragStart: null,\n\n      //Last grid coordinates\n      lastX: -1,\n      lastY: -1,\n    },\n  });\n\n  /**\n   * Player mode definition\n   */\n  let PlayerMode = {\n\n    /**\n     * Handler for keydown events\n     */\n    keyDown: function(event, keyboardEvent) {\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Switch key code\n      switch (keyboardEvent.keyCode) {\n\n        //ESC\n        case KeyCodes.ESC:\n\n          //Cancel drag event, and prevent click event as well\n          this.mouse.dragStart = null;\n          this.preventClickEvent = true;\n          break;\n\n        //Right arrow\n        case KeyCodes.RIGHT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Advance to the next move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\n              this.next();\n            }\n          }\n          break;\n\n        //Left arrow\n        case KeyCodes.LEFT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Go to the previous move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\n              this.previous();\n            }\n          }\n          break;\n\n        //Up arrow\n        case KeyCodes.UP:\n          break;\n\n        //Down arrow\n        case KeyCodes.DOWN:\n          break;\n      }\n    },\n\n    /**\n     * Handler for mousewheel events\n     */\n    mouseWheel: function(event, mouseEvent) {\n\n      //Disabled or not using move tool?\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\n        return true;\n      }\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return true;\n      }\n\n      //Normalize mousewheel event\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\n\n      //Find delta\n      let delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\n\n      //Next move\n      if (delta < 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.next();\n      }\n\n      //Previous move\n      else if (delta > 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.previous();\n      }\n\n      //Don't scroll the window\n      if (delta !== 0) {\n        mouseEvent.preventDefault();\n      }\n    },\n\n    /**\n     * Mouse out handler\n     */\n    mouseOut: function() {\n      if (this.board) {\n        this.board.removeAll('hover');\n      }\n    },\n\n    /**\n     * Mouse move handler\n     */\n    mouseMove: function(event, mouseEvent) {\n\n      //Attach drag object to events\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n      }\n\n      //Nothing else to do?\n      if (!this.board || !this.board.layers.hover) {\n        return;\n      }\n\n      //Last coordinates are the same?\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\n        return;\n      }\n\n      //Remember last coordinates\n      this.mouse.lastX = event.x;\n      this.mouse.lastY = event.y;\n\n      //Broadcast hover event\n      this.broadcast('hover', mouseEvent);\n    },\n\n    /**\n     * Mouse down handler\n     */\n    mouseDown: function(event) {\n      this.mouse.dragStart = {\n        x: event.x,\n        y: event.y,\n      };\n    },\n\n    /**\n     * Mouse up handler\n     */\n    mouseUp: function(event, mouseEvent) {\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n        this.broadcast('mousedrag', mouseEvent);\n      }\n      this.mouse.dragStart = null;\n    },\n  };\n\n  //Return\n  return PlayerMode;\n});\n","\n/**\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\n * a game record and its board positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Edit.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service',\n])\n\n/**\n * Setup tools\n */\n.constant('SetupTools', {\n  BLACK: 'black',\n  WHITE: 'white',\n  CLEAR: 'clear',\n})\n\n/**\n * Markup tools\n */\n.constant('MarkupTools', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  SAD: 'sad',\n  HAPPY: 'happy',\n  TEXT: 'text',\n  NUMBER: 'number',\n  CLEAR: 'clear',\n})\n\n/**\n * Extend player functionality and register the mode\n */\n.run(function(Player, PlayerModes, PlayerModeEdit) {\n\n  //Register event handlers\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\n\n  //Register mode\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\n})\n\n/**\n * Provider definition\n */\n.provider('PlayerModeEdit', function() {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function(\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\n  ) {\n\n    //Character codes\n    let aChar = 'A'.charCodeAt(0);\n    let aCharLc = 'a'.charCodeAt(0);\n\n    /**\n     * Update hover mark at specific coordinates\n     */\n    function updateHoverMark(x, y, isDrag) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Setup tool\n        case PlayerTools.SETUP:\n\n          //Clear tool\n          if (this.setupTool === SetupTools.CLEAR) {\n\n            //Stone present? Can remove it\n            if (this.game.hasStone(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK,\n              });\n            }\n          }\n\n          //Stone color tool;\n          //Add or overwrite stone if no stone present of the given color\n          else if (!this.game.hasStone(x, y, this.setupToolColor())) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.setupToolColor(),\n            });\n          }\n\n          //Stone present of same color? Can remove it if we're not dragging\n          else if (!isDrag) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK,\n            });\n          }\n          break;\n\n        //Markup tool\n        case PlayerTools.MARKUP:\n\n          //Clear tool, or already markup in place?\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\n            if (this.game.hasMarkup(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK,\n              });\n            }\n          }\n\n          //Text or number\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: {\n                type: MarkupTypes.LABEL,\n                text: this.markupLabel,\n              },\n            });\n          }\n\n          //Other markup\n          else {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: this.markupTool,\n            });\n          }\n          break;\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn(),\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK,\n            });\n          }\n          break;\n      }\n    }\n\n    /**\n     * Helper to set markup\n     */\n    function setMarkup(x, y) {\n\n      //Already markup in place? Remove it first\n      if (this.game.hasMarkup(x, y)) {\n\n        //Check what markup there is\n        let markup = this.game.getMarkup(x, y);\n\n        //Label? Also remove from our labels list\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\n          let i = this.markupLabels.indexOf(markup.text);\n          if (i !== -1) {\n            this.markupLabels.splice(i, 1);\n          }\n        }\n\n        //Remove from game\n        this.game.removeMarkup(x, y);\n        return;\n      }\n\n      //Clear tool used? Done\n      if (this.markupTool === MarkupTools.CLEAR) {\n        return;\n      }\n\n      //Text\n      else if (this.markupTool === MarkupTools.TEXT) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel,\n        });\n\n        //Determine next text label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Number\n      else if (this.markupTool === MarkupTools.NUMBER) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel,\n        });\n\n        //Determine next number label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Other markup\n      else {\n        this.game.addMarkup(x, y, this.markupTool);\n      }\n    }\n\n    /**\n     * Helper to set a stone\n     */\n    function setStone(x, y, isDrag) {\n\n      //Get the stone color\n      let color = this.setupToolColor();\n\n      //Trying to remove a stone\n      if (color === StoneColor.EMPTY) {\n        this.game.removeStone(x, y);\n      }\n\n      //Adding a stone\n      else {\n\n        //A stone there already of the same color? Just remove if not dragging\n        if (!isDrag && this.game.hasStone(x, y, color)) {\n          this.game.removeStone(x, y);\n          return;\n        }\n\n        //Any stone present?\n        else if (this.game.hasStone(x, y)) {\n          this.game.removeStone(x, y);\n        }\n\n        //Add stone now\n        this.game.addStone(x, y, color);\n      }\n\n      //Redraw markup\n      this.board.layers.markup.redrawCell(x, y);\n    }\n\n    /**\n     * Find all markup labels in current position\n     */\n    function findAllMarkupLabels() {\n\n      //Clear\n      this.markupLabels = [];\n\n      //Must have game\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get all markup from position\n      let markup = this.game.position.markup.all('type');\n      for (let i = 0; i < markup.length; i++) {\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\n          this.markupLabels.push(markup[i].text);\n        }\n      }\n    }\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Active setup tool and markup tool\n      setupTool: SetupTools.BLACK,\n      markupTool: MarkupTools.TRIANGLE,\n\n      //Current markup labels on the board and current markup label\n      markupLabels: [],\n      markupLabel: '',\n\n      /**\n       * Set the setup tool\n       */\n      switchSetupTool: function(tool) {\n        this.setupTool = tool;\n      },\n\n      /**\n       * Set the markup tool\n       */\n      switchMarkupTool: function(tool) {\n        this.markupTool = tool;\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          this.determineMarkupLabel();\n        }\n      },\n\n      /**\n       * Conversion of setup tool to stone color\n       */\n      setupToolColor: function() {\n        switch (this.setupTool) {\n          case SetupTools.BLACK:\n            return StoneColor.B;\n          case SetupTools.WHITE:\n            return StoneColor.W;\n          default:\n            return StoneColor.EMPTY;\n        }\n      },\n\n      /**\n       * Set the new text markup label\n       */\n      setMarkupLabel: function(label) {\n        if (label) {\n          this.markupLabel = label;\n        }\n      },\n\n      /**\n       * Determine the new text markup label\n       */\n      determineMarkupLabel: function() {\n\n        //Clear\n        this.markupLabel = '';\n\n        //Check what tool we're using\n        switch (this.markupTool) {\n\n          //Text tool?\n          case MarkupTools.TEXT:\n            let i = 0;\n\n            //Loop while the label is present\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n\n              //A-Z\n              if (i < 26) {\n                this.markupLabel = String.fromCharCode(aChar + i);\n              }\n\n              //a-z\n              else if (i < 52) {\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\n              }\n\n              //AA, AB, AC, etc.\n              else {\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\n                  String.fromCharCode(aChar + (i % 26));\n              }\n\n              //Keep going\n              i++;\n            }\n            break;\n\n          //Number tool?\n          case MarkupTools.NUMBER:\n            this.markupLabel = 0;\n\n            //Loop while the label is present\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n              this.markupLabel++;\n            }\n            break;\n        }\n      },\n    });\n\n    /**\n     * Player mode definition\n     */\n    let PlayerModeEdit = {\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Remove all hover items\n        this.board.removeAll('hover');\n\n        //Single coordinate?\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //No dragging for labels\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //Loop area\n        for (let x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n          for (let y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n            updateHoverMark.call(this, x, y, true);\n          }\n        }\n      },\n\n      /**\n       * Keydown handler\n       */\n      keyDown: function(/*event, keyboardEvent*/) {\n\n        //TODO: tool switching via keyboard input\n        //Switch key code\n        // switch (keyboardEvent.keyCode) {\n        //\n        // }\n      },\n\n      /**\n       * Click handler\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        this.board.removeAll('hover');\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Try to play the move\n            if (!this.game.play(event.x, event.y)) {\n              return;\n            }\n            this.processPosition();\n            break;\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Set stone and update board\n            setStone.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Set markup and update board\n            setMarkup.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Mouse drag handler\n       */\n      mouseDrag: function(event) {\n\n        //Initialize vars\n        let x, y;\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setStone.call(this, x, y, true);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Don't do this for labels\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n              break;\n            }\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setMarkup.call(this, x, y);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Path change\n       */\n      pathChange: function() {\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SETUP,\n          PlayerTools.MARKUP,\n          PlayerTools.SCORE,\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Find all markup labels in the current game position\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else if (this.statePreScoring) {\n          this.board.restoreState(this.statePreScoring);\n          delete this.statePreScoring;\n        }\n      },\n    };\n\n    //Return\n    return PlayerModeEdit;\n  };\n});\n","\n/**\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\n * through an existing game record without the ability to deviate from the tree or its variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Replay.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service',\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(function(Player, PlayerModes, PlayerModeReplay) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\n\n  //Register the mode\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\n})\n\n/**\n * Provider definition\n */\n.provider('PlayerModeReplay', function() {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n    //Auto play delay\n    autoPlayDelay: 1000,\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\n\n    /**\n     * Helper to update the hover mark\n     */\n    function updateHoverMark(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn(),\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK,\n            });\n          }\n          break;\n      }\n    }\n\n    /**\n     * Helper to show move variations on the board\n     */\n    function showMoveVariations(variations) {\n      for (let i = 0; i < variations.length; i++) {\n\n        //Auto variation markup should never overwrite existing markup\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\n          continue;\n        }\n\n        //Add to board\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n          type: this.board.theme.get('markup.variation.type'),\n          text: this.board.theme.get('markup.variation.text', i),\n          color: this.board.theme.get('markup.variation.color'),\n        });\n      }\n    }\n\n    /**\n     * Helper to hide move variations from the board\n     */\n    function hideMoveVariations(variations) {\n      for (let i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    }\n\n    /**\n     * Draw (or clear) move variations on the board\n     */\n    function drawMoveVariations(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get the current node\n      let node = this.game.getNode();\n      let variations;\n      if (!node) {\n        return;\n      }\n\n      //Child variations?\n      if (this.variationChildren && node.hasMoveVariations()) {\n        variations = node.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n\n      //Sibling variations?\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\n        variations = node.parent.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n    }\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Auto play vars\n      autoPlaying: false,\n      autoPlayDelay: 1000,\n      autoPlayPromise: null,\n\n      /**\n       * Set auto play delay\n       */\n      setAutoPlayDelay: function(delay) {\n        if (this.autoPlayDelay !== delay) {\n          this.autoPlayDelay = delay;\n          this.broadcast('settingChange', 'autoPlayDelay');\n        }\n      },\n\n      /**\n       * Start auto play with a given delay\n       */\n      start: function(delay) {\n\n        //Not in replay mode or already auto playing?\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\n          return;\n        }\n\n        //Already auto playing, no game or no move children?\n        if (!this.game || !this.game.node.hasChildren()) {\n          return;\n        }\n\n        //Get self\n        let self = this;\n\n        //Determine delay\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\n\n        //Switch tool\n        this.switchTool(PlayerTools.NONE);\n\n        //Create interval\n        this.autoPlaying = true;\n        this.autoPlayPromise = $interval(function() {\n\n          //Advance to the next node\n          self.next(0, true);\n\n          //Ran out of children?\n          if (!self.game.node.hasChildren()) {\n            self.stop();\n          }\n        }, delay);\n\n        //Broadcast event\n        this.broadcast('autoPlayStarted', this.game.node);\n      },\n\n      /**\n       * Stop auto play\n       */\n      stop: function() {\n\n        //Not in replay mode or not auto playing?\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\n          return;\n        }\n\n        //Cancel interval\n        if (this.autoPlayPromise) {\n          $interval.cancel(this.autoPlayPromise);\n        }\n\n        //Clear flags\n        this.autoPlayPromise = null;\n        this.autoPlaying = false;\n\n        //Broadcast event\n        this.broadcast('autoPlayStopped', this.game.node);\n      },\n    });\n\n    /**\n     * Player mode definition\n     */\n    let PlayerModeReplay = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.setAutoPlayDelay(this.config.autoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'variationMarkup') {\n          drawMoveVariations.call(this, this.variationMarkup);\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Check if we clicked a move variation, advance to the next position if so\n            if (this.game.isMoveVariation(event.x, event.y)) {\n              this.next(this.game.getMoveVariation(event.x, event.y));\n            }\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeReplay.hover.call(this, event);\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SCORE,\n          PlayerTools.NONE,\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Stop auto playing\n        if (this.autoPlaying) {\n          this.stop();\n        }\n\n        //Hide move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, false);\n        }\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else if (this.statePreScoring) {\n          this.board.restoreState(this.statePreScoring);\n          delete this.statePreScoring;\n        }\n      },\n    };\n\n    //Return\n    return PlayerModeReplay;\n  };\n});\n","\n/**\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\n * go problems and finding the right move or variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Solve.Service', [\n  'ngGo',\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(function(Player, PlayerModes, PlayerModeSolve) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\n\n  //Register mode\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\n})\n\n/**\n * Provider definition\n */\n.provider('PlayerModeSolve', function(StoneColor) {\n\n  /**\n   * Default configuration\n   */\n  let defaultConfig = {\n\n    //Player color\n    playerColor: StoneColor.B,\n\n    //Show solution paths\n    solutionPaths: false,\n\n    //Auto play settings\n    solveAutoPlay: true,\n    solveAutoPlayDelay: 500,\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\n\n    /**\n     * Check if we can make a move\n     */\n    function canMakeMove() {\n\n      //We can make a move when...\n\n      //...there is no auto play going on\n      if (!this.solveAutoPlay) {\n        return true;\n      }\n\n      //...we solved the puzzle already\n      if (this.problemSolved) {\n        return true;\n      }\n\n      //...we are off path\n      if (this.problemOffPath) {\n        return true;\n      }\n\n      //...it's our turn\n      if (this.game.getTurn() === this.playerColor) {\n        return true;\n      }\n\n      //Otherwise, we can't make a move\n      return false;\n    }\n\n    /**\n     * Helper to update the hover mark\n     */\n    function updateHoverMark(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn(),\n            });\n          }\n          break;\n      }\n    }\n\n    /**\n     * Helper to show solution paths\n     */\n    function showSolutionPaths(variations) {\n      for (let i = 0; i < variations.length; i++) {\n        if (variations[i].solution === true) {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.valid.type'),\n            text: this.board.theme.get('markup.solution.valid.text', i),\n            scale: this.board.theme.get('markup.solution.valid.scale'),\n            color: this.board.theme.get('markup.solution.valid.color'),\n          });\n        }\n        else {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.invalid.type'),\n            text: this.board.theme.get('markup.solution.invalid.text', i),\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\n            color: this.board.theme.get('markup.solution.invalid.color'),\n          });\n        }\n      }\n    }\n\n    /**\n     * Helper to hide solution paths\n     */\n    function hideSolutionPaths(variations) {\n      for (let i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    }\n\n    /**\n     * Draw (or clear) solution paths\n     */\n    function drawSolutionPaths(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get node and variations\n      let node = this.game.getNode();\n      let variations = node.getMoveVariations();\n\n      //When showing, make sure it's not during the auto solver's move\n      if (show && !this.problemSolved && this.solveAutoPlay) {\n        if (this.game.getTurn() !== this.playerColor) {\n          hideSolutionPaths.call(this, variations);\n          return;\n        }\n      }\n\n      //Call helper\n      if (show) {\n        showSolutionPaths.call(this, variations);\n      }\n      else {\n        hideSolutionPaths.call(this, variations);\n      }\n    }\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Solved and off-path flags\n      problemSolved: false,\n      problemOffPath: false,\n\n      //Problem start path\n      problemStartPath: null,\n\n      //The player color\n      playerColor: 0,\n\n      //Solution paths\n      solutionPaths: false,\n\n      //Auto play vars\n      solveAutoPlay: true,\n      solveAutoPlayDelay: 500,\n\n      //Navigation blocked flag\n      solveNavigationBlocked: false,\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlay: function(autoPlay) {\n        if (this.solveAutoPlay !== autoPlay) {\n          this.solveAutoPlay = autoPlay;\n          this.broadcast('settingChange', 'solveAutoPlay');\n        }\n      },\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlayDelay: function(delay) {\n        if (this.solveAutoPlayDelay !== delay) {\n          this.solveAutoPlayDelay = delay;\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\n        }\n      },\n\n      /**\n       * Set player color\n       */\n      setPlayerColor: function(color) {\n        if (this.playerColor !== color) {\n          this.playerColor = color;\n          this.broadcast('settingChange', 'playerColor');\n        }\n      },\n\n      /**\n       * Get player color\n       */\n      getPlayerColor: function(asOnBoard) {\n        if (asOnBoard && this.board) {\n          return this.board.colorMultiplier * this.playerColor;\n        }\n        return this.playerColor;\n      },\n\n      /**\n       * Toggle solution paths\n       */\n      toggleSolutionPaths: function(solutionPaths) {\n\n        //Toggle if not given\n        if (typeof solutionPaths === 'undefined') {\n          solutionPaths = !this.solutionPaths;\n        }\n\n        //Change?\n        if (solutionPaths !== this.solutionPaths) {\n          this.solutionPaths = solutionPaths;\n          this.broadcast('settingChange', 'solutionPaths');\n        }\n      },\n\n      /**\n       * Auto play next move\n       */\n      autoPlayNext: function(immediately) {\n\n        //Must have game and children\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\n          return;\n        }\n\n        //Init vars\n        let children = [];\n        let self = this;\n        let i;\n\n        //When picking a child node, we always prefer to pick a valid solution\n        for (i = 0; i < this.game.node.children.length; i++) {\n          if (this.game.node.children[i].solution) {\n            children.push(this.game.node.children[i]);\n          }\n        }\n\n        //No solution nodes? Just use all nodes then.\n        if (children.length === 0) {\n          children = this.game.node.children;\n        }\n\n        //Pick a random child node\n        i = Math.floor(Math.random() * children.length);\n\n        //No delay?\n        if (immediately || !this.solveAutoPlayDelay) {\n          this.next(children[i]);\n          return;\n        }\n\n        //Block navigation and run the timeout\n        this.solveNavigationBlocked = true;\n        $timeout(function() {\n\n          //Move to next move and unblock navigation\n          self.next(children[i]);\n          self.solveNavigationBlocked = false;\n\n        }, this.solveAutoPlayDelay);\n      },\n\n      /**\n       * Start solving from the current game node\n       */\n      solve: function() {\n\n        //Must have a game\n        if (!this.game || !this.game.isLoaded()) {\n          return false;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Remember problem start path\n        this.problemStartPath = this.game.getPath(true);\n\n        //Restrict start of navigation to the current node\n        this.restrictNode();\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      },\n\n      /**\n       * Restart the problem\n       */\n      restartProblem: function() {\n\n        //Must be in solve mode, must have game\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Go back to the start path\n        if (this.problemStartPath) {\n          this.goto(this.problemStartPath);\n        }\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      },\n    });\n\n    /**\n     * Player mode definition\n     */\n    let PlayerModeSolve = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.toggleSolutionPaths(this.config.solutionPaths);\n        this.setPlayerColor(this.config.playerColor);\n        this.setSolveAutoPlay(this.config.solveAutoPlay);\n        this.setSolveAutoPlayDelay(this.config.solveAutoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'solutionPaths') {\n          drawSolutionPaths.call(this, this.solutionPaths);\n        }\n\n        //Player color changed?\n        if (setting === 'playerColor') {\n\n          //Draw (or hide) solution paths\n          drawSolutionPaths.call(this, this.solutionPaths);\n\n          //Make an auto play move if it's not our turn\n          if (\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\n          ) {\n            this.autoPlayNext(true);\n          }\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this, event.x, event.y);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for keydown events\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //Right arrow\n          case KeyCodes.RIGHT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\n\n                //Go forward one move if solved\n                if (this.problemSolved) {\n                  this.next();\n                }\n              }\n            }\n            break;\n\n          //Left arrow\n          case KeyCodes.LEFT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked and not reached the start?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\n\n                //Go back one move\n                this.previous();\n\n                //Go back one more if this is not the player's turn and if\n                //the problem hasn't been solved yet\n                if (\n                  !this.problemSolved && this.solveAutoPlay &&\n                  this.game.getTurn() === -this.playerColor\n                ) {\n                  this.previous();\n                }\n              }\n            }\n            break;\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //A valid variation\n        if (this.game.isMoveVariation(event.x, event.y)) {\n\n          //Get the node\n          let i = this.game.getMoveVariation(event.x, event.y);\n\n          //Advance to the next position and get the next node\n          this.next(i);\n          let node = this.game.getNode();\n\n          //No children left? Check if we solved it or not\n          if (node.children.length === 0) {\n            if (node.solution === true) {\n              this.problemSolved = true;\n              this.broadcast('solutionFound', node);\n            }\n            else {\n              this.broadcast('solutionWrong', node);\n            }\n          }\n\n          //Auto-play next move?\n          else if (!this.problemSolved && this.solveAutoPlay) {\n            this.autoPlayNext();\n          }\n        }\n\n        //Unknown variation, try to play\n        else if (this.game.play(event.x, event.y)) {\n          this.problemOffPath = true;\n          this.processPosition();\n          this.broadcast('solutionOffPath', this.game.getNode());\n        }\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Draw solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Hide any solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, false);\n        }\n      },\n    };\n\n    //Return\n    return PlayerModeSolve;\n  };\n});\n"]}