{"version":3,"sources":["ngGo.js","board/board.directive.js","board/board.service.js","board/defaultClearHandler.service.js","board/grid.service.js","board/gridChanges.service.js","board/layer.service.js","board/object.service.js","board/shellPattern.service.js","board/theme.service.js","errors/invalidDataError.service.js","errors/invalidPositionError.service.js","game/game.service.js","game/node.service.js","game/path.service.js","game/position.service.js","game/score.service.js","game/scorer.service.js","player/player.directive.js","player/player.service.js","kifu/blank.service.js","kifu/parser.service.js","board/layer/gridLayer.service.js","board/layer/hoverLayer.service.js","board/layer/markupLayer.service.js","board/layer/scoreLayer.service.js","board/layer/shadowLayer.service.js","board/layer/stonesLayer.service.js","board/object/coordinates.service.js","board/object/markup.service.js","board/object/stone.service.js","board/object/stoneFaded.service.js","board/object/stoneMini.service.js","board/object/stoneShadow.service.js","player/mode/common.service.js","player/mode/edit.service.js","player/mode/replay.service.js","player/mode/solve.service.js","kifu/parsers/gib2jgf.service.js","kifu/parsers/jgf2sgf.service.js","kifu/parsers/sgf2jgf.service.js","ngGo.min.js"],"names":["window","angular","undefined","module","constant","name","version","error","POSITION_OUT_OF_BOUNDS","POSITION_ALREADY_HAS_STONE","POSITION_IS_SUICIDE","POSITION_IS_REPEATING","NO_DATA","UNKNOWN_DATA","INVALID_SGF","INVALID_GIB","INVALID_JGF_JSON","INVALID_JGF_TREE_JSON","E","EMPTY","B","BLACK","W","WHITE","TRIANGLE","CIRCLE","SQUARE","MARK","SELECT","LABEL","LAST","SAD","HAPPY","PLAY","REPLAY","EDIT","SOLVE","NONE","MOVE","SCORE","SETUP","MARKUP","LEFT","RIGHT","UP","DOWN","ESC","ENTER","SPACE","TAB","SHIFT","CTRL","ALT","HOME","END","PAGEUP","PAGEDOWN","directive","$window","Board","pixelRatio","createLayerCanvas","canvas","document","createElement","context","getContext","scale","className","width","this","clientWidth","height","clientHeight","appendChild","determineDrawSize","scope","availableWidth","availableHeight","drawWidth","drawHeight","cellSize","Math","min","floor","lastDrawWidth","lastDrawHeight","$broadcast","restrict","instance","link","element","attrs","i","layer","playerElement","parent","sizingElement","existingInstance","linkElement","tagName","$on","event","find","length","forceSize","css","setDrawSize","on","board","resized","addClass","makeStatic","call","layerOrder","layers","setContext","$observe","size","toLowerCase","indexOf","split","setSize","attr","toggleCoordinates","isDefined","setCutoff","swapColors","$parent","Player","setBoard","redraw","provider","defaultConfig","cutoff","section","top","right","bottom","left","coordinates","colorMultiplier","setConfig","config","extend","$get","$rootScope","$injector","BoardTheme","init","parseConfig","prototype","removeAll","theme","drawMarginHor","drawMarginVer","gridDrawWidth","gridDrawHeight","l","layerClass","toUpperCase","substr","LayerClass","get","margin","grid","setCoordinates","setSection","setMargin","isArray","changes","side","hasOwnProperty","parseInt","isNaN","show","multiplier","getTheme","setTheme","add","x","y","value","remove","has","setAll","updatePosition","position","pathChanged","stones","markup","getState","getAll","state","isEmpty","restoreState","clear","draw","xLeft","xRight","yTop","yBot","noCellsHor","noCellsVer","getCellSize","getAbsX","gridX","offset","round","getAbsY","gridY","getGridX","absX","getGridY","absY","isOnBoard","factory","obj","s","r","clearRect","BoardGridChanges","toObject","valueKey","BoardGrid","emptyValue","set","isOnGrid","unset","is","all","objects","push","populate","empty","clone","newGrid","copy","isSameAs","compare","console","warn","whenEmpty","getSize","setSubtract","a","b","q","n","j","concat","newChanges","BoardLayer","clearCell","drawCell","redrawCell","DefaultClearHandler","BoardObject","drawheight","shellLine","ctx","radius","startAngle","endAngle","strokeStyle","shadowBlur","lineWidth","thickness","beginPath","max","m","angle","x1","cos","PI","y1","sin","x2","y2","atan","c","factor","dx","dy","bx1","by1","bx2","by2","moveTo","bezierCurveTo","stroke","lines","StoneColor","MarkupTypes","defaultTheme","stone","style","shadow","shell","color","stoneColor","types","mono","lineColor","mini","alpha","faded","blur","offsetX","ceil","offsetY","triangle","square","circle","mark","lineCap","last","smiley","label","font","variation","type","text","String","fromCharCode","solution","valid","invalid","star","points","vertical","inverse","ch","horizontal","merge","instanceTheme","reset","property","path","prop","args","arguments","apply","canvasTranslate","ngGo","InvalidDataError","code","message","Error","constructor","InvalidPositionError","POSTITION_OUT_OF_BOUNDS","POSTITION_ALREADY_HAS_STONE","POSTITION_IS_SUICIDE","POSTITION_IS_REPEATING","defaultSize","defaultKomi","defaultHandicap","rememberPath","checkRepeat","allowSuicide","GamePath","GameNode","GamePosition","KifuParser","KifuBlank","validateInfo","info","game","komi","handicap","nextNode","node","children","_remembered_path","advance","previousNode","retreat","firstNode","root","setTurn","initializeHistory","history","pushPosition","newPosition","popPosition","pop","replacePosition","executeNode","move","pass","validateMove","turn","setup","Game","data","Object","defineProperty","load","jgf","fromData","errorCode","first","reload","isLoaded","props","getOwnPropertyNames","p","charAt","fromSgf","fromJgf","fromGib","gib","gib2jgf","sgf","sgf2jgf","fromJson","tree","toSgf","jgf2sgf","toJgf","stringify","toJson","getNode","getMoveNodeAt","moveNo","getChild","getMoveNodes","fromMove","toMove","getMoveCount","nodes","getPosition","getPath","clonePath","getPathToNode","nodeName","findNode","getKomi","parseFloat","setKomi","getName","getResult","getTurn","getCaptureCount","captures","getMoveVariation","getMove","noMoves","defaultValue","key","isMoveVariation","isRepeatingPosition","checkPosition","stop","isValidMove","captureAdjacent","hasLiberties","captureGroup","validatePlacement","addStone","tempPosition","appendTo","addMarkup","removeStone","foundInSetup","splice","removeMarkup","hasStone","hasMarkup","getStone","getMarkup","play","next","previous","target","setMove","nodeAt","nextFork","previousFork","nextComment","hasComments","previousComment","aChar","charCodeAt","convertCoordinates","coords","coordinatesObject","baseObject","toStringColor","toColorConstant","convertMoveToJgf","jgfMove","convertMoveFromJgf","convertSetupToJgf","jgfSetup","convertSetupFromJgf","gameSetup","convertMarkupToJgf","jgfMarkup","convertMarkupFromJgf","gameMarkup","convertTurnToJgf","convertTurnFromJgf","conversionMap","properties","getChildren","hasChildren","hasMoveVariations","moveVariations","getMoveVariations","comments","moveUp","temp","moveDown","insertNode","gameNode","variationNode","container","variationsContainer","variationContainer","branches","no","otherPath","newPath","findNodeName","rootNode","setStone","setMarkup","groupColor","tested","friendlyColor","captured","canCapture","enemyColor","doCapture","captureStone","setCaptures","getCaptures","switchTurn","calcTotal","territory","GameScore","self","black","white","total","winner","w","scoreState","UNKNOWN","BLACK_STONE","WHITE_STONE","BLACK_CANDIDATE","WHITE_CANDIDATE","NEUTRAL","territorySet","candidateColor","boundaryColor","posColor","origColor","territoryReset","determineScoreState","curState","newState","adjacent","change","GameScorer","score","getScore","getPoints","calculate","controller","$scope","mode","switchMode","tool","switchTool","setVariationMarkup","toggleSolutionPaths","setLastMoveMarker","PlayerModes","PlayerTools","arrowKeysNavigation","scrollWheelNavigation","lastMoveMarker","variationMarkup","variationChildren","variationSiblings","$document","processMouseEvent","broadcastEvent","mouseEvent","originalEvent","layerX","layerY","devicePixelRatio","drag","modes","tools","restrictNodeStart","restrictNodeEnd","registerElementEvent","setArrowKeysNavigation","setScrollWheelNavigation","arrowKeys","broadcast","scrollWheel","registerMode","PlayerMode","setTools","hasMode","hasTool","force","saveState","playerState","saveGameState","restoreGameState","allowPlayerConfig","processPosition","gameState","goto","restrictNode","end","updateBoard","showMoveNumbers","forEach","newGame","scoreGame","getBoard","off","bind","listener","querySelector","preventClickEvent","t","$$phase","$apply","blankJgf","record","application","charset","players","blankSgf","AP","CA","FF","GM","SZ","PB","PW","base","blank","CP","SO","US","AN","GN","KM","HA","RE","RU","TM","OT","DT","PC","EV","RO","ON","GC","BT","WT","BR","WR","N","C","CR","TR","SQ","MA","SL","LB",1,2,3,4,6,7,8,"Gib2Jgf","Sgf2Jgf","Jgf2Sgf","stringified","parse","Coordinates","drawStarPoint","starRadius","starColor","fillStyle","arc","fill","GridLayer","tx","ty","starPoints","translate","lineTo","Markup","StoneFaded","HoverLayer","restore","hover","object","objectClass","MarkupLayer","StoneMini","ScoreLayer","StoneShadow","ShadowLayer","shadowSize","setTransform","Stone","StonesLayer","kanji","aCharLc","numbers","letters","xl","xr","yt","yb","textBaseline","textAlign","fillText","cosPi4","cosPi6","drawTriangle","closePath","drawSquare","rcos","rect","drawCircle","drawMark","drawSelect","drawLast","drawHappySmiley","drawSadSmiley","drawLabel","toString","clearLabel","ShellPattern","shellSeed","drawMono","globalAlpha","drawGlass","createRadialGradient","addColorStop","drawSlateShell","random","shellTypes","z","handler","shadowColor","run","PlayerModeCommon","keyDown","mouseWheel","mouseMove","mouseOut","mouseDown","mouseUp","KeyCodes","normalizeMousewheelEvent","deltaX","deltaY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","mouseWheelX","mouseWheelY","dragObject","start","mouse","dragStart","lastX","lastY","keyboardEvent","keyCode","preventDefault","delta","CLEAR","TEXT","NUMBER","PlayerModeEdit","pathChange","toolSwitch","modeEnter","mouseDrag","click","SetupTools","MarkupTools","updateHoverMark","isDrag","setupTool","setupToolColor","markupTool","markupLabel","markupLabels","determineMarkupLabel","findAllMarkupLabels","switchSetupTool","switchMarkupTool","setMarkupLabel","statePreScoring","PlayerModeReplay","settingChange","boardUpdate","modeExit","autoPlayDelay","$interval","showMoveVariations","variations","hideMoveVariations","drawMoveVariations","autoPlaying","autoPlayPromise","setAutoPlayDelay","delay","cancel","setting","PlayerModeSolve","playerColor","solutionPaths","solveAutoPlay","solveAutoPlayDelay","$timeout","canMakeMove","problemSolved","problemOffPath","showSolutionPaths","hideSolutionPaths","drawSolutionPaths","problemStartPath","solveNavigationBlocked","setSolveAutoPlay","autoPlay","setSolveAutoPlayDelay","setPlayerColor","getPlayerColor","asOnBoard","autoPlayNext","immediately","solve","restartProblem","regMove","regPlayer","regKomi","regDate","regResultMargin","regResultOther","parsePlayer","match","player","rank","parseKomi","parseDate","dates","parseResult","result","parseMove","Parser","exec","sgfAliases","sgfGames","jgfAliases","sgfProp","escapeSgf","replace","writeGroup","values","output","escape","parseSetup","parseScore","parseMarkup","parseTurn","parseComments","flatComments","comment","parseNodeName","parseGame","parseApplication","parts","rootProperties","st","ST","parseBoard","parsePlayers","team","parsingMap","record.application","game.type","game.players","writeTree","extractRootProperties","subKey","jgfKey","regSequence","regNode","regProperty","regValues","parseApp","app","parseSgfFormat","parseComment","parseLabel","parseSize","d","parseVariations","AB","AW","AE","PL","TW","TB","needsNode","setInfo","stack","sequence","k","substring"],"mappings":"CAOA,SAAAA,EAAAC,EAAAC,GAAA,YA8BAD,GAAAE,OAAA,WAKAC,SAAA,QACAC,KAAA,OACAC,QAAA,QACAC,OAGAC,uBAAA,EACAC,2BAAA,EACAC,oBAAA,EACAC,sBAAA,EAGAC,QAAA,EACAC,aAAA,EACAC,YAAA,EACAC,YAAA,EACAC,iBAAA,EACAC,sBAAA,MAOAb,SAAA,cACAc,EAAA,EACAC,MAAA,EACAC,EAAA,EACAC,MAAA,EACAC,EAAA,GACAC,MAAA,KAMAnB,SAAA,eACAoB,SAAA,WACAC,OAAA,SACAC,OAAA,SACAC,KAAA,OACAC,OAAA,SACAC,MAAA,QACAC,KAAA,OACAC,IAAA,MACAC,MAAA,UAMA5B,SAAA,eACA6B,KAAA,OACAC,OAAA,SACAC,KAAA,OACAC,MAAA,UAMAhC,SAAA,eACAiC,KAAA,OACAC,KAAA,OACAC,MAAA,QACAC,MAAA,QACAC,OAAA,WAMArC,SAAA,YACAsC,KAAA,GACAC,MAAA,GACAC,GAAA,GACAC,KAAA,GACAC,IAAA,GACAC,MAAA,GACAC,MAAA,GACAC,IAAA,EACAC,MAAA,GACAC,KAAA,GACAC,IAAA,GACAC,KAAA,GC9HAC,IAAA,GACAC,OAAA,GACAC,SAAA,MAGAxD,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAIAD,GAAAE,OAAA,wBACA,uBAMAsD,UAAA,SAAA,UAAA,QAAA,SAAAC,EAAAC,GAGA,GAAAC,GAAA5D,EAAA4D,YAAA,EAKAC,EAAA,SAAAxD,GAGA,GAAAyD,GAAAC,SAAAC,cAAA,UACAC,EAAAH,EAAAI,WAAA,KAgBA,OAbAN,GAAA,GACAK,EAAAE,MAAAP,EAAAA,GAIAE,EAAAM,UAAA/D,EAGAyD,EAAAO,MAAAC,KAAAC,YAAAX,EACAE,EAAAU,OAAAF,KAAAG,aAAAb,EAGAU,KAAAI,YAAAZ,GACAG,GAMAU,EAAA,SAAAC,EAAAC,EAAAC,GAGA,GAAAC,GAAAC,EAAAC,CAwBA,OArBA,KAAAH,GAAAD,EAAA,IACAC,EAAAD,GAIAD,EAAAjB,MAAAU,OAAAO,EAAAjB,MAAAa,QAGAS,EAAAC,KAAAC,IAAAN,EAAAD,EAAAjB,MAAAU,MAAAS,EAAAF,EAAAjB,MAAAa,QAGAO,EAAAG,KAAAE,MAAAH,EAAAL,EAAAjB,MAAAU,OACAW,EAAAE,KAAAE,MAAAH,EAAAL,EAAAjB,MAAAa,SAKAO,EAAAC,EAAAE,KAAAC,IAAAN,EAAAC,GAIAF,EAAAS,gBAAAN,GAAAH,EAAAU,iBAAAN,GACAJ,EAAAS,cAAAN,EACAH,EAAAU,eAAAN,EACAJ,EAAAW,WAAA,6BAAAR,EAAAC,IACA,IAIA,EAMA,QACAQ,SAAA,IACAZ,OACAa,SAAA,KAMAC,KAAA,SAAAd,EAAAe,EAAAC,GAGA,GAAAC,GAAA5B,EAAA6B,EAAAC,EACAC,EAAAL,EAAAK,SACAC,EAAAN,EAAA,GACAO,GAAA,CA+EA,IA5EAtB,EAAAS,cAAA,EACAT,EAAAU,eAAA,EAGAV,EAAAjB,MAAAiB,EAAAa,WAGA,kBAAAb,GAAAjB,QACAiB,EAAAjB,MAAAiB,EAAAjB,SAIAiB,EAAAjB,QACAuC,GAAA,EACAtB,EAAAjB,MAAA,GAAAA,IAIAiB,EAAAjB,MAAAwC,YAAAR,GAGA,WAAAK,EAAA,GAAAI,UACAL,EAAAC,EACAC,EAAAD,EAAAA,SAAA,IAIApB,EAAAyB,IAAA,6BAAA,SAAAC,EAAAjC,EAAAG,GAGA,GAAAV,GAAA6B,EAAAY,KAAA,SACA,KAAAV,EAAA,EAAAA,EAAA/B,EAAA0C,OAAAX,IACA/B,EAAA+B,GAAAxB,MAAAA,EAAAT,EACAE,EAAA+B,GAAArB,OAAAA,EAAAZ,GAIAmC,GAAA,SAAAH,EAAAa,YACAd,EAAAe,KAAArC,MAAAA,EAAA,KAAAG,OAAAA,EAAA,OAIAI,EAAAjB,MAAAgD,YAAAtC,EAAAT,EAAAY,EAAAZ,KAIAe,EAAAC,EAAAqB,EAAA1B,YAAA0B,EAAAxB,cAGAxE,EAAA0F,QAAAjC,GAAAkD,GAAA,SAAA,WACAjC,EAAAC,EAAAqB,EAAA1B,YAAA0B,EAAAxB,gBAIAG,EAAAyB,IAAA,+BAAA,WACA1B,EAAAC,EAAAqB,EAAA1B,YAAA0B,EAAAxB,gBAIAG,EAAAyB,IAAA,oBAAA,SAAAC,EAAAO,GAGAA,IAAAjC,EAAAjB,QAQAgB,EAAAC,EAAAqB,EAAA1B,YAAA0B,EAAAxB,eACAG,EAAAjB,MAAAmD,aAKAlB,EAAAA,WAAA,SAAAA,EAAAA,UAQA,IALAD,EAAAoB,SAAA,UACAnC,EAAAjB,MAAAqD,aAGA/C,EAAAJ,EAAAoD,KAAAtB,EAAA,GAAA,UACAE,EAAA,EAAAA,EAAAjB,EAAAjB,MAAAuD,WAAAV,OAAAX,IACAC,EAAAlB,EAAAjB,MAAAuD,WAAArB,GACAjB,EAAAjB,MAAAwD,OAAArB,GAAAsB,WAAAnD,OAQA,KAAA4B,EAAA,EAAAA,EAAAjB,EAAAjB,MAAAuD,WAAAV,OAAAX,IACAC,EAAAlB,EAAAjB,MAAAuD,WAAArB,GACA5B,EAAAJ,EAAAoD,KAAAtB,EAAA,GAAAG,GACAlB,EAAAjB,MAAAwD,OAAArB,GAAAsB,WAAAnD,EAKA2B,GAAAyB,SAAA,OAAA,SAAAC,GACA,gBAAAA,IAAA,KAAAA,EAAAC,cAAAC,QAAA,MACAF,EAAAA,EAAAG,MAAA,KACA7C,EAAAjB,MAAA+D,QAAAJ,EAAA,GAAAA,EAAA,KAGA1C,EAAAjB,MAAA+D,QAAAJ,EAAAA,KAKA1B,EAAAyB,SAAA,cAAA,SAAAM,GACA/C,EAAAjB,MAAAiE,kBAAA,SAAAD,KAIA/B,EAAAyB,SAAA,SAAA,SAAAM,GACA1H,EAAA4H,UAAAF,IACA/C,EAAAjB,MAAAmE,UAAAH,EAAAF,MAAA,QAKA7B,EAAAyB,SAAA,kBAAA,SAAAM,GACA1H,EAAA4H,UAAAF,IACA/C,EAAAjB,MAAAoE,WAAAJ,KAKA/C,EAAAoD,QAAAC,QACArD,EAAAoD,QAAAC,OAAAC,SAAAtD,EAAAjB,OAIAuC,GACAtB,EAAAjB,MAAAwE,eCpPAnI,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAYAD,GAAAE,OAAA,sBACA,OACA,uBACA,2BACA,qCACA,uCACA,uCACA,uCACA,sCACA,sCACA,mCACA,kCACA,sCACA,yCAMAiI,SAAA,QAAA,WAKA,GAAAC,IAGAhE,MAAA,EACAG,OAAA,EAGA8D,UAGAC,SAAAC,IAAA,EAAAC,MAAA,EAAAC,OAAA,EAAAC,KAAA,GAGAC,aAAA,EAGAC,gBAAA,EAMAvE,MAAAwE,UAAA,SAAAC,GACAV,EAAApI,EAAA+I,OAAAX,EAAAU,IAMAzE,KAAA2E,MAAA,aAAA,YAAA,aAAA,SAAAC,EAAAC,EAAAC,GAKA,GAAAzF,GAAA,SAAAoF,GAGAzE,KAAA+E,OAGA/E,KAAAgF,YAAAP,OClFA,ODwFApF,GAAA4F,UAAAF,KAAA,WAGA/E,KAAAkF,YAGAlF,KAAAmF,MAAA,GAAAL,GAGA9E,KAAAW,SAAA,EACAX,KAAAS,UAAA,EACAT,KAAAU,WAAA,EACAV,KAAAoF,cAAA,EACApF,KAAAqF,cAAA,EACArF,KAAAsF,cAAA,EACAtF,KAAAuF,eAAA,EAGAvF,KAAA4C,YAAA,OAAA,SAAA,SAAA,QAAA,SAAA,SAGA5C,KAAA6C,SACA,KAAA,GAAA2C,GAAA,EAAAA,EAAAxF,KAAA4C,WAAAV,OAAAsD,IAAA,CACA,GAAAhE,GAAAxB,KAAA4C,WAAA4C,GACAC,EAAAjE,EAAA,GAAAkE,cAAAlE,EAAAmE,OAAA,GAAA,QACAC,EAAAf,EAAAgB,IAAAJ,EACAzF,MAAA6C,OAAArB,GAAA,GAAAoE,GAAA5F,MAIAA,KAAAA,WAAA,EAGAA,KAAA8F,OAAA9F,KAAAmF,MAAAU,IAAA,gBAGA7F,KAAAuE,gBAAA,EAGAvE,KAAAsE,aAAA,EACAtE,KAAA6C,OAAAkD,KAAAC,gBAAA,GAGAhG,KAAAD,MAAA,EACAC,KAAAE,OAAA,EAGAF,KAAAgE,QACAE,KAAA,EACAG,MAAA,EACAF,OAAA,EACAC,QAAA,GAIApE,KAAAiE,SACAC,IAAA,EACAG,KAAA,EACAF,MAAA,EACAC,OAAA,IAOA/E,EAAA4F,UAAApD,YAAA,SAAAR,GACArB,KAAAqB,QAAAA,GAMAhC,EAAA4F,UAAAvC,WAAA,WACA1C,KAAAA,WAAA,EACAA,KAAA4C,YAAA,OAAA,SAAA,WAUAvD,EAAA4F,UAAAD,YAAA,SAAAP,GAGA,gBAAAA,KAKAA,EAAA9I,EAAA+I,UAAAX,EAAAU,GAGAzE,KAAAsD,kBAAAmB,EAAAH,aACAtE,KAAAyD,WAAAgB,EAAAF,iBACAvE,KAAAwD,UAAAiB,EAAAT,QACAhE,KAAAiG,WAAAxB,EAAAR,SACAjE,KAAAoD,QAAAqB,EAAA1E,MAAA0E,EAAAvE,UAMAb,EAAA4F,UAAAiB,UAAA,SAAAJ,GAcA,MAXA,mBAAAA,KACAA,EAAA9F,KAAAmF,MAAAU,IAAA,iBAIA7F,KAAA8F,SAAAA,IACA9F,KAAA8F,OAAAA,EACA9F,KAAAwC,WAIAxC,MAMAX,EAAA4F,UAAAzB,UAAA,SAAAQ,GAGAA,GAAArI,EAAAwK,QAAAnC,KACAA,KAIA,IAAAoC,IAAA,CAGA,KAAA,GAAAC,KAAArG,MAAAgE,OACAhE,KAAAgE,OAAAsC,eAAAD,KACA,KAAArC,EAAAd,QAAAmD,GACArG,KAAAgE,OAAAqC,KACArG,KAAAgE,OAAAqC,IAAA,EACAD,GAAA,GAIApG,KAAAgE,OAAAqC,KACArG,KAAAgE,OAAAqC,IAAA,EACAD,GAAA,GAYA,OALAA,IACApG,KAAAwC,UAIAxC,MAMAX,EAAA4F,UAAAgB,WAAA,SAAAhC,GAGA,MAAAA,IAAA,gBAAAA,IAKAA,EAAAtI,EAAA+I,QACAR,IAAA,EACAG,KAAA,EACAF,MAAA,EACAC,OAAA,GACAH,GAIAjE,KAAAiE,QAAAC,MAAAD,EAAAC,KAAAlE,KAAAiE,QAAAG,SAAAH,EAAAG,QACApE,KAAAiE,QAAAI,OAAAJ,EAAAI,MAAArE,KAAAiE,QAAAE,QAAAF,EAAAE,MAEAnE,MAIAA,KAAAiE,QAAAA,EACAjE,KAAAwC,UAGAxC,OAxBAA,MA8BAX,EAAA4F,UAAA7B,QAAA,SAAArD,EAAAG,GAOA,GAJAH,EAAAwG,SAAAxG,GAAAG,GAAA,GACAA,EAAAqG,SAAArG,GAAAH,GAAA,IAGAyG,MAAAzG,KAAAyG,MAAAtG,GAAA,CAKA,GAAAH,IAAAC,KAAAD,OAAAG,IAAAF,KAAAE,OAAA,CAGAF,KAAAD,MAAAA,EACAC,KAAAE,OAAAA,CAGA,KAAA,GAAAsB,KAAAxB,MAAA6C,OACA7C,KAAA6C,OAAAyD,eAAA9E,IACAxB,KAAA6C,OAAArB,GAAA4B,QAAArD,EAAAG,EAKA0E,GAAA3D,WAAA,oBAAAjB,KAAAD,EAAAG,GAIA,MAAAF,QAMAX,EAAA4F,UAAA5C,YAAA,SAAAtC,EAAAG,IACAH,IAAAC,KAAAS,WAAAP,IAAAF,KAAAU,cACAV,KAAAS,UAAAV,EACAC,KAAAU,WAAAR,EACAF,KAAAwC,YAOAnD,EAAA4F,UAAA3B,kBAAA,SAAAmD,GAGA,mBAAAA,GACAzG,KAAAsE,YAAAmC,EAGAzG,KAAAsE,aAAAtE,KAAAsE,YAIAtE,KAAA6C,OAAAkD,KAAAC,eAAAhG,KAAAsE,aAGAtE,KAAAsE,YACAtE,KAAAkG,UAAAlG,KAAAmF,MAAAU,IAAA,uBAGA7F,KAAAkG,UAAAlG,KAAAmF,MAAAU,IAAA,kBAOAxG,EAAA4F,UAAAxB,WAAA,SAAAiD,GAGA,GAAA,mBAAAA,GACAA,GAAA1G,KAAAuE,oBAIA,IADAmC,EAAAH,SAAAG,GACAF,MAAAE,GACA,MAKAA,KAAA1G,KAAAuE,kBAKAvE,KAAAuE,gBAAAmC,EAGA1G,KAAAA,UACAA,KAAA6D,UAKA7D,KAAA6D,OAAA,UACA7D,KAAA6D,OAAA,aAWAxE,EAAA4F,UAAA0B,SAAA,WACA,MAAA3G,MAAAmF,OAMA9F,EAAA4F,UAAA2B,SAAA,SAAAzB,GAEA,MADAnF,MAAAmF,MAAAA,EACAnF,MAUAX,EAAA4F,UAAA4B,IAAA,SAAArF,EAAAsF,EAAAC,EAAAC,GACA,mBAAAhH,MAAA6C,OAAArB,IACAxB,KAAA6C,OAAArB,GAAAqF,IAAAC,EAAAC,EAAAC,IAOA3H,EAAA4F,UAAAgC,OAAA,SAAAzF,EAAAsF,EAAAC,GACA,mBAAA/G,MAAA6C,OAAArB,IACAxB,KAAA6C,OAAArB,GAAAyF,OAAAH,EAAAC,IAOA1H,EAAA4F,UAAAY,IAAA,SAAArE,EAAAsF,EAAAC,GACA,MAAA/G,MAAA6C,OAAArB,IAAAxB,KAAA6C,OAAArB,GAAAqE,IAAAiB,EAAAC,IAMA1H,EAAA4F,UAAAiC,IAAA,SAAA1F,EAAAsF,EAAAC,GACA,MAAA/G,MAAA6C,OAAArB,IAAAxB,KAAA6C,OAAArB,GAAA0F,IAAAJ,EAAAC,IAMA1H,EAAA4F,UAAAkC,OAAA,SAAA3F,EAAAuE,GACA,mBAAA/F,MAAA6C,OAAArB,IACAxB,KAAA6C,OAAArB,GAAA2F,OAAApB,IAOA1G,EAAA4F,UAAAC,UAAA,SAAA1D,GACA,GAAAA,EACA,mBAAAxB,MAAA6C,OAAArB,IACAxB,KAAA6C,OAAArB,GAAA0D,gBAIA,KAAA1D,IAAAxB,MAAA6C,OACA7C,KAAA6C,OAAAyD,eAAA9E,IACAxB,KAAA6C,OAAArB,GAAA0D,aAaA7F,EAAA4F,UAAAmC,eAAA,SAAAC,EAAAC,GAGAtH,KAAAD,OAAAC,KAAAE,QACAF,KAAAoD,QAAAiE,EAAAtH,MAAAsH,EAAAnH,QAIAoH,GACAtH,KAAAkF,UAAA,UAIAlF,KAAAmH,OAAA,SAAAE,EAAAE,QACAvH,KAAAmH,OAAA,SAAAE,EAAAG,SAUAnI,EAAA4F,UAAAwC,SAAA,SAAAjG,GAGA,GAAAA,EACA,MAAAxB,MAAA6C,OAAArB,GACAxB,KAAA6C,OAAArB,GAAAkG,SAEA,IAIA,IAAAC,KACA,KAAAnG,IAAAxB,MAAA6C,OACA,GAAA7C,KAAA6C,OAAAyD,eAAA9E,GAAA,CACA,GAAAuE,GAAA/F,KAAA6C,OAAArB,GAAAkG,QACA3B,KAAAA,EAAA6B,YACAD,EAAAnG,GAAAuE,GAIA,MAAA4B,IAMAtI,EAAA4F,UAAA4C,aAAA,SAAAF,EAAAnG,GAGA,GAAAA,EAIA,YAHAxB,KAAA6C,OAAArB,IACAxB,KAAA6C,OAAArB,GAAA2F,OAAAQ,GAMA,KAAAnG,IAAAxB,MAAA6C,OACA7C,KAAA6C,OAAAyD,eAAA9E,KACAxB,KAAA6C,OAAArB,GAAA0D,YACAyC,EAAAnG,IACAxB,KAAA6C,OAAArB,GAAA2F,OAAAQ,EAAAnG,MAaAnC,EAAA4F,UAAA6C,MAAA,SAAAtG,GAGA,GAAAA,EAAA,CAGA,GAAAxB,KAAAA,YAAAA,KAAA6C,OAAArB,GACA,MAKA,YADAxB,MAAA6C,OAAArB,GAAAsG,QAKA,GAAA9H,KAAAA,UAEA,WADAA,MAAA6C,OAAA0E,OAAAO,OAKA,KAAAtG,IAAAxB,MAAA6C,OACA7C,KAAA6C,OAAAyD,eAAA9E,IACAxB,KAAA6C,OAAArB,GAAAsG,SAQAzI,EAAA4F,UAAApB,OAAA,SAAArC,GAGA,GAAAxB,KAAAD,OAAAC,KAAAE,QAAAF,KAAAS,WAAAT,KAAAU,WAAA,CAKA,GAAAc,EAAA,CAGA,GAAAxB,KAAAA,YAAAA,KAAA6C,OAAArB,GACA,MAKA,YADAxB,MAAA6C,OAAArB,GAAAqC,SAKA7D,KAAA8H,OAGA,KAAA,GAAAvG,GAAA,EAAAA,EAAAvB,KAAA4C,WAAAV,OAAAX,IACAC,EAAAxB,KAAA4C,WAAArB,GACAvB,KAAA6C,OAAArB,GAAAuG,SAWA1I,EAAA4F,UAAAzC,QAAA,WAWA,GARAxC,KAAA+F,MACAiC,MAAA,EAAAhI,KAAAiE,QAAAI,KACA4D,OAAAjI,KAAAD,MAAA,EAAAC,KAAAiE,QAAAE,MACA+D,KAAA,EAAAlI,KAAAiE,QAAAC,IACAiE,KAAAnI,KAAAE,OAAA,EAAAF,KAAAiE,QAAAG,QAIApE,KAAAD,OAAAC,KAAAE,QAAAF,KAAAS,WAAAT,KAAAU,WAAA,CAMA,GAAA0H,GAAApI,KAAAD,MAAAC,KAAA8F,OACAuC,EAAArI,KAAAE,OAAAF,KAAA8F,MAGA,KAAA,GAAAO,KAAArG,MAAAgE,OACAhE,KAAAgE,OAAAqC,KACA,QAAAA,GAAA,WAAAA,EACAgC,GAAA,GAGAD,GAAA,GAMApI,MAAAW,SAAAC,KAAAE,MAAAF,KAAAC,IACAb,KAAAS,UAAA2H,EACApI,KAAAU,WAAA2H,IAIArI,KAAAsF,cAAAtF,KAAAW,UAAAyH,EAAApI,KAAA8F,OAAA,GACA9F,KAAAuF,eAAAvF,KAAAW,UAAA0H,EAAArI,KAAA8F,OAAA,GAGA9F,KAAAoF,cAAAxE,KAAAE,OAAAd,KAAAS,UAAAT,KAAAsF,eAAA,GACAtF,KAAAqF,cAAAzE,KAAAE,OAAAd,KAAAU,WAAAV,KAAAuF,gBAAA,GAGAvF,KAAA6D,WAMAxE,EAAA4F,UAAAqD,YAAA,WACA,MAAAtI,MAAAW,UAMAtB,EAAA4F,UAAAsD,QAAA,SAAAC,GACA,GAAAC,GAAAzI,KAAAgE,OAAAK,KAAA,GAAA,CACA,OAAArE,MAAAoF,cAAAxE,KAAA8H,OAAAF,EAAAC,GAAAzI,KAAAW,WAMAtB,EAAA4F,UAAA0D,QAAA,SAAAC,GACA,GAAAH,GAAAzI,KAAAgE,OAAAE,IAAA,GAAA,CACA,OAAAlE,MAAAqF,cAAAzE,KAAA8H,OAAAE,EAAAH,GAAAzI,KAAAW,WAMAtB,EAAA4F,UAAA4D,SAAA,SAAAC,GACA,GAAAL,GAAAzI,KAAAgE,OAAAK,KAAA,GAAA,CACA,OAAAzD,MAAA8H,OAAAI,EAAA9I,KAAAoF,eAAApF,KAAAW,SAAA8H,IAMApJ,EAAA4F,UAAA8D,SAAA,SAAAC,GACA,GAAAP,GAAAzI,KAAAgE,OAAAE,IAAA,GAAA,CACA,OAAAtD,MAAA8H,OAAAM,EAAAhJ,KAAAqF,eAAArF,KAAAW,SAAA8H,IAMApJ,EAAA4F,UAAAgE,UAAA,SAAAT,EAAAI,GACA,MACAJ,IAAAxI,KAAA+F,KAAAiC,OAAAY,GAAA5I,KAAA+F,KAAAmC,MACAM,GAAAxI,KAAA+F,KAAAkC,QAAAW,GAAA5I,KAAA+F,KAAAoC,MCptBA9I,OAIA3D,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAWAD,GAAAE,OAAA,0CACA,SAMAqN,QAAA,sBAAA,WAQA,MAAA,UAAAvJ,EAAAwJ,GAGA,GAAAxJ,EAAA,CAKA,GAAAmH,GAAA9G,KAAAuC,MAAAgG,QAAAY,EAAArC,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAQ,EAAApC,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAArJ,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,EC3CAzJ,GAAA2J,UAAAxC,EAAAuC,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAAA,QAIA3N,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAWAD,GAAAE,OAAA,2BACA,OACA,mCAMAqN,QAAA,aAAA,mBAAA,SAAAK,GAKA,GAAAC,GAAA,SAAA1C,EAAAC,EAAA0C,GAGA,GAAAN,IACArC,EAAAA,EACAC,EAAAA,EAIA,OAAA,gBAAA/G,MAAA+F,KAAAe,GAAAC,GACApL,EAAA+I,OAAAyE,EAAAnJ,KAAA+F,KAAAe,GAAAC,KAIAoC,EAAAM,GAAAzJ,KAAA+F,KAAAe,GAAAC,GACAoC,IAMAO,EAAA,SAAA3J,EAAAG,EAAAyJ,GAGA3J,KAAAD,MAAA,EACAC,KAAAE,OAAA,EACAF,KAAA+F,QACA/F,KAAA2J,WAAA,KAGA,mBAAAA,KACA3J,KAAA2J,WAAAA,IAIA5J,GAAAG,IACAF,KAAAoD,QAAArD,EAAAG,GCjEA,ODwEAwJ,GAAAzE,UAAA2E,IAAA,SAAA9C,EAAAC,EAAAC,GACAhH,KAAA6J,SAAA/C,EAAAC,KACA/G,KAAA+F,KAAAe,GAAAC,GAAAC,IAOA0C,EAAAzE,UAAA6E,MAAA,SAAAhD,EAAAC,GACA/G,KAAA6J,SAAA/C,EAAAC,KACA/G,KAAA+F,KAAAe,GAAAC,GAAA/G,KAAA2J,aAOAD,EAAAzE,UAAAiC,IAAA,SAAAJ,EAAAC,GACA,MAAA/G,MAAA6J,SAAA/C,EAAAC,IAAA/G,KAAA+F,KAAAe,GAAAC,KAAA/G,KAAA2J,YAMAD,EAAAzE,UAAA8E,GAAA,SAAAjD,EAAAC,EAAAC,GACA,MAAAhH,MAAA6J,SAAA/C,EAAAC,IAAA/G,KAAA+F,KAAAe,GAAAC,KAAAC,GAMA0C,EAAAzE,UAAAY,IAAA,SAAAiB,EAAAC,EAAA0C,GAGA,MAAAzJ,MAAA6J,SAAA/C,EAAAC,IAAA/G,KAAA+F,KAAAe,GAAAC,KAAA/G,KAAA2J,WAKAF,EAKAD,EAAA7G,KAAA3C,KAAA8G,EAAAC,EAAA0C,GAJAzJ,KAAA+F,KAAAe,GAAAC,GALA/G,KAAA2J,YAoBAD,EAAAzE,UAAA+E,IAAA,SAAAP,GAGA,IAAAA,EACA,MAAAzJ,MAAA+F,IAOA,KAAA,GAHAkE,MAGAnD,EAAA,EAAAA,EAAA9G,KAAAD,MAAA+G,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAA/G,KAAAE,OAAA6G,IACA/G,KAAA+F,KAAAe,GAAAC,KAAA/G,KAAA2J,YACAM,EAAAC,KAAAV,EAAA7G,KAAA3C,KAAA8G,EAAAC,EAAA0C,GAMA,OAAAQ,IAMAP,EAAAzE,UAAA2C,QAAA,WACA,IAAA,GAAAd,GAAA,EAAAA,EAAA9G,KAAAD,MAAA+G,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAA/G,KAAAE,OAAA6G,IACA,GAAA/G,KAAA+F,KAAAe,GAAAC,KAAA/G,KAAA2J,WACA,OAAA,CAIA,QAAA,GAMAD,EAAAzE,UAAAkF,SAAA,SAAAnD,GACA,IAAA,GAAAF,GAAA,EAAAA,EAAA9G,KAAAD,MAAA+G,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAA/G,KAAAE,OAAA6G,IACA/G,KAAA+F,KAAAe,GAAAC,GAAAC,GAQA0C,EAAAzE,UAAAmF,MAAA,WACA,IAAA,GAAAtD,GAAA,EAAAA,EAAA9G,KAAAD,MAAA+G,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAA/G,KAAAE,OAAA6G,IACA/G,KAAA+F,KAAAe,GAAAC,GAAA/G,KAAA2J,YAQAD,EAAAzE,UAAAoF,MAAA,WAGA,GAAAC,GAAA,GAAAZ,EASA,OANAY,GAAAvE,KAAApK,EAAA4O,KAAAvK,KAAA+F,MACAuE,EAAAX,WAAA3J,KAAA2J,WACAW,EAAAvK,MAAAC,KAAAD,MACAuK,EAAApK,OAAAF,KAAAE,OAGAoK,GAUAZ,EAAAzE,UAAAuF,SAAA,SAAAzE,GAGA,GAAA/F,KAAAD,QAAAgG,EAAAhG,OAAAC,KAAAE,SAAA6F,EAAA7F,OACA,OAAA,CAIA,KAAA,GAAA4G,GAAA,EAAAA,EAAA9G,KAAAD,MAAA+G,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAA/G,KAAAE,OAAA6G,IACA,GAAA/G,KAAA+F,KAAAe,GAAAC,KAAAhB,EAAAe,GAAAC,GACA,OAAA,CAMA,QAAA,GAMA2C,EAAAzE,UAAAwF,QAAA,SAAAH,EAAAb,GAGA,GAAArD,GAAA,GAAAmD,EAGA,IAAAvJ,KAAAD,QAAAuK,EAAAvK,OAAAC,KAAAE,SAAAoK,EAAApK,OAEA,MADAwK,SAAAC,KAAA,+CACAvE,CAIA,KAAA,GAAAU,GAAA,EAAAA,EAAA9G,KAAAD,MAAA+G,IACA,IAAA,GAAAC,GAAA,EAAAA,EAAA/G,KAAAE,OAAA6G,IAGAuD,EAAAvE,KAAAe,GAAAC,KAAA/G,KAAA2J,YAAAW,EAAAvE,KAAAe,GAAAC,KAAA/G,KAAA+F,KAAAe,GAAAC,IACAX,EAAAS,IAAAqD,KAAAV,EAAA7G,KAAA2H,EAAAxD,EAAAC,EAAA0C,IAIAzJ,KAAA+F,KAAAe,GAAAC,KAAA/G,KAAA2J,YAAAW,EAAAvE,KAAAe,GAAAC,KAAA/G,KAAA+F,KAAAe,GAAAC,IACAX,EAAAa,OAAAiD,KAAAV,EAAA7G,KAAA3C,KAAA8G,EAAAC,EAAA0C,GAMA,OAAArD,IAUAsD,EAAAzE,UAAA4E,SAAA,SAAA/C,EAAAC,GACA,MAAAD,IAAA,GAAAC,GAAA,GAAAD,EAAA9G,KAAAD,OAAAgH,EAAA/G,KAAAE,QAMAwJ,EAAAzE,UAAA2F,UAAA,SAAAjB,GACA3J,KAAA2J,WAAAA,GAMAD,EAAAzE,UAAA7B,QAAA,SAAArD,EAAAG,GAGAH,EAAAA,GAAAG,GAAA,EACAA,EAAAA,GAAAH,GAAA,EAGAC,KAAAD,MAAAwG,SAAAxG,GACAC,KAAAE,OAAAqG,SAAArG,GAGAF,KAAA+F,OACA,KAAA,GAAAe,GAAA,EAAAA,EAAA9G,KAAAD,MAAA+G,IAAA,CACA9G,KAAA+F,KAAAe,KACA,KAAA,GAAAC,GAAA,EAAAA,EAAA/G,KAAAE,OAAA6G,IACA/G,KAAA+F,KAAAe,GAAAC,GAAA/G,KAAA2J,aAQAD,EAAAzE,UAAA4F,QAAA,WACA,OAAA9K,MAAAC,KAAAD,MAAAG,OAAAF,KAAAE,SCvTAwJ,MAGAhO,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,kCACA,SAMAqN,QAAA,mBAAA,WAKA,GAAA4B,GAAA,SAAAC,EAAAC,GAGA,IAAA,GADAC,GADAC,KAEA3J,EAAA,EAAAA,EAAAwJ,EAAA7I,OAAAX,IAAA,CACA0J,GAAA,CACA,KAAA,GAAAE,KAAAH,GACA,GAAAD,EAAAxJ,GAAAuF,IAAAkE,EAAAG,GAAArE,GAAAiE,EAAAxJ,GAAAwF,IAAAiE,EAAAG,GAAApE,EAAA,CACAkE,GAAA,CACA,OAGAA,GACAC,EAAAhB,KAAAa,EAAAxJ,IAGA,MAAA2J,GAMA,OAAA,YAKAlL,KAAA6G,OACA7G,KAAAiH,UAKAjH,KAAAoL,OAAA,SAAAC,GACArL,KAAA6G,IAAAiE,EAAA9K,KAAA6G,IAAAwE,EAAApE,QAAAmE,OAAAC,EAAAxE,KACA7G,KAAAiH,OAAA6D,EAAA9K,KAAAiH,OAAAoE,EAAAxE,KAAAuE,OAAAC,EAAApE,SAMAjH,KAAAkH,IAAA,WCrEA,SAAAlH,KAAA6G,IAAA3E,SAAAlC,KAAAiH,OAAA/E,aAKAxG,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAWAD,GAAAE,OAAA,4BACA,OACA,4BAMAqN,QAAA,cAAA,YAAA,SAAAQ,GAKA,GAAA4B,GAAA,SAAA/I,EAAA5C,GAGAK,KAAAuC,MAAAA,EACAvC,KAAAL,QAAAA,EAGAK,KAAA+F,KAAA,GAAA2D,GCpCA,OD8CA4B,GAAArG,UAAA7B,QAAA,SAAArD,EAAAG,GAOAF,KAAA+F,KAAA3C,QAAArD,EAAAG,IAMAoL,EAAArG,UAAAyC,OAAA,WACA,MAAA1H,MAAA+F,KAAAsE,SAMAiB,EAAArG,UAAAkC,OAAA,SAAApB,GACA/F,KAAA+F,KAAAA,EAAAsE,SAMAiB,EAAArG,UAAAC,UAAA,WACAlF,KAAA8H,QACA9H,KAAA+F,KAAAqE,SAMAkB,EAAArG,UAAA4B,IAAA,SAAAC,EAAAC,EAAAC,GACAhH,KAAAuL,UAAAzE,EAAAC,GACA/G,KAAA+F,KAAA6D,IAAA9C,EAAAC,EAAAC,GACAhH,KAAAwL,SAAA1E,EAAAC,IAMAuE,EAAArG,UAAAgC,OAAA,SAAAH,EAAAC,GACA/G,KAAAuL,UAAAzE,EAAAC,GACA/G,KAAA+F,KAAA+D,MAAAhD,EAAAC,IAMAuE,EAAArG,UAAAY,IAAA,SAAAiB,EAAAC,GACA,MAAA/G,MAAA+F,KAAAF,IAAAiB,EAAAC,IAMAuE,EAAArG,UAAAiC,IAAA,SAAAJ,EAAAC,GACA,MAAA/G,MAAA+F,KAAAmB,IAAAJ,EAAAC,IAUAuE,EAAArG,UAAA8C,KAAA,aAOAuD,EAAArG,UAAA6C,MAAA,WACA9H,KAAAL,SACAK,KAAAL,QAAA2J,UACA,EAAA,EAAAtJ,KAAAL,QAAAH,OAAAS,YAAAD,KAAAL,QAAAH,OAAAW,eAQAmL,EAAArG,UAAApB,OAAA,WACA7D,KAAA8H,QACA9H,KAAA+H,QAMAuD,EAAArG,UAAAuG,SAAA,aAOAF,EAAArG,UAAAsG,UAAA,aAOAD,EAAArG,UAAAwG,WAAA,SAAA3E,EAAAC,GACA/G,KAAAuL,UAAAzE,EAAAC,GACA/G,KAAAwL,SAAA1E,EAAAC,IAMAuE,EAAArG,UAAAnC,WAAA,SAAAnD,GACAK,KAAAL,QAAAA,GAMA2L,EAAArG,UAAArF,WAAA,WACA,MAAAI,MAAAL,SC5KA2L,MAGA5P,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,6BACA,OACA,2CAMAqN,QAAA,eAAA,sBAAA,SAAAwC,GAKA,GAAAC,IAKA5D,KAAA,WACA,IAAA/H,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,YAQA9D,MAAA,SAAAqB,GACAuC,EAAA/I,KAAA3C,KAAAA,KAAAL,QAAAwJ,IC1CA,OAAAwC,OAGAjQ,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,mCACA,SAMAqN,QAAA,eAAA,WAKA,GAAA2C,GAAA,SAAAC,EAAAhF,EAAAC,EAAAgF,EAAAC,EAAAC,EAAAC,GAGAJ,EAAAK,WAAA,EACAL,EAAAI,YAAAA,EACAJ,EAAAM,UAAAL,EAAA,GAAA/L,KAAAqM,UACAP,EAAAQ,YAGAP,GAAAnL,KAAA2L,IAAA,EAAAT,EAAAM,UAGA,IAMAI,GAAAC,EANAC,EAAA5F,EAAAiF,EAAAnL,KAAA+L,IAAAX,EAAApL,KAAAgM,IACAC,EAAA9F,EAAAgF,EAAAnL,KAAAkM,IAAAd,EAAApL,KAAAgM,IACAG,EAAAjG,EAAAiF,EAAAnL,KAAA+L,IAAAV,EAAArL,KAAAgM,IACAI,EAAAjG,EAAAgF,EAAAnL,KAAAkM,IAAAb,EAAArL,KAAAgM,GAIAG,GAAAL,GACAF,GAAAQ,EAAAH,IAAAE,EAAAL,GACAD,EAAA7L,KAAAqM,KAAAT,IAEAO,IAAAL,EACAD,EAAA7L,KAAAgM,GAAA,GAGAJ,GAAAQ,EAAAH,IAAAE,EAAAL,GACAD,EAAA7L,KAAAqM,KAAAT,GAAA5L,KAAAgM,GAIA,IAAAM,GAAAlN,KAAAmN,OAAApB,EACAqB,EAAAxM,KAAAkM,IAAAL,GAAAS,EACAG,EAAAzM,KAAA+L,IAAAF,GAAAS,EAGAI,EAAAZ,EAAAU,EACAG,EAAAV,EAAAQ,EACAG,EAAAT,EAAAK,EACAK,EAAAT,EAAAK,CAGAvB,GAAA4B,OAAAhB,EAAAG,GACAf,EAAA6B,cAAAL,EAAAC,EAAAC,EAAAC,EAAAV,EAAAC,GACAlB,EAAA8B,SAMA,OAAA,UAAA9B,EAAAhF,EAAAC,EAAAgF,EAAAU,EAAAP,GAOA,IAAA,GAJAF,GAAAS,EACAR,EAAAQ,EAGAlL,EAAA,EAAAA,EAAAvB,KAAA6N,MAAA3L,OAAAX,IACAyK,GAAAhM,KAAA6N,MAAAtM,GACA0K,GAAAjM,KAAA6N,MAAAtM,GCxFAsK,EAAAlJ,KAAA3C,KAAA8L,EAAAhF,EAAAC,EAAAgF,EAAAC,EAAAC,EAAAC,OAKAxQ,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAYAD,GAAAE,OAAA,4BACA,SAMAiI,SAAA,cAAA,aAAA,cAAA,SAAAgK,EAAAC,GAKA,GAAAC,IAGAzL,OAGAuD,OAAA,KAIAmI,OAGAC,MAAA,QACAC,QAAA,EACApC,OAAA,SAAApL,GACA,MAAAC,MAAAE,MAAAH,EAAA,IAIAyN,OACAC,MAAA,SAAAC,GACA,MAAAA,KAAAR,EAAAhR,EACA,OAEA,WAEA8Q,OAAA,yBACAW,QAEAV,OAAA,GAAA,IAAA,IAAA,GAAA,IAAA,IAAA,IAAA,KACAV,OAAA,IACAd,UAAA,OAGAwB,OAAA,GAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAV,OAAA,GACAd,UAAA,MAGAwB,OAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAV,OAAA,IACAd,UAAA,OAGAwB,OAAA,IAAA,IAAA,IAAA,IAAA,KACAV,OAAA,GACAd,UAAA,KAMAmC,MACApC,UAAA,EACAqC,UAAA,WACA,MAAA,QAEAJ,MAAA,SAAAC,GACA,MAAAA,KAAAR,EAAAhR,EACA,OAEA,SAKA4R,MACA7O,MAAA,GACA8O,MAAA,GAIAC,OACA/O,MAAA,EACA8O,MAAA,SAAAL,GACA,MAAAA,KAAAR,EAAAhR,EACA,GAEA,MAMAqR,QAGAE,MAAA,qBAGArL,KAAA,SAAArC,GACA,MAAAC,MAAAE,MAAAH,EAAA,KAIAkO,KAAA,SAAAlO,GACA,MAAAA,GAAA,IAIAmO,QAAA,SAAAnO,GACA,MAAAC,MAAAmO,KAAApO,EAAA,KAEAqO,QAAA,SAAArO,GACA,MAAAC,MAAAmO,KAAApO,EAAA,MAKA6G,QAGA6G,MAAA,SAAAC,GACA,MAAAA,KAAAR,EAAAhR,EACA,wBAEA,mBAIAsP,UAAA,SAAAzL,GACA,MAAAC,MAAA2L,IAAA,EAAA3L,KAAAE,MAAAH,EAAA,MAIAsO,UACApP,MAAA,KAIAqP,QACArP,MAAA,KAIAsP,QACAtP,MAAA,KAIAuP,MACAC,QAAA,SACAxP,MAAA,KAIAyP,MACAzP,MAAA,IAIA0P,QACAF,QAAA,QACAxP,MAAA,KAIA2P,OACAC,KAAA,SAIAC,WACAC,KAAA5B,EAAAxQ,MACAqS,KAAA,SAAArO,GACA,MAAAsO,QAAAC,aAAA,GAAAvO,IAEA8M,MAAA,uBAIA0B,UACAC,OACAL,KAAA5B,EAAAzQ,OACAsS,KAAA,KACAvB,MAAA,oBACAxO,MAAA,IAEAoQ,SACAN,KAAA5B,EAAA1Q,KACAuS,KAAA,KACAvB,MAAA,mBACAxO,MAAA,MAMAkG,MAGA0I,UAAA,mBACArC,UAAA,SAAAzL,GACA,MAAAA,GAAA,GACA,EAEAA,EAAA,GACA,IAEA,GAEA0O,QAAA,SAGAa,MAGA7B,MAAA,mBACAtC,OAAA,SAAApL,GACA,MAAAA,GAAA,GACAC,KAAAE,MAAAH,EAAA,GAAA,GAEAA,EAAA,GACA,EAEAA,EAAA,GACA,EAEAA,EAAA,EACA,IAEA,GAIAwP,OAAA,SAAApQ,EAAAG,GAGA,MAAAH,KAAAG,GAAA,KAAAH,IAEA+G,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IAAAD,EAAA,GAAAC,EAAA,IACAD,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IAAAD,EAAA,GAAAC,EAAA,IACAD,EAAA,EAAAC,EAAA,KAAAD,EAAA,EAAAC,EAAA,KAAAD,EAAA,GAAAC,EAAA,KAKAhH,IAAAG,GAAA,KAAAH,IAEA+G,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IACAD,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IAKAhH,IAAAG,GAAA,IAAAH,IAEA+G,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IACAD,EAAA,EAAAC,EAAA,IAAAD,EAAA,EAAAC,EAAA,IACAD,EAAA,EAAAC,EAAA,UAWAzC,aAGA+J,MAAA,sBAGAvI,OAAA,KAGAsK,UACAX,KAAA,QACAvB,MAAA,UACAmC,SAAA,EACArN,KAAA,WACA,MAAA,UAAAsN,EAAA3P,GACA,MAAAC,MAAAE,MAAA,GAAAH,EAAA,GAAA,QAMA4P,YACAd,KAAA,QACAvB,MAAA,UACAmC,SAAA,EACArN,KAAA,WACA,MAAA,UAAAsN,EAAA3P,GACA,MAAAC,MAAAE,MAAA,GAAAH,EAAA,GAAA,SAUAX,MAAA4G,SAAA,SAAAzB,GACAA,IACA6I,EAAArS,EAAA6U,MAAAxC,EAAA7I,KAOAnF,KAAA2E,KAAA,WAKA,GAAAG,GAAA,SAAAK,GAGAnF,KAAAyQ,cAAAtL,EACAnF,KAAA0Q,QC1VA,ODgWA5L,GAAAG,UAAAyL,MAAA,WAGA1Q,KAAAmF,MAAAxJ,EAAA4O,KAAAyD,GAGAhO,KAAAyQ,eACA9U,EAAA6U,MAAAxQ,KAAAmF,MAAAnF,KAAAyQ,gBAOA3L,EAAAG,UAAAY,IAAA,SAAA8K,GAOA,IAAA,GAJAC,GAAAD,EAAAxN,MAAA,KACA0N,EAAA7Q,KAAAmF,MAGA5D,EAAA,EAAAA,EAAAqP,EAAA1O,OAAAX,IAAA,CAGA,GAAA,mBAAAsP,GAAAD,EAAArP,IAEA,MADAmJ,SAAAC,KAAA,gCAAAgG,GACA,IAIAE,GAAAA,EAAAD,EAAArP,IAIA,GAAA,kBAAAsP,GACA,MAAAA,EAIA,IAAAC,KACA,IAAAC,UAAA7O,OAAA,EACA,IAAA,GAAA6I,GAAA,EAAAA,EAAAgG,UAAA7O,OAAA6I,IACA+F,EAAA5G,KAAA6G,UAAAhG,GAKA,OAAA8F,GAAAG,MAAAhR,KAAA8Q,IAMAhM,EAAAG,UAAA2E,IAAA,SAAA+G,EAAA3J,GAOA,IAAA,GAJA4J,GAAAD,EAAAxN,MAAA,KACA0N,EAAA7Q,KAAAmF,MAGA5D,EAAA,EAAAA,EAAAqP,EAAA1O,OAAAX,IAAA,CAGA,GAAAA,EAAA,IAAAqP,EAAA1O,OAAA,CACA2O,EAAAD,EAAArP,IAAAyF,CACA,OAIA,mBAAA6J,GAAAD,EAAArP,MACAsP,EAAAD,EAAArP,QAIAsP,EAAAA,EAAAD,EAAArP,IAIA,MAAAvB,OAOA8E,EAAAG,UAAAgM,gBAAA,SAAA7E,GASA,MALA,mBAAAA,KACAA,EAAApM,KAAA6F,IAAA,mBAIAuG,EAAA,EAAA,IC9bAtH,OAIApJ,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,wCACA,SAMAqN,QAAA,oBAAA,OAAA,SAAAgI,GAKA,GAAAC,GAAA,SAAAC,GAQA,OALApR,KAAAoR,KAAAA,EACApR,KAAAjE,KAAA,mBACAiE,KAAAqR,QAAA,iBAGAD,GACA,IAAAF,GAAAjV,MAAAK,QACA0D,KAAAqR,SAAA,qBACA,MACA,KAAAH,GAAAjV,MAAAM,aACAyD,KAAAqR,SAAA,sBACA,MACA,KAAAH,GAAAjV,MAAAQ,YACAuD,KAAAqR,SAAA,2BACA,MACA,KAAAH,GAAAjV,MAAAO,YACAwD,KAAAqR,SAAA,2BACA,MACA,KAAAH,GAAAjV,MAAAS,iBACAsD,KAAAqR,SAAA,2BACA,MACA,KAAAH,GAAAjV,MAAAU,sBACAqD,KAAAqR,SAAA,oCACA,MACA,SACArR,KAAAqR,SAAA,6BCtDA,OD6DAF,GAAAlM,UAAA,GAAAqM,OACAH,EAAAlM,UAAAsM,YAAAJ,EC9DAA,MAGAzV,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,4CACA,SAMAqN,QAAA,wBAAA,OAAA,aAAA,SAAAgI,EAAApD,GAKA,GAAA0D,GAAA,SAAAJ,EAAAtK,EAAAC,EAAAsH,GAcA,OAXArO,KAAAoR,KAAAA,EACApR,KAAAjE,KAAA,uBACAiE,KAAAqR,QAAA,6BAGA,mBAAAvK,IAAA,mBAAAC,IAAA,mBAAAsH,KACArO,KAAAqR,SAAA,uBAAAhD,IAAAP,EAAA9Q,EAAA,QAAA,SACA,cAAA8J,EAAA,KAAAC,EAAA,KAIAqK,GACA,IAAAF,GAAAjV,MAAAwV,wBACAzR,KAAAqR,SAAA,+CACA,MACA,KAAAH,GAAAjV,MAAAyV,4BACA1R,KAAAqR,SAAA,sDACA,MACA,KAAAH,GAAAjV,MAAA0V,qBACA3R,KAAAqR,SAAA,8BACA,MACA,KAAAH,GAAAjV,MAAA2V,uBACA5R,KAAAqR,SAAA,sCACA,MACA,SACArR,KAAAqR,SAAA,KCtDA,OD6DAG,GAAAvM,UAAA,GAAAqM,OACAE,EAAAvM,UAAAsM,YAAAC,EC9DAA,MAGA9V,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAaAD,GAAAE,OAAA,qBACA,OACA,yBACA,yBACA,6BACA,0BACA,2BACA,uCACA,6CAMAiI,SAAA,OAAA,WAKA,GAAAC,IAGA8N,YAAA,EAGAC,YAAA,EACAC,gBAAA,EAGAC,cAAA,EAGAC,YAAA,KAGAC,cAAA,EAMAlS,MAAAwE,UAAA,SAAAC,GACAV,EAAApI,EAAA+I,OAAAX,EAAAU,IAMAzE,KAAA2E,MAAA,OAAA,aAAA,WAAA,WAAA,eAAA,aAAA,YAAA,mBAAA,uBAAA,SACAuM,EAAApD,EAAAqE,EAAAC,EAAAC,EAAAC,EACAC,EAAApB,EAAAK,GAUA,GAAAgB,GAAA,WAGAxS,KAAAyS,KAAAlQ,QACAvC,KAAAyS,KAAAlQ,UAIAvC,KAAAyS,KAAAC,OACA1S,KAAAyS,KAAAC,SAIA,mBAAA1S,MAAAyS,KAAAlQ,MAAAxC,QACAC,KAAAyS,KAAAlQ,MAAAxC,MAAAC,KAAAyE,OAAAoN,aAEA,mBAAA7R,MAAAyS,KAAAlQ,MAAArC,SACAF,KAAAyS,KAAAlQ,MAAArC,OAAAF,KAAAyE,OAAAoN,aAEA,mBAAA7R,MAAAyS,KAAAC,KAAAC,OACA3S,KAAAyS,KAAAC,KAAAC,KAAA3S,KAAAyE,OAAAqN,aAEA,mBAAA9R,MAAAyS,KAAAC,KAAAE,WACA5S,KAAAyS,KAAAC,KAAAE,SAAA5S,KAAAyE,OAAAsN,kBAWAc,EAAA,SAAAtR,GAGA,MAAA,KAAAvB,KAAA8S,KAAAC,SAAA7Q,QACA,GAIAX,IAAA3F,IACA2F,EAAAvB,KAAA8S,KAAAE,kBAIAzR,EAAAA,GAAA,EACA,KAAAA,IACAA,EAAA,GAIAA,GAAAvB,KAAA8S,KAAAC,SAAA7Q,SAAAlC,KAAA8S,KAAAC,SAAAxR,IACA,GAIAvB,KAAA4Q,KAAAqC,QAAA1R,GAGAvB,KAAA8S,KAAA9S,KAAA8S,KAAAC,SAAAxR,IACA,KAMA2R,EAAA,WAGA,MAAAlT,MAAA8S,KAAApR,QAKA1B,KAAA4Q,KAAAuC,UAGAnT,KAAA8S,KAAA9S,KAAA8S,KAAApR,QACA,IARA,GAcA0R,EAAA,WAGApT,KAAA4Q,KAAAF,QAGA1Q,KAAA8S,KAAA9S,KAAAqT,KAIArT,KAAAsT,QAAAtT,KAAAyS,KAAAC,KAAAE,SAAA,EAAA9E,EAAA9Q,EAAA8Q,EAAAhR,IAUAyW,EAAA,WAGA,IAAAvT,KAAAwT,QAAAtR,SAKAlC,KAAAwT,WACAxT,KAAAwT,QAAAtJ,KAAA,GAAAmI,IAGArS,KAAAyS,KAAAlQ,OACAvC,KAAAwT,QAAA,GAAApQ,QAAApD,KAAAyS,KAAAlQ,MAAAxC,MAAAC,KAAAyS,KAAAlQ,MAAArC,UAQAuT,EAAA,SAAAC,GASA,MANAA,KACAA,EAAA1T,KAAAqH,SAAAgD,SAIArK,KAAAwT,QAAAtJ,KAAAwJ,GACAA,GAMAC,EAAA,WAGA,MAAA,KAAA3T,KAAAwT,QAAAtR,OACA,KAIAlC,KAAAwT,QAAAI,OAMAC,EAAA,SAAAH,GACAA,IACA1T,KAAAwT,QAAAI,MACA5T,KAAAwT,QAAAtJ,KAAAwJ,KAWAI,EAAA,WAGA9T,KAAA8S,KAAApR,SACA1B,KAAA8S,KAAApR,OAAAsR,iBAAAhT,KAAA8S,KAAApR,OAAAqR,SAAA7P,QAAAlD,KAAA8S,MAIA,IAAAvR,GACAmS,EAAA1T,KAAAqH,SAAAgD,OAkBA,IAfArK,KAAA8S,KAAAiB,OACA/T,KAAA8S,KAAAiB,KAAAC,KACAN,EAAAJ,SAAAtT,KAAA8S,KAAAiB,KAAA1F,OAGArO,KAAAiU,aAAAjU,KAAA8S,KAAAiB,KAAAjN,EAAA9G,KAAA8S,KAAAiB,KAAAhN,EAAA/G,KAAA8S,KAAAiB,KAAA1F,MAAAqF,IAKA1T,KAAA8S,KAAAoB,MACAR,EAAAJ,QAAAtT,KAAA8S,KAAAoB,MAIAlU,KAAA8S,KAAAqB,MACA,IAAA5S,IAAAvB,MAAA8S,KAAAqB,MACAnU,KAAA8S,KAAAqB,MAAA7N,eAAA/E,IACAmS,EAAAnM,OAAAqC,IACA5J,KAAA8S,KAAAqB,MAAA5S,GAAAuF,EAAA9G,KAAA8S,KAAAqB,MAAA5S,GAAAwF,EAAA/G,KAAA8S,KAAAqB,MAAA5S,GAAA8M,MAOA,IAAArO,KAAA8S,KAAAtL,OACA,IAAAjG,IAAAvB,MAAA8S,KAAAtL,OACAxH,KAAA8S,KAAAtL,OAAAlB,eAAA/E,IACAmS,EAAAlM,OAAAoC,IACA5J,KAAA8S,KAAAtL,OAAAjG,GAAAuF,EAAA9G,KAAA8S,KAAAtL,OAAAjG,GAAAwF,EAAA/G,KAAA8S,KAAAtL,OAAAjG,GAOAkS,GAAA9Q,KAAA3C,KAAA0T,IAUAU,EAAA,SAAAC,EAAA5P,GAGAzE,KAAAyE,OAAA9I,EAAA+I,UAAAX,EAAAU,OAGA6P,OAAAC,eAAAvU,KAAA,YAGA6F,IAAA,WACA,MAAA7F,MAAAwT,QAAAxT,KAAAwT,QAAAtR,OAAA,IAIA0H,IAAA,SAAA8J,GACA1T,KAAAwT,QAAAxT,KAAAwT,QAAAtR,QAAAwR,KAKAW,EACArU,KAAAwU,KAAAH,GAGArU,KAAA+E,OC5UA,ODmVAqP,GAAAnP,UAAAF,KAAA,WAGA/E,KAAAyS,QAGAzS,KAAAqT,KAAA,KACArT,KAAA8S,KAAA,KAGA9S,KAAA4Q,KAAA,GAAAuB,GAGAnS,KAAAyU,IAAA,KAGAzU,KAAAwT,YAMAY,EAAAnP,UAAAuP,KAAA,SAAAH,GAGArU,KAAA+E,MAGA,KACA/E,KAAA0U,SAAAL,GAEA,MAAAM,GAMA,KAHApB,GAAA5Q,KAAA3C,MAGA,GAAAmR,GAAAwD,GAIA3U,KAAA4U,SAMAR,EAAAnP,UAAA4P,OAAA,WACA7U,KAAAyU,KACAzU,KAAAwU,KAAAxU,KAAAyU,MAOAL,EAAAnP,UAAA6P,SAAA,WACA,MAAA,QAAA9U,KAAAqT,MAUAe,EAAAnP,UAAAoF,MAAA,WAOA,IAAA,GAJAA,GAAA,GAAA+J,GACAW,EAAAT,OAAAU,oBAAAhV,MAGAiV,EAAA,EAAAA,EAAAF,EAAA7S,OAAA+S,IACA5K,EAAA4K,GAAAtZ,EAAA4O,KAAAvK,KAAAiV,GAIA,OAAA5K,IAMA+J,EAAAnP,UAAAyP,SAAA,SAAAL,GAGA,IAAAA,EACA,KAAAnD,GAAAjV,MAAAK,OAIA,IAAA,gBAAA+X,GAAA,CACA,GAAAnH,GAAAmH,EAAAa,OAAA,EACA,IAAA,MAAAhI,EACA,MAAAlN,MAAAmV,QAAAd,EAEA,IAAA,MAAAnH,GAAA,MAAAA,EACA,MAAAlN,MAAAoV,QAAAf,EAEA,IAAA,OAAAnH,EACA,MAAAlN,MAAAqV,QAAAhB,EAGA,MAAAnD,GAAAjV,MAAAM,aAKA,GAAA,gBAAA8X,GAMA,KAAAnD,GAAAjV,MAAAM,YALAyD,MAAAoV,QAAAf,IAYAD,EAAAnP,UAAAoQ,QAAA,SAAAC,GAGA,GAAAb,GAAAnC,EAAAiD,QAAAD,EACA,KAAAb,EACA,KAAAvD,GAAAjV,MAAAQ,WAIAuD,MAAAoV,QAAAX,IAMAL,EAAAnP,UAAAkQ,QAAA,SAAAK,GAGA,GAAAf,GAAAnC,EAAAmD,QAAAD,EACA,KAAAf,EACA,KAAAvD,GAAAjV,MAAAO,WAIAwD,MAAAoV,QAAAX,IAMAL,EAAAnP,UAAAmQ,QAAA,SAAAX,GAGA,GAAA,gBAAAA,GACA,IACAA,EAAA9Y,EAAA+Z,SAAAjB,GAEA,MAAAxY,GACA,KAAAiV,GAAAjV,MAAAS,iBAYA,GAPAf,EAAAwK,QAAAsO,KACAA,GACAkB,KAAAlB,IAKA,gBAAAA,GAAAkB,KACA,GAAA,MAAAlB,EAAAkB,KAAAT,OAAA,GACA,IACAT,EAAAkB,KAAAha,EAAA+Z,SAAAjB,EAAAkB,MAEA,MAAA1Z,GACA,KAAAiV,GAAAjV,MAAAU,0BAIA8X,GAAAkB,OAKA,KAAA,GAAApU,KAAAkT,GACAA,EAAAnO,eAAA/E,IAAA,SAAAA,IACAvB,KAAAyS,KAAAlR,GAAA5F,EAAA4O,KAAAkK,EAAAlT,IAKAiR,GAAA7P,KAAA3C,MAGAA,KAAAqT,KAAA,GAAAjB,GAGAqC,EAAAkB,MACA3V,KAAAqT,KAAA+B,QAAAX,EAAAkB,MAIA3V,KAAAyU,IAAAA,GAMAL,EAAAnP,UAAA2Q,MAAA,WACA,MAAAtD,GAAAuD,QAAA7V,KAAA8V,UAMA1B,EAAAnP,UAAA6Q,MAAA,SAAAC,GAOA,IAAA,GAJAtB,GAAAlC,EAAAkC,MACAM,EAAAT,OAAAU,oBAAAhV,MAGAiV,EAAA,EAAAA,EAAAF,EAAA7S,OAAA+S,IAGA,SAAAA,IAKAR,EAAAQ,GACAR,EAAAQ,GAAAtZ,EAAA+I,OAAA+P,EAAAQ,GAAAjV,KAAAiV,IAKAR,EAAAQ,GAAAtZ,EAAA4O,KAAAvK,KAAAiV,IAQA,OAHAR,GAAAkB,KAAA3V,KAAAqT,KAAAyC,QAGAC,EAAApa,EAAAqa,OAAAvB,GAAAA,GAUAL,EAAAnP,UAAAgR,QAAA,WACA,MAAAjW,MAAA8S,MAMAsB,EAAAnP,UAAAiR,cAAA,SAAAnC,GAGAA,EAAAA,GAAA,CAOA,KAJA,GAAAjB,GAAA9S,KAAAqT,KACA8C,EAAA,EAGArD,GASA,GANAA,EAAAA,EAAAsD,SAAAtD,EAAAE,kBACAF,GAAAA,EAAAiB,MACAoC,IAIAA,IAAApC,EACA,MAAAjB,EAKA,OAAA,OAMAsB,EAAAnP,UAAAoR,aAAA,SAAAC,EAAAC,GAGAD,EAAAA,GAAA,EACAC,EAAAA,GAAAvW,KAAAwW,cAGA,IAAA1D,GAAA9S,KAAAkW,cAAAI,EACA,KAAAxD,EACA,QAQA,KAJA,GAAA2D,IAAA3D,GACAiB,EAAAuC,EAGAxD,GAAAyD,EAAAxC,GAGAjB,EAAAA,EAAAsD,SAAAtD,EAAAE,kBACAF,GAAAA,EAAAiB,OAKAA,IACA0C,EAAAvM,KAAA4I,GAIA,OAAA2D,IAMArC,EAAAnP,UAAAyR,YAAA,WACA,MAAA1W,MAAAqH,UAMA+M,EAAAnP,UAAA0R,QAAA,SAAAtM,GACA,MAAAA,GACArK,KAAA4Q,KAAAvG,QAEArK,KAAA4Q,MAMAwD,EAAAnP,UAAA2R,UAAA,WACA,MAAA5W,MAAA4Q,KAAAvG,SAMA+J,EAAAnP,UAAA4R,cAAA,SAAAC,GACA,MAAA3E,GAAA4E,SAAAD,EAAA9W,KAAAqT,OAMAe,EAAAnP,UAAA+R,QAAA,WACA,GAAArE,GAAA3S,KAAA6F,IAAA,YAAA,EACA,OAAAoR,YAAAtE,IAMAyB,EAAAnP,UAAAiS,QAAA,SAAAvE,GACA,mBAAAA,KACAA,EAAA3S,KAAAyE,OAAAqN,aAEA9R,KAAAyS,KAAAC,KAAAC,KAAAsE,WAAAtE,IAMAyB,EAAAnP,UAAAkS,QAAA,WACA,MAAAnX,MAAA6F,IAAA,YAAA,KAMAuO,EAAAnP,UAAAmS,UAAA,WACA,MAAApX,MAAA6F,IAAA,cAAA,KAMAuO,EAAAnP,UAAAoS,QAAA,WAGA,MAAArX,MAAAwT,QAAAtR,OAKAlC,KAAAqH,SAAAgQ,UAJAvJ,EAAAhR,GAUAsX,EAAAnP,UAAAqO,QAAA,SAAAjF,GAGArO,KAAAwT,QAAAtR,QAKAlC,KAAAqH,SAAAiM,QAAAjF,IAMA+F,EAAAnP,UAAAqS,gBAAA,WAGA,GAAAC,KACAA,GAAAzJ,EAAAhR,GAAA,EACAya,EAAAzJ,EAAA9Q,GAAA,CAGA,KAAA,GAAAuE,GAAA,EAAAA,EAAAvB,KAAAwT,QAAAtR,OAAAX,IACAgW,EAAAzJ,EAAAhR,IAAAkD,KAAAwT,QAAAjS,GAAA+V,gBAAAxJ,EAAAhR,GACAya,EAAAzJ,EAAA9Q,IAAAgD,KAAAwT,QAAAjS,GAAA+V,gBAAAxJ,EAAA9Q,EAIA,OAAAua,IAMAnD,EAAAnP,UAAAuS,iBAAA,SAAA1Q,EAAAC,GACA,MAAA/G,MAAA8S,KACA9S,KAAA8S,KAAA0E,iBAAA1Q,EAAAC,GAEA,IAMAqN,EAAAnP,UAAAwS,QAAA,WACA,MAAAzX,MAAA4Q,KAAA6G,WAMArD,EAAAnP,UAAAuR,aAAA,WAOA,IAJA,GAAA1D,GAAA9S,KAAAqT,KACAqE,EAAA,EAGA5E,GACAA,EAAAA,EAAAsD,SAAAtD,EAAAE,kBACAF,GAAAA,EAAAiB,MACA2D,GAKA,OAAAA,IAMAtD,EAAAnP,UAAAY,IAAA,SAAA8K,EAAAgH,GAGA,GAAAhH,EAAA,CAKA,gBAAAA,KACAA,EAAAA,EAAAxN,MAAA,KAQA,KAAA,GAHAyU,GADAzO,EAAAnJ,KAAAyS,KAIAwC,EAAA,EAAAA,EAAAtE,EAAAzO,OAAA+S,IAAA,CAMA,GAHA2C,EAAAjH,EAAAsE,GAGAA,EAAA,IAAAtE,EAAAzO,OACA,MAAA,mBAAAiH,GAAAyO,GACAD,EAEAxO,EAAAyO,EAIA,IAAA,gBAAAzO,GAAAyO,GAEA,MADAlN,SAAAC,KAAA,qBAAAiN,EAAA,oBACAD,CAIAxO,GAAAA,EAAAyO,MAWAxD,EAAAnP,UAAAgE,UAAA,SAAAnC,EAAAC,GACA,MAAAD,IAAA,GAAAC,GAAA,GAAAD,EAAA9G,KAAAyS,KAAAlQ,MAAAxC,OAAAgH,EAAA/G,KAAAyS,KAAAlQ,MAAArC,QAMAkU,EAAAnP,UAAA4S,gBAAA,SAAA/Q,EAAAC,GACA,MAAA/G,MAAA8S,KACA9S,KAAA8S,KAAA+E,gBAAA/Q,EAAAC,IAEA,GAMAqN,EAAAnP,UAAA6S,oBAAA,SAAAC,GAGA,GAAAC,EAGA,IAAA,OAAAhY,KAAAiS,aAAAjS,KAAAwT,QAAAtR,OAAA,GAAA,EACA8V,EAAAhY,KAAAwT,QAAAtR,OAAA,MAIA,CAAA,GAAA,QAAAlC,KAAAiS,YAMA,OAAA,CALA+F,GAAA,EASA,IAAA,GAAAzW,GAAAvB,KAAAwT,QAAAtR,OAAA,EAAAX,GAAAyW,EAAAzW,IACA,GAAAwW,EAAAvN,SAAAxK,KAAAwT,QAAAjS,IACA,OAAA,CAKA,QAAA,GAMA6S,EAAAnP,UAAAgT,YAAA,SAAAnR,EAAAC,EAAAsH,GACA,IAEA,MADArO,MAAAiU,aAAAnN,EAAAC,EAAAsH,IACA,EAEA,MAAApS,GACA,OAAA,IAQAmY,EAAAnP,UAAAgP,aAAA,SAAAnN,EAAAC,EAAAsH,EAAAqF,GAGA,IAAA1T,KAAAiJ,UAAAnC,EAAAC,GACA,KAAA,IAAAyK,GAAAN,EAAAjV,MAAAwV,wBAAA3K,EAAAC,EAAAsH,EAIA,IAAArO,KAAAqH,SAAAE,OAAA1B,IAAAiB,EAAAC,KAAA+G,EAAAjR,MACA,KAAA,IAAA2U,GAAAN,EAAAjV,MAAAyV,4BAAA5K,EAAAC,EAAAsH,EAIAA,GAAAA,GAAArO,KAAAqH,SAAAgQ,UAGA3D,EAAAA,GAAA1T,KAAAqH,SAAAgD,QAGAqJ,EAAAnM,OAAAqC,IAAA9C,EAAAC,EAAAsH,EAGA,IAAAkJ,GAAA7D,EAAAwE,gBAAApR,EAAAC,EAGA,KAAAwQ,IAGA7D,EAAAyE,aAAArR,EAAAC,GAAA,CAGA,IAAA/G,KAAAkS,aAMA,KAAA,IAAAV,GAAAN,EAAAjV,MAAA0V,qBAAA7K,EAAAC,EAAAsH,EALAqF,GAAA0E,aAAAtR,EAAAC,GAWA,GAAA/G,KAAAiS,aAAAjS,KAAA8X,oBAAApE,GACA,KAAA,IAAAlC,GAAAN,EAAAjV,MAAA2V,uBAAA9K,EAAAC,EAAAsH,EAOA,OAHAqF,GAAAJ,SAAAjF,GAGAqF,GAMAU,EAAAnP,UAAAoT,kBAAA,SAAAvR,EAAAC,EAAAsH,EAAAhH,GAGA,IAAArH,KAAAiJ,UAAAnC,EAAAC,GACA,KAAA,IAAAyK,GAAAN,EAAAjV,MAAAwV,wBAAA3K,EAAAC,EAAAsH,EAOA,IAHAhH,EAAAE,OAAAqC,IAAA9C,EAAAC,EAAAsH,GAGAA,IAAAP,EAAAjR,MAAA,CAKA,GAAA0a,GAAAlQ,EAAA6Q,gBAAApR,EAAAC,EAGAwQ,IAGAlQ,EAAA8Q,aAAArR,EAAAC,IACAM,EAAA+Q,aAAAtR,EAAAC,KAYAqN,EAAAnP,UAAAqT,SAAA,SAAAxR,EAAAC,EAAAsH,GAGA,IAAArO,KAAAqH,SAAAE,OAAAwC,GAAAjD,EAAAC,EAAAsH,GAAA,CAKA,GAAAkK,GAAAvY,KAAAqH,SAAAgD,OAMA,IAHArK,KAAAqY,kBAAAvR,EAAAC,EAAAsH,EAAAkK,GAGA,mBAAAvY,MAAA8S,KAAAqB,MAAA,CAGA,GAAAnU,KAAA8S,KAAAiB,KAAA,CAGAN,EAAA9Q,KAAA3C,KAGA,IAAA8S,GAAA,GAAAV,GAGA7Q,EAAAuR,EAAA0F,SAAAxY,KAAA8S,KACA9S,MAAA8S,KAAAA,EAGA9S,KAAA4Q,KAAAqC,QAAA1R,GAIAvB,KAAA8S,KAAAqB,SAIAN,EAAAlR,KAAA3C,KAAAuY,GAGAvY,KAAA8S,KAAAqB,MAAAjK,KAAAlK,KAAAqH,SAAAE,OAAA1B,IAAAiB,EAAAC,EAAA,YAMAqN,EAAAnP,UAAAwT,UAAA,SAAA3R,EAAAC,EAAAS,GAGA,mBAAAxH,MAAA8S,KAAAtL,SACAxH,KAAA8S,KAAAtL,WAIAxH,KAAAqH,SAAAG,OAAAoC,IAAA9C,EAAAC,EAAAS,GAGAxH,KAAA8S,KAAAtL,OAAA0C,KAAAlK,KAAAqH,SAAAG,OAAA3B,IAAAiB,EAAAC,EAAA,UAMAqN,EAAAnP,UAAAyT,YAAA,SAAA5R,EAAAC,GAGA,GAAA4R,IAAA,CAGA,IAAA,mBAAA3Y,MAAA8S,KAAAqB,MACA,IAAA,GAAA5S,GAAA,EAAAA,EAAAvB,KAAA8S,KAAAqB,MAAAjS,OAAAX,IACA,GAAAuF,IAAA9G,KAAA8S,KAAAqB,MAAA5S,GAAAuF,GAAAC,IAAA/G,KAAA8S,KAAAqB,MAAA5S,GAAAwF,EAAA,CAGA/G,KAAA8S,KAAAqB,MAAAyE,OAAArX,EAAA,GACAvB,KAAAqH,SAAAE,OAAAuC,MAAAhD,EAAAC,GAGA4R,GAAA,CACA,OAMAA,GACA3Y,KAAAsY,SAAAxR,EAAAC,EAAA+G,EAAAjR,QAOAuX,EAAAnP,UAAA4T,aAAA,SAAA/R,EAAAC,GAGA,GAAA,mBAAA/G,MAAA8S,KAAAtL,OACA,IAAA,GAAAjG,GAAA,EAAAA,EAAAvB,KAAA8S,KAAAtL,OAAAtF,OAAAX,IACA,GAAAuF,IAAA9G,KAAA8S,KAAAtL,OAAAjG,GAAAuF,GAAAC,IAAA/G,KAAA8S,KAAAtL,OAAAjG,GAAAwF,EAAA,CACA/G,KAAA8S,KAAAtL,OAAAoR,OAAArX,EAAA,GACAvB,KAAAqH,SAAAG,OAAAsC,MAAAhD,EAAAC,EACA,SASAqN,EAAAnP,UAAA6T,SAAA,SAAAhS,EAAAC,EAAAsH,GACA,MAAA,mBAAAA,GACArO,KAAAqH,SAAAE,OAAAwC,GAAAjD,EAAAC,EAAAsH,GAEArO,KAAAqH,SAAAE,OAAAL,IAAAJ,EAAAC,IAMAqN,EAAAnP,UAAA8T,UAAA,SAAAjS,EAAAC,EAAA4I,GACA,MAAA,mBAAAA,GACA3P,KAAAqH,SAAAG,OAAAuC,GAAAjD,EAAAC,EAAA4I,GAEA3P,KAAAqH,SAAAG,OAAAN,IAAAJ,EAAAC,IAMAqN,EAAAnP,UAAA+T,SAAA,SAAAlS,EAAAC,GACA,MAAA/G,MAAAqH,SAAAE,OAAA1B,IAAAiB,EAAAC,IAMAqN,EAAAnP,UAAAgU,UAAA,SAAAnS,EAAAC,GACA,MAAA/G,MAAAqH,SAAAG,OAAA3B,IAAAiB,EAAAC,IAUAqN,EAAAnP,UAAAiU,KAAA,SAAApS,EAAAC,EAAAsH,GAGAA,EAAAA,GAAArO,KAAAqH,SAAAgQ,SAGA,IAAA3D,GAAA1T,KAAAiU,aAAAnN,EAAAC,EAAAsH,EAGAoF,GAAA9Q,KAAA3C,KAAA0T,EAGA,IAAAZ,GAAA,GAAAV,IACA2B,MACAjN,EAAAA,EACAC,EAAAA,EACAsH,MAAAA,KAKA9M,EAAAuR,EAAA0F,SAAAxY,KAAA8S,KAQA,OAPA9S,MAAA8S,KAAAE,iBAAAzR,EACAvB,KAAA8S,KAAAA,EAGA9S,KAAA4Q,KAAAqC,QAAA1R,IAGA,GAMA6S,EAAAnP,UAAA+O,KAAA,SAAA3F,GAGAA,EAAAA,GAAArO,KAAAqH,SAAAgQ,SAGA,IAAA3D,GAAA1T,KAAAqH,SAAAgD,OACAqJ,GAAAJ,SAAAjF,GAGAoF,EAAA9Q,KAAA3C,KAAA0T,EAGA,IAAAZ,GAAA,GAAAV,IACA2B,MACAC,MAAA,EACA3F,MAAAA,KAKA9M,EAAAuR,EAAA0F,SAAAxY,KAAA8S,KACA9S,MAAA8S,KAAAE,iBAAAzR,EACAvB,KAAA8S,KAAAA,EAGA9S,KAAA4Q,KAAAqC,QAAA1R,IAUA6S,EAAAnP,UAAAkU,KAAA,SAAA5X,GAQA,GALA,gBAAAA,KACAA,EAAAvB,KAAA8S,KAAAC,SAAA7P,QAAA3B,IAIAsR,EAAAlQ,KAAA3C,KAAAuB,GAGA,IAEA,MADAuS,GAAAnR,KAAA3C,OACA,EAEA,MAAA/D,GAEA,KADAiX,GAAAvQ,KAAA3C,MACA/D,EAKA,OAAA,GAMAmY,EAAAnP,UAAAmU,SAAA,WAGA,MAAAlG,GAAAvQ,KAAA3C,OACA2T,EAAAhR,KAAA3C,OACA,IAIA,GAMAoU,EAAAnP,UAAAqK,KAAA,WAGA,KAAAuD,EAAAlQ,KAAA3C,OAGA,IACA8T,EAAAnR,KAAA3C,MAEA,MAAA/D,GAEA,KADAiX,GAAAvQ,KAAA3C,MACA/D,IAQAmY,EAAAnP,UAAA2P,MAAA,WAGAxB,EAAAzQ,KAAA3C,MAGAuT,EAAA5Q,KAAA3C,MACA8T,EAAAnR,KAAA3C,OAMAoU,EAAAnP,UAAAmP,QAAA,SAAAiF,GAGA,GAAA,OAAArZ,KAAAqT,MAKA,mBAAAgG,GAAA,CAKA,kBAAAA,KACAA,EAAAA,EAAA1W,KAAA3C,MAIA,IAAA4Q,EAGA,IAAA,gBAAAyI,GACAzI,EAAA5Q,KAAA4Q,KAAAvG,QACAuG,EAAA0I,QAAAD,OAIA,IAAA,gBAAAA,GAAA,CAGA,GAAArZ,KAAA8S,KAAA/W,OAAAsd,EACA,MAKA,IADAzI,EAAA5Q,KAAA6W,cAAAwC,GACA,OAAAzI,EACA,WAMAA,GAAAyI,CAIA,KAAArZ,KAAA4Q,KAAAnG,QAAAmG,GAAA,CAKAwC,EAAAzQ,KAAA3C,MAGAuT,EAAA5Q,KAAA3C,MACAyT,EAAA9Q,KAAA3C,MACA8T,EAAAnR,KAAA3C,KAIA,KAAA,GADAkL,GAAA0F,EAAA6G,UACAlW,EAAA,EAAA2J,EAAA3J,GAGAsR,EAAAlQ,KAAA3C,KAAA4Q,EAAA2I,OAAAhY,IAHAA,IAQA,IACAuS,EAAAnR,KAAA3C,MAEA,MAAA/D,GAEA,KADAiX,GAAAvQ,KAAA3C,MACA/D,MAQAmY,EAAAnP,UAAAuU,SAAA,WAGA,KAAA3G,EAAAlQ,KAAA3C,OAAA,CAGA,IACA8T,EAAAnR,KAAA3C,MAEA,MAAA/D,GAEA,KADAiX,GAAAvQ,KAAA3C,MACA/D,EAIA,GAAA+D,KAAA8S,KAAAC,SAAA7Q,OAAA,EACA,QAQAkS,EAAAnP,UAAAwU,aAAA,WAGA,KAAAvG,EAAAvQ,KAAA3C,QACA2T,EAAAhR,KAAA3C,QACAA,KAAA8S,KAAAC,SAAA7Q,OAAA,QASAkS,EAAAnP,UAAAyU,YAAA,WAGA,KAAA7G,EAAAlQ,KAAA3C,OAAA,CAGA,IACA8T,EAAAnR,KAAA3C,MAEA,MAAA/D,GAEA,KADAiX,GAAAvQ,KAAA3C,MACA/D,EAIA,GAAA+D,KAAA8S,KAAA6G,cACA,QAQAvF,EAAAnP,UAAA2U,gBAAA,WAGA,KAAA1G,EAAAvQ,KAAA3C,QAGA2T,EAAAhR,KAAA3C,OAGAA,KAAA8S,KAAA6G,mBAaAvF,EAAAnP,UAAAwC,SAAA,WAGA,IAAAzH,KAAAyU,MAAAzU,KAAA4Q,KACA,MAAA;AAIA,GAAAjJ,IACA8M,IAAAzU,KAAAyU,IACA7D,KAAA5Q,KAAA4Q,KAAAvG,QAIA,OAAA1C,IAMAyM,EAAAnP,UAAA4C,aAAA,SAAAF,GAGAA,GAAAA,EAAA8M,KAAA9M,EAAAiJ,OAKA5Q,KAAAwU,KAAA7M,EAAA8M,KACAzU,KAAAA,QAAA2H,EAAAiJ,QC5+CAwD,OAIA1Y,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAaAD,GAAAE,OAAA,0BACA,SAMAqN,QAAA,YAAA,aAAA,SAAA4E,GAKA,GAAA+L,GAAA,IAAAC,WAAA,GAKAC,EAAA,SAAAC,GACA,OAAAA,EAAAF,WAAA,GAAAD,EAAAG,EAAAF,WAAA,GAAAD,IAMAI,EAAA,SAAAD,EAAAE,GAgBA,MAfAA,GAAAA,MACA,KAAAF,GAAA,SAAAA,EACAE,EAAAlG,MAAA,GAKA,gBAAAgG,KACAA,EAAAD,EAAAC,IAIAE,EAAApT,EAAA,EAAAkT,EAAA,GACAE,EAAAnT,EAAA,EAAAiT,EAAA,IAEAE,GAMAC,EAAA,SAAA9L,GACA,MAAAA,KAAAP,EAAAhR,EAAA,IAAAuR,IAAAP,EAAA9Q,EAAA,IAAA,IAMAod,EAAA,SAAA/L,GACA,MAAA,MAAAA,EACAP,EAAAhR,EAEA,MAAAuR,EACAP,EAAA9Q,EAEA8Q,EAAAlR,GAUAyd,EAAA,SAAAtG,GAGA,GAAAuG,GAAA3e,EAAA4O,KAAAwJ,GACA1F,EAAA8L,EAAApG,EAAA1F,MAGA,OAAA,KAAAA,EACA,MAIA0F,EAAAC,QAAA,EACAsG,EAAAjM,GAAA,OAKAiM,EAAAjM,IAAA0F,EAAAjN,EAAAiN,EAAAhN,SAIAuT,GAAAxT,QACAwT,GAAAvT,QACAuT,GAAAjM,MAGAiM,IAMAC,EAAA,SAAAxG,GAGA,GAAA1F,GAAA2L,CAaA,OAVAjG,GAAA/W,GACAqR,EAAA,IACA2L,EAAAjG,EAAA/W,GAEA+W,EAAAjX,IACAuR,EAAA,IACA2L,EAAAjG,EAAAjX,GAIAkd,EAKAC,EAAAD,GACA3L,MAAA+L,EAAA/L,KALA,MAYAmM,EAAA,SAAArG,GAGA,GAAA5S,GAAA8M,EACAoM,IAGA,KAAAlZ,IAAA4S,GACAA,EAAA7N,eAAA/E,KAGA8M,EAAA8L,EAAAhG,EAAA5S,GAAA8M,QAAA,IAGA,mBAAAoM,GAAApM,KACAoM,EAAApM,OAIAoM,EAAApM,GAAAnE,MAAAiK,EAAA5S,GAAAuF,EAAAqN,EAAA5S,GAAAwF,IAKA,OAAA0T,IAMAC,EAAA,SAAAvG,GAGA,GAAAjH,GAAA0K,EAAAvJ,EACAsM,IAGA,KAAA/C,IAAAzD,GACA,GAAAA,EAAA7N,eAAAsR,GAAA,CAGAvJ,EAAA+L,EAAAxC,EAGA,KAAA1K,IAAAiH,GAAAyD,GACAzD,EAAAyD,GAAAtR,eAAA4G,IACAyN,EAAAzQ,KAAA+P,EAAA9F,EAAAyD,GAAA1K,IACAmB,MAAAA,KAQA,MAAAsM,IAMAC,EAAA,SAAApT,GAGA,GAAAjG,GAAAoO,EACAkL,IAGA,KAAAtZ,IAAAiG,GACAA,EAAAlB,eAAA/E,KAGAoO,EAAAnI,EAAAjG,GAAAoO,KAGA,mBAAAkL,GAAAlL,KACAkL,EAAAlL,OAIA,UAAAA,EACAkL,EAAAlL,GAAAzF,MAAA1C,EAAAjG,GAAAuF,EAAAU,EAAAjG,GAAAwF,EAAAS,EAAAjG,GAAAqO,OAGAiL,EAAAlL,GAAAzF,MAAA1C,EAAAjG,GAAAuF,EAAAU,EAAAjG,GAAAwF,IAMA,OAAA8T,IAMAC,EAAA,SAAAtT,GAGA,GAAAhC,GAAAmK,EACAoL,IAGA,KAAApL,IAAAnI,GACA,GAAAA,EAAAlB,eAAAqJ,GAGA,GAAA,UAAAA,GACA,IAAAnK,EAAA,EAAAA,EAAAgC,EAAAmI,GAAAzN,OAAAsD,IAGA,GAAA7J,EAAAwK,QAAAqB,EAAAmI,GAAAnK,IAAA,CAKA,GAAA,IAAAgC,EAAAmI,GAAAnK,GAAAtD,QAAA,gBAAAsF,GAAAmI,GAAAnK,GAAA,GAAA,CACA,GAAAoK,GAAApI,EAAAmI,GAAAnK,GAAA,EACAgC,GAAAmI,GAAAnK,GAAAuU,EAAAvS,EAAAmI,GAAAnK,GAAA,IACAgC,EAAAmI,GAAAnK,GAAA0E,KAAA0F,GAIApI,EAAAmI,GAAAnK,GAAAtD,OAAA,GAKA6Y,EAAA7Q,KAAA+P,EAAAzS,EAAAmI,GAAAnK,IACAmK,KAAAA,EACAC,KAAApI,EAAAmI,GAAAnK,GAAA,WAOA,KAAAA,IAAAgC,GAAAmI,GACAnI,EAAAmI,GAAArJ,eAAAd,IACAuV,EAAA7Q,KAAA+P,EAAAzS,EAAAmI,GAAAnK,IACAmK,KAAAA,IASA,OAAAoL,IAMAC,EAAA,SAAA9G,GACA,OAAAA,GACA,IAAApG,GAAA9Q,EACA,MAAA,GACA,KAAA8Q,GAAAhR,EACA,MAAA,GACA,SACA,MAAA,KAOAme,EAAA,SAAA/G,GACA,OAAAA,GACA,IAAA,IACA,MAAApG,GAAA9Q,CACA,KAAA,IACA,MAAA8Q,GAAAhR,CACA,SACA,MAAAgR,GAAAjR,QAOAqe,GACApF,OACA/B,KAAAsG,EACAlG,MAAAqG,EACAhT,OAAAoT,EACA1G,KAAA8G,GAEA5F,SACArB,KAAAwG,EACApG,MAAAuG,EACAlT,OAAAsT,EACA5G,KAAA+G,IAOA7I,EAAA,SAAA+I,EAAAzZ,GAOA,GAJA1B,KAAA0B,OAAAA,GAAA,KACA1B,KAAA+S,YAGAoI,EACA,IAAA,GAAAvD,KAAAuD,GACAA,EAAA7U,eAAAsR,KACA5X,KAAA4X,GAAAuD,EAAAvD,ICzWA,ODkXAxF,GAAAnN,UAAAmR,SAAA,SAAA7U,GAEA,MADAA,GAAAA,GAAA,EACAvB,KAAA+S,SAAAxR,GACAvB,KAAA+S,SAAAxR,GAEA,MAMA6Q,EAAAnN,UAAAmW,YAAA,WACA,MAAApb,MAAA+S,UAMAX,EAAAnN,UAAAoW,YAAA,WACA,MAAArb,MAAA+S,SAAA7Q,OAAA,GAMAkQ,EAAAnN,UAAAqW,kBAAA,WAGA,GAAAtb,KAAA+S,SAAA7Q,QAAA,EACA,OAAA,CAKA,KAAA,GADAqZ,GAAA,EACAha,EAAA,EAAAA,EAAAvB,KAAA+S,SAAA7Q,OAAAX,IAQA,GALAvB,KAAA+S,SAAAxR,GAAAwS,MACAwH,IAIAA,EAAA,EACA,OAAA,CAKA,QAAA,GAMAnJ,EAAAnN,UAAAuW,kBAAA,WAGA,GAAA,IAAAxb,KAAA+S,SAAA7Q,OACA,OAAA,CAOA,KAAA,GAHAqZ,MAGAha,EAAA,EAAAA,EAAAvB,KAAA+S,SAAA7Q,OAAAX,IAGAvB,KAAA+S,SAAAxR,GAAAwS,MACAwH,EAAArR,KAAAlK,KAAA+S,SAAAxR,GAKA,OAAAga,IAMAnJ,EAAAnN,UAAAuS,iBAAA,SAAA1Q,EAAAC,GAGA,IAAA,GAAAxF,GAAA,EAAAA,EAAAvB,KAAA+S,SAAA7Q,OAAAX,IACA,GAAAvB,KAAA+S,SAAAxR,GAAAwS,MAAA/T,KAAA+S,SAAAxR,GAAAwS,KAAAjN,IAAAA,GAAA9G,KAAA+S,SAAAxR,GAAAwS,KAAAhN,IAAAA,EACA,MAAAxF,EAKA,OAAA,IAMA6Q,EAAAnN,UAAA4S,gBAAA,SAAA/Q,EAAAC,GAGA,IAAA,GAAAxF,GAAA,EAAAA,EAAAvB,KAAA+S,SAAA7Q,OAAAX,IACA,GAAAvB,KAAA+S,SAAAxR,GAAAwS,MAAA/T,KAAA+S,SAAAxR,GAAAwS,KAAAjN,IAAAA,GAAA9G,KAAA+S,SAAAxR,GAAAwS,KAAAhN,IAAAA,EACA,OAAA,CAKA,QAAA,GAMAqL,EAAAnN,UAAA0U,YAAA,WACA,MAAA3Z,MAAAyb,UAAAzb,KAAAyb,SAAAvZ,OAAA,GAUAkQ,EAAAnN,UAAAgC,OAAA,WAGA,GAAAjH,KAAA0B,OAAA,CAKA,GAAAH,GAAAvB,KAAA0B,OAAAqR,SAAA7P,QAAAlD,KACA,MAAAuB,GACAvB,KAAA0B,OAAAqR,SAAA6F,OAAArX,EAAA,GAIAvB,KAAA0B,OAAA,OAMA0Q,EAAAnN,UAAAyW,OAAA,WAGA,GAAA1b,KAAA0B,OAAA,CAKA,GAAAH,GAAAvB,KAAA0B,OAAAqR,SAAA7P,QAAAlD,KACA,IAAAuB,EAAA,EAAA,CACA,GAAAoa,GAAA3b,KAAA0B,OAAAqR,SAAAxR,EAAA,EACAvB,MAAA0B,OAAAqR,SAAAxR,EAAA,GAAAvB,KACAA,KAAA0B,OAAAqR,SAAAxR,GAAAoa,KAOAvJ,EAAAnN,UAAA2W,SAAA,WAGA,GAAA5b,KAAA0B,OAAA,CAKA,GAAAH,GAAAvB,KAAA0B,OAAAqR,SAAA7P,QAAAlD,KACA,IAAA,KAAAuB,GAAAA,EAAAvB,KAAA0B,OAAAqR,SAAA7Q,OAAA,EAAA,CACA,GAAAyZ,GAAA3b,KAAA0B,OAAAqR,SAAAxR,EAAA,EACAvB,MAAA0B,OAAAqR,SAAAxR,EAAA,GAAAvB,KACAA,KAAA0B,OAAAqR,SAAAxR,GAAAoa,KAOAvJ,EAAAnN,UAAAuT,SAAA,SAAA1F,GAQA,MALA9S,MAAAiH,SAGAjH,KAAA0B,OAAAoR,EACAA,EAAAC,SAAA7I,KAAAlK,MACA8S,EAAAC,SAAA7Q,OAAA,GAMAkQ,EAAAnN,UAAA7E,YAAA,SAAA0S,GAGA,MAFAA,GAAApR,OAAA1B,KACAA,KAAA+S,SAAA7I,KAAA4I,GACA9S,KAAA+S,SAAA7Q,OAAA,GAMAkQ,EAAAnN,UAAA4W,WAAA,SAAA/I,GAGA,IAAA,GAAAvR,GAAA,EAAAA,EAAAvB,KAAA+S,SAAA7Q,OAAAX,IACAvB,KAAA+S,SAAAxR,GAAAG,OAAAoR,CAIAA,GAAAC,SAAAD,EAAAC,SAAA3H,OAAApL,KAAA+S,UACAD,EAAApR,OAAA1B,KAGAA,KAAA+S,UAAAD,IAUAV,EAAAnN,UAAAmQ,QAAA,SAAAX,EAAAqH,GAGA,GAAA,mBAAArH,GAAAkB,KACA,MAAAvD,GAAAgD,QAAAX,EAAAkB,KAAAmG,EAIA,IAAAC,GAAAlJ,EAAAtR,EAAA4J,CAMA,KAHA2Q,EAAAA,GAAA9b,KAGAuB,EAAA,EAAAA,EAAAkT,EAAAvS,OAAAX,IAAA,CAGA,GAAA5F,EAAAwK,QAAAsO,EAAAlT,IAGA,IAAA4J,EAAA,EAAAA,EAAAsJ,EAAAlT,GAAAW,OAAAiJ,IAGA4Q,EAAA,GAAA3J,GACA2J,EAAA3G,QAAAX,EAAAlT,GAAA4J,IAGA2Q,EAAA1b,YAAA2b,OAKA,CAGA,GAAAZ,GAAA7G,OAAAU,oBAAAP,EAAAlT,GAGA,KAAA,GAAAqW,KAAAuD,GACA,GAAAA,EAAA7U,eAAAsR,GAAA,CACA,GAAA/G,GAAAsK,EAAAvD,EAGA,oBAAAsD,GAAA9F,QAAAvE,GACAiL,EAAAjL,GAAAqK,EAAA9F,QAAAvE,GAAA4D,EAAAlT,GAAAsP,IAEA,gBAAA4D,GAAAlT,GAAAsP,GACAiL,EAAAjL,GAAAlV,EAAA4O,KAAAkK,EAAAlT,GAAAsP,IAGAiL,EAAAjL,GAAA4D,EAAAlT,GAAAsP,IASAtP,EAAA,EAAAkT,EAAAvS,SAAAvG,EAAAwK,QAAAsO,EAAAlT,EAAA,MACAsR,EAAA,GAAAT,GACA0J,EAAA1b,YAAAyS,GACAiJ,EAAAjJ,KAQAT,EAAAnN,UAAA6Q,MAAA,SAAAkG,GAGAA,EAAAA,KAGA,IAAAlJ,MACAqI,EAAA7G,OAAAU,oBAAAhV,KAGA,KAAA,GAAA4X,KAAAuD,GACA,GAAAA,EAAA7U,eAAAsR,GAAA,CACA,GAAA/G,GAAAsK,EAAAvD,EAGA,IAAA,WAAA/G,GAAA,aAAAA,EACA,QAIA,oBAAAqK,GAAApF,MAAAjF,GACAiC,EAAAjC,GAAAqK,EAAApF,MAAAjF,GAAA7Q,KAAA6Q,IAEA,gBAAA7Q,MAAA6Q,GACAiC,EAAAjC,GAAAlV,EAAA4O,KAAAvK,KAAA6Q,IAGAiC,EAAAjC,GAAA7Q,KAAA6Q,GASA,GAHAmL,EAAA9R,KAAA4I,GAGA9S,KAAA+S,SAAA7Q,OAAA,EAAA,CAGA,GAAA+Z,KACAD,GAAA9R,KAAA+R,EAGA,KAAA,GAAA1a,GAAA,EAAAA,EAAAvB,KAAA+S,SAAA7Q,OAAAX,IAAA,CAGA,GAAA2a,KACAD,GAAA/R,KAAAgS,GAGAlc,KAAA+S,SAAAxR,GAAAuU,MAAAoG,QAKA,KAAAlc,KAAA+S,SAAA7Q,QACAlC,KAAA+S,SAAA,GAAA+C,MAAAkG,EAIA,OAAAA,ICttBA5J,MAGA1W,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,0BACA,SAMAqN,QAAA,WAAA,WAKA,GAAAiJ,GAAA,WACAnS,KAAA0Q,QAMAyB,GAAAlN,UAAAyL,MAAA,WAIA,MAHA1Q,MAAA+T,KAAA,EACA/T,KAAA4Q,QACA5Q,KAAAmc,SAAA,EACAnc,MAMAmS,EAAAlN,UAAAgO,QAAA,SAAA1R,GAUA,MAPAA,GAAA,IACAvB,KAAA4Q,KAAA5Q,KAAA+T,MAAA,EACA/T,KAAAmc,YAIAnc,KAAA+T,OACA/T,MAMAmS,EAAAlN,UAAAkO,QAAA,WAGA,MAAA,KAAAnT,KAAA+T,MAKA/T,KAAA4Q,KAAA5Q,KAAA+T,cACA/T,MAAA4Q,KAAA5Q,KAAA+T,MACA/T,KAAAmc,YAIAnc,KAAA+T,OACA/T,MAZA,QAkBAmS,EAAAlN,UAAAqU,QAAA,SAAA8C,GAGA,GAAAA,EAAApc,KAAA+T,KACA,IAAA,GAAAxS,KAAAvB,MAAA4Q,KACArP,EAAA6a,UACApc,MAAA4Q,KAAArP,GACAvB,KAAAmc,WAOA,OADAnc,MAAA+T,KAAAqI,EACApc,MAMAmS,EAAAlN,UAAAwS,QAAA,WACA,MAAAzX,MAAA+T,MAMA5B,EAAAlN,UAAAsU,OAAA,SAAA6C,GACA,MAAA,mBAAApc,MAAA4Q,KAAAwL,GAAA,EAAApc,KAAA4Q,KAAAwL,IAMAjK,EAAAlN,UAAAwF,QAAA,SAAA4R,GAGA,GAAAA,GAAA,gBAAAA,IAAA,mBAAAA,GAAAtI,KAAA,CAKA,GAAA/T,KAAA+T,OAAAsI,EAAAtI,MAAA/T,KAAAmc,WAAAE,EAAAF,SACA,OAAA,CAIA,KAAA,GAAA5a,KAAAvB,MAAA4Q,KACA,GAAA,mBAAAyL,GAAAzL,KAAArP,IAAAvB,KAAA4Q,KAAArP,KAAA8a,EAAAzL,KAAArP,GACA,OAAA,CAKA,QAAA,IAMA4Q,EAAAlN,UAAAoF,MAAA,WAGA,GAAAiS,GAAA,GAAAnK,EAQA,OALAmK,GAAAvI,KAAA/T,KAAA+T,KACAuI,EAAAH,SAAAnc,KAAAmc,SACAG,EAAA1L,KAAAjV,EAAA4O,KAAAvK,KAAA4Q,MAGA0L,EAMA,IAAAC,GAAA,SAAAzJ,EAAAgE,EAAAlG,GAGA,GAAAkC,EAAA/W,MAAA+W,EAAA/W,OAAA+a,EACA,OAAA,CAIA,KAAA,GAAAvV,GAAA,EAAAA,EAAAuR,EAAAC,SAAA7Q,OAAAX,IAAA,CAMA,GAHAqP,EAAAqC,QAAA1R,GAGAgb,EAAAzJ,EAAAC,SAAAxR,GAAAuV,EAAAlG,GACA,OAAA,CAIAA,GAAAuC,UAIA,OAAA,ECpLA,OD0LAhB,GAAA4E,SAAA,SAAAD,EAAA0F,GAGA,GAAA5L,GAAA,GAAAuB,EAGA,OAAAoK,GAAAC,EAAA1F,EAAAlG,GACAA,EAIA,MCrMAuB,KAGAzW,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAYAD,GAAAE,OAAA,8BACA,OACA,4BAMAqN,QAAA,gBAAA,aAAA,YAAA,SAAA4E,EAAApE,GAKA,GAAA2I,GAAA,SAAAtS,EAAAG,GAGAF,KAAA/D,MAAA,EACA+D,KAAAD,MAAA,EACAC,KAAAE,OAAA,EACAF,KAAAuH,OAAA,GAAAmC,GACA1J,KAAAwH,OAAA,GAAAkC,GACA1J,KAAAkU,KAAApG,EAAAhR,EAGAkD,KAAAuX,YACAvX,KAAAuX,SAAAzJ,EAAAhR,MACAkD,KAAAuX,SAAAzJ,EAAA9Q,MAGAgD,KAAAuH,OAAAqD,UAAAkD,EAAAjR,QAGAkD,GAAAG,IACAF,KAAAoD,QAAArD,EAAAG,GClDA,ODyDAmS,GAAApN,UAAA7B,QAAA,SAAArD,EAAAG,GAGAH,EAAAA,GAAAG,GAAA,EACAA,EAAAA,GAAAH,GAAA,EAGAC,KAAAD,MAAAwG,SAAAxG,GACAC,KAAAE,OAAAqG,SAAArG,GAGAF,KAAAuH,OAAAnE,QAAArD,EAAAG,GACAF,KAAAwH,OAAApE,QAAArD,EAAAG,GAGAF,KAAAoK,SAMAiI,EAAApN,UAAAmF,MAAA,WACApK,KAAAuH,OAAA6C,QACApK,KAAAwH,OAAA4C,SAMAiI,EAAApN,UAAAwX,SAAA,SAAA3V,EAAAC,EAAAsH,GACArO,KAAAuH,OAAAqC,IAAA9C,EAAAC,EAAAsH,IAMAgE,EAAApN,UAAAyX,UAAA,SAAA5V,EAAAC,EAAAS,GACAxH,KAAAwH,OAAAoC,IAAA9C,EAAAC,EAAAS,IAUA6K,EAAApN,UAAAkT,aAAA,SAAArR,EAAAC,EAAA4V,EAAAC,GAGA,IAAA5c,KAAAuH,OAAAsC,SAAA/C,EAAAC,GACA,OAAA,CAIA6V,GAAAA,GAAA,GAAAlT,GAAA1J,KAAAD,MAAAC,KAAAE,OAGA,IAAAmO,GAAArO,KAAAuH,OAAA1B,IAAAiB,EAAAC,EAMA,OAHA4V,GAAAA,GAAAtO,EAGAuO,EAAA/W,IAAAiB,EAAAC,MAAA,GAAAsH,KAAAsO,GACA,EAIAtO,IAAAP,EAAAjR,OACA,GAIA+f,EAAAhT,IAAA9C,EAAAC,GAAA,GAIA/G,KAAAmY,aAAArR,EAAAC,EAAA,EAAA4V,EAAAC,IACA5c,KAAAmY,aAAArR,EAAAC,EAAA,EAAA4V,EAAAC,IACA5c,KAAAmY,aAAArR,EAAA,EAAAC,EAAA4V,EAAAC,IACA5c,KAAAmY,aAAArR,EAAA,EAAAC,EAAA4V,EAAAC,KAMAvK,EAAApN,UAAAiT,gBAAA,SAAApR,EAAAC,EAAA8V,GAGA,IAAA7c,KAAAuH,OAAAsC,SAAA/C,EAAAC,GACA,OAAA,CAOA,IAHA8V,EAAAA,GAAA7c,KAAAuH,OAAA1B,IAAAiB,EAAAC,GAGA8V,IAAA/O,EAAAjR,MACA,OAAA,CAIA,IAAAigB,IAAA,CAiBA,OAdA9c,MAAA+c,WAAAjW,EAAAC,EAAA,GAAA8V,GAAA,KACAC,GAAA,GAEA9c,KAAA+c,WAAAjW,EAAAC,EAAA,GAAA8V,GAAA,KACAC,GAAA,GAEA9c,KAAA+c,WAAAjW,EAAA,EAAAC,GAAA8V,GAAA,KACAC,GAAA,GAEA9c,KAAA+c,WAAAjW,EAAA,EAAAC,GAAA8V,GAAA,KACAC,GAAA,GAIAA,GAMAzK,EAAApN,UAAA8X,WAAA,SAAAjW,EAAAC,EAAAiW,EAAAC,GAGA,MAAAjd,MAAAuH,OAAAsC,SAAA/C,EAAAC,GAKA/G,KAAAuH,OAAA1B,IAAAiB,EAAAC,KAAA+G,EAAAjR,OACA,GAIAmgB,EAAAA,GAAAhd,KAAAuH,OAAA1B,IAAAiB,EAAAC,GAGA/G,KAAAuH,OAAA1B,IAAAiB,EAAAC,KAAAiW,GACA,EAIAhd,KAAAmY,aAAArR,EAAAC,EAAAiW,IACA,GAIAC,GACAjd,KAAAoY,aAAAtR,EAAAC,EAAAiW,IAIA,KA3BA,GAiCA3K,EAAApN,UAAAmT,aAAA,SAAAtR,EAAAC,EAAAiW,GAGA,MAAAhd,MAAAuH,OAAAsC,SAAA/C,EAAAC,IAKAiW,EAAAA,GAAAhd,KAAAuH,OAAA1B,IAAAiB,EAAAC,GAGA/G,KAAAuH,OAAA1B,IAAAiB,EAAAC,KAAAiW,GACA,GAIAhd,KAAAkd,aAAApW,EAAAC,GAGA/G,KAAAoY,aAAAtR,EAAAC,EAAA,EAAAiW,GACAhd,KAAAoY,aAAAtR,EAAAC,EAAA,EAAAiW,GACAhd,KAAAoY,aAAAtR,EAAA,EAAAC,EAAAiW,GACAhd,KAAAoY,aAAAtR,EAAA,EAAAC,EAAAiW,IAGA,KArBA,GA2BA3K,EAAApN,UAAAiY,aAAA,SAAApW,EAAAC,GAGA,GAAA/G,KAAAuH,OAAAsC,SAAA/C,EAAAC,GAAA,CAKA,GAAAsH,GAAArO,KAAAuH,OAAA1B,IAAAiB,EAAAC,EAGAsH,KAAAP,EAAAjR,QAKAmD,KAAAuH,OAAAqC,IAAA9C,EAAAC,EAAA+G,EAAAjR,OACAmD,KAAAuX,SAAAlJ,GAAAnE,MAAApD,EAAAA,EAAAC,EAAAA,OAMAsL,EAAApN,UAAAkY,YAAA,SAAA9O,EAAAkJ,GACAvX,KAAAuX,SAAAlJ,GAAAkJ,GAMAlF,EAAApN,UAAAmY,YAAA,SAAA/O,GACA,MAAArO,MAAAuX,SAAAlJ,QAMAgE,EAAApN,UAAAqS,gBAAA,SAAAjJ,GACA,MAAArO,MAAAuX,UAAAlJ,GAAAnM,QAUAmQ,EAAApN,UAAAqO,QAAA,SAAAjF,GACArO,KAAAkU,KAAA7F,GAMAgE,EAAApN,UAAAoS,QAAA,WACA,MAAArX,MAAAkU,MAMA7B,EAAApN,UAAAoY,WAAA,WACArd,KAAAkU,MAAAlU,KAAAkU,MAUA7B,EAAApN,UAAAoF,MAAA,WAGA,GAAAqJ,GAAA,GAAArB,EAUA,OAPAqB,GAAAQ,KAAAlU,KAAAkU,KACAR,EAAA3T,MAAAC,KAAAD,MACA2T,EAAAxT,OAAAF,KAAAE,OACAwT,EAAAnM,OAAAvH,KAAAuH,OAAA8C,QACAqJ,EAAAlM,OAAA,GAAAkC,GAAA1J,KAAAD,MAAAC,KAAAE,QAGAwT,GAMArB,EAAApN,UAAAuF,SAAA,SAAAkJ,GAGA,MAAA1T,MAAAD,QAAA2T,EAAA3T,OAAAC,KAAAE,SAAAwT,EAAAxT,QACA,EAIAF,KAAAuH,OAAAiD,SAAAkJ,EAAAnM,SC/VA8K,MAGA3W,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,2BACA,SAMAqN,QAAA,aAAA,aAAA,SAAA4E,GAKA,GAAAwP,GAAA,WACA,MAAA/W,UAAAvG,KAAAuH,QAAAhB,SAAAvG,KAAAud,WACAhX,SAAAvG,KAAAuX,UAAAhR,SAAAvG,KAAA2S,OAMA6K,EAAA,WAGA,GAAAC,GAAAzd,IAGAA,MAAA0d,SACA1d,KAAA2d,SAGA3d,KAAA0Q,QAGA1Q,KAAA0d,MAAAE,MAAA,WACA,MAAAN,GAAA3a,KAAA8a,EAAAC,QAEA1d,KAAA2d,MAAAC,MAAA,WACA,MAAAN,GAAA3a,KAAA8a,EAAAE,QCnDA,OD0DAH,GAAAvY,UAAAyL,MAAA,WAMA,IAAA,GAHAqE,IAAA,SAAA,YAAA,WAAA,QAGAxT,EAAA,EAAAA,EAAAwT,EAAA7S,OAAAX,IACAvB,KAAA0d,MAAA3I,EAAAxT,IAAA,EACAvB,KAAA2d,MAAA5I,EAAAxT,IAAA,GAOAic,EAAAvY,UAAA4Y,OAAA,WAGA,GAAA7S,GAAAhL,KAAA0d,MAAAE,QACAE,EAAA9d,KAAA2d,MAAAC,OAGA,OAAAE,GAAA9S,EACA8C,EAAA9Q,EAEAgO,EAAA8S,EACAhQ,EAAAhR,EAEAgR,EAAAlR,GCtFA4gB,MAGA9hB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,4BACA,OACA,0BACA,4BAMAqN,QAAA,cAAA,YAAA,aAAA,YAAA,SAAAsU,EAAA1P,EAAApE,GAKA,GAAAqU,IACAC,QAAAlQ,EAAAjR,MACAohB,YAAAnQ,EAAAhR,EACAohB,YAAApQ,EAAA9Q,EACAmhB,gBAAA,EAAArQ,EAAAhR,EACAshB,gBAAA,EAAAtQ,EAAA9Q,EACAqhB,QAAA,EAAAvQ,EAAAhR,GAMAwhB,EAAA,SAAAxX,EAAAC,EAAAwX,EAAAC,GAGA,GAAAC,GAAAze,KAAAuH,OAAA1B,IAAAiB,EAAAC,GACA2X,EAAA1e,KAAA0S,KAAArL,SAAAE,OAAA1B,IAAAiB,EAAAC,EAGA/G,MAAAuH,OAAAsC,SAAA/C,EAAAC,IAAA0X,IAAAF,GAAAE,IAAAD,IAMA,EAAAE,IAAAH,EACAve,KAAAuH,OAAAqC,IAAA9C,EAAAC,EAAA2X,GAKA1e,KAAAuH,OAAAqC,IAAA9C,EAAAC,EAAAwX,GAIAD,EAAA3b,KAAA3C,KAAA8G,EAAA,EAAAC,EAAAwX,EAAAC,GACAF,EAAA3b,KAAA3C,KAAA8G,EAAAC,EAAA,EAAAwX,EAAAC,GACAF,EAAA3b,KAAA3C,KAAA8G,EAAA,EAAAC,EAAAwX,EAAAC,GACAF,EAAA3b,KAAA3C,KAAA8G,EAAAC,EAAA,EAAAwX,EAAAC,KAMAG,EAAA,SAAA7X,EAAAC,GAGA,GAAA2X,GAAA1e,KAAA0S,KAAArL,SAAAE,OAAA1B,IAAAiB,EAAAC,EAGA/G,MAAAuH,OAAAsC,SAAA/C,EAAAC,IAAA/G,KAAAuH,OAAA1B,IAAAiB,EAAAC,KAAA2X,IAKA1e,KAAAuH,OAAAqC,IAAA9C,EAAAC,EAAA2X,GAGAC,EAAAhc,KAAA3C,KAAA8G,EAAA,EAAAC,GACA4X,EAAAhc,KAAA3C,KAAA8G,EAAAC,EAAA,GACA4X,EAAAhc,KAAA3C,KAAA8G,EAAA,EAAAC,GACA4X,EAAAhc,KAAA3C,KAAA8G,EAAAC,EAAA,KAMA6X,EAAA,WAOA,IAJA,GACAC,GAAAC,EAAAC,EAAA/T,EAAA8S,EAAA/S,EAAAjE,EAAAC,EADAiY,GAAA,EAIAA,GAMA,IAHAA,GAAA,EAGAlY,EAAA,EAAAA,EAAA9G,KAAAuH,OAAAxH,MAAA+G,IACA,IAAAC,EAAA,EAAAA,EAAA/G,KAAAuH,OAAArH,OAAA6G,IAMA,GAHA8X,EAAA7e,KAAAuH,OAAA1B,IAAAiB,EAAAC,GAIA8X,IAAAd,EAAAC,SACAa,IAAAd,EAAAI,iBACAU,IAAAd,EAAAK,gBACA,CAcA,IAXAW,GACA/e,KAAAuH,OAAA1B,IAAAiB,EAAA,EAAAC,GACA/G,KAAAuH,OAAA1B,IAAAiB,EAAAC,EAAA,GACA/G,KAAAuH,OAAA1B,IAAAiB,EAAA,EAAAC,GACA/G,KAAAuH,OAAA1B,IAAAiB,EAAAC,EAAA,IAIAiE,EAAA8S,GAAA,EAGA/S,EAAA,EAAA,EAAAA,EAAAA,IAEAgU,EAAAhU,KAAAgT,EAAAE,aACAc,EAAAhU,KAAAgT,EAAAI,gBAEAnT,GAAA,EAGA+T,EAAAhU,KAAAgT,EAAAG,aACAa,EAAAhU,KAAAgT,EAAAK,gBAEAN,GAAA,EAEAiB,EAAAhU,KAAAgT,EAAAM,UACArT,EAAA8S,GAAA,EAMAgB,GADA9T,GAAA8S,EACAC,EAAAM,QAEArT,EACA+S,EAAAI,gBAEAL,EACAC,EAAAK,iBAGA,EAIAU,KAAA,GAAAA,IAAAD,IACAG,GAAA,EACAhf,KAAAuH,OAAAqC,IAAA9C,EAAAC,EAAA+X,MAWAG,GAGAvM,KAAA,KAGAwM,MAAA,KAGA3X,OAAA,KACAgQ,SAAA,KACApH,OAAA,KAKAqE,KAAA,SAAA9B,GAGA1S,KAAAkf,MAAA,GAAA1B,GAGAxd,KAAA0S,KAAAA,EAGA1S,KAAAuH,OAAAvH,KAAA0S,KAAArL,SAAAE,OAAA8C,QAGArK,KAAAuX,SAAA,GAAA7N,GAAA1J,KAAAuH,OAAAxH,MAAAC,KAAAuH,OAAArH,OAAAF,KAAAuH,OAAAoC,YACA3J,KAAAmQ,OAAA,GAAAzG,GAAA1J,KAAAuH,OAAAxH,MAAAC,KAAAuH,OAAArH,OAAAF,KAAAuH,OAAAoC,aAMAwV,SAAA,WACA,MAAAnf,MAAAkf,OAMAE,UAAA,WACA,MAAApf,MAAAmQ,QAMAiN,YAAA,WACA,MAAApd,MAAAuX,UAMA8H,UAAA,WAGA,IAAArf,KAAA0S,KAEA,WADAhI,SAAAC,KAAA,wDAKA3K,MAAAmQ,OAAA/F,QACApK,KAAAuX,SAAAnN,QAGAwU,EAAAjc,KAAA3C,KAGA,IAAA2S,GAAA3S,KAAA0S,KAAA7M,IAAA,aACA0R,EAAAvX,KAAA0S,KAAA4E,iBAGAtX,MAAAkf,MAAAxO,QAGA1Q,KAAAkf,MAAAxB,MAAAnG,SAAAA,EAAAzJ,EAAAhR,GACAkD,KAAAkf,MAAAvB,MAAApG,SAAAA,EAAAzJ,EAAA9Q,GACAgD,KAAAkf,MAAAxB,MAAA/K,KAAA,EAAAA,EAAAA,EAAA,EACA3S,KAAAkf,MAAAvB,MAAAhL,KAAAA,EAAA,EAAAA,EAAA,CAGA,IAAA7L,GAAAC,EAAAY,EAAA0G,CAGA,KAAAvH,EAAA,EAAAA,EAAA9G,KAAAuH,OAAAxH,MAAA+G,IACA,IAAAC,EAAA,EAAAA,EAAA/G,KAAAuH,OAAArH,OAAA6G,IAGAY,EAAA3H,KAAAuH,OAAA1B,IAAAiB,EAAAC,GACAsH,EAAArO,KAAA0S,KAAArL,SAAAE,OAAA1B,IAAAiB,EAAAC,GAGAY,IAAAoW,EAAAE,aAAA5P,IAAAP,EAAAhR,EAMA6K,IAAAoW,EAAAG,aAAA7P,IAAAP,EAAA9Q,EAMA2K,IAAAoW,EAAAI,gBAaAxW,IAAAoW,EAAAK,kBACApe,KAAAkf,MAAAvB,MAAAJ,YACAvd,KAAAmQ,OAAAvG,IAAA9C,EAAAC,EAAA+G,EAAA9Q,GAGAqR,IAAAP,EAAAhR,IACAkD,KAAAkf,MAAAvB,MAAApG,WACAvX,KAAAuX,SAAA3N,IAAA9C,EAAAC,EAAA+G,EAAAhR,MAnBAkD,KAAAkf,MAAAxB,MAAAH,YACAvd,KAAAmQ,OAAAvG,IAAA9C,EAAAC,EAAA+G,EAAAhR,GAGAuR,IAAAP,EAAA9Q,IACAgD,KAAAkf,MAAAxB,MAAAnG,WACAvX,KAAAuX,SAAA3N,IAAA9C,EAAAC,EAAA+G,EAAA9Q,KAZAgD,KAAAkf,MAAAvB,MAAApW,SANAvH,KAAAkf,MAAAxB,MAAAnW,UA0CA6H,KAAA,SAAAtI,EAAAC,GAGA,GAAAsH,GAAArO,KAAA0S,KAAArL,SAAAE,OAAA1B,IAAAiB,EAAAC,GACAY,EAAA3H,KAAAuH,OAAA1B,IAAAiB,EAAAC,EAGAsH,KAAAP,EAAA9Q,EAGA2K,IAAAoW,EAAAG,YACAI,EAAA3b,KAAA3C,KAAA8G,EAAAC,EAAAgX,EAAAI,gBAAAJ,EAAAE,aAKAU,EAAAhc,KAAA3C,KAAA8G,EAAAC,GAKAsH,IAAAP,EAAAhR,IAGA6K,IAAAoW,EAAAE,YACAK,EAAA3b,KAAA3C,KAAA8G,EAAAC,EAAAgX,EAAAK,gBAAAL,EAAAG,aAKAS,EAAAhc,KAAA3C,KAAA8G,EAAAC,KC7VA,OAAAkY,OAGAvjB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAIAD,GAAAE,OAAA,yBACA,yBAMAsD,UAAA,UAAA,SAAA,SAAAwE,GACA,OACAzC,SAAA,IAKAoe,YAAA,SAAA,SAAAC,GAGAA,EAAA5b,SACA4b,EAAA5b,OAAAA,KAOAvC,KAAA,SAAAd,EAAAe,EAAAC,GAGAqC,EAAA9B,YAAAR,GAGAC,EAAAyB,SAAA,OAAA,SAAAyc,GACA7b,EAAA8b,WAAAD,KAEAle,EAAAyB,SAAA,OAAA,SAAA2c,GACA/b,EAAAgc,WAAAD,KAIApe,EAAAyB,SAAA,kBAAA,SAAAM,GACAM,EAAAic,mBAAA,SAAAvc,KAEA/B,EAAAyB,SAAA,gBAAA,SAAAM,GACAM,EAAAkc,oBAAA,SAAAxc,KAEA/B,EAAAyB,SAAA,iBAAA,SAAAM,GACAM,EAAAmc,kBAAAzc,WCpDA3H,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAYAD,GAAAE,OAAA,uBACA,OACA,wBACA,kCACA,qBACA,oBACA,6BAMAiI,SAAA,UAAA,cAAA,cAAA,cAAA,SAAAic,EAAAC,EAAAjS,GAKA,GAAAhK,IAGAyb,KAAAO,EAAAniB,OACA8hB,KAAAM,EAAAhiB,KAGAiiB,qBAAA,EACAC,uBAAA,EAGAC,eAAApS,EAAAvQ,KAIA4iB,iBAAA,EACAC,mBAAA,EACAC,mBAAA,EAMAtgB,MAAAwE,UAAA,SAAAC,GACAV,EAAApI,EAAA+I,OAAAX,EAAAU,IAMAzE,KAAA2E,MAAA,aAAA,YAAA,OAAA,aAAA,QAAA,cAAA,SAAAC,EAAA2b,EAAAnM,EAAA6K,EAAA5f,EAAA2gB,GAKA,GAAAQ,GAAA,SAAAC,EAAAC,GAGA,IAAA1gB,KAAAuC,QAAAme,EAGA,MAFAD,GAAA3Z,EAAA,QACA2Z,EAAA1Z,EAAA,GAKA,IAAAD,GAAA,EACAC,EAAA,CAGA,oBAAA2Z,GAAA5R,QACAhI,EAAA4Z,EAAA5R,QAGA4R,EAAAC,eAAA,mBAAAD,GAAAC,cAAA7R,QAEAhI,EAAA4Z,EAAAC,cAAA7R,QAGA4R,EAAAC,eAAA,mBAAAD,GAAAC,cAAAC,SAEA9Z,EAAA4Z,EAAAC,cAAAC,QAIA,mBAAAF,GAAA1R,QACAjI,EAAA2Z,EAAA1R,QAGA0R,EAAAC,eAAA,mBAAAD,GAAAC,cAAA3R,QAEAjI,EAAA2Z,EAAAC,cAAA3R,QAGA0R,EAAAC,eAAA,mBAAAD,GAAAC,cAAAE,SAEA9Z,EAAA2Z,EAAAC,cAAAE,QAIA/Z,GAAApL,EAAAolB,kBAAA,EACA/Z,GAAArL,EAAAolB,kBAAA,EAGAL,EAAA3Z,EAAA9G,KAAAuC,MAAAsG,SAAA/B,GACA2Z,EAAA1Z,EAAA/G,KAAAuC,MAAAwG,SAAAhC,GAGA2Z,EAAAK,OACAN,EAAAM,KAAAL,EAAAK,OAOApd,GAGAc,UAGAlC,MAAA,KACAmQ,KAAA,KAGAsO,SACAC,SAGAzB,KAAA,GACAE,KAAA,GAGA9O,KAAA,KAKA7L,KAAA,WAGA/E,KAAAuC,MAAA,KACAvC,KAAA0S,KAAA,GAAA0B,GAGApU,KAAA4Q,KAAA,KAGA5Q,KAAAwf,KAAA,GACAxf,KAAA0f,KAAA,GAGA1f,KAAAigB,qBAAA,EACAjgB,KAAAkgB,uBAAA,EAGAlgB,KAAAmgB,eAAA,GAGAngB,KAAAogB,iBAAA,EACApgB,KAAAqgB,mBAAA,EACArgB,KAAAsgB,mBAAA,EAGAtgB,KAAAkhB,kBAAA,KACAlhB,KAAAmhB,gBAAA,KAGAnhB,KAAAgF,eAMAnD,YAAA,SAAAR,GAGArB,KAAAqB,QAAAA,EAGArB,KAAAohB,qBAAA,UAAAb,GAGAvgB,KAAAohB,qBAAA,SACAphB,KAAAohB,qBAAA,aACAphB,KAAAohB,qBAAA,WACAphB,KAAAohB,qBAAA,aACAphB,KAAAohB,qBAAA,YACAphB,KAAAohB,qBAAA,cACAphB,KAAAohB,qBAAA,UAUApc,YAAA,SAAAP,GAGAzE,KAAAyE,OAAA9I,EAAA+I,UAAAX,EAAAU,OAGAzE,KAAAyf,WAAAzf,KAAAyE,OAAA+a,MACAxf,KAAA2f,WAAA3f,KAAAyE,OAAAib,MACA1f,KAAAqhB,uBAAArhB,KAAAyE,OAAAwb,qBACAjgB,KAAAshB,yBAAAthB,KAAAyE,OAAAyb,uBACAlgB,KAAA8f,kBAAA9f,KAAAyE,OAAA0b,gBACAngB,KAAA4f,mBACA5f,KAAAyE,OAAA2b,gBACApgB,KAAAyE,OAAA4b,kBACArgB,KAAAyE,OAAA6b,kBAIA,KAAA,GAAAd,KAAAxf,MAAAghB,MACAhhB,KAAAghB,MAAAxB,GAAAxa,aACAhF,KAAAghB,MAAAxB,GAAAxa,YAAArC,KAAA3C,KAAAA,KAAAyE,SAQA4c,uBAAA,SAAAE,GACAA,IAAAvhB,KAAAigB,sBACAjgB,KAAAigB,oBAAAsB,EACAvhB,KAAAwhB,UAAA,gBAAA,yBAOAF,yBAAA,SAAAG,GACAA,IAAAzhB,KAAAkgB,wBACAlgB,KAAAkgB,sBAAAuB,EACAzhB,KAAAwhB,UAAA,gBAAA,2BAOA1B,kBAAA,SAAAK,GACAA,IAAAngB,KAAAmgB,iBACAngB,KAAAmgB,eAAAA,EACAngB,KAAAwhB,UAAA,gBAAA,oBAOA5B,mBAAA,SAAAQ,EAAAC,EAAAC,GAGA,GAAAtB,IAAA,CAGAoB,KAAApgB,KAAAogB,kBACApgB,KAAAogB,gBAAAA,EACApB,GAAA,GAKA,mBAAAqB,IAAAA,IAAArgB,KAAAqgB,oBAEArgB,KAAAqgB,kBAAAA,EACArB,GAAA,GAKA,mBAAAsB,IAAAA,IAAAtgB,KAAAsgB,oBAEAtgB,KAAAsgB,kBAAAA,EACAtB,GAAA,GAIAA,GACAhf,KAAAwhB,UAAA,gBAAA,oBAWAE,aAAA,SAAAlC,EAAAmC,GAGA3hB,KAAAghB,MAAAxB,GAAAmC,EAGA3hB,KAAAghB,MAAAxB,GAAAxa,aACAhF,KAAAghB,MAAAxB,GAAAxa,YAAArC,KAAA3C,KAAAA,KAAAyE,QAIAzE,KAAAwf,OAAAA,IACAxf,KAAAyf,WAAAzf,KAAAwf,MAAA,GACAxf,KAAA2f,WAAA3f,KAAA0f,MAAA,KAOAkC,SAAA,SAAAX,GACAjhB,KAAAihB,MAAAA,IAAAjB,EAAAjiB,OAMA8jB,QAAA,SAAArC,GACA,MAAAxf,MAAAghB,MAAAxB,IAAA,GAAA,GAMAsC,QAAA,SAAApC,GACA,MAAA,KAAA1f,KAAAihB,MAAA/d,QAAAwc,IAMAD,WAAA,SAAAD,EAAAuC,GAGA,MAAAA,IAAAvC,GAAAxf,KAAAwf,OAAAA,GAKAxf,KAAAwf,MACAxf,KAAAwhB,UAAA,WAAAxhB,KAAAwf,MAIAxf,KAAAwf,KAAAA,EACAxf,KAAAihB,SACAjhB,KAAA0f,KAAAM,EAAAjiB,KAGAiC,KAAAwhB,UAAA,YAAAxhB,KAAAwf,OACA,IAfA,GAqBAG,WAAA,SAAAD,EAAAqC,GAGA,MAAAA,IAAArC,GAAA1f,KAAA0f,OAAAA,EAKA1f,KAAAwf,MAAAxf,KAAAghB,MAAAhhB,KAAAwf,OAAA,KAAAxf,KAAAihB,MAAA/d,QAAAwc,IACA,GAIA1f,KAAA0f,KAAAA,EACA1f,KAAAwhB,UAAA,aAAAxhB,KAAA0f,OACA,IAXA,GAiBAsC,UAAA,WAGAhiB,KAAAiiB,aACAzC,KAAAxf,KAAAwf,KACAE,KAAA1f,KAAA0f,KACAwB,kBAAAlhB,KAAAkhB,kBACAC,gBAAAnhB,KAAAmhB,iBAIAnhB,KAAAkiB,iBAMAra,aAAA,WAGA7H,KAAAiiB,cAKAjiB,KAAAyf,WAAAzf,KAAAiiB,YAAAzC,MACAxf,KAAA2f,WAAA3f,KAAAiiB,YAAAvC,MACA1f,KAAAkhB,kBAAAlhB,KAAAiiB,YAAAf,kBACAlhB,KAAAmhB,gBAAAnhB,KAAAiiB,YAAAd,gBAGAnhB,KAAAmiB,qBAUA3N,KAAA,SAAAH,EAAA+N,GAGA,IACApiB,KAAA0S,KAAA8B,KAAAH,GAEA,MAAApY,GACA,KAAAA,GAsBA,MAlBA+D,MAAA4Q,KAAA,MAGAwR,GAAA,mBAAAA,KACApiB,KAAAgF,YAAAhF,KAAA0S,KAAA7M,IAAA,aAIA7F,KAAAwhB,UAAA,aAAAxhB,KAAA0S,MAGA1S,KAAAuC,QACAvC,KAAAuC,MAAA2C,YACAlF,KAAAuC,MAAAyC,YAAAhF,KAAA0S,KAAA7M,IAAA,UACA7F,KAAAqiB,oBAIA,GAMAxN,OAAA,WAGA7U,KAAA0S,MAAA1S,KAAA0S,KAAAoC,aAKA9U,KAAA0S,KAAAmC,SAGA7U,KAAAuC,QACAvC,KAAAuC,MAAA2C,YACAlF,KAAAqiB,qBAOAH,cAAA,WACAliB,KAAA0S,MAAA1S,KAAA0S,KAAAoC,aACA9U,KAAAsiB,UAAAtiB,KAAA0S,KAAAjL,aAOA0a,iBAAA,WAGAniB,KAAA0S,MAAA1S,KAAAsiB,YAKAtiB,KAAA0S,KAAA7K,aAAA7H,KAAAsiB,WAGAtiB,KAAAuC,QACAvC,KAAAuC,MAAA2C,YACAlF,KAAAqiB,qBAWAlJ,KAAA,SAAA5X,GACAvB,KAAA0S,MAAA1S,KAAA0S,KAAAI,OAAA9S,KAAAmhB,kBACAnhB,KAAA0S,KAAAyG,KAAA5X,GACAvB,KAAAqiB,oBAOAjJ,SAAA,WACApZ,KAAA0S,MAAA1S,KAAA0S,KAAAI,OAAA9S,KAAAkhB,oBACAlhB,KAAA0S,KAAA0G,WACApZ,KAAAqiB,oBAOA/S,KAAA,WACAtP,KAAA0S,OACA1S,KAAA0S,KAAApD,OACAtP,KAAAqiB,oBAOAzN,MAAA,WACA5U,KAAA0S,OACA1S,KAAA0S,KAAAkC,QACA5U,KAAAqiB,oBAOAE,OAAA,SAAAlJ,GACArZ,KAAA0S,MAAA2G,IACArZ,KAAA0S,KAAA1S,QAAAqZ,GACArZ,KAAAqiB,oBAOA5I,aAAA,WACAzZ,KAAA0S,OACA1S,KAAA0S,KAAA+G,eACAzZ,KAAAqiB,oBAOA7I,SAAA,WACAxZ,KAAA0S,OACA1S,KAAA0S,KAAA8G,WACAxZ,KAAAqiB,oBAOA3I,YAAA,WACA1Z,KAAA0S,MAAA1S,KAAA0S,KAAAI,OAAA9S,KAAAmhB,kBACAnhB,KAAA0S,KAAAgH,cACA1Z,KAAAqiB,oBAOAzI,gBAAA,WACA5Z,KAAA0S,MAAA1S,KAAA0S,KAAAI,OAAA9S,KAAAkhB,oBACAlhB,KAAA0S,KAAAkH,kBACA5Z,KAAAqiB,oBAOAG,aAAA,SAAAC,GAGAziB,KAAA0S,MAAA1S,KAAA0S,KAAAI,OAKA2P,EACAziB,KAAAmhB,gBAAAnhB,KAAA0S,KAAAI,KAGA9S,KAAAkhB,kBAAAlhB,KAAA0S,KAAAI,OAOAuP,gBAAA,WAGA,GAAAriB,KAAA0S,MAAA1S,KAAA0S,KAAAoC,WAAA,CAKA,GAAAhC,GAAA9S,KAAA0S,KAAAuD,UACArF,EAAA5Q,KAAA0S,KAAAiE,UACAtP,EAAArH,KAAA0S,KAAAgE,cACApP,GAAAsJ,EAAAnG,QAAAzK,KAAA4Q,KAGA5Q,MAAA0iB,YAAA5P,EAAAzL,EAAAC,GAGAA,IAGAtH,KAAA4Q,KAAAA,EAAAvG,QACArK,KAAAwhB,UAAA,aAAA1O,GAGAA,EAAA/W,MACAiE,KAAAwhB,UAAA,eAAA1O,EAAA/W,KAAA+W,IAKAA,EAAAiB,MAAAjB,EAAAiB,KAAAC,MACAhU,KAAAwhB,UAAA,aAAA1O,KAOA6P,gBAAA,SAAArM,EAAAC,GAGA,GAAAvW,KAAA0S,MAAA1S,KAAA0S,KAAAoC,WAAA,CAKAwB,EAAAA,GAAA,EACAC,EAAAA,GAAAvW,KAAA0S,KAAA+E,SAGA,IAAAhB,GAAAzW,KAAA0S,KAAA2D,aAAAC,EAAAC,GACAxC,EAAAuC,CAGA3a,GAAAinB,QAAAnM,EAAA,SAAA3D,GACA9S,KAAAuC,MAAAsE,IAAA,SAAAiM,EAAAiB,KAAAjN,EAAAgM,EAAAiB,KAAAhN,GACA4I,KAAA5B,EAAAxQ,MACAqS,KAAAmE,OAEA/T,MAGAA,KAAAuC,MAAAsB,OAAA,YAUAgf,QAAA,WACA7iB,KAAA0S,KAAA,GAAA0B,GACApU,KAAAqiB,mBAMAS,UAAA,WAGA7D,EAAAI,WAGA,IAAAH,GAAAD,EAAAE,WACAhP,EAAA8O,EAAAG,YACA7H,EAAA0H,EAAA7B,aAGApd,MAAAuC,MAAAM,OAAA2E,OAAAtC,YACAlF,KAAAuC,MAAAM,OAAAqc,MAAA/X,OAAAgJ,EAAAoH,GAGAvX,KAAAwhB,UAAA,kBAAAtC,IAUA6D,SAAA,WACA,MAAA/iB,MAAAuC,OAMAqB,SAAA,SAAAvE,GAGAW,KAAAuC,MAAAlD,EAGAW,KAAAuC,OACAvC,KAAAwhB,UAAA,aAAAxhB,KAAAuC,OAIAvC,KAAA0S,MAAA1S,KAAA0S,KAAAoC,aACA9U,KAAAuC,MAAA2C,YACAlF,KAAAuC,MAAAyC,YAAAhF,KAAA0S,KAAA7M,IAAA,UACA7F,KAAAqiB,oBAOAK,YAAA,SAAA5P,EAAAzL,EAAAC,GAGAtH,KAAAuC,QAKAvC,KAAAuC,MAAA6E,eAAAC,EAAAC,GAGAtH,KAAAmgB,gBAAArN,EAAAiB,OAAAjB,EAAAiB,KAAAC,MACAhU,KAAAuC,MAAAsE,IAAA,SAAAiM,EAAAiB,KAAAjN,EAAAgM,EAAAiB,KAAAhN,EAAA/G,KAAAmgB,gBAIAngB,KAAAwhB,UAAA,cAAA1O,KAUAsO,qBAAA,SAAApf,EAAAX,GAGA,mBAAAA,IAAAA,EAAAiB,KACAjB,EAAArB,KAAAqB,SAKAA,EAAA2hB,IAAAhhB,GACAX,EAAAiB,GAAAN,EAAAhC,KAAAwhB,UAAAyB,KAAAjjB,KAAAgC,KAMAM,GAAA,SAAAqN,EAAAuT,EAAA1D,EAAAD,GAGA,GAAA,kBAAA2D,GAEA,WADAxY,SAAAC,KAAA,8BAAAuY,EAKA1D,IAAAA,EAAA9b,UACA6b,EAAAC,EACAA,EAAA,GAIA,EAAA,GAAA,KAAA7P,EAAAzM,QAAA,KAAA,CASA,GAAAua,GAAAzd,KACAM,EAAAif,GAAA3a,CAGA,OAAAtE,GAAAyB,IAAA,eAAA4N,EAAA,WAGA,KAAA6P,IAEA,gBAAAA,IAAAA,IAAA/B,EAAA+B,MACA,KAAAA,EAAAtc,QAAAua,EAAA+B,QAOA,YAAA7P,GAAA4Q,EAAA,GAAA4C,cAAA,WAAA,CAUA,IALA,UAAAxT,GAAA,UAAAA,GAAA,UAAAA,EAAAhK,OAAA,EAAA,KACA6a,EAAA7d,KAAA8a,EAAA1M,UAAA,GAAAA,UAAA,IAIA0M,EAAA2F,mBAAA,UAAAzT,EAEA,kBADA8N,GAAA2F,iBAGA,eAAAzT,IACA8N,EAAA2F,mBAAA,GAIAF,EAAAlS,MAAAyM,EAAA1M,cA3CA,IAAA,GADAxC,GAAAoB,EAAAxM,MAAA,KACAkgB,EAAA,EAAAA,EAAA9U,EAAArM,OAAAmhB,IACArjB,KAAAsC,GAAAiM,EAAA8U,GAAAH,EAAA1D,EAAAD,KAiDAiC,UAAA,SAAA7R,EAAAmB,GAGAnB,IAKA/K,EAAA0e,QAMA1e,EAAA3D,WAAA,eAAA0O,EAAAmB,GALAlM,EAAA2e,OAAA,WACA3e,EAAA3D,WAAA,eAAA0O,EAAAmB,OCz3BA,ODm4BAnN,GAAAoB,OCn4BApB,QAIAjI,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,2BACA,SAMAqN,QAAA,aAAA,OAAA,SAAAgI,GAKA,GAAAsS,IACAC,QACAC,YAAAxS,EAAAnV,KAAA,KAAAmV,EAAAlV,QACAA,QAAA,EACA2nB,QAAA,SAEAjR,MACA/C,KAAA,KACAiU,UAEAvV,MAAA,QACAtS,KAAA,UAGAsS,MAAA,QACAtS,KAAA,WAIAwG,OACAxC,MAAA,GACAG,OAAA,IAEAyV,SAMAkO,GACAC,GAAA5S,EAAAnV,KAAA,IAAAmV,EAAAlV,QACA+nB,GAAA,QACAC,GAAA,IACAC,GAAA,IACAC,GAAA,KACAC,GAAA,QACAC,GAAA,SAMA7R,GAKAkC,IAAA,SAAA4P,GAGA,GAAAC,GAAA3oB,EAAA4O,KAAAiZ,EAGA,IAAAa,EACA,IAAA,GAAApP,KAAAoP,GACAA,EAAA/d,eAAA2O,KACAqP,EAAArP,GAAAtZ,EAAA+I,OAAA4f,EAAArP,OAAAoP,EAAApP,IAMA,OAAAqP,IAMA9O,IAAA,SAAA6O,GAGA,GAAAC,GAAA3oB,EAAA4O,KAAAsZ,EAGA,IAAAQ,EACA,IAAA,GAAApP,KAAAoP,GACAA,EAAA/d,eAAA2O,KACAqP,EAAArP,GAAAoP,EAAApP,GAMA,OAAAqP,IC7GA,OAAA/R,OAGA7W,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,4BACA,OACA,oCACA,oCACA,sCAQAC,SAAA,cAGAgoB,GAAA,qBACAC,GAAA,iBACAQ,GAAA,mBACAC,GAAA,gBACAC,GAAA,qBACAC,GAAA,mBAGAT,GAAA,YACAU,GAAA,YACAC,GAAA,YACAC,GAAA,gBACAC,GAAA,cACAC,GAAA,aACAC,GAAA,iBACAC,GAAA,qBACAC,GAAA,aACAC,GAAA,gBACAC,GAAA,aACAC,GAAA,aACAC,GAAA,eACAC,GAAA,eAGApB,GAAA,OACAC,GAAA,OACAoB,GAAA,OACAC,GAAA,OACAC,GAAA,OACAC,GAAA,OAGAC,EAAA,OACAC,EAAA,WACAC,GAAA,SACAC,GAAA,WACAC,GAAA,SACAC,GAAA,OACAC,GAAA,SACAC,GAAA,UAMArqB,SAAA,YACAsqB,EAAA,KACAC,EAAA,UACAC,EAAA,QACAC,EAAA,QACAC,EAAA,aACAC,EAAA,gBACAC,EAAA,UAMAxd,QAAA,cAAA,UAAA,UAAA,UAAA,SAAAyd,EAAAC,EAAAC,GAKA,GAAAvU,IAKAiD,QAAA,SAAAD,EAAAwR,GACA,MAAAH,GAAAI,MAAAzR,EAAAwR,IAMArR,QAAA,SAAAD,EAAAsR,GACA,MAAAF,GAAAG,MAAAvR,EAAAsR,IAMAjR,QAAA,SAAApB,GACA,MAAAoS,GAAAE,MAAAtS,ICjHA,OAAAnC,OAGA5W,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,sCACA,OACA,2BACA,0CAMAqN,QAAA,aAAA,aAAA,cAAA,SAAAoC,EAAA0b,GAKA,GAAAC,GAAA,SAAAze,EAAAI,EAAAse,EAAAC,GAGA,KAAA3e,EAAAxI,KAAAuC,MAAAwD,KAAAiC,OAAAQ,EAAAxI,KAAAuC,MAAAwD,KAAAkC,QAGAW,EAAA5I,KAAAuC,MAAAwD,KAAAmC,MAAAU,EAAA5I,KAAAuC,MAAAwD,KAAAoC,MAAA,CAKA,GAAArB,GAAA9G,KAAAuC,MAAAgG,QAAAC,GACAzB,EAAA/G,KAAAuC,MAAAoG,QAAAC,EAGA5I,MAAAL,QAAA2M,YACAtM,KAAAL,QAAAynB,UAAAD,EACAnnB,KAAAL,QAAA0nB,IAAAvgB,EAAAC,EAAAmgB,EAAA,EAAA,EAAAtmB,KAAAgM,IAAA,GACA5M,KAAAL,QAAA2nB,SAMAC,EAAA,SAAAhlB,EAAA5C,GAGAK,KAAAsE,aAAA,EAGAgH,EAAA3I,KAAA3C,KAAAuC,EAAA5C,GC3DA,ODiEAhE,GAAA+I,OAAA6iB,EAAAtiB,UAAAqG,EAAArG,WAKAsiB,EAAAtiB,UAAAe,eAAA,SAAAS,GACAzG,KAAAsE,YAAAmC,GAUA8gB,EAAAtiB,UAAAyC,OAAA,WACA,MAAA,OAMA6f,EAAAtiB,UAAAkC,OAAA,aAOAogB,EAAAtiB,UAAAC,UAAA,aAWAqiB,EAAAtiB,UAAA8C,KAAA,WAGA,GAAA/H,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,WAAA,CAKA,GAAA4b,GAAAxnB,KAAAuC,MAAA6C,cACAqiB,EAAAznB,KAAAuC,MAAA8C,cAGA1E,EAAAX,KAAAuC,MAAA+F,cACA8D,EAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,iBAAAlF,GACA0O,EAAArP,KAAAuC,MAAA4C,MAAAU,IAAA,gBACAqG,EAAAlM,KAAAuC,MAAA4C,MAAAU,IAAA,kBACAqhB,EAAAlnB,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAlF,GACAwmB,EAAAnnB,KAAAuC,MAAA4C,MAAAU,IAAA,mBACA6hB,EAAA1nB,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAA7F,KAAAuC,MAAAxC,MAAAC,KAAAuC,MAAArC,QACA+Q,EAAAjR,KAAAuC,MAAA4C,MAAA8L,gBAAA7E,EAGApM,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAA2M,YACAtM,KAAAL,QAAAyM,UAAAA,EACApM,KAAAL,QAAA0P,QAAAA,EACArP,KAAAL,QAAAuM,YAAAA,CAGA,IAAA3K,GAAAuF,EAAAC,CAGA,KAAAxF,EAAAvB,KAAAuC,MAAAwD,KAAAiC,MAAAzG,GAAAvB,KAAAuC,MAAAwD,KAAAkC,OAAA1G,IACAuF,EAAA9G,KAAAuC,MAAAgG,QAAAhH,GACAvB,KAAAL,QAAA+N,OAAA5G,EAAA2gB,GACAznB,KAAAL,QAAAioB,OAAA9gB,EAAA2gB,EAAAznB,KAAAuC,MAAAgD,eAIA,KAAAhE,EAAAvB,KAAAuC,MAAAwD,KAAAmC,KAAA3G,GAAAvB,KAAAuC,MAAAwD,KAAAoC,KAAA5G,IACAwF,EAAA/G,KAAAuC,MAAAoG,QAAApH,GACAvB,KAAAL,QAAA+N,OAAA8Z,EAAAzgB,GACA/G,KAAAL,QAAAioB,OAAAJ,EAAAxnB,KAAAuC,MAAA+C,cAAAyB,EAOA,KAHA/G,KAAAL,QAAAiO,SAGArM,EAAA,EAAAA,EAAAmmB,EAAAxlB,OAAAX,IACA0lB,EAAAtkB,KAAA3C,KAAA0nB,EAAAnmB,GAAAuF,EAAA4gB,EAAAnmB,GAAAwF,EAAAmgB,EAAAC,EAIAnnB,MAAAL,QAAAgoB,WAAA1W,GAAAA,GAGAjR,KAAAsE,aACA0iB,EAAAjf,KAAApF,KAAA3C,QAOAunB,EAAAtiB,UAAAsG,UAAA,SAAA/C,EAAAI,GAGA,GAAA9B,GAAA9G,KAAAuC,MAAAgG,QAAAC,GACAzB,EAAA/G,KAAAuC,MAAAoG,QAAAC,GACAQ,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAArJ,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAGAgD,EAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,iBAAAuD,GACA6H,EAAAjR,KAAAuC,MAAA4C,MAAA8L,gBAAA7E,EAGApM,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAA2J,UAAAxC,EAAAuC,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAAA,GAGArJ,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMAsW,EAAAtiB,UAAAwG,WAAA,SAAAjD,EAAAI,GAGA,GAAA9B,GAAA9G,KAAAuC,MAAAgG,QAAAC,GACAzB,EAAA/G,KAAAuC,MAAAoG,QAAAC,GACAQ,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAArJ,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAGAgD,EAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,iBAAAuD,GACA8C,EAAAlM,KAAAuC,MAAA4C,MAAAU,IAAA,kBACAqhB,EAAAlnB,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAuD,GACA+d,EAAAnnB,KAAAuC,MAAA4C,MAAAU,IAAA,mBACAoL,EAAAjR,KAAAuC,MAAA4C,MAAA8L,gBAAA7E,GACAsb,EAAA1nB,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAA7F,KAAAuC,MAAAxC,MAAAC,KAAAuC,MAAArC,QAGAwM,EAAA,IAAAlE,EAAA1B,EAAAA,EAAAuC,EACA0D,EAAAvE,IAAAxI,KAAAuC,MAAAxC,MAAA,EAAA+G,EAAAA,EAAAuC,EACAwD,EAAA,IAAAjE,EAAA7B,EAAAA,EAAAsC,EACA2D,EAAApE,IAAA5I,KAAAuC,MAAArC,OAAA,EAAA6G,EAAAA,EAAAsC,CAGArJ,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAA2M,YACAtM,KAAAL,QAAAyM,UAAAA,EACApM,KAAAL,QAAAuM,YAAAA,EAGAlM,KAAAL,QAAA+N,OAAAhB,EAAA3F,GACA/G,KAAAL,QAAAioB,OAAA7a,EAAAhG,GACA/G,KAAAL,QAAA+N,OAAA5G,EAAA+F,GACA7M,KAAAL,QAAAioB,OAAA9gB,EAAAkG,GACAhN,KAAAL,QAAAiO,QAGA,KAAA,GAAArM,KAAAmmB,GACAA,EAAAnmB,GAAAuF,IAAA0B,GAAAkf,EAAAnmB,GAAAwF,IAAA6B,GACAqe,EAAAtkB,KAAA3C,KAAAwI,EAAAI,EAAAse,EAAAC,EAKAnnB,MAAAL,QAAAgoB,WAAA1W,GAAAA,ICnPAsW,MAGA7rB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAKAD,GAAAE,OAAA,uCACA,OACA,2BACA,mCACA,yCAMAqN,QAAA,cAAA,aAAA,SAAA,aAAA,SAAAoC,EAAAuc,EAAAC,GAKA,GAAAC,GAAA,SAAAxlB,EAAA5C,GAGAK,KAAAgoB,WAGA1c,EAAA3I,KAAA3C,KAAAuC,EAAA5C,GC/BA,ODqCAhE,GAAA+I,OAAAqjB,EAAA9iB,UAAAqG,EAAArG,WAKA8iB,EAAA9iB,UAAA4B,IAAA,SAAAC,EAAAC,EAAAkhB,GAGA,GAAAjoB,KAAA+F,KAAA8D,SAAA/C,EAAAC,GAAA,CAcA,GATA/G,KAAAiH,OAAAH,EAAAC,GAGAkhB,EAAAC,QACAphB,EAAAA,EACAC,EAAAA,GAIA,WAAAkhB,EAAAtY,KACAsY,EAAAE,YAAAL,EACAG,EAAAC,OAAA7Z,MAAA4Z,EAAAjhB,UAIA,CAAA,GAAA,WAAAihB,EAAAtY,KAaA,WADAjF,SAAAC,KAAA,qBAAAsd,EAAAtY,KAXAsY,GAAAE,YAAAN,EACA,gBAAAI,GAAAjhB,MACAihB,EAAAC,OAAAvsB,EAAA+I,OAAAujB,EAAAC,OAAAD,EAAAjhB,OAGAihB,EAAAC,OAAAvY,KAAAsY,EAAAjhB,MAWAhH,KAAAuC,MAAA2E,IAAA+gB,EAAAtY,KAAA7I,EAAAC,KACA/G,KAAAgoB,QAAA9d,MACApD,EAAAA,EACAC,EAAAA,EACAvF,MAAAymB,EAAAtY,KACA3I,MAAAhH,KAAAuC,MAAAsD,IAAAoiB,EAAAtY,KAAA7I,EAAAC,KAEA/G,KAAAuC,MAAA0E,OAAAghB,EAAAtY,KAAA7I,EAAAC,IAIA/G,KAAA+F,KAAA6D,IAAA9C,EAAAC,EAAAkhB,GAGAA,EAAAE,aAAAF,EAAAE,YAAApgB,MACAkgB,EAAAE,YAAApgB,KAAApF,KAAA3C,KAAAioB,EAAAC,UAOAH,EAAA9iB,UAAAgC,OAAA,SAAAH,EAAAC,GAGA,GAAA/G,KAAA+F,KAAAmB,IAAAJ,EAAAC,GAAA,CAKA,GAAAkhB,GAAAjoB,KAAA+F,KAAAF,IAAAiB,EAAAC,EACAkhB,GAAAE,aAAAF,EAAAE,YAAArgB,OACAmgB,EAAAE,YAAArgB,MAAAnF,KAAA3C,KAAAioB,EAAAC,OAIA,KAAA,GAAA3mB,GAAA,EAAAA,EAAAvB,KAAAgoB,QAAA9lB,OAAAX,IACAvB,KAAAgoB,QAAAzmB,GAAAuF,IAAAA,GAAA9G,KAAAgoB,QAAAzmB,GAAAwF,IAAAA,IACA/G,KAAAuC,MAAAsE,IACA7G,KAAAgoB,QAAAzmB,GAAAC,MAAAxB,KAAAgoB,QAAAzmB,GAAAuF,EAAA9G,KAAAgoB,QAAAzmB,GAAAwF,EAAA/G,KAAAgoB,QAAAzmB,GAAAyF,OAEAhH,KAAAgoB,QAAApP,OAAArX,EAAA,MAQAwmB,EAAA9iB,UAAAC,UAAA,WAGA,IAAAlF,KAAA+F,KAAA6B,UAAA,CAKA,GAAArG,GACA0mB,EAAAjoB,KAAA+F,KAAAiE,IAAA,QAGA,KAAAzI,EAAA,EAAAA,EAAA0mB,EAAA/lB,OAAAX,IACA0mB,EAAA1mB,GAAA4mB,aAAAF,EAAA1mB,GAAA4mB,YAAArgB,OACAmgB,EAAA1mB,GAAA4mB,YAAArgB,MAAAnF,KAAA3C,KAAAioB,EAAA1mB,GAAA2mB,OASA,KAJAloB,KAAA8H,QACA9H,KAAA+F,KAAAqE,QAGA7I,EAAA,EAAAA,EAAAvB,KAAAgoB,QAAA9lB,OAAAX,IACAvB,KAAAuC,MAAAsE,IACA7G,KAAAgoB,QAAAzmB,GAAAC,MAAAxB,KAAAgoB,QAAAzmB,GAAAuF,EAAA9G,KAAAgoB,QAAAzmB,GAAAwF,EAAA/G,KAAAgoB,QAAAzmB,GAAAyF,MAKAhH,MAAAgoB,aAMAD,EAAA9iB,UAAA8C,KAAA,WAGA,GAAA/H,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,WAMA,IAAA,GADAqc,GAAAjoB,KAAA+F,KAAAiE,IAAA,SACAzI,EAAA,EAAAA,EAAA0mB,EAAA/lB,OAAAX,IACA0mB,EAAAE,aAAAF,EAAAE,YAAApgB,MACAkgB,EAAAE,YAAApgB,KAAApF,KAAA3C,KAAAioB,EAAAC,SClLAH,MAGArsB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAKAD,GAAAE,OAAA,wCACA,OACA,2BACA,qCAMAqN,QAAA,eAAA,aAAA,SAAA,SAAAoC,EAAAuc,GAKA,GAAAO,GAAA,SAAA7lB,EAAA5C,GAGA2L,EAAA3I,KAAA3C,KAAAuC,EAAA5C,GC3BA,ODiCAhE,GAAA+I,OAAA0jB,EAAAnjB,UAAAqG,EAAArG,WASAmjB,EAAAnjB,UAAAkC,OAAA,SAAApB,GAGA,GAAAxE,GACA6E,EAAApG,KAAA+F,KAAA0E,QAAA1E,EAAA,OAGA,KAAAxE,EAAA,EAAAA,EAAA6E,EAAAa,OAAA/E,OAAAX,IACAsmB,EAAA/f,MAAAnF,KAAA3C,KAAAoG,EAAAa,OAAA1F,GAIA,KAAAA,EAAA,EAAAA,EAAA6E,EAAAS,IAAA3E,OAAAX,IACAsmB,EAAA9f,KAAApF,KAAA3C,KAAAoG,EAAAS,IAAAtF,GAIAvB,MAAA+F,KAAAA,EAAAsE,SAMA+d,EAAAnjB,UAAAC,UAAA,WAMA,IAAA,GAHAsC,GAAAxH,KAAA+F,KAAAiE,IAAA,QAGAzI,EAAA,EAAAA,EAAAiG,EAAAtF,OAAAX,IACAsmB,EAAA/f,MAAAnF,KAAA3C,KAAAwH,EAAAjG,GAIAvB,MAAA+F,KAAAqE,SAUAge,EAAAnjB,UAAA8C,KAAA,WAGA,GAAA/H,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,WAQA,IAAA,GAHApE,GAAAxH,KAAA+F,KAAAiE,IAAA,QAGAzI,EAAA,EAAAA,EAAAiG,EAAAtF,OAAAX,IACAsmB,EAAA9f,KAAApF,KAAA3C,KAAAwH,EAAAjG,KAOA6mB,EAAAnjB,UAAAuG,SAAA,SAAA1E,EAAAC,GAGA,IAAA/G,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,YAKA5L,KAAA+F,KAAAmB,IAAAJ,EAAAC,IACA8gB,EAAA9f,KAAApF,KAAA3C,KAAAA,KAAA+F,KAAAF,IAAAiB,EAAAC,EAAA,UAOAqhB,EAAAnjB,UAAAsG,UAAA,SAAAzE,EAAAC,GACA/G,KAAA+F,KAAAmB,IAAAJ,EAAAC,IACA8gB,EAAA/f,MAAAnF,KAAA3C,KAAAA,KAAA+F,KAAAF,IAAAiB,EAAAC,EAAA,UC3HAqhB,MAGA1sB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAKAD,GAAAE,OAAA,uCACA,OACA,2BACA,sCACA,yCAMAqN,QAAA,cAAA,aAAA,YAAA,aAAA,SAAAoC,EAAA+c,EAAAP,GAKA,GAAAQ,GAAA,SAAA/lB,EAAA5C,GAGAK,KAAAmQ,UACAnQ,KAAAuX,YAGAjM,EAAA3I,KAAA3C,KAAAuC,EAAA5C,GChCA,ODsCAhE,GAAA+I,OAAA4jB,EAAArjB,UAAAqG,EAAArG,WASAqjB,EAAArjB,UAAAkC,OAAA,SAAAgJ,EAAAoH,GAGAvX,KAAAkF,YAGAlF,KAAAmQ,OAAAA,EAAAnG,IAAA,SACAhK,KAAAuX,SAAAA,EAAAvN,IAAA,SAGAhK,KAAA+H,QAMAugB,EAAArjB,UAAAC,UAAA,WAGA,IAAA,GAAA3D,GAAA,EAAAA,EAAAvB,KAAAuX,SAAArV,OAAAX,IACAvB,KAAAuC,MAAAsE,IAAA,SAAA7G,KAAAuX,SAAAhW,GAAAuF,EAAA9G,KAAAuX,SAAAhW,GAAAwF,EAAA/G,KAAAuX,SAAAhW,GAAA8M,MAIArO,MAAA8H,QAGA9H,KAAAmQ,UACAnQ,KAAAuX,aAUA+Q,EAAArjB,UAAA8C,KAAA,WAGA,GAAA/H,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,WAAA,CAKA,GAAArK,EAGA,KAAAA,EAAA,EAAAA,EAAAvB,KAAAuX,SAAArV,OAAAX,IACAvB,KAAAuC,MAAA0E,OAAA,SAAAjH,KAAAuX,SAAAhW,GAAAuF,EAAA9G,KAAAuX,SAAAhW,GAAAwF,GACA+gB,EAAA/f,KAAApF,KAAA3C,KAAAA,KAAAuX,SAAAhW,GAIA,KAAAA,EAAA,EAAAA,EAAAvB,KAAAmQ,OAAAjO,OAAAX,IACA8mB,EAAAtgB,KAAApF,KAAA3C,KAAAA,KAAAmQ,OAAA5O,MCvGA+mB,MAGA5sB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAKAD,GAAAE,OAAA,wCACA,OACA,2BACA,0CAMAqN,QAAA,eAAA,aAAA,cAAA,SAAAoC,EAAAid,GAKA,GAAAC,GAAA,SAAAjmB,EAAA5C,GAGA2L,EAAA3I,KAAA3C,KAAAuC,EAAA5C,GC3BA,ODiCAhE,GAAA+I,OAAA8jB,EAAAvjB,UAAAqG,EAAArG,WAKAujB,EAAAvjB,UAAA4B,IAAA,SAAAoH,GAGAA,EAAAE,UAAA,GAAA,mBAAAF,GAAAU,OAAAV,EAAAU,MAAA,GAKA3O,KAAA+F,KAAAmB,IAAA+G,EAAAnH,EAAAmH,EAAAlH,KAKA/G,KAAA+F,KAAA6D,IAAAqE,EAAAnH,EAAAmH,EAAAlH,EAAAkH,EAAAI,OAGArO,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,YACA2c,EAAAxgB,KAAApF,KAAA3C,KAAAiO,KAOAua,EAAAvjB,UAAAgC,OAAA,SAAAgH,GAGAjO,KAAA+F,KAAA+D,MAAAmE,EAAAnH,EAAAmH,EAAAlH,GAGA/G,KAAA6D,UAMA2kB,EAAAvjB,UAAA8C,KAAA,WAGA,GAAA/H,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,WAAA,CAKA,GAAA6c,GAAAzoB,KAAAuC,MAAA4C,MAAAU,IAAA,cAAA7F,KAAAuC,MAAA+F,cAGAtI,MAAAL,QAAA+oB,aAAA,EAAA,EAAA,EAAA,EAAAD,EAAAA,EAMA,KAAA,GAHAlhB,GAAAvH,KAAA+F,KAAAiE,IAAA,SAGAzI,EAAA,EAAAA,EAAAgG,EAAArF,OAAAX,IACAgnB,EAAAxgB,KAAApF,KAAA3C,KAAAuH,EAAAhG,MC5FAinB,MAGA9sB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAKAD,GAAAE,OAAA,wCACA,OACA,2BACA,oCAMAqN,QAAA,eAAA,aAAA,QAAA,aAAA,SAAAoC,EAAAqd,EAAA7a,GAKA,GAAA8a,GAAA,SAAArmB,EAAA5C,GAGA2L,EAAA3I,KAAA3C,KAAAuC,EAAA5C,GAGAK,KAAA+F,KAAA6E,UAAAkD,EAAAjR,OC9BA,ODoCAlB,GAAA+I,OAAAkkB,EAAA3jB,UAAAqG,EAAArG,WASA2jB,EAAA3jB,UAAAkC,OAAA,SAAApB,GAGA,GAAAxE,GACA6E,EAAApG,KAAA+F,KAAA0E,QAAA1E,EAAA,QAGA,KAAAxE,EAAA,EAAAA,EAAA6E,EAAAa,OAAA/E,OAAAX,IACAonB,EAAA7gB,MAAAnF,KAAA3C,KAAAoG,EAAAa,OAAA1F,GAIA,KAAAA,EAAA,EAAAA,EAAA6E,EAAAS,IAAA3E,OAAAX,IACAonB,EAAA5gB,KAAApF,KAAA3C,KAAAoG,EAAAS,IAAAtF;AAIAvB,KAAA+F,KAAAA,EAAAsE,SAUAue,EAAA3jB,UAAA8C,KAAA,WAGA,GAAA/H,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,WAQA,IAAA,GAHArE,GAAAvH,KAAA+F,KAAAiE,IAAA,SAGAzI,EAAA,EAAAA,EAAAgG,EAAArF,OAAAX,IACAonB,EAAA5gB,KAAApF,KAAA3C,KAAAuH,EAAAhG,KAOAqnB,EAAA3jB,UAAApB,OAAA,WAGA7D,KAAAuC,MAAA2C,UAAA,UAGAlF,KAAA8H,QACA9H,KAAA+H,QAMA6gB,EAAA3jB,UAAAuG,SAAA,SAAA1E,EAAAC,GAGA,IAAA/G,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,YAKA5L,KAAA+F,KAAAmB,IAAAJ,EAAAC,IACA4hB,EAAA5gB,KAAApF,KAAA3C,KAAAA,KAAA+F,KAAAF,IAAAiB,EAAAC,EAAA,WAOA6hB,EAAA3jB,UAAAsG,UAAA,SAAAzE,EAAAC,GACA/G,KAAA+F,KAAAmB,IAAAJ,EAAAC,IACA4hB,EAAA7gB,MAAAnF,KAAA3C,KAAAA,KAAA+F,KAAAF,IAAAiB,EAAAC,EAAA,WC1HA6hB,MAGAltB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,yCACA,SAMAqN,QAAA,cAAA,WAGA,GAAA2f,IACA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IACA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KACA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,KACA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAAA,MAIAhP,EAAA,IAAAC,WAAA,GACAgP,EAAA,IAAAhP,WAAA,GAKAxV,GAGAukB,MAAA,SAAAtnB,GACA,MAAAsnB,GAAAtnB,IAAA,IAIAwnB,QAAA,SAAAxnB,GACA,MAAAA,GAAA,GAIAynB,QAAA,SAAAznB,GAGA,GAAA+O,GAAA,EAcA,OAXA/O,IAAA,KACA+O,EAAA,IACA/O,GAAA,IAIAA,GAAA,GACAA,IAIA+O,EAAAT,OAAAC,aAAA+J,EAAAtY,IAIAkT,IAAA,SAAAlT,GACA,MAAAA,IAIAiU,IAAA,SAAAjU,GACA,GAAA+O,EAOA,OALAA,GADA,GAAA/O,EACAunB,EAAAvnB,EAGAsY,EAAAtY,EAEAsO,OAAAC,aAAAQ,KAOA0W,GAKAjf,KAAA,WAGA,GAAA/H,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,WAAA,CAKA,GAAAjL,GAAAX,KAAAuC,MAAA+F,cAGA2gB,EAAAroB,KAAAmO,MAAA/O,KAAAuC,MAAA6C,cAAAzE,EAAA,GAAA,GACAuoB,EAAAlpB,KAAAuC,MAAA9B,UAAAwoB,EACAE,EAAAvoB,KAAAmO,MAAA/O,KAAAuC,MAAA8C,cAAA1E,EAAA,GAAA,GACAyoB,EAAAppB,KAAAuC,MAAA7B,WAAAyoB,EAGA/B,EAAApnB,KAAAuC,MAAA4C,MAAAU,IAAA,qBACAuK,GACAX,KAAAzP,KAAAuC,MAAA4C,MAAAU,IAAA,6BACA7C,KAAAhD,KAAAuC,MAAA4C,MAAAU,IAAA,6BACAqI,MAAAlO,KAAAuC,MAAA4C,MAAAU,IAAA,8BACAwK,QAAArQ,KAAAuC,MAAA4C,MAAAU,IAAA,iCAEA0K,GACAd,KAAAzP,KAAAuC,MAAA4C,MAAAU,IAAA,+BACA7C,KAAAhD,KAAAuC,MAAA4C,MAAAU,IAAA,+BACAqI,MAAAlO,KAAAuC,MAAA4C,MAAAU,IAAA,gCACAwK,QAAArQ,KAAAuC,MAAA4C,MAAAU,IAAA,kCAIA7F,MAAAL,QAAAynB,UAAAA,EACApnB,KAAAL,QAAA0pB,aAAA,SACArpB,KAAAL,QAAA2pB,UAAA,QAGA,IAAA/nB,GAAA4J,EAAArE,EAAAC,EAAAuJ,CAGA,KAAA/O,EAAA,EAAAA,EAAAvB,KAAAuC,MAAArC,OAAAqB,IAGA4J,EAAA5J,EACA6O,EAAAC,UACAlF,EAAAnL,KAAAuC,MAAArC,OAAAqB,EAAA,GAKA+O,EADA,kBAAAF,GAAAlC,MACAkC,EAAAlC,MAAAvL,KAAA3C,KAAAmL,GAEA7G,EAAA8L,EAAAlC,OACA5J,EAAA8L,EAAAlC,OAAAvL,KAAA3C,KAAAmL,GAGAA,EAIApE,EAAA/G,KAAAuC,MAAAoG,QAAApH,GACAvB,KAAAL,QAAA8P,KAAAW,EAAApN,KAAAsN,EAAA3P,GAAA,IAAAyP,EAAAX,KACAzP,KAAAL,QAAA4pB,SAAAjZ,EAAA2Y,EAAAliB,GACA/G,KAAAL,QAAA4pB,SAAAjZ,EAAA4Y,EAAAniB,EAIA,KAAAxF,EAAA,EAAAA,EAAAvB,KAAAuC,MAAAxC,MAAAwB,IAGA4J,EAAA5J,EACAgP,EAAAF,UACAlF,EAAAnL,KAAAuC,MAAAxC,MAAAwB,EAAA,GAKA+O,EADA,kBAAAC,GAAArC,MACAqC,EAAArC,MAAAvL,KAAA3C,KAAAmL,GAEA7G,EAAAiM,EAAArC,OACA5J,EAAAiM,EAAArC,OAAAvL,KAAA3C,KAAAmL,GAGAA,EAIArE,EAAA9G,KAAAuC,MAAAgG,QAAAhH,GACAvB,KAAAL,QAAA8P,KAAAc,EAAAvN,KAAAsN,EAAA3P,GAAA,IAAA4P,EAAAd,KACAzP,KAAAL,QAAA4pB,SAAAjZ,EAAAxJ,EAAAqiB,GACAnpB,KAAAL,QAAA4pB,SAAAjZ,EAAAxJ,EAAAsiB,KC3LA,OAAApC,MAGAtrB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,oCACA,OACA,8BAMAqN,QAAA,UAAA,cAAA,cAAA,SAAA6E,EAAApC,GAKA,GAAA6d,GAAA5oB,KAAA+L,IAAA/L,KAAAgM,GAAA,GACA6c,EAAA7oB,KAAA+L,IAAA/L,KAAAgM,GAAA,GAKA8c,EAAA,SAAAliB,GAGA,GAAAV,GAAA9G,KAAAuC,MAAAgG,QAAAf,EAAAV,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAAzI,KAAA8H,MACA1I,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAApJ,KAAAuC,MAAA4C,MAAAU,IAAA,yBAIA2B,GAAA3H,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA7B,EAAA3H,OAIA,IAAAyO,GAAAtO,KAAAuC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAA/G,KAAAuC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACA8C,EAAA1E,EAAA6G,OAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAjR,KAAAuC,MAAA4C,MAAA8L,gBAAA7E,EAGApM,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAAuM,YAAAA,EACAlM,KAAAL,QAAAyM,UAAAA,EAGApM,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA+N,OAAA5G,EAAAC,EAAAsC,GACArJ,KAAAL,QAAAioB,OAAA9gB,EAAAlG,KAAA8H,MAAAW,EAAAogB,GAAA1iB,EAAAnG,KAAA8H,MAAAW,EAAA,IACArJ,KAAAL,QAAAioB,OAAA9gB,EAAAlG,KAAA8H,MAAAW,EAAAogB,GAAA1iB,EAAAnG,KAAA8H,MAAAW,EAAA,IACArJ,KAAAL,QAAAgqB,YACA3pB,KAAAL,QAAAiO,SAGA5N,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMA2Y,EAAA,SAAApiB,GAGA,GAAAV,GAAA9G,KAAAuC,MAAAgG,QAAAf,EAAAV,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAAzI,KAAA8H,MACA1I,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAApJ,KAAAuC,MAAA4C,MAAAU,IAAA,uBAIA2B,GAAA3H,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA7B,EAAA3H,OAIA,IAAAgqB,GAAAjpB,KAAA8H,MAAAW,EAAAmgB,GAGAlb,EAAAtO,KAAAuC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAA/G,KAAAuC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACA8C,EAAA1E,EAAA6G,OAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAjR,KAAAuC,MAAA4C,MAAA8L,gBAAA7E,EAGApM,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAAuM,YAAAA,EACAlM,KAAAL,QAAAyM,UAAAA,EAGApM,KAAAL,QAAA2M,YACAtM,KAAAL,QAAAmqB,KAAAhjB,EAAA+iB,EAAA9iB,EAAA8iB,EAAA,EAAAA,EAAA,EAAAA,GACA7pB,KAAAL,QAAAiO,SAGA5N,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMA8Y,EAAA,SAAAviB,GAGA,GAAAV,GAAA9G,KAAAuC,MAAAgG,QAAAf,EAAAV,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAAzI,KAAA8H,MACA1I,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAApJ,KAAAuC,MAAA4C,MAAAU,IAAA,uBAIA2B,GAAA3H,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA7B,EAAA3H,OAIA,IAAAyO,GAAAtO,KAAAuC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAA/G,KAAAuC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACA8C,EAAA1E,EAAA6G,OAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAjR,KAAAuC,MAAA4C,MAAA8L,iBAGAjR,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAAuM,YAAAA,EACAlM,KAAAL,QAAAyM,UAAAA,EAGApM,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA0nB,IAAAvgB,EAAAC,EAAAsC,EAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAAiO,SAGA5N,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMA+Y,EAAA,SAAAxiB,GAGA,GAAAV,GAAA9G,KAAAuC,MAAAgG,QAAAf,EAAAV,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAAzI,KAAA8H,MACA1I,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAApJ,KAAAuC,MAAA4C,MAAAU,IAAA,qBAIA2B,GAAA3H,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA7B,EAAA3H,OAIA,IAAAgqB,GAAAjpB,KAAA8H,MAAAW,EAAAmgB,GAGAlb,EAAAtO,KAAAuC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAA/G,KAAAuC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACAiG,EAAA7H,EAAA6H,SAAArP,KAAAuC,MAAA4C,MAAAU,IAAA,uBACAqG,EAAA1E,EAAA6G,OAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAjR,KAAAuC,MAAA4C,MAAA8L,gBAAA7E,EAGApM,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAAuM,YAAAA,EACAlM,KAAAL,QAAAyM,UAAAA,EACApM,KAAAL,QAAA0P,QAAAA,EAGArP,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA+N,OAAA5G,EAAA+iB,EAAA9iB,EAAA8iB,GACA7pB,KAAAL,QAAAioB,OAAA9gB,EAAA+iB,EAAA9iB,EAAA8iB,GACA7pB,KAAAL,QAAA+N,OAAA5G,EAAA+iB,EAAA9iB,EAAA8iB,GACA7pB,KAAAL,QAAAioB,OAAA9gB,EAAA+iB,EAAA9iB,EAAA8iB,GACA7pB,KAAAL,QAAAiO,SAGA5N,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMAgZ,EAAA,SAAAziB,GAGA,GAAAV,GAAA9G,KAAAuC,MAAAgG,QAAAf,EAAAV,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAAzI,KAAA8H,MACA1I,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAApJ,KAAAuC,MAAA4C,MAAAU,IAAA,uBAIA2B,GAAA3H,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA7B,EAAA3H,OAIA,IAAAyO,GAAAtO,KAAAuC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAA/G,KAAAuC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACAge,EAAA5f,EAAA6G,OAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAjR,KAAAuC,MAAA4C,MAAA8L,iBAGAjR,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAAynB,UAAAA,EACApnB,KAAAL,QAAAyM,UAAAA,EAGApM,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA0nB,IAAAvgB,EAAAC,EAAAsC,EAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAA2nB,OAGAtnB,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMAiZ,EAAA,SAAA1iB,GAGA,GAAAV,GAAA9G,KAAAuC,MAAAgG,QAAAf,EAAAV,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAAzI,KAAA8H,MACA1I,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAApJ,KAAAuC,MAAA4C,MAAAU,IAAA,qBAIA2B,GAAA3H,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA7B,EAAA3H,OAIA,IAAAyO,GAAAtO,KAAAuC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAA/G,KAAAuC,MAAAgC,gBAGA6iB,EAAA5f,EAAA6G,OAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAjR,KAAAuC,MAAA4C,MAAA8L,gBAAA7H,EAGApJ,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAAynB,UAAAA,EAGApnB,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA+N,OAAA5G,EAAAC,GACA/G,KAAAL,QAAAioB,OAAA9gB,EAAAuC,EAAAtC,GACA/G,KAAAL,QAAAioB,OAAA9gB,EAAAC,EAAAsC,GACArJ,KAAAL,QAAAgqB,YACA3pB,KAAAL,QAAA2nB,OAGAtnB,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMAkZ,EAAA,SAAA3iB,GAGA,GAAAV,GAAA9G,KAAAuC,MAAAgG,QAAAf,EAAAV,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAAzI,KAAA8H,MACA1I,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAApJ,KAAAuC,MAAA4C,MAAAU,IAAA,uBAIA2B,GAAA3H,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA7B,EAAA3H,OAIA,IAAAyO,GAAAtO,KAAAuC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAA/G,KAAAuC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACAiG,EAAA7H,EAAA6H,SAAArP,KAAAuC,MAAA4C,MAAAU,IAAA,yBACAqG,EAAA1E,EAAA6G,OAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAjR,KAAAuC,MAAA4C,MAAA8L,iBAGAjR,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAAuM,YAAAA,EACAlM,KAAAL,QAAAyM,UAAAA,EACApM,KAAAL,QAAA0P,QAAAA,EAGArP,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA0nB,IAAAvgB,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAAiO,SACA5N,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA0nB,IAAAvgB,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAAiO,SACA5N,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA+N,OAAA5G,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,GACArJ,KAAAL,QAAAgO,cACA7G,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,IAAAvC,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,IAAAvC,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,GAEArJ,KAAAL,QAAAiO,SAGA5N,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMAmZ,EAAA,SAAA5iB,GAGA,GAAAV,GAAA9G,KAAAuC,MAAAgG,QAAAf,EAAAV,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAAzI,KAAA8H,MACA1I,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAApJ,KAAAuC,MAAA4C,MAAAU,IAAA,uBAIA2B,GAAA3H,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA7B,EAAA3H,OAIA,IAAAyO,GAAAtO,KAAAuC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAA/G,KAAAuC,MAAAgC,gBAGA6H,EAAA5E,EAAA4E,WAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAuD,IAAA,EACAiG,EAAA7H,EAAA6H,SAAArP,KAAAuC,MAAA4C,MAAAU,IAAA,yBACAqG,EAAA1E,EAAA6G,OAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAjR,KAAAuC,MAAA4C,MAAA8L,iBAGAjR,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAAuM,YAAAA,EACAlM,KAAAL,QAAAyM,UAAAA,EACApM,KAAAL,QAAA0P,QAAAA,EAGArP,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA0nB,IAAAvgB,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAAiO,SACA5N,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA0nB,IAAAvgB,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,EAAA,EAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAAiO,SACA5N,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA+N,OAAA5G,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,IAAA,GACArJ,KAAAL,QAAAgO,cACA7G,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,EAAA,EAAAvC,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,EAAA,EAAAvC,EAAAuC,EAAA,IAAAtC,EAAAsC,EAAA,IAAA,GAEArJ,KAAAL,QAAAiO,SAGA5N,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMAoZ,EAAA,SAAA7iB,GAGA,GAAAV,GAAA9G,KAAAuC,MAAAgG,QAAAf,EAAAV,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAnB,EAAAT,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAArJ,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,EAGA5B,GAAA3H,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA7B,EAAA3H,OAIA,IAAAyO,GAAAtO,KAAAuC,MAAAsD,IAAA,SAAA2B,EAAAV,EAAAU,EAAAT,GAAA/G,KAAAuC,MAAAgC,gBAGAkL,EAAAjI,EAAAiI,MAAAzP,KAAAuC,MAAA4C,MAAAU,IAAA,sBAAA,GACAuhB,EAAA5f,EAAA6G,OAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAyI,GACA2C,EAAAjR,KAAAuC,MAAA4C,MAAA8L,iBAGAjR,MAAAuC,MAAA2E,IAAA,SAAAM,EAAAV,EAAAU,EAAAT,IACA/G,KAAAuC,MAAAM,OAAAkD,KAAAwF,UAAA/D,EAAAV,EAAAU,EAAAT,GAIA/G,KAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAjR,KAAAL,QAAAynB,UAAAA,EACApnB,KAAAL,QAAA0pB,aAAA,SACArpB,KAAAL,QAAA2pB,UAAA,SAGA,gBAAA9hB,GAAAoI,OACApI,EAAAoI,KAAApI,EAAAoI,KAAA0a,YAIA,IAAA9iB,EAAAoI,KAAA1N,OACAlC,KAAAL,QAAA8P,KAAA7O,KAAA8H,MAAA,IAAAW,GAAA,MAAAoG,EAEA,IAAAjI,EAAAoI,KAAA1N,OACAlC,KAAAL,QAAA8P,KAAA7O,KAAA8H,MAAA,IAAAW,GAAA,MAAAoG,EAGAzP,KAAAL,QAAA8P,KAAApG,EAAA,MAAAoG,EAIAzP,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA4pB,SAAA/hB,EAAAoI,KAAA9I,EAAAC,EAAA,EAAAsC,GAGArJ,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMAsZ,EAAA,SAAA/iB,GAGAxH,KAAAuC,MAAA2E,IAAA,SAAAM,EAAAV,EAAAU,EAAAT,IACA/G,KAAAuC,MAAAM,OAAAkD,KAAA0F,WAAAjE,EAAAV,EAAAU,EAAAT,IAOA8gB,GAKA9f,KAAA,SAAAP,GAGA,GAAAxH,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,WAKA,OAAApE,EAAAmI,MAGA,IAAA5B,GAAA7Q,SACAwsB,EAAA/mB,KAAA3C,KAAAwH,EACA,MAGA,KAAAuG,GAAA3Q,OACAwsB,EAAAjnB,KAAA3C,KAAAwH,EACA,MAGA,KAAAuG,GAAA5Q,OACA4sB,EAAApnB,KAAA3C,KAAAwH,EACA,MAGA,KAAAuG,GAAA1Q,KACA2sB,EAAArnB,KAAA3C,KAAAwH,EACA,MAGA,KAAAuG,GAAAzQ,OACA2sB,EAAAtnB,KAAA3C,KAAAwH,EACA,MAGA,KAAAuG,GAAArQ,MACAysB,EAAAxnB,KAAA3C,KAAAwH,EACA,MAGA,KAAAuG,GAAAtQ,IACA2sB,EAAAznB,KAAA3C,KAAAwH,EACA,MAGA,KAAAuG,GAAAvQ,KACA0sB,EAAAvnB,KAAA3C,KAAAwH,EACA,MAGA,KAAAuG,GAAAxQ,MACAiK,EAAAoI,KAAApI,EAAAoI,MAAA,GACAya,EAAA1nB,KAAA3C,KAAAwH,KAQAM,MAAA,SAAAN,GAGAxH,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,aAKAD,EAAA7D,MAAAnF,KAAA3C,KAAAwH,GAGAA,EAAAmI,OAAA5B,EAAAxQ,OACAgtB,EAAA5nB,KAAA3C,KAAAwH,KC5iBA,OAAAqgB,OAGAnsB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,mCACA,OACA,4BACA,oCAMAqN,QAAA,SAAA,YAAA,cAAA,aAAA,eAAA,SAAArE,EAAA8G,EAAAmC,EAAA0c,GAKA,GAAAC,GAKAC,EAAA,SAAAzc,GAGA,GAAAnH,GAAA9G,KAAAuC,MAAAgG,QAAA0F,EAAAnH,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAsF,EAAAlH,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAArJ,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,EAGA6E,GAAApO,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA4E,EAAApO,QAIAoO,EAAAE,QAAA,CAGA,IAAAE,GAAAJ,EAAAI,MAAArO,KAAAuC,MAAAgC,gBAGA6H,EAAApM,KAAAuC,MAAA4C,MAAAU,IAAA,uBAAAuD,IAAA,EACAge,EAAApnB,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAwI,GACAnC,EAAAlM,KAAAuC,MAAA4C,MAAAU,IAAA,uBAAAwI,GACA4C,EAAAjR,KAAAuC,MAAA4C,MAAA8L,iBAGAjR,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAhD,EAAAU,OAAAV,EAAAU,MAAA,IACA3O,KAAAL,QAAAgrB,YAAA1c,EAAAU,OAIA3O,KAAAL,QAAAynB,UAAAA,EAGApnB,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA0nB,IAAAvgB,EAAAC,EAAAnG,KAAA2L,IAAA,EAAAlD,EAAA+C,GAAA,EAAA,EAAAxL,KAAAgM,IAAA,GACA5M,KAAAL,QAAA2nB,OAGAtnB,KAAAL,QAAAyM,UAAAA,EACApM,KAAAL,QAAAuM,YAAAA,EAGAlM,KAAAL,QAAAiO,SAGAK,EAAAU,OAAAV,EAAAU,MAAA,IACA3O,KAAAL,QAAAgrB,YAAA,GAIA3qB,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMA2Z,EAAA,SAAA3c,GAGA,GAAAnH,GAAA9G,KAAAuC,MAAAgG,QAAA0F,EAAAnH,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAsF,EAAAlH,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAArJ,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,EAGA6E,GAAApO,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA4E,EAAApO,OAIA,IAAAwO,GAAAJ,EAAAI,MAAArO,KAAAuC,MAAAgC,gBAGA0M,EAAAjR,KAAAuC,MAAA4C,MAAA8L,iBAGAjR,MAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAhD,EAAAU,OAAAV,EAAAU,MAAA,IACA3O,KAAAL,QAAAgrB,YAAA1c,EAAAU,OAIA3O,KAAAL,QAAA2M,YAGA+B,IAAAP,EAAA9Q,GACAgD,KAAAL,QAAAynB,UAAApnB,KAAAL,QAAAkrB,qBACA/jB,EAAA,EAAAuC,EAAA,EAAAtC,EAAA,EAAAsC,EAAA,EAAAA,EAAA,EAAAvC,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAA,EAAAA,EAAA,GAEArJ,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,QACA9qB,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,UAGA9qB,KAAAL,QAAAynB,UAAApnB,KAAAL,QAAAkrB,qBACA/jB,EAAA,EAAAuC,EAAA,EAAAtC,EAAA,EAAAsC,EAAA,EAAA,EAAAvC,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAA,EAAAA,EAAA,GAEArJ,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,QACA9qB,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,SAIA9qB,KAAAL,QAAA0nB,IAAAvgB,EAAAC,EAAAnG,KAAA2L,IAAA,EAAAlD,EAAA,IAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAA2nB,OAGArZ,EAAAU,OAAAV,EAAAU,MAAA,IACA3O,KAAAL,QAAAgrB,YAAA,GAIA3qB,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMA8Z,EAAA,SAAA9c,GAGA,GAAAnH,GAAA9G,KAAAuC,MAAAgG,QAAA0F,EAAAnH,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAsF,EAAAlH,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAArJ,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,EAGA6E,GAAApO,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA4E,EAAApO,QAIA4qB,EAAAA,GAAA7pB,KAAAmO,KAAA,QAAAnO,KAAAoqB,SAGA,IAAA3c,GAAAJ,EAAAI,MAAArO,KAAAuC,MAAAgC,gBAGA0mB,EAAAjrB,KAAAuC,MAAA4C,MAAAU,IAAA,qBACAuhB,EAAApnB,KAAAuC,MAAA4C,MAAAU,IAAA,oBAAAwI,GACAnC,EAAAlM,KAAAuC,MAAA4C,MAAAU,IAAA,sBACAoL,EAAAjR,KAAAuC,MAAA4C,MAAA8L,iBAiBA,IAdAjR,KAAAL,QAAAgoB,UAAA1W,EAAAA,GAGAhD,EAAAU,OAAAV,EAAAU,MAAA,IACA3O,KAAAL,QAAAgrB,YAAA1c,EAAAU,OAIA3O,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA0nB,IAAAvgB,EAAAC,EAAAnG,KAAA2L,IAAA,EAAAlD,EAAA,IAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAAynB,UAAAA,EACApnB,KAAAL,QAAA2nB,OAGAjZ,IAAAP,EAAA9Q,EAAA,CAGA,GAAA2S,GACA8a,GAAAQ,EAAA/oB,OAAA+L,EAAAnH,EAAA9G,KAAAuC,MAAAxC,MAAAkO,EAAAlH,GAAAkkB,EAAA/oB,OAGAgpB,EAAAlrB,KAAAuC,MAAAxC,MAAAC,KAAAuC,MAAArC,OAAA+N,EAAAnH,EAAA9G,KAAAuC,MAAAxC,MAAAkO,EAAAlH,EACA0F,EAAA,EAAAye,GAAAT,EAAAS,EAGAV,GAAA7nB,KAAAsoB,EAAAtb,GAAA3P,KAAAL,QAAAmH,EAAAC,EAAAsC,EAAAoD,EAAAP,GAGAlM,KAAAL,QAAA2M,YACAtM,KAAAL,QAAAynB,UAAApnB,KAAAL,QAAAkrB,qBACA/jB,EAAA,EAAAuC,EAAA,EAAAtC,EAAA,EAAAsC,EAAA,EAAAA,EAAA,EAAAvC,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,GAEArJ,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,yBACA9qB,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,uBACA9qB,KAAAL,QAAA0nB,IAAAvgB,EAAAC,EAAAnG,KAAA2L,IAAA,EAAAlD,EAAA,IAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAA2nB,WAOAtnB,MAAAL,QAAA2M,YACAtM,KAAAL,QAAAynB,UAAApnB,KAAAL,QAAAkrB,qBACA/jB,EAAA,EAAAuC,EAAA,EAAAtC,EAAA,EAAAsC,EAAA,EAAA,EAAAvC,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAAA,GAEArJ,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,oBACA9qB,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,iBACA9qB,KAAAL,QAAA0nB,IAAAvgB,EAAAC,EAAAnG,KAAA2L,IAAA,EAAAlD,EAAA,IAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAA2nB,OAGAtnB,KAAAL,QAAA2M,YACAtM,KAAAL,QAAAynB,UAAApnB,KAAAL,QAAAkrB,qBACA/jB,EAAA,EAAAuC,EAAA,EAAAtC,EAAA,EAAAsC,EAAA,EAAA,EAAAvC,EAAAuC,EAAA,EAAAtC,EAAAsC,EAAA,EAAA,EAAAA,EAAA,GAEArJ,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,oBACA9qB,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,iBACA9qB,KAAAL,QAAA0nB,IAAAvgB,EAAAC,EAAAnG,KAAA2L,IAAA,EAAAlD,EAAA,IAAA,EAAA,EAAAzI,KAAAgM,IAAA,GACA5M,KAAAL,QAAA2nB,MAIArZ,GAAAU,OAAAV,EAAAU,MAAA,IACA3O,KAAAL,QAAAgrB,YAAA,GAIA3qB,KAAAL,QAAAgoB,WAAA1W,GAAAA,IAMA0X,GAKA5gB,KAAA,SAAAkG,GAGA,GAAAjO,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,WAAA,CAKA,GAAAsC,GAAAlO,KAAAuC,MAAA4C,MAAAU,IAAA,cAGA,QAAAqI,GAGA,IAAA,QACA6c,EAAApoB,KAAA3C,KAAAiO,EACA,MAGA,KAAA,QACA2c,EAAAjoB,KAAA3C,KAAAiO,EACA,MAGA,KAAA,OACAyc,EAAA/nB,KAAA3C,KAAAiO,EACA,MAGA,SACA,GAAAkd,GAAAtmB,EAAAgB,IAAAqI,EACAid,IACAA,EAAAxoB,KAAA3C,KAAAiO,IAKAjO,KAAAuC,MAAAvC,WAAAiO,EAAAE,UAAA,GAAAnO,KAAAuC,MAAA4C,MAAAU,IAAA,iBACA7F,KAAAuC,MAAAM,OAAAsL,OAAAtH,IAAAoH,KAOAnG,MAAA,SAAAmG,GAGAjO,KAAAL,SAAA,IAAAK,KAAAuC,MAAA9B,WAAA,IAAAT,KAAAuC,MAAAqJ,aAKAD,EAAA7D,MAAAnF,KAAA3C,KAAAiO,IAGAjO,KAAAuC,MAAAvC,WAAAiO,EAAAE,UAAA,GAAAnO,KAAAuC,MAAA4C,MAAAU,IAAA,iBACA7F,KAAAuC,MAAAM,OAAAsL,OAAAlH,OAAAgH,KC7TA,OAAA0a,OAGAjtB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,wCACA,OACA,oCAMAqN,QAAA,cAAA,QAAA,SAAAyf,GAKA,GAAAb,IAKA/f,KAAA,SAAAkG,GAGAA,EAAApO,MAAAG,KAAAuC,MAAA4C,MAAAU,IAAA,qBACAoI,EAAAU,MAAA3O,KAAAuC,MAAA4C,MAAAU,IAAA,oBAAAoI,EAAAI,OAGAJ,EAAAE,QAAA,EAGAwa,EAAA5gB,KAAApF,KAAA3C,KAAAiO,IAMAnG,MAAA,SAAAmG,GAGAA,EAAAE,QAAA,EAGAwa,EAAA7gB,MAAAnF,KAAA3C,KAAAiO,ICtDA,OAAA6Z,OAGApsB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,uCACA,OACA,oCAMAqN,QAAA,aAAA,QAAA,SAAAyf,GAKA,GAAAN,IAKAtgB,KAAA,SAAAkG,GAGAA,EAAApO,MAAAG,KAAAuC,MAAA4C,MAAAU,IAAA,oBACAoI,EAAAU,MAAA3O,KAAAuC,MAAA4C,MAAAU,IAAA,mBAAAoI,EAAAI,OAGAJ,EAAAE,QAAA,EAGAwa,EAAA5gB,KAAApF,KAAA3C,KAAAiO,IAMAnG,MAAA,SAAAmG,GAGAA,EAAAE,QAAA,EAGAwa,EAAA7gB,MAAAnF,KAAA3C,KAAAiO,ICvDA,OAAAoa,OAGA3sB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,yCACA,OACA,8BAMAqN,QAAA,cAAA,WAKA,GAAAqf,IAKAxgB,KAAA,SAAAkG,GAGA,GAAAjO,KAAAL,WAKAsO,EAAAU,OAAAV,EAAAU,MAAA,GAAAV,EAAAE,UAAA,GAAA,CAKA,GAAArH,GAAA9G,KAAAuC,MAAAgG,QAAA0F,EAAAnH,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAsF,EAAAlH,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAAzI,KAAA2L,IAAA,EAAAvM,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,GAAA,GAGA6E,GAAApO,QACAwJ,EAAAzI,KAAA8H,MAAAW,EAAA4E,EAAApO,OAIA,IAAAgP,GAAA7O,KAAAuC,MAAA4C,MAAAU,IAAA,cAAAuD,GACA0F,EAAA9O,KAAAuC,MAAA4C,MAAAU,IAAA,iBAAAuD,GACA4F,EAAAhP,KAAAuC,MAAA4C,MAAAU,IAAA,iBAAAuD,GACAgiB,EAAAprB,KAAAuC,MAAA4C,MAAAU,IAAA,eAGA7F,MAAAL,QAAAynB,UAAApnB,KAAAL,QAAAkrB,qBACA/jB,EAAAgI,EAAA/H,EAAAiI,EAAA3F,EAAA,EAAAwF,EAAA/H,EAAAgI,EAAA/H,EAAAiI,EAAA3F,EAAAwF,GAEA7O,KAAAL,QAAAynB,UAAA0D,aAAA,EAAAM,GACAprB,KAAAL,QAAAynB,UAAA0D,aAAA,EAAA,iBAGA9qB,KAAAL,QAAA2M,YACAtM,KAAAL,QAAA0nB,IAAAvgB,EAAAgI,EAAA/H,EAAAiI,EAAA3F,EAAAwF,EAAA,EAAA,EAAAjO,KAAAgM,IAAA,GACA5M,KAAAL,QAAA2nB,SAMAxf,MAAA,SAAAmG,GAQA,GAAAjO,KAAAL,WAKAsO,EAAAU,OAAAV,EAAAU,MAAA,GAAAV,EAAAE,UAAA,GAAA,CAKA,GAAArH,GAAA9G,KAAAuC,MAAAgG,QAAA0F,EAAAnH,GACAC,EAAA/G,KAAAuC,MAAAoG,QAAAsF,EAAAlH,GACAqC,EAAApJ,KAAAuC,MAAA+F,cACAe,EAAArJ,KAAAuC,MAAA4C,MAAAU,IAAA,eAAAuD,EAGApJ,MAAAL,QAAA2J,UAAAxC,EAAA,IAAAuC,EAAAtC,EAAA,IAAAsC,EAAA,IAAAA,EAAA,IAAAA,KCrGA,OAAAkf,MAGA7sB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,mCACA,OACA,6BAMAwvB,KAAA,SAAA,cAAA,mBAAA,SAAA1nB,EAAAoc,EAAAuL,GAKA3nB,EAAArB,GAAA,UAAAgpB,EAAAC,SACAxL,EAAAniB,OAAAmiB,EAAAliB,OAEA8F,EAAArB,GAAA,mBAAAgpB,EAAAE,YACAzL,EAAAniB,OAAAmiB,EAAAliB,OAEA8F,EAAArB,GAAA,YAAAgpB,EAAAG,WACA1L,EAAAniB,OAAAmiB,EAAAliB,KAAAkiB,EAAAjiB,QAEA6F,EAAArB,GAAA,WAAAgpB,EAAAI,UACA3L,EAAAniB,OAAAmiB,EAAAliB,KAAAkiB,EAAAjiB,QAEA6F,EAAArB,GAAA,YAAAgpB,EAAAK,WACA5L,EAAAniB,OAAAmiB,EAAAliB,KAAAkiB,EAAAjiB,QAEA6F,EAAArB,GAAA,UAAAgpB,EAAAM,SACA7L,EAAAniB,OAAAmiB,EAAAliB,KAAAkiB,EAAAjiB,WAOAoL,QAAA,oBAAA,SAAA,cAAA,aAAA,WAAA,SAAAvF,EAAAqc,EAAAf,EAAA4M,GAwCA,QAAAC,GAAA9pB,GAGA,GAAA+pB,GAAA,EACAC,EAAA,CAmCA,OAhCA,UAAAhqB,KACAgqB,EAAA,GAAAhqB,EAAAiqB,QAEA,cAAAjqB,KACAgqB,EAAAhqB,EAAAkqB,YAEA,eAAAlqB,KACAgqB,EAAAhqB,EAAAmqB,aAEA,eAAAnqB,KACA+pB,EAAA,GAAA/pB,EAAAoqB,aAIA,QAAApqB,IAAAA,EAAAqqB,OAAArqB,EAAAsqB,kBACAP,EAAA,GAAAC,EACAA,EAAA,GAIA,UAAAhqB,KACAgqB,EAAA,GAAAhqB,EAAAgqB,QAEA,UAAAhqB,KACA+pB,EAAA/pB,EAAA+pB,QAIA/pB,EAAAuqB,YAAAR,EACA/pB,EAAAwqB,YAAAR,EAGAhqB,EA1EA,GAAAyqB,GAAA,SAAAzqB,GAGA,GAAA+e,IACA2L,OACA5lB,EAAA9G,KAAA2sB,MAAAC,UAAA9lB,EAAA9E,EAAA8E,EAAA9E,EAAA8E,EAAA9G,KAAA2sB,MAAAC,UAAA9lB,EACAC,EAAA/G,KAAA2sB,MAAAC,UAAA7lB,EAAA/E,EAAA+E,EAAA/E,EAAA+E,EAAA/G,KAAA2sB,MAAAC,UAAA7lB,GAEAiR,MACAlR,EAAA9G,KAAA2sB,MAAAC,UAAA9lB,EAAA9E,EAAA8E,EAAA9G,KAAA2sB,MAAAC,UAAA9lB,EAAA9E,EAAA8E,EACAC,EAAA/G,KAAA2sB,MAAAC,UAAA7lB,EAAA/E,EAAA+E,EAAA/G,KAAA2sB,MAAAC,UAAA7lB,EAAA/E,EAAA+E,GAmBA,OAdAga,GAAA2L,MAAA5lB,EAAA,IACAia,EAAA2L,MAAA5lB,EAAA,GAEAia,EAAA2L,MAAA3lB,EAAA,IACAga,EAAA2L,MAAA3lB,EAAA,GAEAga,EAAA/I,KAAAlR,EAAA9G,KAAAuC,MAAAxC,MAAA,IACAghB,EAAA/I,KAAAlR,EAAA9G,KAAAuC,MAAAxC,MAAA,GAEAghB,EAAA/I,KAAAjR,EAAA/G,KAAAuC,MAAArC,OAAA,IACA6gB,EAAA/I,KAAAjR,EAAA/G,KAAAuC,MAAArC,OAAA,GAIA6gB,EAmDAplB,GAAA+I,OAAAf,GAKAgpB,OAGAC,UAAA,KAGAC,MAAA,GACAC,MAAA,KAOA,IAAAnL,IAKA4J,QAAA,SAAAvpB,EAAA+qB,GAGA,GAAA/sB,KAAA0S,MAAA1S,KAAA0S,KAAAoC,WAKA,OAAAiY,EAAAC,SAGA,IAAAnB,GAAArtB,IAGAwB,KAAA2sB,MAAAC,UAAA,KACA5sB,KAAAojB,mBAAA,CACA,MAGA,KAAAyI,GAAAxtB,MAGA2B,KAAAigB,sBACA8M,EAAAE,iBAGAjtB,KAAA0f,OAAAM,EAAAhiB,MAAAgC,KAAA0S,KAAAI,OAAA9S,KAAAmhB,iBACAnhB,KAAAmZ,OAGA,MAGA,KAAA0S,GAAAztB,KAGA4B,KAAAigB,sBACA8M,EAAAE,iBAGAjtB,KAAA0f,OAAAM,EAAAhiB,MAAAgC,KAAA0S,KAAAI,OAAA9S,KAAAkhB,mBACAlhB,KAAAoZ,WAGA,MAGA,KAAAyS,GAAAvtB,GACA,KAGA,KAAAutB,GAAAttB,QAQAitB,WAAA,SAAAxpB,EAAA0e,GAGA,IAAA1gB,KAAAkgB,uBAAAlgB,KAAA0f,OAAAM,EAAAhiB,KACA,OAAA,CAIA,KAAAgC,KAAA0S,OAAA1S,KAAA0S,KAAAoC,WACA,OAAA,CAIA4L,GAAAoL,EAAApL,EAGA,IAAAwM,GAAAxM,EAAA8L,aAAA9L,EAAAsL,MAGA,GAAAkB,GACAltB,KAAAuC,OACAvC,KAAAuC,MAAA2C,UAAA,SAEAlF,KAAAmZ,QAIA+T,EAAA,IACAltB,KAAAuC,OACAvC,KAAAuC,MAAA2C,UAAA,SAEAlF,KAAAoZ,YAIA,IAAA8T,GACAxM,EAAAuM,kBAOAvB,SAAA,WACA1rB,KAAAuC,OACAvC,KAAAuC,MAAA2C,UAAA,UAOAumB,UAAA,SAAAzpB,EAAA0e,IAIA1gB,KAAA2sB,MAAAC,WACA5sB,KAAA2sB,MAAAC,UAAA9lB,IAAA9E,EAAA8E,GAAA9G,KAAA2sB,MAAAC,UAAA7lB,IAAA/E,EAAA+E,IAEA2Z,EAAAK,KAAA0L,EAAA9pB,KAAA3C,KAAAgC,IAIAhC,KAAAuC,OAAAvC,KAAAuC,MAAAM,OAAAolB,QAKAjoB,KAAA2sB,MAAAE,QAAA7qB,EAAA8E,GAAA9G,KAAA2sB,MAAAG,QAAA9qB,EAAA+E,KAKA/G,KAAA2sB,MAAAE,MAAA7qB,EAAA8E,EACA9G,KAAA2sB,MAAAG,MAAA9qB,EAAA+E,EAGA/G,KAAAwhB,UAAA,QAAAd,KAMAiL,UAAA,SAAA3pB,GACAhC,KAAA2sB,MAAAC,WACA9lB,EAAA9E,EAAA8E,EACAC,EAAA/E,EAAA+E,IAOA6kB,QAAA,SAAA5pB,EAAA0e,IAEA1gB,KAAA2sB,MAAAC,WACA5sB,KAAA2sB,MAAAC,UAAA9lB,IAAA9E,EAAA8E,GAAA9G,KAAA2sB,MAAAC,UAAA7lB,IAAA/E,EAAA+E,IAEA2Z,EAAAK,KAAA0L,EAAA9pB,KAAA3C,KAAAgC,GACAhC,KAAAwhB,UAAA,YAAAd,IAEA1gB,KAAA2sB,MAAAC,UAAA,MChUA,OAAAjL,OAGAjmB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,iCACA,OACA,6BAMAC,SAAA,cACAiB,MAAA,QACAE,MAAA,QACAkwB,MAAA,UAMArxB,SAAA,eACAoB,SAAA,WACAC,OAAA,SACAC,OAAA,SACAC,KAAA,OACAC,OAAA,SACAG,IAAA,MACAC,MAAA,QACA0vB,KAAA,OACAC,OAAA,SACAF,MAAA,UAMA9B,KAAA,SAAA,cAAA,iBAAA,SAAA1nB,EAAAoc,EAAAuN,GAGA3pB,EAAArB,GAAA,aAAAgrB,EAAAC,WAAAxN,EAAAliB,MACA8F,EAAArB,GAAA,aAAAgrB,EAAAE,WAAAzN,EAAAliB,MACA8F,EAAArB,GAAA,YAAAgrB,EAAAG,UAAA1N,EAAAliB,MACA8F,EAAArB,GAAA,YAAAgrB,EAAAI,UAAA3N,EAAAliB,MACA8F,EAAArB,GAAA,UAAAgrB,EAAA/B,QAAAxL,EAAAliB,MACA8F,EAAArB,GAAA,QAAAgrB,EAAAK,MAAA5N,EAAAliB,MACA8F,EAAArB,GAAA,QAAAgrB,EAAArF,MAAAlI,EAAAliB,MAGA8F,EAAA+d,aAAA3B,EAAAliB,KAAAyvB,MAMAxpB,SAAA,iBAAA,WAKA,GAAAC,KAOA/D,MAAAwE,UAAA,SAAAC,GACAV,EAAApI,EAAA+I,OAAAX,EAAAU,IAMAzE,KAAA2E,MAAA,SAAA,cAAA,aAAA,cAAA,cAAA,aAAA,aAAA,SACAhB,EAAAqc,EAAA4N,EAAAC,EAAA9f,EAAAkR,EAAAnR,GAIA,GAAA+L,GAAA,IAAAC,WAAA,GACAgP,EAAA,IAAAhP,WAAA,GAKAgU,EAAA,SAAAhnB,EAAAC,EAAAgnB,GASA,IANA,mBAAAjnB,IAAA,mBAAAC,MACAD,EAAA9G,KAAA2sB,MAAAE,MACA9lB,EAAA/G,KAAA2sB,MAAAG,OAIA9sB,KAAAuC,OAAAvC,KAAAuC,MAAA0G,UAAAnC,EAAAC,GAKA,OAAA/G,KAAA0f,MAGA,IAAAM,GAAA9hB,MAGA8B,KAAAguB,YAAAJ,EAAAT,MAGAntB,KAAA0S,KAAAoG,SAAAhS,EAAAC,IACA/G,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAA+G,EAAA1Q,OASA2C,KAAA0S,KAAAoG,SAAAhS,EAAAC,EAAA/G,KAAAiuB,kBAQAF,GACA/tB,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAA+G,EAAA1Q,OAVA2C,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAAhH,KAAAiuB,kBAYA,MAGA,KAAAjO,GAAA7hB,OAGA6B,KAAAkuB,aAAAL,EAAAV,OAAAntB,KAAA0S,KAAAqG,UAAAjS,EAAAC,GACA/G,KAAA0S,KAAAqG,UAAAjS,EAAAC,IACA/G,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAA+G,EAAA1Q,OAMA2C,KAAAkuB,aAAAL,EAAAT,MAAAptB,KAAAkuB,aAAAL,EAAAR,OACArtB,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,OACA2I,KAAA5B,EAAAxQ,MACAqS,KAAA5P,KAAAmuB,eAOAnuB,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAAhH,KAAAkuB,YAGA,MAGA,KAAAlO,GAAAhiB,MAGAgC,KAAA0S,KAAAoG,SAAAhS,EAAAC,IAAA/G,KAAA0S,KAAAuF,YAAAnR,EAAAC,IACA/G,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAAhH,KAAA0S,KAAA2E,WAGA,MAGA,KAAA2I,GAAA/hB,MAGA+B,KAAA0S,KAAAoG,SAAAhS,EAAAC,IACA/G,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAA+G,EAAA1Q,SAUAqf,EAAA,SAAA5V,EAAAC,GAGA,GAAA/G,KAAA0S,KAAAqG,UAAAjS,EAAAC,GAAA,CAGA,GAAAS,GAAAxH,KAAA0S,KAAAuG,UAAAnS,EAAAC,EAGA,IAAAS,EAAAmI,OAAA5B,EAAAxQ,OAAAiK,EAAAoI,KAAA,CACA,GAAArO,GAAAvB,KAAAouB,aAAAlrB,QAAAsE,EAAAoI,KACA,MAAArO,GACAvB,KAAAouB,aAAAxV,OAAArX,EAAA,GAMA,WADAvB,MAAA0S,KAAAmG,aAAA/R,EAAAC,GAKA/G,KAAAkuB,aAAAL,EAAAV,QAKAntB,KAAAkuB,aAAAL,EAAAT,MACAptB,KAAA0S,KAAA+F,UAAA3R,EAAAC,GACA4I,KAAA5B,EAAAxQ,MACAqS,KAAA5P,KAAAmuB,cAIAnuB,KAAAouB,aAAAlkB,KAAAlK,KAAAmuB,aACAnuB,KAAAquB,wBAIAruB,KAAAkuB,aAAAL,EAAAR,QACArtB,KAAA0S,KAAA+F,UAAA3R,EAAAC,GACA4I,KAAA5B,EAAAxQ,MACAqS,KAAA5P,KAAAmuB,cAIAnuB,KAAAouB,aAAAlkB,KAAAlK,KAAAmuB,aACAnuB,KAAAquB,wBAKAruB,KAAA0S,KAAA+F,UAAA3R,EAAAC,EAAA/G,KAAAkuB,cAOAzR,EAAA,SAAA3V,EAAAC,EAAAgnB,GAGA,GAAA1f,GAAArO,KAAAiuB,gBAGA,IAAA5f,IAAAP,EAAAjR,MACAmD,KAAA0S,KAAAgG,YAAA5R,EAAAC,OAIA,CAGA,IAAAgnB,GAAA/tB,KAAA0S,KAAAoG,SAAAhS,EAAAC,EAAAsH,GAEA,WADArO,MAAA0S,KAAAgG,YAAA5R,EAAAC,EAKA/G,MAAA0S,KAAAoG,SAAAhS,EAAAC,IACA/G,KAAA0S,KAAAgG,YAAA5R,EAAAC,GAIA/G,KAAA0S,KAAA4F,SAAAxR,EAAAC,EAAAsH,GAIArO,KAAAuC,MAAAM,OAAA2E,OAAAiE,WAAA3E,EAAAC,IAMAunB,EAAA,WAMA,GAHAtuB,KAAAouB,gBAGApuB,KAAA0S,MAAA1S,KAAA0S,KAAAoC,WAMA,IAAA,GADAtN,GAAAxH,KAAA0S,KAAArL,SAAAG,OAAAwC,IAAA,QACAzI,EAAA,EAAAA,EAAAiG,EAAAtF,OAAAX,IACAiG,EAAAjG,GAAAoO,OAAA5B,EAAAxQ,OAAA,KAAAiK,EAAAjG,GAAAqO,MACA5P,KAAAouB,aAAAlkB,KAAA1C,EAAAjG,GAAAqO,MAQAjU,GAAA+I,OAAAf,GAGAqqB,UAAAJ,EAAA7wB,MACAmxB,WAAAL,EAAA3wB,SAGAkxB,gBACAD,YAAA,GAKAI,gBAAA,SAAA7O,GACA1f,KAAAguB,UAAAtO,GAMA8O,iBAAA,SAAA9O,GACA1f,KAAAkuB,WAAAxO,GACA1f,KAAAkuB,aAAAL,EAAAT,MAAAptB,KAAAkuB,aAAAL,EAAAR,SACArtB,KAAAquB,wBAOAJ,eAAA,WACA,OAAAjuB,KAAAguB,WACA,IAAAJ,GAAA7wB,MACA,MAAA+Q,GAAAhR,CACA,KAAA8wB,GAAA3wB,MACA,MAAA6Q,GAAA9Q,CACA,SACA,MAAA8Q,GAAAjR,QAOA4xB,eAAA,SAAAjf,GACAA,IACAxP,KAAAmuB,YAAA3e,IAOA6e,qBAAA,WAMA,OAHAruB,KAAAmuB,YAAA,GAGAnuB,KAAAkuB,YAGA,IAAAL,GAAAT,KAIA,IAHA,GAAA7rB,GAAA,GAGAvB,KAAAmuB,aAAA,KAAAnuB,KAAAouB,aAAAlrB,QAAAlD,KAAAmuB,cAGA,GAAA5sB,EACAvB,KAAAmuB,YAAAte,OAAAC,aAAA+J,EAAAtY,GAIA,GAAAA,EACAvB,KAAAmuB,YAAAte,OAAAC,aAAAgZ,EAAAvnB,EAAA,IAKAvB,KAAAmuB,YAAAte,OAAAC,aAAA+J,EAAAjZ,KAAAE,MAAAS,EAAA,IAAA,GACAsO,OAAAC,aAAA+J,EAAAtY,EAAA,IAIAA,GAEA,MAGA,KAAAssB,GAAAR,OAIA,IAHArtB,KAAAmuB,YAAA,EAGA,IAAAnuB,KAAAmuB,aAAA,KAAAnuB,KAAAouB,aAAAlrB,QAAAlD,KAAAmuB,cACAnuB,KAAAmuB,iBAUA,IAAAb,IAKArF,MAAA,SAAAjmB,GAGA,GAAAhC,KAAAuC,MAAA,CAQA,GAHAvC,KAAAuC,MAAA2C,UAAA,UAGAlD,EAAA+e,MAAA/gB,KAAA0f,OAAAM,EAAA9hB,OAAA8B,KAAA0f,OAAAM,EAAA7hB,OAEA,WADA2vB,GAAAnrB,KAAA3C,KAKA,IAAAA,KAAAkuB,aAAAL,EAAAT,MAAAptB,KAAAkuB,aAAAL,EAAAR,OAEA,WADAS,GAAAnrB,KAAA3C,KAKA,KAAA,GAAA8G,GAAA9E,EAAA+e,KAAA2L,MAAA5lB,EAAAA,GAAA9E,EAAA+e,KAAA/I,KAAAlR,EAAAA,IACA,IAAA,GAAAC,GAAA/E,EAAA+e,KAAA2L,MAAA3lB,EAAAA,GAAA/E,EAAA+e,KAAA/I,KAAAjR,EAAAA,IACA+mB,EAAAnrB,KAAA3C,KAAA8G,EAAAC,GAAA,KAQAwkB,QAAA,SAAAvpB,EAAA+qB,GAGAA,EAAAC,SASAW,MAAA,SAAA3rB,GAGA,GAAAhC,KAAAuC,OAAAvC,KAAAuC,MAAA0G,UAAAjH,EAAA8E,EAAA9E,EAAA+E,GAAA,CASA,OAHA/G,KAAAuC,MAAA2C,UAAA,SAGAlF,KAAA0f,MAGA,IAAAM,GAAAhiB,KAGA,IAAAgC,KAAA0S,KAAAwG,KAAAlX,EAAA8E,EAAA9E,EAAA+E,GACA,MAEA/G,MAAAqiB,iBACA,MAGA,KAAArC,GAAA9hB,MAGAue,EAAA9Z,KAAA3C,KAAAgC,EAAA8E,EAAA9E,EAAA+E,GACA/G,KAAAqiB,iBACA,MAGA,KAAArC,GAAA7hB,OAGAue,EAAA/Z,KAAA3C,KAAAgC,EAAA8E,EAAA9E,EAAA+E,GACA/G,KAAAqiB,iBACA,MAGA,KAAArC,GAAA/hB,MAGAghB,EAAA7P,KAAApN,EAAA8E,EAAA9E,EAAA+E,GACA/G,KAAA8iB,YAKAwK,EAAArF,MAAAtlB,KAAA3C,KAAAgC,KAMA0rB,UAAA,SAAA1rB,GAGA,GAAA8E,GAAAC,CASA,QALA/G,KAAAuC,OACAvC,KAAAuC,MAAA2C,UAAA,SAIAlF,KAAA0f,MAGA,IAAAM,GAAA9hB,MAGA,IAAA4I,EAAA9E,EAAA+e,KAAA2L,MAAA5lB,EAAAA,GAAA9E,EAAA+e,KAAA/I,KAAAlR,EAAAA,IACA,IAAAC,EAAA/E,EAAA+e,KAAA2L,MAAA3lB,EAAAA,GAAA/E,EAAA+e,KAAA/I,KAAAjR,EAAAA,IACA0V,EAAA9Z,KAAA3C,KAAA8G,EAAAC,GAAA,EAKA/G,MAAAqiB,iBACA,MAGA,KAAArC,GAAA7hB,OAGA,GAAA6B,KAAAkuB,aAAAL,EAAAT,MAAAptB,KAAAkuB,aAAAL,EAAAR,OACA,KAIA,KAAAvmB,EAAA9E,EAAA+e,KAAA2L,MAAA5lB,EAAAA,GAAA9E,EAAA+e,KAAA/I,KAAAlR,EAAAA,IACA,IAAAC,EAAA/E,EAAA+e,KAAA2L,MAAA3lB,EAAAA,GAAA/E,EAAA+e,KAAA/I,KAAAjR,EAAAA,IACA2V,EAAA/Z,KAAA3C,KAAA8G,EAAAC,EAKA/G,MAAAqiB,kBAKAiL,EAAArF,MAAAtlB,KAAA3C,KAAAgC,IAMAurB,WAAA,WACAe,EAAA3rB,KAAA3C,OAMAytB,UAAA,WAGAztB,KAAA4hB,UACA5B,EAAAhiB,KACAgiB,EAAA9hB,MACA8hB,EAAA7hB,OACA6hB,EAAA/hB,QAIA+B,KAAA0f,KAAA1f,KAAAihB,MAAA,GAGAqN,EAAA3rB,KAAA3C,OAMAwtB,WAAA,WAGAxtB,KAAA0f,OAAAM,EAAA/hB,OAGA+B,KAAA0uB,gBAAA1uB,KAAAuC,MAAAkF,WAGAwX,EAAAzK,KAAAxU,KAAA0S,MACA1S,KAAA8iB,aAKA9iB,KAAA0uB,kBACA1uB,KAAAuC,MAAAsF,aAAA7H,KAAA0uB,uBACA1uB,MAAA0uB,kBC7nBA,OAAApB,QAIA5xB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,mCACA,OACA,6BAMAwvB,KAAA,SAAA,cAAA,mBAAA,SAAA1nB,EAAAoc,EAAA4O,GAGAhrB,EAAArB,GAAA,gBAAAqsB,EAAAC,cAAA7O,EAAAniB,QACA+F,EAAArB,GAAA,cAAAqsB,EAAAE,YAAA9O,EAAAniB,QACA+F,EAAArB,GAAA,aAAAqsB,EAAApB,WAAAxN,EAAAniB,QACA+F,EAAArB,GAAA,aAAAqsB,EAAAnB,WAAAzN,EAAAniB,QACA+F,EAAArB,GAAA,YAAAqsB,EAAAlB,UAAA1N,EAAAniB,QACA+F,EAAArB,GAAA,WAAAqsB,EAAAG,SAAA/O,EAAAniB,QACA+F,EAAArB,GAAA,QAAAqsB,EAAAhB,MAAA5N,EAAAniB,QACA+F,EAAArB,GAAA,QAAAqsB,EAAA1G,MAAAlI,EAAAniB,QAGA+F,EAAA+d,aAAA3B,EAAAniB,OAAA+wB,MAMA7qB,SAAA,mBAAA,WAKA,GAAAC,IAGAgrB,cAAA,IAMA/uB,MAAAwE,UAAA,SAAAC,GACAV,EAAApI,EAAA+I,OAAAX,EAAAU,IAMAzE,KAAA2E,MAAA,YAAA,SAAA,cAAA,cAAA,cAAA,aAAA,SAAAqqB,EAAArrB,EAAAoc,EAAAC,EAAAjS,EAAAkR,GAKA,GAAA6O,GAAA,SAAAhnB,EAAAC,GASA,IANA,mBAAAD,IAAA,mBAAAC,MACAD,EAAA9G,KAAA2sB,MAAAE,MACA9lB,EAAA/G,KAAA2sB,MAAAG,OAIA9sB,KAAAuC,OAAAvC,KAAAuC,MAAA0G,UAAAnC,EAAAC,GAKA,OAAA/G,KAAA0f,MAGA,IAAAM,GAAAhiB,MAGAgC,KAAA0S,KAAAoG,SAAAhS,EAAAC,IAAA/G,KAAA0S,KAAAmF,gBAAA/Q,EAAAC,IACA/G,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAAhH,KAAA0S,KAAA2E,WAGA,MAGA,KAAA2I,GAAA/hB,MAGA+B,KAAA0S,KAAAoG,SAAAhS,EAAAC,IACA/G,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAA+G,EAAA1Q,SAUA4xB,EAAA,SAAAC,GACA,IAAA,GAAA3tB,GAAA,EAAAA,EAAA2tB,EAAAhtB,OAAAX,IAGAvB,KAAAuC,MAAA2E,IAAA,SAAAgoB,EAAA3tB,GAAAwS,KAAAjN,EAAAooB,EAAA3tB,GAAAwS,KAAAhN,IAKA/G,KAAAuC,MAAAsE,IAAA,SAAAqoB,EAAA3tB,GAAAwS,KAAAjN,EAAAooB,EAAA3tB,GAAAwS,KAAAhN,GACA4I,KAAA3P,KAAAuC,MAAA4C,MAAAU,IAAA,yBACA+J,KAAA5P,KAAAuC,MAAA4C,MAAAU,IAAA,wBAAAtE,GACA8M,MAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,6BAQAspB,EAAA,SAAAD,GACA,IAAA,GAAA3tB,GAAA,EAAAA,EAAA2tB,EAAAhtB,OAAAX,IACAvB,KAAAuC,MAAA0E,OAAA,SAAAioB,EAAA3tB,GAAAwS,KAAAjN,EAAAooB,EAAA3tB,GAAAwS,KAAAhN,IAOAqoB,EAAA,SAAA3oB,GAGA,GAAAzG,KAAAuC,OAAAvC,KAAA0S,MAAA1S,KAAA0S,KAAAoC,WAAA,CAKA,GACAoa,GADApc,EAAA9S,KAAA0S,KAAAuD,SAEAnD,KAKA9S,KAAAqgB,mBAAAvN,EAAAwI,sBACA4T,EAAApc,EAAA0I,oBACA/U,EACAwoB,EAAAtsB,KAAA3C,KAAAkvB,GAGAC,EAAAxsB,KAAA3C,KAAAkvB,IAKAlvB,KAAAsgB,mBAAAxN,EAAApR,QAAAoR,EAAApR,OAAA4Z,sBACA4T,EAAApc,EAAApR,OAAA8Z,oBACA/U,EACAwoB,EAAAtsB,KAAA3C,KAAAkvB,GAGAC,EAAAxsB,KAAA3C,KAAAkvB,MAQAvzB,GAAA+I,OAAAf,GAGA0rB,aAAA,EACAN,cAAA,IACAO,gBAAA,KAKAC,iBAAA,SAAAC,GACAxvB,KAAA+uB,gBAAAS,IACAxvB,KAAA+uB,cAAAS,EACAxvB,KAAAwhB,UAAA,gBAAA,mBAOAkL,MAAA,SAAA8C,GAGA,GAAAxvB,KAAAwf,OAAAO,EAAAniB,SAAAoC,KAAAqvB,aAKArvB,KAAA0S,MAAA1S,KAAA0S,KAAAI,KAAAuI,cAAA,CAKA,GAAAoC,GAAAzd,IAGAwvB,GAAA,gBAAAA,GAAAA,EAAAxvB,KAAA+uB,cAGA/uB,KAAA2f,WAAAK,EAAAjiB,MAGAiC,KAAAqvB,aAAA,EACArvB,KAAAsvB,gBAAAN,EAAA,WAGAvR,EAAAtE,KAAA,GAAA,GAGAsE,EAAA/K,KAAAI,KAAAuI,eACAoC,EAAAzF,QAEAwX,GAGAxvB,KAAAwhB,UAAA,kBAAAxhB,KAAA0S,KAAAI,QAMAkF,KAAA,WAGAhY,KAAAwf,OAAAO,EAAAniB,QAAAoC,KAAAqvB,cAKArvB,KAAAsvB,iBACAN,EAAAS,OAAAzvB,KAAAsvB,iBAIAtvB,KAAAsvB,gBAAA,KACAtvB,KAAAqvB,aAAA,EAGArvB,KAAAwhB,UAAA,kBAAAxhB,KAAA0S,KAAAI,SAOA,IAAA6b,IAKA3pB,YAAA,SAAAP,GAGAzE,KAAAyE,OAAA9I,EAAA+I,UAAA1E,KAAAyE,OAAAV,EAAAU,OAGAzE,KAAAuvB,iBAAAvvB,KAAAyE,OAAAsqB,gBAMAH,cAAA,SAAA5sB,EAAA0tB,GAGA,oBAAAA,GACAN,EAAAzsB,KAAA3C,KAAAA,KAAAogB,kBAOA6H,MAAA,WAGAjoB,KAAAuC,QACAvC,KAAAuC,MAAA2C,UAAA,SACA4oB,EAAAnrB,KAAA3C,QAOA6uB,YAAA,WAGA7uB,KAAAogB,iBACAgP,EAAAzsB,KAAA3C,MAAA,IAOA2tB,MAAA,SAAA3rB,GAGA,GAAAhC,KAAAuC,OAAAvC,KAAAuC,MAAA0G,UAAAjH,EAAA8E,EAAA9E,EAAA+E,GAAA,CAKA,OAAA/G,KAAA0f,MAGA,IAAAM,GAAAhiB,KAGAgC,KAAA0S,KAAAmF,gBAAA7V,EAAA8E,EAAA9E,EAAA+E,IACA/G,KAAAmZ,KAAAnZ,KAAA0S,KAAA8E,iBAAAxV,EAAA8E,EAAA9E,EAAA+E,GAEA,MAGA,KAAAiZ,GAAA/hB,MAGAghB,EAAA7P,KAAApN,EAAA8E,EAAA9E,EAAA+E,GACA/G,KAAA8iB,YAKA6L,EAAA1G,MAAAtlB,KAAA3C,KAAAgC,KAMAurB,WAAA,WAGAvtB,KAAAuC,QACAvC,KAAAuC,MAAA2C,UAAA,SACA4oB,EAAAnrB,KAAA3C,QAOAytB,UAAA,WAGAztB,KAAA4hB,UACA5B,EAAAhiB,KACAgiB,EAAA/hB,MACA+hB,EAAAjiB,OAIAiC,KAAA0f,KAAA1f,KAAAihB,MAAA,GAGAjhB,KAAAogB,iBACAgP,EAAAzsB,KAAA3C,MAAA,IAOA8uB,SAAA,WAGA9uB,KAAAqvB,aACArvB,KAAAgY,OAIAhY,KAAAogB,iBACAgP,EAAAzsB,KAAA3C,MAAA,IAOAwtB,WAAA,WAGAxtB,KAAA0f,OAAAM,EAAA/hB,OAGA+B,KAAA0uB,gBAAA1uB,KAAAuC,MAAAkF,WAGAwX,EAAAzK,KAAAxU,KAAA0S,MACA1S,KAAA8iB,aAKA9iB,KAAA0uB,kBACA1uB,KAAAuC,MAAAsF,aAAA7H,KAAA0uB,uBACA1uB,MAAA0uB,kBCpaA,OAAAC,QAIAjzB,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,kCACA,SAMAwvB,KAAA,SAAA,cAAA,kBAAA,SAAA1nB,EAAAoc,EAAA4P,GAGAhsB,EAAArB,GAAA,gBAAAqtB,EAAAf,cAAA7O,EAAAjiB,OACA6F,EAAArB,GAAA,cAAAqtB,EAAAd,YAAA9O,EAAAjiB,OACA6F,EAAArB,GAAA,aAAAqtB,EAAApC,WAAAxN,EAAAjiB,OACA6F,EAAArB,GAAA,YAAAqtB,EAAAlC,UAAA1N,EAAAjiB,OACA6F,EAAArB,GAAA,WAAAqtB,EAAAb,SAAA/O,EAAAjiB,OACA6F,EAAArB,GAAA,UAAAqtB,EAAApE,QAAAxL,EAAAjiB,OACA6F,EAAArB,GAAA,QAAAqtB,EAAAhC,MAAA5N,EAAAjiB,OACA6F,EAAArB,GAAA,QAAAqtB,EAAA1H,MAAAlI,EAAAjiB,OAGA6F,EAAA+d,aAAA3B,EAAAjiB,MAAA6xB,MAMA7rB,SAAA,mBAAA,aAAA,SAAAgK,GAKA,GAAA/J,IAGA6rB,YAAA9hB,EAAAhR,EAGA+yB,eAAA,EAGAC,eAAA,EACAC,mBAAA,IAMA/vB,MAAAwE,UAAA,SAAAC,GACAV,EAAApI,EAAA+I,OAAAX,EAAAU,IAMAzE,KAAA2E,MAAA,WAAA,SAAA,cAAA,cAAA,WAAA,SAAAqrB,EAAArsB,EAAAoc,EAAAC,EAAA6L,GAKA,GAAAoE,GAAA,WAKA,MAAAjwB,MAAA8vB,cAKA9vB,KAAAkwB,eACA,EAIAlwB,KAAAmwB,gBACA,EAIAnwB,KAAA0S,KAAA2E,YAAArX,KAAA4vB,aACA,GAIA,GAnBA,GAyBA9B,EAAA,SAAAhnB,EAAAC,GASA,IANA,mBAAAD,IAAA,mBAAAC,MACAD,EAAA9G,KAAA2sB,MAAAE,MACA9lB,EAAA/G,KAAA2sB,MAAAG,OAIA9sB,KAAAuC,OAAAvC,KAAAuC,MAAA0G,UAAAnC,EAAAC,GAKA,OAAA/G,KAAA0f,MAGA,IAAAM,GAAAhiB,KAGAiyB,EAAAttB,KAAA3C,OAAAA,KAAA0S,KAAAuF,YAAAnR,EAAAC,IACA/G,KAAAuC,MAAAsE,IAAA,QAAAC,EAAAC,GACA4I,KAAA,SACA3I,MAAAhH,KAAA0S,KAAA2E,cAUA+Y,EAAA,SAAAlB,GACA,IAAA,GAAA3tB,GAAA,EAAAA,EAAA2tB,EAAAhtB,OAAAX,IACA2tB,EAAA3tB,GAAAwO,YAAA,EACA/P,KAAAuC,MAAAsE,IAAA,SAAAqoB,EAAA3tB,GAAAwS,KAAAjN,EAAAooB,EAAA3tB,GAAAwS,KAAAhN,GACA4I,KAAA3P,KAAAuC,MAAA4C,MAAAU,IAAA,8BACA+J,KAAA5P,KAAAuC,MAAA4C,MAAAU,IAAA,6BAAAtE,GACA1B,MAAAG,KAAAuC,MAAA4C,MAAAU,IAAA,+BACAwI,MAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,iCAIA7F,KAAAuC,MAAAsE,IAAA,SAAAqoB,EAAA3tB,GAAAwS,KAAAjN,EAAAooB,EAAA3tB,GAAAwS,KAAAhN,GACA4I,KAAA3P,KAAAuC,MAAA4C,MAAAU,IAAA,gCACA+J,KAAA5P,KAAAuC,MAAA4C,MAAAU,IAAA,+BAAAtE,GACA1B,MAAAG,KAAAuC,MAAA4C,MAAAU,IAAA,iCACAwI,MAAArO,KAAAuC,MAAA4C,MAAAU,IAAA,oCASAwqB,EAAA,SAAAnB,GACA,IAAA,GAAA3tB,GAAA,EAAAA,EAAA2tB,EAAAhtB,OAAAX,IACAvB,KAAAuC,MAAA0E,OAAA,SAAAioB,EAAA3tB,GAAAwS,KAAAjN,EAAAooB,EAAA3tB,GAAAwS,KAAAhN,IAOAupB,EAAA,SAAA7pB,GAGA,GAAAzG,KAAAuC,OAAAvC,KAAA0S,MAAA1S,KAAA0S,KAAAoC,WAAA,CAKA,GAAAhC,GAAA9S,KAAA0S,KAAAuD,UACAiZ,EAAApc,EAAA0I,mBAGA,OAAA/U,KAAAzG,KAAAkwB,eAAAlwB,KAAA8vB,eACA9vB,KAAA0S,KAAA2E,YAAArX,KAAA4vB,gBACAS,GAAA1tB,KAAA3C,KAAAkvB,QAMAzoB,EACA2pB,EAAAztB,KAAA3C,KAAAkvB,GAGAmB,EAAA1tB,KAAA3C,KAAAkvB,KAOAvzB,GAAA+I,OAAAf,GAGAusB,eAAA,EACAC,gBAAA,EAGAI,iBAAA,KAGAX,YAAA,EAGAC,eAAA,EAGAC,eAAA,EACAC,mBAAA,IAGAS,wBAAA,EAKAC,iBAAA,SAAAC,GACA1wB,KAAA8vB,gBAAAY,IACA1wB,KAAA8vB,cAAAY,EACA1wB,KAAAwhB,UAAA,gBAAA,mBAOAmP,sBAAA,SAAAnB,GACAxvB,KAAA+vB,qBAAAP,IACAxvB,KAAA+vB,mBAAAP,EACAxvB,KAAAwhB,UAAA,gBAAA,wBAOAoP,eAAA,SAAAviB,GACArO,KAAA4vB,cAAAvhB,IACArO,KAAA4vB,YAAAvhB,EACArO,KAAAwhB,UAAA,gBAAA,iBAOAqP,eAAA,SAAAC,GACA,MAAAA,IAAA9wB,KAAAuC,MACAvC,KAAAuC,MAAAgC,gBAAAvE,KAAA4vB,YAEA5vB,KAAA4vB,aAMA/P,oBAAA,SAAAgQ;AAGA,mBAAAA,KACAA,GAAA7vB,KAAA6vB,eAIAA,IAAA7vB,KAAA6vB,gBACA7vB,KAAA6vB,cAAAA,EACA7vB,KAAAwhB,UAAA,gBAAA,mBAOAuP,aAAA,SAAAC,GAGA,GAAAhxB,KAAA0S,MAAA1S,KAAA0S,KAAAoC,YAAA,IAAA9U,KAAA0S,KAAAI,KAAAC,SAAA7Q,OAAA,CAKA,GAEAX,GAFAwR,KACA0K,EAAAzd,IAIA,KAAAuB,EAAA,EAAAA,EAAAvB,KAAA0S,KAAAI,KAAAC,SAAA7Q,OAAAX,IACAvB,KAAA0S,KAAAI,KAAAC,SAAAxR,GAAAwO,UACAgD,EAAA7I,KAAAlK,KAAA0S,KAAAI,KAAAC,SAAAxR,GAaA,IARA,IAAAwR,EAAA7Q,SACA6Q,EAAA/S,KAAA0S,KAAAI,KAAAC,UAIAxR,EAAAX,KAAAE,MAAAF,KAAAoqB,SAAAjY,EAAA7Q,QAGA8uB,IAAAhxB,KAAA+vB,mBAEA,WADA/vB,MAAAmZ,KAAApG,EAAAxR,GAKAvB,MAAAwwB,wBAAA,EACAR,EAAA,WAGAvS,EAAAtE,KAAApG,EAAAxR,IACAkc,EAAA+S,wBAAA,GAEAxwB,KAAA+vB,sBAMAkB,MAAA,WAGA,MAAAjxB,MAAA0S,MAAA1S,KAAA0S,KAAAoC,YAKA9U,KAAAkwB,eAAA,EACAlwB,KAAAmwB,gBAAA,EAGAnwB,KAAAuwB,iBAAAvwB,KAAA0S,KAAAiE,SAAA,GAGA3W,KAAAwiB,oBAGAxiB,KAAA8vB,eAAA9vB,KAAA0S,KAAA2E,YAAArX,KAAA4vB,aACA5vB,KAAA+wB,kBAfA,GAsBAG,eAAA,WAGAlxB,KAAAwf,OAAAO,EAAAjiB,OAAAkC,KAAA0S,MAAA1S,KAAA0S,KAAAoC,aAKA9U,KAAAkwB,eAAA,EACAlwB,KAAAmwB,gBAAA,EAGAnwB,KAAAuwB,kBACAvwB,KAAAA,QAAAA,KAAAuwB,kBAIAvwB,KAAA8vB,eAAA9vB,KAAA0S,KAAA2E,YAAArX,KAAA4vB,aACA5vB,KAAA+wB,kBAQA,IAAApB,IAKA3qB,YAAA,SAAAP,GAGAzE,KAAAyE,OAAA9I,EAAA+I,UAAA1E,KAAAyE,OAAAV,EAAAU,OAGAzE,KAAA6f,oBAAA7f,KAAAyE,OAAAorB,eACA7vB,KAAA4wB,eAAA5wB,KAAAyE,OAAAmrB,aACA5vB,KAAAywB,iBAAAzwB,KAAAyE,OAAAqrB,eACA9vB,KAAA2wB,sBAAA3wB,KAAAyE,OAAAsrB,qBAMAnB,cAAA,SAAA5sB,EAAA0tB,GAGA,kBAAAA,GACAY,EAAA3tB,KAAA3C,KAAAA,KAAA6vB,eAIA,gBAAAH,IAGAY,EAAA3tB,KAAA3C,KAAAA,KAAA6vB,gBAIA7vB,KAAAkwB,eAAAlwB,KAAA8vB,eAAA9vB,KAAA0S,KAAA2E,YAAArX,KAAA4vB,aAEA5vB,KAAA+wB,cAAA,KAQA9I,MAAA,SAAAjmB,GAGAhC,KAAAuC,QACAvC,KAAAuC,MAAA2C,UAAA,SACA4oB,EAAAnrB,KAAA3C,KAAAgC,EAAA8E,EAAA9E,EAAA+E,KAOA8nB,YAAA,WAGA7uB,KAAA6vB,eACAS,EAAA3tB,KAAA3C,MAAA,IAOAurB,QAAA,SAAAvpB,EAAA+qB,GAGA,OAAAA,EAAAC,SAGA,IAAAnB,GAAAxtB,MAGA2B,KAAAigB,sBACA8M,EAAAE,iBAGAjtB,KAAAwwB,wBAAAxwB,KAAA0S,KAAAI,OAAA9S,KAAAmhB,iBAGAnhB,KAAAkwB,eACAlwB,KAAAmZ,OAIA,MAGA,KAAA0S,GAAAztB,KAGA4B,KAAAigB,sBACA8M,EAAAE,iBAGAjtB,KAAAwwB,wBAAAxwB,KAAA0S,KAAAI,OAAA9S,KAAAkhB,oBAGAlhB,KAAAoZ,YAKApZ,KAAAkwB,eAAAlwB,KAAA8vB,eACA9vB,KAAA0S,KAAA2E,aAAArX,KAAA4vB,aAEA5vB,KAAAoZ,eAWAuU,MAAA,SAAA3rB,GAGA,GAAAhC,KAAAuC,OAAAvC,KAAAuC,MAAA0G,UAAAjH,EAAA8E,EAAA9E,EAAA+E,GAKA,GAAA/G,KAAA0S,KAAAmF,gBAAA7V,EAAA8E,EAAA9E,EAAA+E,GAAA,CAGA,GAAAxF,GAAAvB,KAAA0S,KAAA8E,iBAAAxV,EAAA8E,EAAA9E,EAAA+E,EAGA/G,MAAAmZ,KAAA5X,EACA,IAAAuR,GAAA9S,KAAA0S,KAAAuD,SAGA,KAAAnD,EAAAC,SAAA7Q,OACA4Q,EAAA/C,YAAA,GACA/P,KAAAkwB,eAAA,EACAlwB,KAAAwhB,UAAA,gBAAA1O,IAGA9S,KAAAwhB,UAAA,gBAAA1O,IAKA9S,KAAAkwB,eAAAlwB,KAAA8vB,eACA9vB,KAAA+wB,mBAKA/wB,MAAA0S,KAAAwG,KAAAlX,EAAA8E,EAAA9E,EAAA+E,KACA/G,KAAAmwB,gBAAA,EACAnwB,KAAAqiB,kBACAriB,KAAAwhB,UAAA,kBAAAxhB,KAAA0S,KAAAuD,aAOAsX,WAAA,WAGAvtB,KAAAuC,QACAvC,KAAAuC,MAAA2C,UAAA,SACA4oB,EAAAnrB,KAAA3C,QAOAytB,UAAA,WAGAztB,KAAA4hB,UACA5B,EAAAhiB,OAIAgC,KAAA0f,KAAA1f,KAAAihB,MAAA,GAGAjhB,KAAA6vB,eACAS,EAAA3tB,KAAA3C,MAAA,IAOA8uB,SAAA,WAGA9uB,KAAA6vB,eACAS,EAAA3tB,KAAA3C,MAAA,ICzkBA,OAAA2vB,SAIAj0B,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YAUAD,GAAAE,OAAA,qCACA,OACA,4BAMAqN,QAAA,WAAA,OAAA,YAAA,SAAAgI,EAAAqB,GAKA,GAAA4e,GAAA,gDACAC,EAAA,0DACAC,EAAA,wBACAC,EAAA,6CACAC,EAAA,gDACAC,EAAA,yDAKAC,EAAA,SAAAhd,EAAAid,GAGA,mBAAAjd,GAAA/B,KAAAkR,UACAnP,EAAA/B,KAAAkR,WAcA,KAAA,GAVAvV,GAAA,UAAAqjB,EAAA,GAAAhsB,cAAA,QAAA,QAGAisB,GACAtjB,MAAAA,EACAtS,KAAA21B,EAAA,GACAE,KAAAF,EAAA,GAAAzuB,eAIAgS,EAAA,EAAAA,EAAAR,EAAA/B,KAAAkR,QAAA1hB,OAAA+S,IACA,GAAAR,EAAA/B,KAAAkR,QAAA3O,GAAA5G,QAAAA,EAEA,YADAoG,EAAA/B,KAAAkR,QAAA3O,GAAA0c,EAMAld,GAAA/B,KAAAkR,QAAA1Z,KAAAynB,IAMAE,EAAA,SAAApd,EAAAid,GACAjd,EAAA/B,KAAAC,KAAAsE,WAAAya,EAAA,GAAA,KAMAI,EAAA,SAAArd,EAAAid,GAGA,mBAAAjd,GAAA/B,KAAAqf,QACAtd,EAAA/B,KAAAqf,UAIAtd,EAAA/B,KAAAqf,MAAA7nB,KAAAwnB,EAAA,GAAA,IAAAA,EAAA,GAAA,IAAAA,EAAA,KAMAM,EAAA,SAAAvd,EAAAid,GAGA,GAAAO,GAAA,UAAAP,EAAA,GAAAzuB,cAAA,IAAA,GACAgvB,IAAA,IAIAA,GADAP,EAAA,GAAAA,MAAA,QACA,IAEAA,EAAA,GAAAA,MAAA,SACA,IAGAA,EAAA,GAIAjd,EAAA/B,KAAAuf,OAAAA,GAMAC,EAAA,SAAAzd,EAAA3B,EAAA4e,GAGA,GAAArjB,GAAAqjB,EAAA,EACA,IAAA,IAAArjB,EACAA,EAAA,QAEA,CAAA,GAAA,IAAAA,EAIA,MAHAA,GAAA,IAOAyE,EAAAiB,QASAjB,EAAAiB,KAAA1F,IAAA,EAAAqjB,EAAA,GAAA,EAAAA,EAAA,KAOAS,GAKApL,MAAA,SAAAzR,EAAAwR,GAGA,GAGA4K,GAHAjd,EAAAlC,EAAAkC,MAIAuH,EAAAvH,EAAAkB,KAKA7C,GAAAO,MAAA,EAIA,KAHA2I,EAAA9R,KAAA4I,GAGA4e,EAAAN,EAAAgB,KAAA9c,IACAmc,EAAAhd,EAAAid,EAmBA,MAfAA,EAAAL,EAAAe,KAAA9c,KACAuc,EAAApd,EAAAid,IAIAA,EAAAJ,EAAAc,KAAA9c,KACAwc,EAAArd,EAAAid,KAIAA,EAAAH,EAAAa,KAAA9c,MAAAoc,EAAAF,EAAAY,KAAA9c,MACA0c,EAAAvd,EAAAid,GAIAA,EAAAP,EAAAiB,KAAA9c,IAGAxC,KAGAof,EAAAzd,EAAA3B,EAAA4e,GAGA1V,EAAA9R,KAAA4I,EAIA,OAAAgU,GACAnrB,EAAAqa,OAAAvB,GAIAA,GC7MA,OAAA0d,OAGAz2B,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,qCACA,OACA,4BAMAqN,QAAA,WAAA,OAAA,aAAA,WAAA,YAAA,SAAAgI,EAAAmhB,EAAAC,EAAA/f,GAKA,GAAAggB,KACA,KAAA,GAAAC,KAAAH,GACAA,EAAA/rB,eAAAksB,KACAD,EAAAF,EAAAG,IAAAA,EAOA,IAAA3Y,GAAA,IAAAC,WAAA,GAKAC,EAAA,SAAAC,GACA,MAAAnK,QAAAC,aAAA+J,EAAAG,EAAA,IAAAnK,OAAAC,aAAA+J,EAAAG,EAAA,KAUAyY,EAAA,SAAA7iB,GACA,MAAA,gBAAAA,GACAA,EAAA8iB,QAAA,MAAA,QAAAA,QAAA,KAAA,OAEA9iB,GAMA+iB,EAAA,SAAA9hB,EAAA+hB,EAAAC,EAAAC,GACA,GAAAF,EAAA1wB,OAAA,CACA2wB,EAAArd,KAAA3E,CACA,KAAA,GAAAtP,GAAA,EAAAA,EAAAqxB,EAAA1wB,OAAAX,IACAsxB,EAAArd,KAAA,KAAAsd,EAAAL,EAAAG,EAAArxB,IAAAqxB,EAAArxB,IAAA,MAQA2wB,EAAA,SAAAne,EAAA8e,GAGA,GAAAxkB,GAAA0F,EAAAjX,EAAA,IAAAiX,EAAA/W,EAAA,IAAA,EACA,IAAA,KAAAqR,EAAA,CAKA,GAAA2L,GAAA,SAAAjG,EAAA1F,GAAA,GAAA0F,EAAA1F,EAGAwkB,GAAArd,KAAAnH,EAAA,IAAA0L,EAAAC,GAAA,MAMA+Y,EAAA,SAAA5e,EAAA0e,GAGA,IAAA,GAAAxkB,KAAA8F,GACA,GAAAA,EAAA7N,eAAA+H,GAAA,CAGA,IAAA,GAAA9M,GAAA,EAAAA,EAAA4S,EAAA9F,GAAAnM,OAAAX,IACA4S,EAAA9F,GAAA9M,GAAAwY,EAAA5F,EAAA9F,GAAA9M,GAIAoxB,GAAA,IAAAtkB,EAAA8F,EAAA9F,GAAAwkB,KAQAG,EAAA,SAAA9T,EAAA2T,GAGA,IAAA,GAAAxkB,KAAA6Q,GACA,GAAAA,EAAA5Y,eAAA+H,GAAA,CAGA,IAAA,GAAA9M,GAAA,EAAAA,EAAA2d,EAAA7Q,GAAAnM,OAAAX,IACA2d,EAAA7Q,GAAA9M,GAAAwY,EAAAmF,EAAA7Q,GAAA9M,GAIAoxB,GAAA,IAAAtkB,EAAA6Q,EAAA7Q,GAAAwkB,KAQAI,EAAA,SAAAzrB,EAAAqrB,GAGA,IAAA,GAAAljB,KAAAnI,GACA,GAAAA,EAAAlB,eAAAqJ,GAAA,CACA,GAAApO,EAGA,IAAA,UAAAoO,EACA,IAAApO,EAAA,EAAAA,EAAAiG,EAAAmI,GAAAzN,OAAAX,IACAiG,EAAAmI,GAAApO,GAAAwY,EAAAvS,EAAAmI,GAAApO,IAAA,IAAAiG,EAAAmI,GAAApO,GAAA,OAIA,KAAAA,EAAA,EAAAA,EAAAiG,EAAAmI,GAAAzN,OAAAX,IACAiG,EAAAmI,GAAApO,GAAAwY,EAAAvS,EAAAmI,GAAApO,GAKA,oBAAAgxB,GAAA5iB,KACAA,EAAA4iB,EAAA5iB,IAIAgjB,EAAAhjB,EAAAnI,EAAAmI,GAAAkjB,KAQAK,EAAA,SAAAhf,EAAA2e,GACAA,EAAArd,KAAA,MAAAtB,EAAA,KAMAif,EAAA,SAAA1X,EAAAoX,GAOA,IAAA,GAJAjb,GAAA,mBAAA2a,GAAA9W,SAAA8W,EAAA9W,SAAA,IAGA2X,KACAlmB,EAAA,EAAAA,EAAAuO,EAAAvZ,OAAAgL,IACA,gBAAAuO,GAAAvO,GACAkmB,EAAAlpB,KAAAuR,EAAAvO,IAEAuO,EAAAvO,GAAAmmB,SACAD,EAAAlpB,KAAAuR,EAAAvO,GAAAmmB,QAKAV,GAAA/a,EAAAwb,EAAAP,GAAA,IAMAS,EAAA,SAAAxc,EAAA+b,GACA,GAAAjb,GAAA,mBAAA2a,GAAAx2B,KAAAw2B,EAAAx2B,KAAA,GACA82B,GAAArd,KAAAoC,EAAA,IAAA6a,EAAA3b,GAAA,KAMAyc,EAAA,SAAA7gB,GAGA,IAAA,GAAAnR,KAAA+wB,GACA,GAAAA,EAAAhsB,eAAA/E,IAAA+wB,EAAA/wB,KAAAmR,EACA,MAAAnR,EAKA,OAAA,IAMAiyB,EAAA,SAAA9P,GACA,GAAA+P,GAAA/P,EAAAvgB,MAAA,KACA,OAAAswB,GAAAvxB,OAAA,EACAuxB,EAAA,GAAA,IAAAA,EAAA,GAEA/P,GAMA+N,EAAA,SAAAE,EAAA+B,GAGA,GAAAC,GAAA,CACAhC,GAAAvR,kBACAuT,GAAA,GAEAhC,EAAArR,oBACAqT,GAAA,GAIAD,EAAAE,GAAAD,GAMAE,EAAA,SAAAtxB,EAAAmxB,GAGAnxB,EAAAxC,OAAAwC,EAAArC,OAGAqC,EAAAxC,QAAAwC,EAAArC,OACAwzB,EAAAxP,GAAA3hB,EAAAxC,MAMA2zB,EAAAxP,GAAA3hB,EAAAxC,MAAA,IAAAwC,EAAArC,OAKAqC,EAAAxC,MACA2zB,EAAAxP,GAAA3hB,EAAAxC,MAEAwC,EAAArC,OACAwzB,EAAAxP,GAAA3hB,EAAArC,OAKAwzB,EAAAxP,GAAA,IAOA4P,EAAA,SAAAlQ,EAAA8P,GAGA,IAAA,GAAAze,GAAA,EAAAA,EAAA2O,EAAA1hB,OAAA+S,IAGA,GAAA2O,EAAA3O,GAAA5G,QAAA,UAAAuV,EAAA3O,GAAA5G,OAAA,UAAAuV,EAAA3O,GAAA5G,OAAA,CAKA,GAAAA,GAAA,UAAAuV,EAAA3O,GAAA5G,MAAA,IAAA,GAGAuV,GAAA3O,GAAAlZ,OACA23B,EAAA,IAAArlB,GAAAuV,EAAA3O,GAAAlZ,MAIA6nB,EAAA3O,GAAA2c,OACA8B,EAAArlB,EAAA,KAAAuV,EAAA3O,GAAA2c,MAIAhO,EAAA3O,GAAA8e,OACAL,EAAArlB,EAAA,KAAAuV,EAAA3O,GAAA8e,QAQAC,GAGAjgB,KAAAme,EACA/d,MAAA4e,EACA7T,MAAA8T,EACAxrB,OAAAyrB,EACA/e,KAAAgf,EACAzX,SAAA0X,EACAp3B,KAAAu3B,EAGAW,qBAAAT,EACA7B,OAAAF,EACAlvB,MAAAsxB,EACAK,YAAAX,EACAY,eAAAL,GAUAM,EAAA,SAAAze,EAAAkd,GAGA,IAAA,GAAAtxB,GAAA,EAAAA,EAAAoU,EAAAzT,OAAAX,IAAA,CACA,GAAAuR,GAAA6C,EAAApU,EAGA,IAAA5F,EAAAwK,QAAA2M,GACA,IAAA,GAAA3H,GAAA,EAAAA,EAAA2H,EAAA5Q,OAAAiJ,IACA0nB,EAAArd,KAAA,OACA4e,EAAAthB,EAAA3H,GAAA0nB,GACAA,EAAArd,KAAA,UAJA,CAYA,IAAA,GAAAoC,KAAA9E,GACA,GAAAA,EAAAxM,eAAAsR,GAAA,CAGA,GAAA,mBAAAoc,GAAApc,GAAA,CACAoc,EAAApc,GAAA9E,EAAA8E,GAAAib,EACA,UAIA,GAAA,gBAAA/f,GAAA8E,GACA,QAIAib,GAAArd,KAAAoC,EAAA,IAAA6a,EAAA3f,EAAA8E,IAAA,IAKArW,EAAA,EAAAoU,EAAAzT,SACA2wB,EAAArd,KAAA,UAQA6e,EAAA,SAAA5f,EAAAif,EAAA9b,GAGA,mBAAAA,KACAA,EAAA,GAIA,KAAA,GAAA0c,KAAA7f,GACA,GAAAA,EAAAnO,eAAAguB,GAAA,CAGA,GAAA,QAAAA,EACA,QAIA,IAAAC,GAAA,KAAA3c,EAAA0c,EAAA1c,EAAA,IAAA0c,CAGA,IAAA,gBAAA7f,GAAA6f,GAAA,CAGA,mBAAAN,GAAAO,GACAP,EAAAO,GAAA9f,EAAA6f,GAAAZ,GAKAW,EAAA5f,EAAA6f,GAAAZ,EAAAa,EAEA,UAIA,GAAAvtB,EACA,oBAAAurB,GAAAgC,KAIAvtB,EADA,mBAAAgtB,GAAAO,GACAP,EAAAO,GAAA9f,EAAA6f,IAGA7B,EAAAhe,EAAA6f,IAIAZ,EAAAnB,EAAAgC,IAAAvtB,KASAmrB,GAKApL,MAAA,SAAAtS,GAQA,GALA,gBAAAA,KACAA,EAAA9Y,EAAA+Z,SAAAjB,KAIAA,EAAAkB,KAEA,WADAjL,SAAAzO,MAAA,8BAKA,IAAA42B,IAAArd,IAAA,QACAnC,EAAA1X,EAAA4O,KAAAkK,GACAif,EAAAnhB,EAAAiD,KAKAf,GAAAkB,MAAAlB,EAAAkB,KAAAzT,OAAA,GAAAuS,EAAAkB,KAAA,GAAAtC,OACAA,EAAA1X,EAAA+I,OAAA2O,EAAAoB,EAAAkB,KAAA,UACAtC,GAAAA,WACAoB,GAAAkB,KAAA,UAIAtC,GAAAsC,KACA0e,EAAAhhB,EAAAqgB,EAGA,KAAA,GAAA9b,KAAA8b,GACAA,EAAA9b,KACAib,EAAArd,KAAAoC,EAAA,IAAA6a,EAAAiB,EAAA9b,IAAA,IASA,OAJAwc,GAAA3f,EAAAkB,KAAAkd,GAGAA,EAAArd,KAAA,IACAqd,EAAArd,KC9eA,OAAA2c,OAGAz2B,OAAAA,OAAAC,SAEA,SAAAD,EAAAC,EAAAC,GAAA,YASAD,GAAAE,OAAA,qCACA,OACA,4BAMAqN,QAAA,WAAA,OAAA,aAAA,WAAA,YAAA,SAAAgI,EAAAmhB,EAAAC,EAAA/f,GAKA,GAAAiiB,GAAA,2DACAC,EAAA,4CACAC,EAAA,SACAC,EAAA,gCAKA9a,EAAA,IAAAC,WAAA,GAKAC,EAAA,SAAAC,GACA,OAAAA,EAAAF,WAAA,GAAAD,EAAAG,EAAAF,WAAA,GAAAD,IAUA+a,EAAA,SAAAngB,EAAA3B,EAAA8E,EAAA5Q,GACA,IAAAyN,EAAAgP,OAAAC,YAAA,CACA,GAAAmR,GAAA7tB,EAAA,GAAA7D,MAAA,IACA0xB,GAAA3yB,OAAA,EACAuS,EAAAgP,OAAAC,YAAAmR,EAAA,GAAA,KAAAA,EAAA,GAGApgB,EAAAgP,OAAAC,YAAAmR,EAAA,KAQAC,EAAA,aAOAvB,EAAA,SAAA9e,EAAA3B,EAAA8E,EAAA5Q,GACA,GAAA0L,GAAA1L,EAAA,EACA,oBAAAsrB,GAAA5f,GACA+B,EAAA/B,KAAA/C,KAAA2iB,EAAA5f,GAGA+B,EAAA/B,KAAA/C,KAAA3I,EAAA,IAOAkrB,EAAA,SAAAzd,EAAA3B,EAAA8E,EAAA5Q,GAGA8L,EAAAiB,QAGA,KAAA/M,EAAA,IAAAyN,EAAA1U,OAAA,IAAA,OAAAiH,EAAA,GACA8L,EAAAiB,KAAA6D,GAAA,OAKA9E,EAAAiB,KAAA6D,GAAAmC,EAAA/S,EAAA,KAOA+tB,EAAA,SAAAtgB,EAAA3B,EAAA8E,EAAA5Q,GAGA,mBAAAqrB,GAAAza,KACAA,EAAAya,EAAAza,IAIA9E,EAAA8E,GAAA5Q,GAMAssB,EAAA,SAAA7e,EAAA3B,EAAA8E,EAAA5Q,GAGA,mBAAAqrB,GAAAza,KACAA,EAAAya,EAAAza,IAIA9E,EAAA8E,GAAA5Q,EAAA,IAMA+rB,EAAA,SAAAte,EAAA3B,EAAA8E,EAAA5Q,GAGA,mBAAA8L,GAAAqB,QACArB,EAAAqB,UAIAyD,EAAAA,EAAA1C,OAAA,GAGA,mBAAApC,GAAAqB,MAAAyD,KACA9E,EAAAqB,MAAAyD,MAIA,KAAA,GAAArW,GAAA,EAAAA,EAAAyF,EAAA9E,OAAAX,IACAuR,EAAAqB,MAAAyD,GAAA1N,KAAA6P,EAAA/S,EAAAzF,MAOAyxB,EAAA,SAAAve,EAAA3B,EAAA8E,EAAA5Q,GAGA,mBAAA8L,GAAAoM,QACApM,EAAAoM,OACApiB,KACAE,OAKA4a,EAAAA,EAAA1C,OAAA,EAGA,KAAA,GAAA3T,GAAA,EAAAA,EAAAyF,EAAA9E,OAAAX,IACAuR,EAAAoM,MAAAtH,GAAA1N,KAAA6P,EAAA/S,EAAAzF,MAOA2xB,EAAA,SAAAze,EAAA3B,EAAA8E,EAAA5Q,GACA8L,EAAAoB,KAAAlN,EAAA,IAMAguB,EAAA,SAAAvgB,EAAA3B,EAAA8E,EAAA5Q,GAGA,mBAAAqrB,GAAAza,KACAA,EAAAya,EAAAza,IAIA,mBAAA9E,GAAAtL,SACAsL,EAAAtL,WAIA,mBAAAsL,GAAAtL,OAAAoQ,KACA9E,EAAAtL,OAAAoQ,MAIA,KAAA,GAAArW,GAAA,EAAAA,EAAAyF,EAAA9E,OAAAX,IAAA,CAGA,GAAAyY,GAAAD,EAAA/S,EAAAzF,GAAAoE,OAAA,EAAA,GACAqU,GAAA9P,KAAAlD,EAAAzF,GAAAoE,OAAA,IAGAmN,EAAAtL,OAAAoQ,GAAA1N,KAAA8P,KAOAiZ,EAAA,SAAAxe,EAAA3B,EAAA8E,EAAA5Q,GAGA,mBAAAqrB,GAAAza,KACAA,EAAAya,EAAAza,IAIA,mBAAA9E,GAAAtL,SACAsL,EAAAtL,WAIA,mBAAAsL,GAAAtL,OAAAoQ,KACA9E,EAAAtL,OAAAoQ,MAIA,KAAA,GAAArW,GAAA,EAAAA,EAAAyF,EAAA9E,OAAAX,IACAuR,EAAAtL,OAAAoQ,GAAA1N,KAAA6P,EAAA/S,EAAAzF,MAOA0zB,EAAA,SAAAxgB,EAAA3B,EAAA8E,EAAA5Q,GAGA,mBAAAyN,GAAAlS,QACAkS,EAAAlS,SAIA,IAAAS,GAAAgE,EAAA,GAAA7D,MAAA,IACAH,GAAAd,OAAA,GACAuS,EAAAlS,MAAAxC,MAAAwG,SAAAvD,EAAA,IACAyR,EAAAlS,MAAArC,OAAAqG,SAAAvD,EAAA,KAGAyR,EAAAlS,MAAAxC,MAAA0U,EAAAlS,MAAArC,OAAAqG,SAAAvD,EAAA,KAOA8uB,EAAA,SAAArd,EAAA3B,EAAA8E,EAAA5Q,GAGA,mBAAAyN,GAAA/B,KAAAqf,QACAtd,EAAA/B,KAAAqf,SAKA,KAAA,GADAA,GAAA/qB,EAAA,GAAA7D,MAAA,KACA+xB,EAAA,EAAAA,EAAAnD,EAAA7vB,OAAAgzB,IACAzgB,EAAA/B,KAAAqf,MAAA7nB,KAAA6nB,EAAAmD,KAOArD,EAAA,SAAApd,EAAA3B,EAAA8E,EAAA5Q,GACAyN,EAAA/B,KAAAC,KAAAsE,WAAAjQ,EAAA,KAMAmuB,EAAA,SAAA1gB,EAAA3B,EAAA8E,EAAA5Q,GAGA,mBAAAyN,GAAAkd,SACAld,EAAAkd,WAIAld,EAAAkd,OAAAvR,iBAAA,EACA3L,EAAAkd,OAAAtR,mBAAA,EACA5L,EAAAkd,OAAArR,mBAAA,CAGA,IAAAqT,GAAAptB,SAAAS,EAAA,GAGA,QAAA2sB,GACA,IAAA,GACAlf,EAAAkd,OAAAvR,iBAAA,EACA3L,EAAAkd,OAAAtR,mBAAA,CACA,MACA,KAAA,GACA5L,EAAAkd,OAAAvR,iBAAA,EACA3L,EAAAkd,OAAArR,mBAAA,CACA,MACA,KAAA,GACA7L,EAAAkd,OAAAtR,mBAAA,CACA,MACA,KAAA,GACA5L,EAAAkd,OAAArR,mBAAA,IAQAmR,EAAA,SAAAhd,EAAA3B,EAAA8E,EAAA5Q,GAGA,mBAAAyN,GAAA/B,KAAAkR,UACAnP,EAAA/B,KAAAkR,WAIA,IAAAvV,GAAA,OAAAuJ,GAAA,OAAAA,GAAA,OAAAA,EAAA,QAAA,OAGA,oBAAAya,GAAAza,KACAA,EAAAya,EAAAza,GAIA,KAAA,GAAA3C,GAAA,EAAAA,EAAAR,EAAA/B,KAAAkR,QAAA1hB,OAAA+S,IACA,GAAAR,EAAA/B,KAAAkR,QAAA3O,GAAA5G,QAAAA,EAEA,YADAoG,EAAA/B,KAAAkR,QAAA3O,GAAA2C,GAAA5Q,EAAA,GAMA,IAAA2qB,IAAAtjB,MAAAA,EACAsjB,GAAA/Z,GAAA5Q,EAAA,GACAyN,EAAA/B,KAAAkR,QAAA1Z,KAAAynB,IAMAqC,GAGAlQ,GAAA8Q,EACA5Q,GAAA8Q,EACA7Q,GAAAsP,EACArP,GAAA+Q,EACArQ,GAAAiN,EACA3M,GAAA4M,EAGA8B,GAAAuB,EAGAhR,GAAAsN,EACArN,GAAAqN,EACAjM,GAAAiM,EACAhM,GAAAgM,EACA/L,GAAA+L,EACA9L,GAAA8L,EAGA30B,EAAAo1B,EACAl1B,EAAAk1B,EAGArM,EAAAkP,EACAnP,EAAA0N,EAGA8B,GAAArC,EACAsC,GAAAtC,EACAuC,GAAAvC,EACAwC,GAAArC,EACAsC,GAAAxC,EACAyC,GAAAzC,EAGAlN,GAAAmN,EACAjN,GAAAiN,EACAlN,GAAAkN,EACAhN,GAAAgN,EACA/M,GAAA+M,EACA9M,GAAA6O,GAMAU,GACA,IAAA,IAAA,IAAA,IAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,MAUAC,EAAA,SAAAlhB,EAAApN,EAAAL,GAGA,GAAA,gBAAAK,GAAA,CASA,IAAA,GAHAuQ,GADA9E,EAAA2B,EAIAQ,EAAA,EAAAA,EAAA5N,EAAAnF,SAGA0V,EAAAvQ,EAAA4N,GAGAA,EAAA,IAAA5N,EAAAnF,QANA+S,IAWA,gBAAAnC,GAAA8E,KACA9E,EAAA8E,OAIA9E,EAAAA,EAAA8E,EAIA9E,GAAA8E,GAAA5Q,IAMAmrB,GAKApL,MAAA,SAAAvR,EAAAsR,GAGA,GAAArS,GAAAlC,EAAAkC,KAAAgP,QAAAjO,UAGAogB,KACA5Z,EAAAvH,EAAAkB,KAKA7C,GAAAO,MAAA,EACA2I,GAAA9R,KAAA4I,EAMA,KAAA,GAHA+iB,GAAArgB,EAAAkc,MAAA8C,GAGAjzB,EAAA,EAAAA,EAAAs0B,EAAA3zB,OAAAX,IAGA,GAAA,MAAAs0B,EAAAt0B,GAyBA,GAAA,MAAAs0B,EAAAt0B,GAAA,CAWA,IAAA,GAHA4Z,GAAA0a,EAAAt0B,GAAAmwB,MAAA+C,OAGAtpB,EAAA,EAAAA,EAAAgQ,EAAAjZ,OAAAiJ,IAAA,CAOA,IAAA,GAJAyM,GAAA8c,EAAAtC,KAAAjX,EAAAhQ,IAAA,GAAAzF,cACAktB,EAAAzX,EAAAhQ,GAAAumB,MAAAiD,GAGAmB,EAAA,EAAAA,EAAAlD,EAAA1wB,OAAA4zB,IACAlD,EAAAkD,GAAAlD,EAAAkD,GAAAC,UAAA,EAAAnD,EAAAkD,GAAA5zB,OAAA,GAAAwwB,QAAA,YAAA,GAIA,oBAAAsB,GAAApc,IAqBA,IAAAgb,EAAA1wB,SACA0wB,EAAAA,EAAA,IAIA,mBAAAP,GAAAza,GAYA9E,EACAA,EAAA8E,GAAAgb,EAKAne,EAAAmD,GAAAgb,EAbA+C,EAAAlhB,EAAA4d,EAAAza,GAAAzU,MAAA,KAAAyvB,KA5BA,KAAA8C,EAAAxyB,QAAA0U,KAIA9E,GAAA,MAAA8E,GAAA,MAAAA,IACA9E,KACAkJ,EAAA9R,KAAA4I,KAKAkhB,EAAApc,GAAAnD,EAAA3B,EAAA8E,EAAAgb,IAmCA9f,IAAAA,EAAAO,OACAP,EAAA,UAxEA8iB,GAAA1zB,SACA8Z,EAAA4Z,EAAAhiB,WA3BA,CAGA,GAAA,IAAArS,GAAA,MAAAA,EACA,QAIAq0B,GAAA1rB,KAAA8R,GAGArgB,EAAAwK,QAAA6V,EAAAA,EAAA9Z,OAAA,KACA8Z,EAAA9R,SAIA8R,EAAAA,EAAAA,EAAA9Z,OAAA,GAGA8Z,EAAA9R,SACA8R,EAAAA,EAAAA,EAAA9Z,OAAA,GAmFA,MAAA4kB,GACAnrB,EAAAqa,OAAAvB,GAIAA,GCw/WE,OAAO0d,OAGNz2B,OAAQA,OAAOC","file":"ngGo.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n/**\n * ngGo\n *\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\n * refactored to fit the Angular framework, as well as having been linted, properly commented\n * and generally cleaned up.\n *\n * Copyright (c) 2013 Jan Prokop (WGo)\n * Copyright (c) 2014-2015 Adam Buczynski (ngGo)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo', [])\n\n/**\n * ngGo constants\n */\n.constant('ngGo', {\n  name: 'ngGo',\n  version: '1.2.7',\n  error: {\n\n    //Position errors\n    POSITION_OUT_OF_BOUNDS: 1,\n    POSITION_ALREADY_HAS_STONE: 2,\n    POSITION_IS_SUICIDE: 3,\n    POSITION_IS_REPEATING: 4,\n\n    //Data loading errors\n    NO_DATA: 5,\n    UNKNOWN_DATA: 6,\n    INVALID_SGF: 7,\n    INVALID_GIB: 8,\n    INVALID_JGF_JSON: 9,\n    INVALID_JGF_TREE_JSON: 10\n  }\n})\n\n/**\n * Stone colors\n */\n.constant('StoneColor', {\n  E: 0,\n  EMPTY: 0,\n  B: 1,\n  BLACK: 1,\n  W: -1,\n  WHITE: -1\n})\n\n/**\n * Markup types\n */\n.constant('MarkupTypes', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  LABEL: 'label',\n  LAST: 'last',\n  SAD: 'sad',\n  HAPPY: 'happy'\n})\n\n/**\n * Player modes\n */\n.constant('PlayerModes', {\n  PLAY: 'play',\n  REPLAY: 'replay',\n  EDIT: 'edit',\n  SOLVE: 'solve'\n})\n\n/**\n * Player tools\n */\n.constant('PlayerTools', {\n  NONE: 'none',\n  MOVE: 'move',\n  SCORE: 'score',\n  SETUP: 'setup',\n  MARKUP: 'markup'\n})\n\n/**\n * Key codes\n */\n.constant('KeyCodes', {\n  LEFT: 37,\n  RIGHT: 39,\n  UP: 38,\n  DOWN: 40,\n  ESC: 27,\n  ENTER: 13,\n  SPACE: 32,\n  TAB: 9,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  HOME: 36,\n  END: 35,\n  PAGEUP: 33,\n  PAGEDOWN: 34\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Directive', [\n  'ngGo.Board.Service'\n])\n\n/**\n * Directive definition\n */\n.directive('board', ['$window', 'Board', function($window, Board) {\n\n  //Get pixel ratio\n  var pixelRatio = window.pixelRatio || 1;\n\n  /**\n   * Helper to create a layer canvas\n   */\n  var createLayerCanvas = function(name) {\n\n    //Create canvas element and get context\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    //Scale context depending on pixel ratio\n    if (pixelRatio > 1) {\n      context.scale(pixelRatio, pixelRatio);\n    }\n\n    //Set class\n    canvas.className = name;\n\n    //Set initial canvas width/height based on our own size\n    canvas.width = this.clientWidth * pixelRatio;\n    canvas.height = this.clientHeight * pixelRatio;\n\n    //Append to element now and return context\n    this.appendChild(canvas);\n    return context;\n  };\n\n  /**\n   * Helper to determine draw size\n   */\n  var determineDrawSize = function(scope, availableWidth, availableHeight) {\n\n    //Init vars\n    var drawWidth, drawHeight, cellSize;\n\n    //Stretch available height to width if zero\n    if (availableHeight === 0 && availableWidth > 0) {\n      availableHeight = availableWidth;\n    }\n\n    //Grid size known?\n    if (scope.Board.width && scope.Board.height) {\n\n      //Determine smallest cell size\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\n\n      //Set draw size\n      drawWidth = Math.floor(cellSize * scope.Board.width);\n      drawHeight = Math.floor(cellSize * scope.Board.height);\n    }\n\n    //Otherwise, use the lesser of the available width/height\n    else {\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\n    }\n\n    //Broadcast new size if changed\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\n      scope.lastDrawWidth = drawWidth;\n      scope.lastDrawHeight = drawHeight;\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\n      return true;\n    }\n\n    //No change\n    return false;\n  };\n\n  /**\n   * Directive\n   */\n  return {\n    restrict: 'E',\n    scope: {\n      instance: '&'\n    },\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Init vars\n      var i, context, layer, playerElement;\n      var parent = element.parent();\n      var sizingElement = element[0];\n      var existingInstance = true;\n\n      //Remember last draw width/height\n      scope.lastDrawWidth = 0;\n      scope.lastDrawHeight = 0;\n\n      //Get board instance\n      scope.Board = scope.instance();\n\n      //Function given?\n      if (typeof scope.Board === 'function') {\n        scope.Board = scope.Board();\n      }\n\n      //Instantiate board if not present in scope\n      if (!scope.Board) {\n        existingInstance = false;\n        scope.Board = new Board();\n      }\n\n      //Link element\n      scope.Board.linkElement(element);\n\n      //Find player element\n      if (parent[0].tagName === 'PLAYER') {\n        playerElement = parent;\n        sizingElement = parent.parent()[0];\n      }\n\n      //Listen for board drawsize events\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\n\n        //First set the new dimensions on the canvas elements\n        var canvas = element.find('canvas');\n        for (i = 0; i < canvas.length; i++) {\n          canvas[i].width = width * pixelRatio;\n          canvas[i].height = height * pixelRatio;\n        }\n\n        //Set on the element if we're using a player element and if there is a size\n        if (playerElement || attrs.forceSize === 'true') {\n          element.css({width: width + 'px', height: height + 'px'});\n        }\n\n        //Next set it on the board itself\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\n      });\n\n      //Determine initial draw size\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n\n      //On window resize, determine the draw size again\n      angular.element($window).on('resize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On manual resize, determine draw size again\n      scope.$on('ngGo.board.determineDrawSize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On board grid resize, determine the draw size again\n      scope.$on('ngGo.board.resize', function(event, board) {\n\n        //Only relevent if this was our own board\n        if (board !== scope.Board) {\n          return;\n        }\n\n        //If the draw size didn't change, the draw size event won't be triggered.\n        //However, that means we should call the resized() method now manually because\n        //it won't be called with the setDrawSize() call.\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\n          scope.Board.resized();\n        }\n      });\n\n      //Static board\n      if (attrs.static && attrs.static === 'true') {\n\n        //Add static class and make the board static\n        element.addClass('static');\n        scope.Board.makeStatic();\n\n        //Create single canvas and link to all relevant layer service classes\n        context = createLayerCanvas.call(element[0], 'static');\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Dynamic board\n      else {\n\n        //Create individual layer canvasses and link the canvas context to the layer service class\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          context = createLayerCanvas.call(element[0], layer);\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Observe the board size attribute\n      attrs.$observe('size', function(size) {\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\n          size = size.split('x');\n          scope.Board.setSize(size[0], size[1]);\n        }\n        else {\n          scope.Board.setSize(size, size);\n        }\n      });\n\n      //Observe the coordinates attribute\n      attrs.$observe('coordinates', function(attr) {\n        scope.Board.toggleCoordinates(attr === 'true');\n      });\n\n      //Observe the cutoff attribute\n      attrs.$observe('cutoff', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.setCutoff(attr.split(','));\n        }\n      });\n\n      //Observe color multiplier\n      attrs.$observe('colorMultiplier', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.swapColors(attr);\n        }\n      });\n\n      //Link board to player if present in parent scope\n      if (scope.$parent.Player) {\n        scope.$parent.Player.setBoard(scope.Board);\n      }\n\n      //Redraw board if we had an existing instance (it might contain data)\n      if (existingInstance) {\n        scope.Board.redraw();\n      }\n    }\n  };\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\n * and is used for placing and removing objects on the board. The class has helpers to figure out\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\n * responsible for drawing all layers on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Service', [\n  'ngGo',\n  'ngGo.Board.Directive',\n  'ngGo.Board.Theme.Service',\n  'ngGo.Board.Layer.GridLayer.Service',\n  'ngGo.Board.Layer.ShadowLayer.Service',\n  'ngGo.Board.Layer.StonesLayer.Service',\n  'ngGo.Board.Layer.MarkupLayer.Service',\n  'ngGo.Board.Layer.ScoreLayer.Service',\n  'ngGo.Board.Layer.HoverLayer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.Stone.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Board', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Width and height\n    width: 0,\n    height: 0,\n\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\n    cutoff: [],\n\n    //Section of board to display\n    section: {top: 0, right: 0, bottom: 0, left: 0},\n\n    //Show coordinates?\n    coordinates: false,\n\n    //Color multiplier (use -1 to swap colors)\n    colorMultiplier: 1\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$injector', 'BoardTheme', function($rootScope, $injector, BoardTheme) {\n\n    /**\n     * Board constructor\n     */\n    var Board = function(config) {\n\n      //Initialize board\n      this.init();\n\n      //Parse config\n      this.parseConfig(config || {});\n    };\n\n    /**\n     * Initialize board\n     */\n    Board.prototype.init = function() {\n\n      //Remove everything\n      this.removeAll();\n\n      //Set board theme\n      this.theme = new BoardTheme();\n\n      //Initialize board draw dimensions in pixels\n      this.cellSize = 0;\n      this.drawWidth = 0;\n      this.drawHeight = 0;\n      this.drawMarginHor = 0;\n      this.drawMarginVer = 0;\n      this.gridDrawWidth = 0;\n      this.gridDrawHeight = 0;\n\n      //Set layer order\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\n\n      //Initialize layers\n      this.layers = {};\n      for (var l = 0; l < this.layerOrder.length; l++) {\n        var layer = this.layerOrder[l];\n        var layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\n        var LayerClass = $injector.get(layerClass);\n        this.layers[layer] = new LayerClass(this);\n      }\n\n      //Static board flag\n      this.static = false;\n\n      //Get margin from theme\n      this.margin = this.theme.get('board.margin');\n\n      //Color multiplier (to allow color swapping)\n      this.colorMultiplier = 1;\n\n      //Turn off coordinates\n      this.coordinates = false;\n      this.layers.grid.setCoordinates(false);\n\n      //Initialize grid size\n      this.width = 0;\n      this.height = 0;\n\n      //Initialize cutoff\n      this.cutoff = {\n        top: false,\n        left: false,\n        right: false,\n        bottom: false\n      };\n\n      //Initialize section\n      this.section = {\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    };\n\n    /**\n     * Link the board to a HTML element\n     */\n    Board.prototype.linkElement = function(element) {\n      this.element = element;\n    };\n\n    /**\n     * Make this board static (one canvas layer, only grid, stones and markup)\n     */\n    Board.prototype.makeStatic = function() {\n      this.static = true;\n      this.layerOrder = ['grid', 'stones', 'markup'];\n    };\n\n    /*****************************************************************************\n     * Configuration\n     ***/\n\n    /**\n     * Parse config instructions\n     */\n    Board.prototype.parseConfig = function(config) {\n\n      //Validate\n      if (typeof config !== 'object') {\n        return;\n      }\n\n      //Extend from default config\n      config = angular.extend({}, defaultConfig, config);\n\n      //Process settigns\n      this.toggleCoordinates(config.coordinates);\n      this.swapColors(config.colorMultiplier);\n      this.setCutoff(config.cutoff);\n      this.setSection(config.section);\n      this.setSize(config.width, config.height);\n    };\n\n    /**\n     * Set margin\n     */\n    Board.prototype.setMargin = function(margin) {\n\n      //Reset when not defined\n      if (typeof margin === 'undefined') {\n        margin = this.theme.get('board.margin');\n      }\n\n      //Set margin if changed\n      if (this.margin !== margin) {\n        this.margin = margin;\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set grid cut-off\n     */\n    Board.prototype.setCutoff = function(cutoff) {\n\n      //Nothing given? Reset cutoff\n      if (!cutoff || !angular.isArray(cutoff)) {\n        cutoff = [];\n      }\n\n      //Init\n      var changes = false;\n\n      //Check if there's a change\n      for (var side in this.cutoff) {\n        if (this.cutoff.hasOwnProperty(side)) {\n          if (cutoff.indexOf(side) !== -1) {\n            if (!this.cutoff[side]) {\n              this.cutoff[side] = true;\n              changes = true;\n            }\n          }\n          else {\n            if (this.cutoff[side]) {\n              this.cutoff[side] = false;\n              changes = true;\n            }\n          }\n        }\n      }\n\n      //Trigger resized if there were changes\n      if (changes) {\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set section of the board to be displayed\n     */\n    Board.prototype.setSection = function(section) {\n\n      //Nothing given?\n      if (!section || typeof section !== 'object') {\n        return this;\n      }\n\n      //Expand on default\n      section = angular.extend({\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      }, section);\n\n      //No changes?\n      if (\n        this.section.top === section.top && this.section.bottom === section.bottom &&\n        this.section.left === section.left && this.section.right === section.right\n      ) {\n        return this;\n      }\n\n      //Set section and call resized handler\n      this.section = section;\n      this.resized();\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set board size. This will clear the board objects.\n     */\n    Board.prototype.setSize = function(width, height) {\n\n      //Check what's given\n      width = parseInt(width || height || 0);\n      height = parseInt(height || width || 0);\n\n      //Invalid?\n      if (isNaN(width) || isNaN(height)) {\n        return;\n      }\n\n      //Changing?\n      if (width !== this.width || height !== this.height) {\n\n        //Remember size\n        this.width = width;\n        this.height = height;\n\n        //Set size in layers\n        for (var layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].setSize(width, height);\n          }\n        }\n\n        //Broadcast event (no call to resized, as that is handled in the directive)\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set new draw size\n     */\n    Board.prototype.setDrawSize = function(width, height) {\n      if (width !== this.drawWidth || height !== this.drawHeight) {\n        this.drawWidth = width;\n        this.drawHeight = height;\n        this.resized();\n      }\n    };\n\n    /**\n     * Toggle the coordinates\n     */\n    Board.prototype.toggleCoordinates = function(show) {\n\n      //Set or toggle\n      if (typeof show !== 'undefined') {\n        this.coordinates = show;\n      }\n      else {\n        this.coordinates = !this.coordinates;\n      }\n\n      //Set in grid layer\n      this.layers.grid.setCoordinates(this.coordinates);\n\n      //Set the proper board margin\n      if (this.coordinates) {\n        this.setMargin(this.theme.get('coordinates.margin'));\n      }\n      else {\n        this.setMargin(this.theme.get('board.margin'));\n      }\n    };\n\n    /**\n     * Swap colors on the board\n     */\n    Board.prototype.swapColors = function(multiplier) {\n\n      //Multiplier not given? Set to inverse of current value\n      if (typeof multiplier === 'undefined') {\n        multiplier = -this.colorMultiplier;\n      }\n      else {\n        multiplier = parseInt(multiplier);\n        if (isNaN(multiplier)) {\n          return;\n        }\n      }\n\n      //No change?\n      if (multiplier === this.colorMultiplier) {\n        return;\n      }\n\n      //Set new value\n      this.colorMultiplier = multiplier;\n\n      //For static board, redraw the whole thing\n      if (this.static) {\n        this.redraw();\n      }\n\n      //For a dynamic board, only these layers\n      else {\n        this.redraw('stones');\n        this.redraw('markup');\n      }\n    };\n\n    /*****************************************************************************\n     * Theme handling\n     ***/\n\n    /**\n     * Get the current theme object\n     */\n    Board.prototype.getTheme = function() {\n      return this.theme;\n    };\n\n    /**\n     * Set the theme object\n     */\n    Board.prototype.setTheme = function(theme) {\n      this.theme = theme;\n      return this;\n    };\n\n    /*****************************************************************************\n     * Object handling\n     ***/\n\n    /**\n     * Add an object to a board layer\n     */\n    Board.prototype.add = function(layer, x, y, value) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].add(x, y, value);\n      }\n    };\n\n    /**\n     * Remove an object from a board layer\n     */\n    Board.prototype.remove = function(layer, x, y) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].remove(x, y);\n      }\n    };\n\n    /**\n     * Get something from a board layer\n     */\n    Board.prototype.get = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].get(x, y));\n    };\n\n    /**\n     * Check if we have something at given coordinates for a given layer\n     */\n    Board.prototype.has = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].has(x, y));\n    };\n\n    /**\n     * Set all objects (grid) for a given layer\n     */\n    Board.prototype.setAll = function(layer, grid) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].setAll(grid);\n      }\n    };\n\n    /**\n     * Remove all objects from the board, optionally for a given layer\n     */\n    Board.prototype.removeAll = function(layer) {\n      if (layer) {\n        if (typeof this.layers[layer] !== 'undefined') {\n          this.layers[layer].removeAll();\n        }\n      }\n      else {\n        for (layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].removeAll();\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Position handling\n     ***/\n\n    /**\n     * Update the board with a new position\n     */\n    Board.prototype.updatePosition = function(position, pathChanged) {\n\n      //If we have no grid size yet, use what's in the position\n      if (!this.width || !this.height) {\n        this.setSize(position.width, position.height);\n      }\n\n      //Remove markup if path changed\n      if (pathChanged) {\n        this.removeAll('markup');\n      }\n\n      //Set new stones and markup grids\n      this.setAll('stones', position.stones);\n      this.setAll('markup', position.markup);\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state (list of objects per layer)\n     */\n    Board.prototype.getState = function(layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          return this.layers[layer].getAll();\n        }\n        return null;\n      }\n\n      //All layers\n      var state = {};\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          var grid = this.layers[layer].getAll();\n          if (grid && !grid.isEmpty()) {\n            state[layer] = grid;\n          }\n        }\n      }\n      return state;\n    };\n\n    /**\n     * Restore the board state from given state object\n     */\n    Board.prototype.restoreState = function(state, layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          this.layers[layer].setAll(state);\n        }\n        return;\n      }\n\n      //All layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].removeAll();\n          if (state[layer]) {\n            this.layers[layer].setAll(state[layer]);\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing control\n     ***/\n\n    /**\n     * Clear the whole board\n     */\n    Board.prototype.clear = function(layer) {\n\n      //Just clearing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Clear the layer\n        this.layers[layer].clear();\n        return;\n      }\n\n      //Static? One clear is enough\n      if (this.static) {\n        this.layers.stones.clear();\n        return;\n      }\n\n      //Clear all layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].clear();\n        }\n      }\n    };\n\n    /**\n     * Redraw everything or just a single layer\n     */\n    Board.prototype.redraw = function(layer) {\n\n      //The board can only be redrawn when there is a grid size and a draw size\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Just redrawing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Redraw the layer\n        this.layers[layer].redraw();\n        return;\n      }\n\n      //Clear the board first\n      this.clear();\n\n      //Now draw all layers again in the correct order\n      for (var i = 0; i < this.layerOrder.length; i++) {\n        layer = this.layerOrder[i];\n        this.layers[layer].draw();\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing helpers\n     ***/\n\n    /**\n     * Called after a board size change, draw size change, section change or margin change\n     */\n    Board.prototype.resized = function() {\n\n      //Determine the new grid\n      this.grid = {\n        xLeft: 0 + this.section.left,\n        xRight: this.width - 1 - this.section.right,\n        yTop: 0 + this.section.top,\n        yBot: this.height - 1 - this.section.bottom\n      };\n\n      //Only redraw when there is sensible data\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Determine number of cells horizontall and vertically\n      //The margin is a factor of the cell size, so let's add it to the number of cells\n      var noCellsHor = this.width + this.margin;\n      var noCellsVer = this.height + this.margin;\n\n      //Are we cutting off parts of the grid? Add half a cell of draw size\n      for (var side in this.cutoff) {\n        if (this.cutoff[side]) {\n          if (side === 'top' || side === 'bottom') {\n            noCellsVer += 0.5;\n          }\n          else {\n            noCellsHor += 0.5;\n          }\n        }\n      }\n\n      //Determine cell size now\n      this.cellSize = Math.floor(Math.min(\n        this.drawWidth / noCellsHor,\n        this.drawHeight / noCellsVer\n      ));\n\n      //Determine actual grid draw size (taking off the margin again)\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\n\n      //Determine draw margins\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\n\n      //Redraw\n      this.redraw();\n    };\n\n    /**\n     * Get the current cell size\n     */\n    Board.prototype.getCellSize = function() {\n      return this.cellSize;\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsX = function(gridX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsY = function(gridY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridX = function(absX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridY = function(absY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\n    };\n\n    /**\n     * Check if given grid coordinates are on board\n     */\n    Board.prototype.isOnBoard = function(gridX, gridY) {\n      return (\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\n      );\n    };\n\n    //Return object\n    return Board;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\n * a small rectangular area on the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('DefaultClearHandler', function() {\n\n  /**\n   * Clear handler definition\n   *\n   * All external handlers are called from the context of the layer that contains the object.\n   * First parameter is the canvas2d context, second parameter is the object itself.\n   */\n  return function(context, obj) {\n\n    //No context?\n    if (!context) {\n      return;\n    }\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(obj.x);\n    var y = this.board.getAbsY(obj.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Clear rectangle the size of the stone radius\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\n * stone color values for the game position class. It has built in validation of coordinates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Grid.Service', [\n  'ngGo',\n  'ngGo.Board.GridChanges.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGrid', ['BoardGridChanges', function(BoardGridChanges) {\n\n  /**\n   * Helper to convert a value at given coordinates to an object\n   */\n  var toObject = function(x, y, valueKey) {\n\n    //Create coordinates object\n    var obj = {\n      x: x,\n      y: y\n    };\n\n    //Already an object?\n    if (typeof this.grid[x][y] === 'object') {\n      return angular.extend(obj, this.grid[x][y]);\n    }\n\n    //Not an object, set value with given value key and return\n    obj[valueKey] = this.grid[x][y];\n    return obj;\n  };\n\n  /**\n   * Constructor\n   */\n  var BoardGrid = function(width, height, emptyValue) {\n\n    //Initialize size and grid array\n    this.width = 0;\n    this.height = 0;\n    this.grid = [];\n    this.emptyValue = null;\n\n    //Set empty value if given\n    if (typeof emptyValue !== 'undefined') {\n      this.emptyValue = emptyValue;\n    }\n\n    //Size given? Set it\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set a value\n   */\n  BoardGrid.prototype.set = function(x, y, value) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = value;\n    }\n  };\n\n  /**\n   * Unset a value\n   */\n  BoardGrid.prototype.unset = function(x, y) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = this.emptyValue;\n    }\n  };\n\n  /**\n   * Check if we have a non null value on the coordinates\n   */\n  BoardGrid.prototype.has = function(x, y) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\n  };\n\n  /**\n   * Check if we have a specific value on the coordinates\n   */\n  BoardGrid.prototype.is = function(x, y, value) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\n  };\n\n  /**\n   * Get a value, or an object with coordinates and the value in the given value key\n   */\n  BoardGrid.prototype.get = function(x, y, valueKey) {\n\n    //Validate\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\n      return this.emptyValue;\n    }\n\n    //Return as is?\n    if (!valueKey) {\n      return this.grid[x][y];\n    }\n\n    //Return as object\n    return toObject.call(this, x, y, valueKey);\n  };\n\n  /*****************************************************************************\n   * Mass operations\n   ***/\n\n  /**\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\n   * and the value in the given value key will be returned.\n   */\n  BoardGrid.prototype.all = function(valueKey) {\n\n    //Just get the grid?\n    if (!valueKey) {\n      return this.grid;\n    }\n\n    //Initialize objects list\n    var objects = [];\n\n    //Loop coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          objects.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return objects list\n    return objects;\n  };\n\n  /**\n   * Check if there is anything\n   */\n  BoardGrid.prototype.isEmpty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Populate the whole grid with a given value\n   */\n  BoardGrid.prototype.populate = function(value) {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = value;\n      }\n    }\n  };\n\n  /**\n   * Empty the grid\n   */\n  BoardGrid.prototype.empty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Clone ourselves\n   */\n  BoardGrid.prototype.clone = function() {\n\n    //Create new instance\n    var newGrid = new BoardGrid();\n\n    //Manually set vars for maximum efficiency\n    newGrid.grid = angular.copy(this.grid);\n    newGrid.emptyValue = this.emptyValue;\n    newGrid.width = this.width;\n    newGrid.height = this.height;\n\n    //Return\n    return newGrid;\n  };\n\n  /*****************************************************************************\n   * Comparison\n   ***/\n\n  /**\n   * Checks if a given grid is the same as the current grid\n   */\n  BoardGrid.prototype.isSameAs = function(grid) {\n\n    //Must have the same size\n    if (this.width !== grid.width || this.height !== grid.height) {\n      return false;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== grid[x][y]) {\n          return false;\n        }\n      }\n    }\n\n    //No differences found\n    return true;\n  };\n\n  /**\n   * Compares this position with another position and return change object\n   */\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\n\n    //Initialize board grid changes object\n    var changes = new BoardGridChanges();\n\n    //Must have the same size\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\n      console.warn('Trying to compare grids of a different size');\n      return changes;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n\n        //Something to add?\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\n        }\n\n        //Something to remove?\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.remove.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return changes grid\n    return changes;\n  };\n\n  /*****************************************************************************\n   * Helpers\n   ***/\n\n  /**\n   * Helper to validate coordinates (first param can be an object)\n   */\n  BoardGrid.prototype.isOnGrid = function(x, y) {\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\n  };\n\n  /**\n   * Helper to set the empty value\n   */\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\n    this.emptyValue = emptyValue;\n  };\n\n  /**\n   * Set the grid size\n   */\n  BoardGrid.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Create grid array\n    this.grid = [];\n    for (var x = 0; x < this.width; x++) {\n      this.grid[x] = [];\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Get the grid size object\n   */\n  BoardGrid.prototype.getSize = function() {\n    return {width: this.width, height: this.height};\n  };\n\n  //Return\n  return BoardGrid;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\n * grids. It simply keeps track of what was added and what was removed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.GridChanges.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGridChanges', function() {\n\n  /**\n   * Helper to subtract sets\n   */\n  var setSubtract = function(a, b) {\n    var n = [];\n    var q;\n    for (var i = 0; i < a.length; i++) {\n      q = true;\n      for (var j in b) {\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\n          q = false;\n          break;\n        }\n      }\n      if (q) {\n        n.push(a[i]);\n      }\n    }\n    return n;\n  };\n\n  /**\n   * Game position constructor\n   */\n  return function() {\n\n    /**\n     * Containers\n     */\n    this.add = [];\n    this.remove = [];\n\n    /**\n     * Concatenation helper\n     */\n    this.concat = function(newChanges) {\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\n    };\n\n    /**\n     * Check if there are changes\n     */\n    this.has = function() {\n      return !!(this.add.length || this.remove.length);\n    };\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\n * for drawing itself as well as its objects onto the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardLayer', ['BoardGrid', function(BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var BoardLayer = function(board, context) {\n\n    //Remember board reference and 2d canvas context\n    this.board = board;\n    this.context = context;\n\n    //Initialize grid for board objects\n    this.grid = new BoardGrid();\n  };\n\n  /*****************************************************************************\n   * Generic grid and object handling\n   ***/\n\n  /**\n   * Set grid size\n   */\n  BoardLayer.prototype.setSize = function(width, height) {\n\n    //Note: since this method is usually only called upon a global board resize,\n    //which also triggers the redraw method for layers, the layer is not cleared\n    //here, as it will happen anyway during the redraw cycle.\n\n    //Set it in the grid (removing all objects in the process)\n    this.grid.setSize(width, height);\n  };\n\n  /**\n   * Get all items\n   */\n  BoardLayer.prototype.getAll = function() {\n    return this.grid.clone();\n  };\n\n  /**\n   * Set all items at once\n   */\n  BoardLayer.prototype.setAll = function(grid) {\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  BoardLayer.prototype.removeAll = function() {\n    this.clear();\n    this.grid.empty();\n  };\n\n  /**\n   * Add a single item\n   */\n  BoardLayer.prototype.add = function(x, y, value) {\n    this.clearCell(x, y);\n    this.grid.set(x, y, value);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Remove a single item\n   */\n  BoardLayer.prototype.remove = function(x, y) {\n    this.clearCell(x, y);\n    this.grid.unset(x, y);\n  };\n\n  /**\n   * Get an item\n   */\n  BoardLayer.prototype.get = function(x, y) {\n    return this.grid.get(x, y);\n  };\n\n  /**\n   * Check if there is an item\n   */\n  BoardLayer.prototype.has = function(x, y) {\n    return this.grid.has(x, y);\n  };\n\n  /*****************************************************************************\n   * Generic drawing methods\n   ***/\n\n  /**\n   * Draw layer\n   */\n  BoardLayer.prototype.draw = function() {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\n   */\n  BoardLayer.prototype.clear = function() {\n    if (this.context) {\n      this.context.clearRect(\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\n      );\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  BoardLayer.prototype.redraw = function() {\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear cell\n   */\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\n    //Clearing method to be implemented in specific layer class\n  };\n\n  /**\n   * Redraw cell\n   */\n  BoardLayer.prototype.redrawCell = function(x, y) {\n    this.clearCell(x, y);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Set the canvas2d context\n   */\n  BoardLayer.prototype.setContext = function(context) {\n    this.context = context;\n  };\n\n  /**\n   * Get the canvas2d context\n   */\n  BoardLayer.prototype.getContext = function() {\n    return this.context;\n  };\n\n  //Return\n  return BoardLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardObject :: Base class for drawing board objects\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Service', [\n  'ngGo',\n  'ngGo.Board.DefaultClearHandler.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardObject', ['DefaultClearHandler', function(DefaultClearHandler) {\n\n  /**\n   * Constructor\n   */\n  var BoardObject = {\n\n    /**\n     * Draw method\n     */\n    draw: function(/*obj*/) {\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n    },\n\n    /**\n     * Clear method\n     */\n    clear: function(obj) {\n      DefaultClearHandler.call(this, this.context, obj);\n    }\n  };\n\n  //Return\n  return BoardObject;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.ShellPattern.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('ShellPattern', function() {\n\n  /**\n   * Helper to draw a shell line\n   */\n  var shellLine = function(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\n\n    //Initialize\n    ctx.shadowBlur = 2;\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = (radius / 30) * this.thickness;\n    ctx.beginPath();\n\n    //Lower radius\n    radius -= Math.max(1, ctx.lineWidth);\n\n    //Determine coordinates\n    var x1 = x + radius * Math.cos(startAngle * Math.PI);\n    var y1 = y + radius * Math.sin(startAngle * Math.PI);\n    var x2 = x + radius * Math.cos(endAngle * Math.PI);\n    var y2 = y + radius * Math.sin(endAngle * Math.PI);\n\n    //Math magic\n    var m, angle;\n    if (x2 > x1) {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m);\n    }\n    else if (x2 === x1) {\n      angle = Math.PI / 2;\n    }\n    else {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m) - Math.PI;\n    }\n\n    //Curvature factor\n    var c = this.factor * radius;\n    var dx = Math.sin(angle) * c;\n    var dy = Math.cos(angle) * c;\n\n    //Curvature coordinates\n    var bx1 = x1 + dx;\n    var by1 = y1 - dy;\n    var bx2 = x2 + dx;\n    var by2 = y2 - dy;\n\n    //Draw shell stroke\n    ctx.moveTo(x1, y1);\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\n    ctx.stroke();\n  };\n\n  /**\n   * Shell pattern drawer\n   */\n  return function(ctx, x, y, radius, angle, strokeStyle) {\n\n    //Initialize start and end angle\n    var startAngle = angle;\n    var endAngle = angle;\n\n    //Loop lines\n    for (var i = 0; i < this.lines.length; i++) {\n      startAngle += this.lines[i];\n      endAngle -= this.lines[i];\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\n    }\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\n * use static values or dynamic values depending on other properties, like the grid cell size.\n * Using the provider, the theme can be configured globally at application launch.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Theme.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.provider('BoardTheme', ['StoneColor', 'MarkupTypes', function(StoneColor, MarkupTypes) {\n\n  /**\n   * Default theme\n   */\n  var defaultTheme = {\n\n    //Board\n    board: {\n\n      //Board margin factor\n      margin: 0.25\n    },\n\n    //Stones\n    stone: {\n\n      //Stone style can be shell, glass, mono, or specify a custom handler service\n      style: 'shell',\n      shadow: true,\n      radius: function(cellSize) {\n        return Math.floor(cellSize / 2);\n      },\n\n      //Shell stones\n      shell: {\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#111';\n          }\n          return '#BFBFBA';\n        },\n        stroke: 'rgba(128,128,128,0.15)',\n        types: [\n          {\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\n            factor: 0.15,\n            thickness: 1.75\n          },\n          {\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\n            factor: 0.1,\n            thickness: 1.5\n          },\n          {\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\n            factor: 0.05,\n            thickness: 1.75\n          },\n          {\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\n            factor: 0.1,\n            thickness: 2\n          }\n        ]\n      },\n\n      //Mono stones\n      mono: {\n        lineWidth: 1,\n        lineColor: function() {\n          return '#000';\n        },\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#000';\n          }\n          return '#fff';\n        }\n      },\n\n      //Mini stones\n      mini: {\n        scale: 0.5,\n        alpha: 1\n      },\n\n      //Faded stones\n      faded: {\n        scale: 1,\n        alpha: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return 0.3;\n          }\n          return 0.4;\n        }\n      }\n    },\n\n    //Shadows\n    shadow: {\n\n      //Shadow gradient colors\n      color: 'rgba(40,30,20,0.5)',\n\n      //Shadow size\n      size: function(cellSize) {\n        return Math.floor(cellSize / 20);\n      },\n\n      //Shadow blur size\n      blur: function(cellSize) {\n        return cellSize / 20;\n      },\n\n      //Shadow offset\n      offsetX: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      },\n      offsetY: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      }\n    },\n\n    //Markup\n    markup: {\n\n      //Standard color\n      color: function(stoneColor) {\n        if (stoneColor === StoneColor.B) {\n          return 'rgba(255,255,255,0.9)';\n        }\n        return 'rgba(0,0,0,0.9)';\n      },\n\n      //Line width\n      lineWidth: function(cellSize) {\n        return Math.max(1, Math.floor(cellSize / 16));\n      },\n\n      //Triangle\n      triangle: {\n        scale: 0.85\n      },\n\n      //Square\n      square: {\n        scale: 0.85\n      },\n\n      //Cricle\n      circle: {\n        scale: 0.55\n      },\n\n      //Mark\n      mark: {\n        lineCap: 'square',\n        scale: 0.75\n      },\n\n      //Last\n      last: {\n        scale: 0.7\n      },\n\n      //Smiley\n      smiley: {\n        lineCap: 'round',\n        scale: 0.85\n      },\n\n      //Label\n      label: {\n        font: 'Arial'\n      },\n\n      //Variation markup\n      variation: {\n        type: MarkupTypes.LABEL,\n        text: function(i) {\n          return String.fromCharCode(65 + i);\n        },\n        color: 'rgba(86,114,30,0.9)'\n      },\n\n      //Solution paths markup\n      solution: {\n        valid: {\n          type: MarkupTypes.SELECT,\n          text: null,\n          color: 'rgba(86,114,30,1)',\n          scale: 0.5\n        },\n        invalid: {\n          type: MarkupTypes.MARK,\n          text: null,\n          color: 'rgba(237,9,15,1)',\n          scale: 0.3\n        }\n      }\n    },\n\n    //Grid\n    grid: {\n\n      //Line properties\n      lineColor: 'rgba(60,40,15,1)',\n      lineWidth: function(cellSize) {\n        if (cellSize > 60) {\n          return 2;\n        }\n        else if (cellSize > 50) {\n          return 1.5;\n        }\n        return 1;\n      },\n      lineCap: 'square',\n\n      //Star points\n      star: {\n\n        //Color and radius\n        color: 'rgba(60,40,15,1)',\n        radius: function(cellSize) {\n          if (cellSize > 50) {\n            return Math.floor((cellSize / 16) + 1);\n          }\n          else if (cellSize > 30) {\n            return 3;\n          }\n          else if (cellSize > 15) {\n            return 2;\n          }\n          else if (cellSize > 5) {\n            return 1.5;\n          }\n          return 1;\n        },\n\n        //Locations\n        points: function(width, height) {\n\n          //19x19\n          if (width === height && width === 19) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15,y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15,y: 9 },\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15,y: 15 }\n            ];\n          }\n\n          //13x13\n          if (width === height && width === 13) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }\n            ];\n          }\n\n          //9x9\n          if (width === height && width === 9) {\n            return [\n              { x: 4, y: 4}, { x: 2, y: 2},\n              { x: 2, y: 6}, { x: 6, y: 2},\n              { x: 6, y: 6}\n            ];\n          }\n\n          //No star points\n          return [];\n        }\n      }\n    },\n\n    //Coordinates\n    coordinates: {\n\n      //Color\n      color: 'rgba(101,69,37,0.5)',\n\n      //Board margin factor when showing coordinates\n      margin: 1.25,\n\n      //Vertical coordinates style\n      vertical: {\n        font: 'Arial',\n        style: 'numbers',\n        inverse: true,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      },\n\n      //Horizontal coordinates style\n      horizontal: {\n        font: 'Arial',\n        style: 'letters',\n        inverse: false,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      }\n    }\n  };\n\n  /**\n   * Set global default theme\n   */\n  this.setTheme = function(theme) {\n    if (theme) {\n      defaultTheme = angular.merge(defaultTheme, theme);\n    }\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function() {\n\n    /**\n     * Board theme constructor\n     */\n    var BoardTheme = function(theme) {\n\n      //Remember the given instance theme settings and (re)set the theme\n      this.instanceTheme = theme;\n      this.reset();\n    };\n\n    /**\n     * Reset the theme to defaults\n     */\n    BoardTheme.prototype.reset = function() {\n\n      //Use default theme as a base\n      this.theme = angular.copy(defaultTheme);\n\n      //Add any instance theme properties\n      if (this.instanceTheme) {\n        angular.merge(this.theme, this.instanceTheme);\n      }\n    };\n\n    /**\n     * Get a theme property\n     */\n    BoardTheme.prototype.get = function(property) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Can't find the property?\n        if (typeof prop[path[i]] === 'undefined') {\n          console.warn('Could not find theme property', property);\n          return null;\n        }\n\n        //Advance further in the object\n        prop = prop[path[i]];\n      }\n\n      //Found what we're looking for\n      if (typeof prop !== 'function') {\n        return prop;\n      }\n\n      //Prepare arguments\n      var args = [];\n      if (arguments.length > 1) {\n        for (var a = 1; a < arguments.length; a++) {\n          args.push(arguments[a]);\n        }\n      }\n\n      //Call function\n      return prop.apply(this, args);\n    };\n\n    /**\n     * Change a theme property dynamically (accepts handler function as value)\n     */\n    BoardTheme.prototype.set = function(property, value) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Time to set?\n        if ((i + 1) === path.length) {\n          prop[path[i]] = value;\n          break;\n        }\n\n        //Not set?\n        if (typeof prop[path[i]] === 'undefined') {\n          prop[path[i]] = {};\n        }\n\n        //Move on\n        prop = prop[path[i]];\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\n     */\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\n\n      //If no linewidth specified, use the grid line width as a reference\n      //to make sure stuff is aligned to the grid\n      if (typeof lineWidth === 'undefined') {\n        lineWidth = this.get('grid.lineWidth');\n      }\n\n      //Return a translation for uneven widths\n      return (lineWidth % 2) * 0.5;\n    };\n\n    //Return\n    return BoardTheme;\n  };\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidDataError :: Error class to handle invalid data.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidDataError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidDataError', ['ngGo', function(ngGo) {\n\n  /**\n   * Define error\n   */\n  var InvalidDataError = function(code) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidDataError';\n    this.message = 'Invalid data: ';\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.NO_DATA:\n        this.message += 'no data to process.';\n        break;\n      case ngGo.error.UNKNOWN_DATA:\n        this.message += 'unknown data format.';\n        break;\n      case ngGo.error.INVALID_GIB:\n        this.message += 'unable to parse GIB data.';\n        break;\n      case ngGo.error.INVALID_SGF:\n        this.message += 'unable to parse SGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_JSON:\n        this.message += 'unable to parse JGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_TREE_JSON:\n        this.message += 'unable to parse the JGF tree data.';\n        break;\n      default:\n        this.message += 'unable to parse the data.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidDataError.prototype = new Error();\n  InvalidDataError.prototype.constructor = InvalidDataError;\n\n  //Return object\n  return InvalidDataError;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidPositionError :: Error class to handle invalid moves.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidPositionError', ['ngGo', 'StoneColor', function(ngGo, StoneColor) {\n\n  /**\n   * Define error\n   */\n  var InvalidPositionError = function(code, x, y, color) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidPositionError';\n    this.message = 'Invalid position detected.';\n\n    //Add position data\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\n        ' stone on (' + x + ', ' + y + ')';\n    }\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\n        this.message += ', but these coordinates are not on the board.';\n        break;\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\n        this.message += ', but there is already a stone on those coordinates.';\n        break;\n      case ngGo.error.POSTITION_IS_SUICIDE:\n        this.message += ', but that would be suicide.';\n        break;\n      case ngGo.error.POSTITION_IS_REPEATING:\n        this.message += ', but this position already occured.';\n        break;\n      default:\n        this.message += '.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidPositionError.prototype = new Error();\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\n\n  //Return object\n  return InvalidPositionError;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Game :: This class represents a game record or a game that is being played/edited. The class\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\n * The class also keeps a stack of all board positions in memory and can validate moves to make\n * sure they are not repeating or suicide.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Service', [\n  'ngGo',\n  'ngGo.Game.Path.Service',\n  'ngGo.Game.Node.Service',\n  'ngGo.Game.Position.Service',\n  'ngGo.Kifu.Blank.Service',\n  'ngGo.Kifu.Parser.Service',\n  'ngGo.Errors.InvalidDataError.Service',\n  'ngGo.Errors.InvalidPositionError.Service'\n])\n\n/**\n * Factory definition\n */\n.provider('Game', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default size of board\n    defaultSize: 0,\n\n    //Default komi and handicap\n    defaultKomi: 0,\n    defaultHandicap: 0,\n\n    //Remember last selected variation when traversing nodes\n    rememberPath: true,\n\n    //Check for repeating positions? (KO / ALL / empty)\n    checkRepeat: 'KO',\n\n    //Allow suicide?\n    allowSuicide: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['ngGo', 'StoneColor', 'GamePath', 'GameNode', 'GamePosition', 'KifuParser', 'KifuBlank', 'InvalidDataError', 'InvalidPositionError', function(\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\n    KifuBlank, InvalidDataError, InvalidPositionError\n  ) {\n\n    /*****************************************************************************\n     * General helpers\n     ***/\n\n    /**\n     * Validate the info we have to make sure the properties exist\n     */\n    var validateInfo = function() {\n\n      //Set board info if not set\n      if (!this.info.board) {\n        this.info.board = {};\n      }\n\n      //Set game info if not set\n      if (!this.info.game) {\n        this.info.game = {};\n      }\n\n      //Set defaults\n      if (typeof this.info.board.width === 'undefined') {\n        this.info.board.width = this.config.defaultSize;\n      }\n      if (typeof this.info.board.height === 'undefined') {\n        this.info.board.height = this.config.defaultSize;\n      }\n      if (typeof this.info.game.komi === 'undefined') {\n        this.info.game.komi = this.config.defaultKomi;\n      }\n      if (typeof this.info.game.handicap === 'undefined') {\n        this.info.game.handicap = this.config.defaultHandicap;\n      }\n    };\n\n    /*****************************************************************************\n     * Node navigation helpers\n     ***/\n\n    /**\n     * Navigate to the next node\n     */\n    var nextNode = function(i) {\n\n      //Check if we have children\n      if (this.node.children.length === 0) {\n        return false;\n      }\n\n      //Remembered the path we took earlier?\n      if (i === undefined) {\n        i = this.node._remembered_path;\n      }\n\n      //Determine which child node to process\n      i = i || 0;\n      if (i === -1) {\n        i = 0;\n      }\n\n      //Validate\n      if (i >= this.node.children.length || !this.node.children[i]) {\n        return false;\n      }\n\n      //Advance path\n      this.path.advance(i);\n\n      //Set pointer of current node\n      this.node = this.node.children[i];\n      return true;\n    };\n\n    /**\n     * Navigate to the previous node\n     */\n    var previousNode = function() {\n\n      //No parent node?\n      if (!this.node.parent) {\n        return false;\n      }\n\n      //Retreat path\n      this.path.retreat();\n\n      //Set pointer of current node\n      this.node = this.node.parent;\n      return true;\n    };\n\n    /**\n     * Navigate to the first node\n     */\n    var firstNode = function() {\n\n      //Reset path\n      this.path.reset();\n\n      //Set node pointer back to root\n      this.node = this.root;\n\n      //Set the initial turn depending on handicap\n      //Can be overwritten by game record instructions\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\n    };\n\n    /*****************************************************************************\n     * Position history helpers\n     ***/\n\n    /**\n     * Clear the position history and initialize with a blank position\n     */\n    var initializeHistory = function() {\n\n      //Already at beginning?\n      if (this.history.length === 1) {\n        return;\n      }\n\n      //Clear positions stack and create new blank position\n      this.history = [];\n      this.history.push(new GamePosition());\n\n      //Set board size if we have the info\n      if (this.info.board) {\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\n      }\n    };\n\n    /**\n     * Add position to stack. If position isn't specified current position is\n     * cloned and stacked. Pointer of actual position is moved to the new position.\n     */\n    var pushPosition = function(newPosition) {\n\n      //Position not given?\n      if (!newPosition) {\n        newPosition = this.position.clone();\n      }\n\n      //Push\n      this.history.push(newPosition);\n      return newPosition;\n    };\n\n    /**\n     * Remove current position from stack\n     */\n    var popPosition = function() {\n\n      //Nothing left?\n      if (this.history.length === 0) {\n        return null;\n      }\n\n      //Get old position\n      return this.history.pop();\n    };\n\n    /**\n     * Replace the current position in the stack\n     */\n    var replacePosition = function(newPosition) {\n      if (newPosition) {\n        this.history.pop();\n        this.history.push(newPosition);\n      }\n    };\n\n    /*****************************************************************************\n     * Execution helpers\n     ***/\n\n    /**\n     * Execute the current node\n     */\n    var executeNode = function() {\n\n      //Remember last selected node if we have a parent\n      if (this.node.parent) {\n        this.node.parent._remembered_path = this.node.parent.children.indexOf(this.node);\n      }\n\n      //Initialize new position\n      var i;\n      var newPosition = this.position.clone();\n\n      //Handle moves\n      if (this.node.move) {\n        if (this.node.move.pass) {\n          newPosition.setTurn(-this.node.move.color);\n        }\n        else {\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\n        }\n      }\n\n      //Handle turn instructions\n      if (this.node.turn) {\n        newPosition.setTurn(this.node.turn);\n      }\n\n      //Handle setup instructions\n      if (this.node.setup) {\n        for (i in this.node.setup) {\n          if (this.node.setup.hasOwnProperty(i)) {\n            newPosition.stones.set(\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\n            );\n          }\n        }\n      }\n\n      //Handle markup\n      if (this.node.markup) {\n        for (i in this.node.markup) {\n          if (this.node.markup.hasOwnProperty(i)) {\n            newPosition.markup.set(\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\n            );\n          }\n        }\n      }\n\n      //Push the new position into the history now\n      pushPosition.call(this, newPosition);\n    };\n\n    /*****************************************************************************\n     * Game class\n     ***/\n\n    /**\n     * Constructor\n     */\n    var Game = function(data, config) {\n\n      //Extend config\n      this.config = angular.extend({}, defaultConfig, config || {});\n\n      //Define property getter/setter for position\n      Object.defineProperty(this, 'position', {\n\n        //Getter returns the last position from the stack\n        get: function() {\n          return this.history[this.history.length - 1];\n        },\n\n        //Setter adds a new position to the stack\n        set: function(newPosition) {\n          this.history[this.history.length] = newPosition;\n        }\n      });\n\n      //Load data\n      if (data) {\n        this.load(data);\n      }\n      else {\n        this.init();\n      }\n    };\n\n    /**\n     * Initialize\n     */\n    Game.prototype.init = function() {\n\n      //Info properties\n      this.info = {};\n\n      //The rood node and pointer to the current node\n      this.root = null;\n      this.node = null;\n\n      //Game path\n      this.path = new GamePath();\n\n      //JGF record we loaded from\n      this.jgf = null;\n\n      //Positions history stack\n      this.history = [];\n    };\n\n    /**\n     * Load game record data\n     */\n    Game.prototype.load = function(data) {\n\n      //Initialize\n      this.init();\n\n      //Try to load game record data\n      try {\n        this.fromData(data);\n      }\n      catch (errorCode) {\n\n        //Just initialize our history with a blank position\n        initializeHistory.call(this);\n\n        //Wrap error code in error object\n        throw new InvalidDataError(errorCode);\n      }\n\n      //Go to the first move\n      this.first();\n    };\n\n    /**\n     * Reload game record\n     */\n    Game.prototype.reload = function() {\n      if (this.jgf) {\n        this.load(this.jgf);\n      }\n    };\n\n    /**\n     * Check if we managed to load a valid game record\n     */\n    Game.prototype.isLoaded = function() {\n      return this.root !== null;\n    };\n\n    /*****************************************************************************\n     * Game cloning and conversion\n     ***/\n\n    /**\n     * Clone this game\n     */\n    Game.prototype.clone = function() {\n\n      //Create new kifu object and get properties\n      var clone = new Game();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy all properties\n      for (var p = 0; p < props.length; p++) {\n        clone[p] = angular.copy(this[p]);\n      }\n\n      //Return clone\n      return clone;\n    };\n\n    /**\n     * Load from an unknown data source\n     */\n    Game.prototype.fromData = function(data) {\n\n      //No data, can't do much\n      if (!data) {\n        throw ngGo.error.NO_DATA;\n      }\n\n      //String given, could be stringified JGF, an SGF or GIB file\n      if (typeof data === 'string') {\n        var c = data.charAt(0);\n        if (c === '(') {\n          return this.fromSgf(data);\n        }\n        else if (c === '{' || c === '[') {\n          return this.fromJgf(data);\n        }\n        else if (c === '\\\\') {\n          return this.fromGib(data);\n        }\n        else {\n          throw ngGo.error.UNKNOWN_DATA;\n        }\n      }\n\n      //Object given? Probably a JGF object\n      else if (typeof data === 'object') {\n        this.fromJgf(data);\n      }\n\n      //Something else?\n      else {\n        throw ngGo.error.UNKNOWN_DATA;\n      }\n    };\n\n    /**\n     * Load from GIB data\n     */\n    Game.prototype.fromGib = function(gib) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.gib2jgf(gib);\n      if (!jgf) {\n        throw ngGo.error.INVALID_GIB;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from SGF data\n     */\n    Game.prototype.fromSgf = function(sgf) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.sgf2jgf(sgf);\n      if (!jgf) {\n        throw ngGo.error.INVALID_SGF;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from JGF data\n     */\n    Game.prototype.fromJgf = function(jgf) {\n\n      //Parse jgf string\n      if (typeof jgf === 'string') {\n        try {\n          jgf = angular.fromJson(jgf);\n        }\n        catch (error) {\n          throw ngGo.error.INVALID_JGF_JSON;\n        }\n      }\n\n      //If array given, convert to object with only tree\n      if (angular.isArray(jgf)) {\n        jgf = {\n          tree: jgf\n        };\n      }\n\n      //Parse tree string\n      if (typeof jgf.tree === 'string') {\n        if (jgf.tree.charAt(0) === '[') {\n          try {\n            jgf.tree = angular.fromJson(jgf.tree);\n          }\n          catch (error) {\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\n          }\n        }\n        else {\n          jgf.tree = [];\n        }\n      }\n\n      //Copy all properties except moves tree\n      for (var i in jgf) {\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\n          this.info[i] = angular.copy(jgf[i]);\n        }\n      }\n\n      //Validate info\n      validateInfo.call(this);\n\n      //Create root node\n      this.root = new GameNode();\n\n      //Tree given? Load all the moves\n      if (jgf.tree) {\n        this.root.fromJgf(jgf.tree);\n      }\n\n      //Remember JGF\n      this.jgf = jgf;\n    };\n\n    /**\n     * Convert to SGF\n     */\n    Game.prototype.toSgf = function() {\n      return KifuParser.jgf2sgf(this.toJgf());\n    };\n\n    /**\n     * Convert to JGF (optionally stringified)\n     */\n    Game.prototype.toJgf = function(stringify) {\n\n      //Initialize JGF and get properties\n      var jgf = KifuBlank.jgf();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy properties\n      for (var p = 0; p < props.length; p++) {\n\n        //Skip root\n        if (p === 'root') {\n          continue;\n        }\n\n        //Already present on JGF object? Extend\n        if (jgf[p]) {\n          jgf[p] = angular.extend(jgf[p], this[p]);\n        }\n\n        //Otherwise copy\n        else {\n          jgf[p] = angular.copy(this[p]);\n        }\n      }\n\n      //Build tree\n      jgf.tree = this.root.toJgf();\n\n      //Return\n      return stringify ? angular.toJson(jgf) : jgf;\n    };\n\n    /*****************************************************************************\n     * Getters\n     ***/\n\n    /**\n     * Get current node\n     */\n    Game.prototype.getNode = function() {\n      return this.node;\n    };\n\n    /**\n     * Get node for a certain move\n     */\n    Game.prototype.getMoveNodeAt = function(move) {\n\n      //Must have a move number\n      move = move || 1;\n\n      //Initialize node to process\n      var node = this.root;\n      var moveNo = 0;\n\n      //Process children\n      while (node) {\n\n        //Get child node\n        node = node.getChild(node._remembered_path);\n        if (node && node.move) {\n          moveNo++;\n        }\n\n        //Reached move?\n        if (moveNo === move) {\n          return node;\n        }\n      }\n\n      //No move node found\n      return null;\n    };\n\n    /**\n     * Get move nodes restricted by given move numbers\n     */\n    Game.prototype.getMoveNodes = function(fromMove, toMove) {\n\n      //Use sensible defaults if no from/to moves given\n      fromMove = fromMove || 1;\n      toMove = toMove || this.getMoveCount();\n\n      //Get the first node\n      var node = this.getMoveNodeAt(fromMove);\n      if (!node) {\n        return [];\n      }\n\n      //Initialize nodes array and counter\n      var nodes = [node];\n      var move = fromMove;\n\n      //Loop nodes\n      while (node && move < toMove) {\n\n        //Get node child\n        node = node.getChild(node._remembered_path);\n        if (!node || !node.move) {\n          continue;\n        }\n\n        //Add count and add to array\n        move++;\n        nodes.push(node);\n      }\n\n      //Return array of nodes\n      return nodes;\n    };\n\n    /**\n     * Get the current game position\n     */\n    Game.prototype.getPosition = function() {\n      return this.position;\n    };\n\n    /**\n     * Get the game path\n     */\n    Game.prototype.getPath = function(clone) {\n      if (clone) {\n        return this.path.clone();\n      }\n      return this.path;\n    };\n\n    /**\n     * Clone the current game path\n     */\n    Game.prototype.clonePath = function() {\n      return this.path.clone();\n    };\n\n    /**\n     * Get the game path to a certain named node\n     */\n    Game.prototype.getPathToNode = function(nodeName) {\n      return GamePath.findNode(nodeName, this.root);\n    };\n\n    /**\n     * Get the game komi\n     */\n    Game.prototype.getKomi = function() {\n      var komi = this.get('game.komi', 0);\n      return parseFloat(komi);\n    };\n\n    /**\n     * Set the game komi\n     */\n    Game.prototype.setKomi = function(komi) {\n      if (typeof komi === 'undefined') {\n        komi = this.config.defaultKomi;\n      }\n      this.info.game.komi = parseFloat(komi);\n    };\n\n    /**\n     * Get the game name\n     */\n    Game.prototype.getName = function() {\n      return this.get('game.name', '');\n    };\n\n    /**\n     * Get the game result\n     */\n    Game.prototype.getResult = function() {\n      return this.get('game.result', '');\n    };\n\n    /**\n     * Get the player turn for this position\n     */\n    Game.prototype.getTurn = function() {\n\n      //Must have a position\n      if (!this.history.length) {\n        return StoneColor.B;\n      }\n\n      //Get from position\n      return this.position.getTurn();\n    };\n\n    /**\n     * Set the player turn for the current position\n     */\n    Game.prototype.setTurn = function(color) {\n\n      //Must have a position\n      if (!this.history.length) {\n        return;\n      }\n\n      //Set in position\n      this.position.setTurn(color);\n    };\n\n    /**\n     * Get the total capture count up to the current position\n     */\n    Game.prototype.getCaptureCount = function() {\n\n      //Initialize\n      var captures = {};\n      captures[StoneColor.B] = 0;\n      captures[StoneColor.W] = 0;\n\n      //Loop all positions and increment capture count\n      for (var i = 0; i < this.history.length; i++) {\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\n      }\n\n      //Return\n      return captures;\n    };\n\n    /**\n     * Get the move variation for given coordinates\n     */\n    Game.prototype.getMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.getMoveVariation(x, y);\n      }\n      return -1;\n    };\n\n    /**\n     * Get current move number\n     */\n    Game.prototype.getMove = function() {\n      return this.path.getMove();\n    };\n\n    /**\n     * Get the number of moves in the main branch\n     */\n    Game.prototype.getMoveCount = function() {\n\n      //Initialize node to process\n      var node = this.root;\n      var noMoves = 0;\n\n      //Process children\n      while (node) {\n        node = node.getChild(node._remembered_path);\n        if (node && node.move) {\n          noMoves++;\n        }\n      }\n\n      //Return move count\n      return noMoves;\n    };\n\n    /**\n     * Get an info property\n     */\n    Game.prototype.get = function(property, defaultValue) {\n\n      //Must have a property\n      if (!property) {\n        return;\n      }\n\n      //The item's property in the object is given by dot separated strings\n      if (typeof property === 'string') {\n        property = property.split('.');\n      }\n\n      //Initialize object we're getting info from\n      var obj = this.info;\n      var key;\n\n      //Loop the properties\n      for (var p = 0; p < property.length; p++) {\n\n        //Get actual key\n        key = property[p];\n\n        //Last key reached? Done, get value\n        if ((p + 1) === property.length) {\n          if (typeof obj[key] === 'undefined') {\n            return defaultValue;\n          }\n          return obj[key];\n        }\n\n        //Must be object container\n        if (typeof obj[key] !== 'object') {\n          console.warn('Game info property', key, 'is not an object');\n          return defaultValue;\n        }\n\n        //Move up in tree\n        obj = obj[key];\n      }\n    };\n\n    /*****************************************************************************\n     * Checkers\n     ***/\n\n    /**\n     * Check if coordinates are on the board\n     */\n    Game.prototype.isOnBoard = function(x, y) {\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\n    };\n\n    /**\n     * Check if given coordinates are one of the next child node coordinates\n     */\n    Game.prototype.isMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.isMoveVariation(x, y);\n      }\n      return false;\n    };\n\n    /**\n     * Check if a given position is repeating within this game\n     */\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\n\n      //Init\n      var stop;\n\n      //Check for ko only? (Last two positions)\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\n        stop = this.history.length - 2;\n      }\n\n      //Check all history?\n      else if (this.checkRepeat === 'ALL') {\n        stop = 0;\n      }\n\n      //Not repeating\n      else {\n        return false;\n      }\n\n      //Loop history of positions to check\n      for (var i = this.history.length - 2; i >= stop; i--) {\n        if (checkPosition.isSameAs(this.history[i])) {\n          return true;\n        }\n      }\n\n      //Not repeating\n      return false;\n    };\n\n    /**\n     * Wrapper for validateMove() returning a boolean and catching any errors\n     */\n    Game.prototype.isValidMove = function(x, y, color) {\n      try {\n        this.validateMove(x, y, color);\n        return true;\n      }\n      catch (error) {\n        return false;\n      }\n    };\n\n    /**\n     * Check if a move is valid. If valid, the new game position object is returned.\n     * You can supply a pre-created position to use, or the current position is cloned.\n     */\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Something already here?\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\n      }\n\n      //Set color of move to make\n      color = color || this.position.getTurn();\n\n      //Determine position to use\n      newPosition = newPosition || this.position.clone();\n\n      //Place the stone\n      newPosition.stones.set(x, y, color);\n\n      //Capture adjacent stones if possible\n      var captures = newPosition.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created?\n        if (!newPosition.hasLiberties(x, y)) {\n\n          //Capture the group if it's allowed\n          if (this.allowSuicide) {\n            newPosition.captureGroup(x, y);\n          }\n\n          //Invalid move\n          else {\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\n          }\n        }\n      }\n\n      //Check history for repeating moves\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\n      }\n\n      //Set proper turn\n      newPosition.setTurn(-color);\n\n      //Move is valid\n      return newPosition;\n    };\n\n    /**\n     * Check if a stone (setup) placement is valid.\n     */\n    Game.prototype.validatePlacement = function(x, y, color, position) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Place the stone\n      position.stones.set(x, y, color);\n\n      //Empty spot? Don't need to check for captures\n      if (color === StoneColor.EMPTY) {\n        return;\n      }\n\n      //Capture adjacent stones if possible\n      var captures = position.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created? Capture it\n        if (!position.hasLiberties(x, y)) {\n          position.captureGroup(x, y);\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Stone and markup handling\n     ***/\n\n    /**\n     * Add a stone\n     */\n    Game.prototype.addStone = function(x, y, color) {\n\n      //Check if there's anything to do at all\n      if (this.position.stones.is(x, y, color)) {\n        return;\n      }\n\n      //Create temporary position\n      var tempPosition = this.position.clone();\n\n      //Validate placement on temp position\n      this.validatePlacement(x, y, color, tempPosition);\n\n      //No setup instructions container in this node?\n      if (typeof this.node.setup === 'undefined') {\n\n        //Is this a move node?\n        if (this.node.move) {\n\n          //Clone our position\n          pushPosition.call(this);\n\n          //Create new node\n          var node = new GameNode();\n\n          //Append it to the current node and change the pointer\n          var i = node.appendTo(this.node);\n          this.node = node;\n\n          //Advance path to the added node index\n          this.path.advance(i);\n        }\n\n        //Create setup container in this node\n        this.node.setup = [];\n      }\n\n      //Replace current position\n      replacePosition.call(this, tempPosition);\n\n      //Add setup instructions to node\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\n    };\n\n    /**\n     * Add markup\n     */\n    Game.prototype.addMarkup = function(x, y, markup) {\n\n      //No markup instructions container in this node?\n      if (typeof this.node.markup === 'undefined') {\n        this.node.markup = [];\n      }\n\n      //Add markup to game position\n      this.position.markup.set(x, y, markup);\n\n      //Add markup instructions to node\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\n    };\n\n    /**\n     * Remove a stone\n     */\n    Game.prototype.removeStone = function(x, y) {\n\n      //Check if the stone is found in setup instructions\n      var foundInSetup = false;\n\n      //Remove from node setup instruction\n      if (typeof this.node.setup !== 'undefined') {\n        for (var i = 0; i < this.node.setup.length; i++) {\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\n\n            //Remove from node and unset in position\n            this.node.setup.splice(i, 1);\n            this.position.stones.unset(x, y);\n\n            //Mark as found\n            foundInSetup = true;\n            break;\n          }\n        }\n      }\n\n      //Not found in setup? Add as no stone color\n      if (!foundInSetup) {\n        this.addStone(x, y, StoneColor.EMPTY);\n      }\n    };\n\n    /**\n     * Remove markup\n     */\n    Game.prototype.removeMarkup = function(x, y) {\n\n      //Remove from node\n      if (typeof this.node.markup !== 'undefined') {\n        for (var i = 0; i < this.node.markup.length; i++) {\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\n            this.node.markup.splice(i, 1);\n            this.position.markup.unset(x, y);\n            break;\n          }\n        }\n      }\n    };\n\n    /**\n     * Check if there is a stone at the given coordinates for the current position\n     */\n    Game.prototype.hasStone = function(x, y, color) {\n      if (typeof color !== 'undefined') {\n        return this.position.stones.is(x, y, color);\n      }\n      return this.position.stones.has(x, y);\n    };\n\n    /**\n     * Check if there is markup at the given coordinate for the current position\n     */\n    Game.prototype.hasMarkup = function(x, y, type) {\n      if (typeof type !== 'undefined') {\n        return this.position.markup.is(x, y, type);\n      }\n      return this.position.markup.has(x, y);\n    };\n\n    /**\n     * Get stone on coordinates\n     */\n    Game.prototype.getStone = function(x, y) {\n      return this.position.stones.get(x, y);\n    };\n\n    /**\n     * Get markup on coordinates\n     */\n    Game.prototype.getMarkup = function(x, y) {\n      return this.position.markup.get(x, y);\n    };\n\n    /*****************************************************************************\n     * Move handling\n     ***/\n\n    /**\n     * Play move\n     */\n    Game.prototype.play = function(x, y, color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Validate move and get new position\n      var newPosition = this.validateMove(x, y, color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          x: x,\n          y: y,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node._remembered_path = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n\n      //Valid move\n      return true;\n    };\n\n    /**\n     * Play pass\n     */\n    Game.prototype.pass = function(color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Initialize new position and switch the turn\n      var newPosition = this.position.clone();\n      newPosition.setTurn(-color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          pass: true,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node._remembered_path = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n    };\n\n    /*****************************************************************************\n     * Game tree navigation\n     ***/\n\n    /**\n     * Go to the next position\n     */\n    Game.prototype.next = function(i) {\n\n      //Object (node) given as parameter? Find index\n      if (typeof i === 'object') {\n        i = this.node.children.indexOf(i);\n      }\n\n      //Go to the next node\n      if (nextNode.call(this, i)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n          return true;\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n\n      //Didn't go to next position\n      return false;\n    };\n\n    /**\n     * Go to the previous position\n     */\n    Game.prototype.previous = function() {\n\n      //Go to the previous node\n      if (previousNode.call(this)) {\n        popPosition.call(this);\n        return true;\n      }\n\n      //Didn't go to previous position\n      return false;\n    };\n\n    /**\n     * Go to the last position\n     */\n    Game.prototype.last = function() {\n\n      //Keep going to the next node until we reach the end\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the first position\n     */\n    Game.prototype.first = function() {\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      executeNode.call(this);\n    };\n\n    /**\n     * Go to position specified by a path object, a numeric move numer, or a node name string\n     */\n    Game.prototype.goto = function(target) {\n\n      //Must have a tree\n      if (this.root === null) {\n        return;\n      }\n\n      //Nothing given?\n      if (typeof target === 'undefined') {\n        return;\n      }\n\n      //Function given? Call now\n      if (typeof target === 'function') {\n        target = target.call(this);\n      }\n\n      //Initialize path\n      var path;\n\n      //Simple move number? Convert to path object\n      if (typeof target === 'number') {\n        path = this.path.clone();\n        path.setMove(target);\n      }\n\n      //String? Named node\n      else if (typeof target === 'string') {\n\n        //Already here?\n        if (this.node.name === target) {\n          return;\n        }\n\n        //Find path to node\n        path = this.getPathToNode(target);\n        if (path === null) {\n          return;\n        }\n      }\n\n      //Otherwise assume path object\n      else {\n        path = target;\n      }\n\n      //Already here?\n      if (this.path.compare(path)) {\n        return;\n      }\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      pushPosition.call(this);\n      executeNode.call(this);\n\n      //Loop path\n      var n = path.getMove();\n      for (var i = 0; i < n; i++) {\n\n        //Try going to the next node\n        if (!nextNode.call(this, path.nodeAt(i))) {\n          break;\n        }\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the next fork\n     */\n    Game.prototype.nextFork = function() {\n\n      //Keep going to the next node until we reach one with multiple children\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Have multiple children?\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous fork\n     */\n    Game.prototype.previousFork = function() {\n\n      //Loop until we find a node with more than one child\n      while (previousNode.call(this)) {\n        popPosition.call(this);\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the next move with comments\n     */\n    Game.prototype.nextComment = function() {\n\n      //Keep going to the next node until we find one with comments\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous move with comments\n     */\n    Game.prototype.previousComment = function() {\n\n      //Go back until we find a node with comments\n      while (previousNode.call(this)) {\n\n        //Pop the position\n        popPosition.call(this);\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state\n     */\n    Game.prototype.getState = function() {\n\n      //Can only create when we have a JGF and path\n      if (!this.jgf || !this.path) {\n        return null;\n      }\n\n      //Create state\n      var state = {\n        jgf: this.jgf,\n        path: this.path.clone()\n      };\n\n      //Return\n      return state;\n    };\n\n    /**\n     * Restore the game state\n     */\n    Game.prototype.restoreState = function(state) {\n\n      //Must have jgf and path\n      if (!state || !state.jgf || !state.path) {\n        return;\n      }\n\n      //Restore state\n      this.load(state.jgf);\n      this.goto(state.path);\n    };\n\n    //Return object\n    return Game;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GameNode :: This class represents a single node in the game moves tree. It contains\n * properties like the x and y grid coordinates, the move played, board setup instructions,\n * markup, player turn and comments. The moves tree in the game record is represented by a\n * string of GameNodes, each with pointers to their parent and children. Each node can have\n * multiple children (move variations), but only one parent.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Node.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameNode', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /**\n   * Helper to construct a coordinates base object\n   */\n  var coordinatesObject = function(coords, baseObject) {\n    baseObject = baseObject || {};\n    if (coords === '' || coords === 'pass') {\n      baseObject.pass = true;\n    }\n    else {\n\n      //Backwards compatibility with SGF string coordinates in JGF\n      if (typeof coords === 'string') {\n        coords = convertCoordinates(coords);\n      }\n\n      //Append coordinates\n      baseObject.x = coords[0] * 1;\n      baseObject.y = coords[1] * 1;\n    }\n    return baseObject;\n  };\n\n  /**\n   * Convert a numeric color value (color constant) to a string\n   */\n  var toStringColor = function(color) {\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\n  };\n\n  /**\n   * Convert a string color value to a numeric color constant\n   */\n  var toColorConstant = function(color) {\n    if (color === 'B') {\n      return StoneColor.B;\n    }\n    else if (color === 'W') {\n      return StoneColor.W;\n    }\n    return StoneColor.E;\n  };\n\n  /*****************************************************************************\n   * Helpers for conversion between JGF / KIFU format\n   ***/\n\n  /**\n   * Convert move object to JGF format\n   */\n  var convertMoveToJgf = function(move) {\n\n    //Initialize JGF move object and determine color\n    var jgfMove = angular.copy(move);\n    var color = toStringColor(move.color);\n\n    //No color?\n    if (color === '') {\n      return null;\n    }\n\n    //Pass move?\n    if (move.pass === true) {\n      jgfMove[color] = 'pass';\n    }\n\n    //Regular move\n    else {\n      jgfMove[color] = [move.x, move.y];\n    }\n\n    //Delete coordinates and color\n    delete jgfMove.x;\n    delete jgfMove.y;\n    delete jgfMove.color;\n\n    //Return move\n    return jgfMove;\n  };\n\n  /**\n   * Convert move from JGF format\n   */\n  var convertMoveFromJgf = function(move) {\n\n    //Prepare color, coordinates\n    var color, coords;\n\n    //Check whose move it was\n    if (move.W) {\n      color = 'W';\n      coords = move.W;\n    }\n    else if (move.B) {\n      color = 'B';\n      coords = move.B;\n    }\n\n    //No coordinates?\n    if (!coords) {\n      return null;\n    }\n\n    //Return coordinates object\n    return coordinatesObject(coords, {\n      color: toColorConstant(color)\n    });\n  };\n\n  /**\n   * Convert setup object to JGF format\n   */\n  var convertSetupToJgf = function(setup) {\n\n    //Initialize variables\n    var i, color;\n    var jgfSetup = {};\n\n    //Loop setup objects\n    for (i in setup) {\n      if (setup.hasOwnProperty(i)) {\n\n        //Get color\n        color = toStringColor(setup[i].color) || 'E';\n\n        //Initialize array\n        if (typeof jgfSetup[color] === 'undefined') {\n          jgfSetup[color] = [];\n        }\n\n        //Add coordinates\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\n      }\n    }\n\n    //Return\n    return jgfSetup;\n  };\n\n  /**\n   * Convert setup from JGF format\n   */\n  var convertSetupFromJgf = function(setup) {\n\n    //Initialize variables\n    var c, key, color;\n    var gameSetup = [];\n\n    //Loop setup\n    for (key in setup) {\n      if (setup.hasOwnProperty(key)) {\n\n        //Get color constant\n        color = toColorConstant(key);\n\n        //Loop coordinates\n        for (c in setup[key]) {\n          if (setup[key].hasOwnProperty(c)) {\n            gameSetup.push(coordinatesObject(setup[key][c], {\n              color: color\n            }));\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameSetup;\n  };\n\n  /**\n   * Convert markup object to JGF format\n   */\n  var convertMarkupToJgf = function(markup) {\n\n    //Initialize variables\n    var i, type;\n    var jgfMarkup = {};\n\n    //Loop setup objects\n    for (i in markup) {\n      if (markup.hasOwnProperty(i)) {\n\n        //Get type\n        type = markup[i].type;\n\n        //Initialize array\n        if (typeof jgfMarkup[type] === 'undefined') {\n          jgfMarkup[type] = [];\n        }\n\n        //Label?\n        if (type === 'label') {\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\n        }\n        else {\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\n        }\n      }\n    }\n\n    //Return\n    return jgfMarkup;\n  };\n\n  /**\n   * Convert markup from JGF format\n   */\n  var convertMarkupFromJgf = function(markup) {\n\n    //Initialize variables\n    var l, type;\n    var gameMarkup = [];\n\n    //Loop markup types\n    for (type in markup) {\n      if (markup.hasOwnProperty(type)) {\n\n        //Label?\n        if (type === 'label') {\n          for (l = 0; l < markup[type].length; l++) {\n\n            //Validate\n            if (!angular.isArray(markup[type][l])) {\n              continue;\n            }\n\n            //SGF type coordinates?\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\n              var text = markup[type][l][1];\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\n              markup[type][l].push(text);\n            }\n\n            //Validate length\n            if (markup[type][l].length < 3) {\n              continue;\n            }\n\n            //Add to stack\n            gameMarkup.push(coordinatesObject(markup[type][l], {\n              type: type,\n              text: markup[type][l][2]\n            }));\n          }\n        }\n        else {\n\n          //Loop coordinates\n          for (l in markup[type]) {\n            if (markup[type].hasOwnProperty(l)) {\n              gameMarkup.push(coordinatesObject(markup[type][l], {\n                type: type\n              }));\n            }\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameMarkup;\n  };\n\n  /**\n   * Convert turn object to JGF format\n   */\n  var convertTurnToJgf = function(turn) {\n    switch (turn) {\n      case StoneColor.W:\n        return 'W';\n      case StoneColor.B:\n        return 'B';\n      default:\n        return '';\n    }\n  };\n\n  /**\n   * Convert turn from JGF format\n   */\n  var convertTurnFromJgf = function(turn) {\n    switch (turn) {\n      case 'W':\n        return StoneColor.W;\n      case 'B':\n        return StoneColor.B;\n      default:\n        return StoneColor.EMPTY;\n    }\n  };\n\n  /**\n   * Conversions map\n   */\n  var conversionMap = {\n    toJgf: {\n      move: convertMoveToJgf,\n      setup: convertSetupToJgf,\n      markup: convertMarkupToJgf,\n      turn: convertTurnToJgf\n    },\n    fromJgf: {\n      move: convertMoveFromJgf,\n      setup: convertSetupFromJgf,\n      markup: convertMarkupFromJgf,\n      turn: convertTurnFromJgf\n    }\n  };\n\n  /**\n   * Constructor\n   */\n  var GameNode = function(properties, parent) {\n\n    //Set parent and children\n    this.parent = parent || null;\n    this.children = [];\n\n    //Save properties\n    if (properties) {\n      for (var key in properties) {\n        if (properties.hasOwnProperty(key)) {\n          this[key] = properties[key];\n        }\n      }\n    }\n  };\n\n  /**\n   * Get node's child specified by index or null if doesn't exist\n   */\n  GameNode.prototype.getChild = function(i) {\n    i = i || 0;\n    if (this.children[i]) {\n      return this.children[i];\n    }\n    return null;\n  };\n\n  /**\n   * Get all the children\n   */\n  GameNode.prototype.getChildren = function() {\n    return this.children;\n  };\n\n  /**\n   * Check if the node has any chilren\n   */\n  GameNode.prototype.hasChildren = function() {\n    return (this.children.length > 0);\n  };\n\n  /**\n   * Check if the node has more than one move variation\n   */\n  GameNode.prototype.hasMoveVariations = function() {\n\n    //Less than two child nodes?\n    if (this.children.length <= 1) {\n      return false;\n    }\n\n    //Loop children\n    var moveVariations = 0;\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].move) {\n        moveVariations++;\n      }\n\n      //More than one move node present?\n      if (moveVariations > 1) {\n        return true;\n      }\n    }\n\n    //No move variations\n    return false;\n  };\n\n  /**\n   * Get all the move variation nodes\n   */\n  GameNode.prototype.getMoveVariations = function() {\n\n    //No child nodes?\n    if (this.children.length === 0) {\n      return false;\n    }\n\n    //Initialize\n    var moveVariations = [];\n\n    //Loop child nodes\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].move) {\n        moveVariations.push(this.children[i]);\n      }\n    }\n\n    //Return\n    return moveVariations;\n  };\n\n  /**\n   * Get the move variation for given coordinates\n   */\n  GameNode.prototype.getMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return i;\n      }\n    }\n\n    //Not found\n    return -1;\n  };\n\n  /**\n   * Check if given coordinates are one of the next child node coordinates\n   */\n  GameNode.prototype.isMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return true;\n      }\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Check if we have comments\n   */\n  GameNode.prototype.hasComments = function() {\n    return (this.comments && this.comments.length > 0);\n  };\n\n  /*****************************************************************************\n   * Node manipulation\n   ***/\n\n  /**\n   * Remove this node from its parent\n   */\n  GameNode.prototype.remove = function() {\n\n    //Can't remove if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found remove it\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1) {\n      this.parent.children.splice(i, 1);\n    }\n\n    //Clear parent reference\n    this.parent = null;\n  };\n\n  /**\n   * Move the node up in the parent's child tree\n   */\n  GameNode.prototype.moveUp = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i > 0) {\n      var temp = this.parent.children[i - 1];\n      this.parent.children[i - 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Move the node down in the parent's child tree\n   */\n  GameNode.prototype.moveDown = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\n      var temp = this.parent.children[i + 1];\n      this.parent.children[i + 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Append this node to another node\n   */\n  GameNode.prototype.appendTo = function(node) {\n\n    //Remove from existing parent\n    this.remove();\n\n    //Set new parent\n    this.parent = node;\n    node.children.push(this);\n    return node.children.length - 1;\n  };\n\n  /**\n   * Append child node to this node.\n   */\n  GameNode.prototype.appendChild = function(node) {\n    node.parent = this;\n    this.children.push(node);\n    return this.children.length - 1;\n  };\n\n  /**\n   * Insert another node after this one\n   */\n  GameNode.prototype.insertNode = function(node) {\n\n    //Loop our children and change parent node\n    for (var i = 0; i < this.children.length; i++) {\n      this.children[i].parent = node;\n    }\n\n    //Merge children, set this node as the parent of given node\n    node.children = node.children.concat(this.children);\n    node.parent = this;\n\n    //Set given node as the child of this node\n    this.children = [node];\n  };\n\n  /*****************************************************************************\n   * JGF conversion\n   ***/\n\n  /**\n   * Build a Game Node from a given JGF tree\n   */\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\n\n    //Root JGF file given?\n    if (typeof jgf.tree !== 'undefined') {\n      return GameNode.fromJgf(jgf.tree, gameNode);\n    }\n\n    //Initialize helper vars\n    var variationNode, nextNode, i, j;\n\n    //Node to work with given? Otherwise, work with ourselves\n    gameNode = gameNode || this;\n\n    //Loop moves in the JGF tree\n    for (i = 0; i < jgf.length; i++) {\n\n      //Array? That means a variation branch\n      if (angular.isArray(jgf[i])) {\n\n        //Loop variation stacks\n        for (j = 0; j < jgf[i].length; j++) {\n\n          //Build the variation node\n          variationNode = new GameNode();\n          variationNode.fromJgf(jgf[i][j]);\n\n          //Append to working node\n          gameNode.appendChild(variationNode);\n        }\n      }\n\n      //Regular node\n      else {\n\n        //Get properties to copy\n        var properties = Object.getOwnPropertyNames(jgf[i]);\n\n        //Copy node properties\n        for (var key in properties) {\n          if (properties.hasOwnProperty(key)) {\n            var prop = properties[key];\n\n            //Conversion function present?\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\n            }\n            else if (typeof jgf[i][prop] === 'object') {\n              gameNode[prop] = angular.copy(jgf[i][prop]);\n            }\n            else {\n              gameNode[prop] = jgf[i][prop];\n            }\n          }\n        }\n      }\n\n      //Next element is a regular node? Prepare new working node\n      //Otherwise, if there are no more nodes or if the next element is\n      //an array (e.g. variations), we keep our working node as the current one\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\n        nextNode = new GameNode();\n        gameNode.appendChild(nextNode);\n        gameNode = nextNode;\n      }\n    }\n  };\n\n  /**\n   * Convert this node to a JGF node container\n   */\n  GameNode.prototype.toJgf = function(container) {\n\n    //Initialize container to add nodes to\n    container = container || [];\n\n    //Initialize node and get properties\n    var node = {};\n    var properties = Object.getOwnPropertyNames(this);\n\n    //Copy node properties\n    for (var key in properties) {\n      if (properties.hasOwnProperty(key)) {\n        var prop = properties[key];\n\n        //Skip some properties\n        if (prop === 'parent' || prop === 'children') {\n          continue;\n        }\n\n        //Conversion function present?\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\n        }\n        else if (typeof this[prop] === 'object') {\n          node[prop] = angular.copy(this[prop]);\n        }\n        else {\n          node[prop] = this[prop];\n        }\n      }\n    }\n\n    //Add node to container\n    container.push(node);\n\n    //Variations present?\n    if (this.children.length > 1) {\n\n      //Create variations container\n      var variationsContainer = [];\n      container.push(variationsContainer);\n\n      //Loop child (variation) nodes\n      for (var i = 0; i < this.children.length; i++) {\n\n        //Create container for this variation\n        var variationContainer = [];\n        variationsContainer.push(variationContainer);\n\n        //Call child node converter\n        this.children[i].toJgf(variationContainer);\n      }\n    }\n\n    //Just one child?\n    else if (this.children.length === 1) {\n      this.children[0].toJgf(container);\n    }\n\n    //Return container\n    return container;\n  };\n\n  //Return object\n  return GameNode;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePath :: A simple class that keeps track of a path taken in a game.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Path.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePath', function() {\n\n  /**\n   * Constructor\n   */\n  var GamePath = function() {\n    this.reset();\n  };\n\n  /**\n   * Reset\n   */\n  GamePath.prototype.reset = function() {\n    this.move = 0;\n    this.path = {};\n    this.branches = 0;\n    return this;\n  };\n\n  /**\n   * Advance a move\n   */\n  GamePath.prototype.advance = function(i) {\n\n    //Different child variation chosen? Remember\n    if (i > 0) {\n      this.path[this.move] = 1;\n      this.branches++;\n    }\n\n    //Increment move\n    this.move++;\n    return this;\n  };\n\n  /**\n   * Retreat a move\n   */\n  GamePath.prototype.retreat = function() {\n\n    //At start?\n    if (this.move === 0) {\n      return;\n    }\n\n    //Delete path choice\n    if (this.path[this.move]) {\n      delete this.path[this.move];\n      this.branches--;\n    }\n\n    //Decrement move\n    this.move--;\n    return this;\n  };\n\n  /**\n   * Go to a specific move number\n   */\n  GamePath.prototype.setMove = function(no) {\n\n    //Less than our current move? We need to erase any paths above the move number\n    if (no < this.move) {\n      for (var i in this.path) {\n        if (i > no) {\n          delete this.path[i];\n          this.branches--;\n        }\n      }\n    }\n\n    //Set move number\n    this.move = no;\n    return this;\n  };\n\n  /**\n   * Get the move number\n   */\n  GamePath.prototype.getMove = function() {\n    return this.move;\n  };\n\n  /**\n   * Get the node choice at a specific move number\n   */\n  GamePath.prototype.nodeAt = function(no) {\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\n  };\n\n  /**\n   * Compare to another path\n   */\n  GamePath.prototype.compare = function(otherPath) {\n\n    //Invalid object?\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\n      return;\n    }\n\n    //Different move number or path length?\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\n      return false;\n    }\n\n    //Check path\n    for (var i in this.path) {\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\n        return false;\n      }\n    }\n\n    //Same path!\n    return true;\n  };\n\n  /**\n   * Clone\n   */\n  GamePath.prototype.clone = function() {\n\n    //Create new instance\n    var newPath = new GamePath();\n\n    //Set vars\n    newPath.move = this.move;\n    newPath.branches = this.branches;\n    newPath.path = angular.copy(this.path);\n\n    //Return\n    return newPath;\n  };\n\n  /**\n   * Helper to find node name recursively\n   */\n  var findNodeName = function(node, nodeName, path) {\n\n    //Found in this node?\n    if (node.name && node.name === nodeName) {\n      return true;\n    }\n\n    //Loop children\n    for (var i = 0; i < node.children.length; i++) {\n\n      //Advance path\n      path.advance(i);\n\n      //Found in child node?\n      if (findNodeName(node.children[i], nodeName, path)) {\n        return true;\n      }\n\n      //Not found in this child node, retreat path\n      path.retreat();\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Static helper to create a path object to reach a certain node\n   */\n  GamePath.findNode = function(nodeName, rootNode) {\n\n    //Create new instance\n    var path = new GamePath();\n\n    //Find the node name\n    if (findNodeName(rootNode, nodeName, path)) {\n      return path;\n    }\n\n    //Not found\n    return null;\n  };\n\n  //Return\n  return GamePath;\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\n * markup on the board in this position, as well as any captures that were made and which player's\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\n * compare changes to other positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Position.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePosition', ['StoneColor', 'BoardGrid', function(StoneColor, BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var GamePosition = function(width, height) {\n\n    //Initialize\n    this.error = 0;\n    this.width = 0;\n    this.height = 0;\n    this.stones = new BoardGrid();\n    this.markup = new BoardGrid();\n    this.turn = StoneColor.B;\n\n    //Initialize captures\n    this.captures = {};\n    this.captures[StoneColor.B] = [];\n    this.captures[StoneColor.W] = [];\n\n    //Set empty value for stones grid\n    this.stones.whenEmpty(StoneColor.EMPTY);\n\n    //Set size\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set the grid size\n   */\n  GamePosition.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Set in grids\n    this.stones.setSize(width, height);\n    this.markup.setSize(width, height);\n\n    //Empty the position\n    this.empty();\n  };\n\n  /**\n   * Clear the whole position\n   */\n  GamePosition.prototype.empty = function() {\n    this.stones.empty();\n    this.markup.empty();\n  };\n\n  /**\n   * Sets stone color at given coordinates.\n   */\n  GamePosition.prototype.setStone = function(x, y, color) {\n    this.stones.set(x, y, color);\n  };\n\n  /**\n   * Sets markup type at given coordinates.\n   */\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\n    this.markup.set(x, y, markup);\n  };\n\n  /*****************************************************************************\n   * Liberties and capturing\n   ***/\n\n  /**\n   * Check if a group of given color has liberties, starting at the given coordinates\n   */\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\n\n    //Out of bounds? No liberties outside of the board\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Initialize tested grid if needed\n    tested = tested || new BoardGrid(this.width, this.height);\n\n    //See what color is present on the coordinates\n    var color = this.stones.get(x, y);\n\n    //If no group color was given, use what's on the position\n    groupColor = groupColor || color;\n\n    //Already tested, or enemy stone? Not giving any liberties\n    if (tested.get(x, y) === true || color === -groupColor) {\n      return false;\n    }\n\n    //Empty? That's a liberty\n    if (color === StoneColor.EMPTY) {\n      return true;\n    }\n\n    //Mark this position as tested now\n    tested.set(x, y, true);\n\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\n    //If we get at least one true, we have a liberty\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\n        this.hasLiberties(x + 1, y, groupColor, tested);\n  };\n\n  /**\n   * Helper to capture adjacent groups\n   */\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    friendlyColor = friendlyColor || this.stones.get(x, y);\n\n    //Can't capture empty spots\n    if (friendlyColor === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Flag to see if we captured stuff\n    var captured = false;\n\n    //Check adjacent positions now, capturing stones in the process if possible\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n\n    //Return\n    return captured;\n  };\n\n  /**\n   * Helper if we can capture a certain group\n   */\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\n\n    //Out of bounds? Nothing to capture\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Empty spot? Can't capture\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //We need to have a stone of matching group color in order to be able to capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //There is a capturable stone, let's see if it has any liberties left\n    if (this.hasLiberties(x, y, enemyColor)) {\n      return false;\n    }\n\n    //No liberties left, the group is capturable. Capture if we want to\n    if (doCapture) {\n      this.captureGroup(x, y, enemyColor);\n    }\n\n    //Capturable\n    return true;\n  };\n\n  /**\n   * Capture a group of certain color, starting at the given coordinates\n   */\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //If no group color was given, use what's on the position\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //Stone at position does not match the given group color? Can't capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //Capture the stone\n    this.captureStone(x, y);\n\n    //Capture the rest of the group\n    this.captureGroup(x, y - 1, enemyColor);\n    this.captureGroup(x, y + 1, enemyColor);\n    this.captureGroup(x - 1, y, enemyColor);\n    this.captureGroup(x + 1, y, enemyColor);\n\n    //At least one stone was captured\n    return true;\n  };\n\n  /**\n   * Capture a stone at given coordinates\n   */\n  GamePosition.prototype.captureStone = function(x, y) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Get color\n    var color = this.stones.get(x, y);\n\n    //Empty?\n    if (color === StoneColor.EMPTY) {\n      return;\n    }\n\n    //Ok, stone present, capture it\n    this.stones.set(x, y, StoneColor.EMPTY);\n    this.captures[color].push({x: x, y: y});\n  };\n\n  /**\n   * Set captures for a color (expects array with capture object coordinates)\n   */\n  GamePosition.prototype.setCaptures = function(color, captures) {\n    this.captures[color] = captures;\n  };\n\n  /**\n   * Get captures for a color\n   */\n  GamePosition.prototype.getCaptures = function(color) {\n    return this.captures[color] || [];\n  };\n\n  /**\n   * Get the capture count for a color (= the number of captures of the opposing color)\n   */\n  GamePosition.prototype.getCaptureCount = function(color) {\n    return this.captures[-color].length;\n  };\n\n  /*****************************************************************************\n   * Turn control\n   ***/\n\n  /**\n   * Set color for whose move it is at this position\n   */\n  GamePosition.prototype.setTurn = function(color) {\n    this.turn = color;\n  };\n\n  /**\n   * Get color for whose move it is at this position\n   */\n  GamePosition.prototype.getTurn = function() {\n    return this.turn;\n  };\n\n  /**\n   * Switch the player turn on this position\n   */\n  GamePosition.prototype.switchTurn = function() {\n    this.turn = -this.turn;\n  };\n\n  /*****************************************************************************\n   * Cloning and comparison\n   ***/\n\n  /**\n   * Clones the whole position except turn and captures\n   */\n  GamePosition.prototype.clone = function() {\n\n    //Create a new position\n    var newPosition = new GamePosition();\n\n    //Set vars manually for maximum efficiency\n    newPosition.turn = this.turn;\n    newPosition.width = this.width;\n    newPosition.height = this.height;\n    newPosition.stones = this.stones.clone();\n    newPosition.markup = new BoardGrid(this.width, this.height);\n\n    //Return\n    return newPosition;\n  };\n\n  /**\n   * Checks if a given position is the same as the current position\n   */\n  GamePosition.prototype.isSameAs = function(newPosition) {\n\n    //Must have the same size\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\n      return false;\n    }\n\n    //Compare the grids\n    return this.stones.isSameAs(newPosition.stones);\n  };\n\n  //Return\n  return GamePosition;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScore :: A simple class that contains a game score\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Score.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScore', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Helper to calculate the total points\n   */\n  var calcTotal = function() {\n    return parseInt(this.stones) + parseInt(this.territory) +\n      parseInt(this.captures) + parseInt(this.komi);\n  };\n\n  /**\n   * Constructor\n   */\n  var GameScore = function() {\n\n    //Get self\n    var self = this;\n\n    //Setup score containers\n    this.black = {};\n    this.white = {};\n\n    //Initialize\n    this.reset();\n\n    //Add total handlers\n    this.black.total = function() {\n      return calcTotal.call(self.black);\n    };\n    this.white.total = function() {\n      return calcTotal.call(self.white);\n    };\n  };\n\n  /**\n   * Reset the game score\n   */\n  GameScore.prototype.reset = function() {\n\n    //Get properties to loop\n    var props = ['stones', 'territory', 'captures', 'komi'];\n\n    //Score for black player\n    for (var i = 0; i < props.length; i++) {\n      this.black[props[i]] = 0;\n      this.white[props[i]] = 0;\n    }\n  };\n\n  /**\n   * Get the winner\n   */\n  GameScore.prototype.winner = function() {\n\n    //Get totals\n    var b = this.black.total();\n    var w = this.white.total();\n\n    //Determine winner\n    if (w > b) {\n      return StoneColor.W;\n    }\n    else if (b > w) {\n      return StoneColor.B;\n    }\n    return StoneColor.E;\n  };\n\n  //Return\n  return GameScore;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScorer :: This class is used to determine the score of a certain game position. It also\n * provides handling of manual adjustment of dead / living groups.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Scorer.Service', [\n  'ngGo',\n  'ngGo.Game.Score.Service',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScorer', ['GameScore', 'StoneColor', 'BoardGrid', function(GameScore, StoneColor, BoardGrid) {\n\n  /**\n   * Possible score states\n   */\n  var scoreState = {\n    UNKNOWN: StoneColor.EMPTY,\n    BLACK_STONE: StoneColor.B,\n    WHITE_STONE: StoneColor.W,\n    BLACK_CANDIDATE: StoneColor.B * 2,\n    WHITE_CANDIDATE: StoneColor.W * 2,\n    NEUTRAL: StoneColor.B * 3\n  };\n\n  /**\n   * Helper to set territory\n   */\n  var territorySet = function(x, y, candidateColor, boundaryColor) {\n\n    //Get color at given position\n    var posColor = this.stones.get(x, y);\n    var origColor = this.game.position.stones.get(x, y);\n\n    //If border reached, or a position which is already this color, or boundary color, can't set\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\n      return;\n    }\n\n    //Don't turn stones which are already this color into candidates, instead\n    //reset their color to what they were\n    if (origColor * 2 === candidateColor) {\n      this.stones.set(x, y, origColor);\n    }\n\n    //Otherwise, mark as candidate\n    else {\n      this.stones.set(x, y, candidateColor);\n    }\n\n    //Set adjacent squares\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\n  };\n\n  /**\n   * Helper to reset territory\n   */\n  var territoryReset = function(x, y) {\n\n    //Get original color from this position\n    var origColor = this.game.position.stones.get(x, y);\n\n    //Not on grid, or already this color?\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\n      return;\n    }\n\n    //Reset the color\n    this.stones.set(x, y, origColor);\n\n    //Set adjacent squares\n    territoryReset.call(this, x - 1, y);\n    territoryReset.call(this, x, y - 1);\n    territoryReset.call(this, x + 1, y);\n    territoryReset.call(this, x, y + 1);\n  };\n\n  /**\n   * Helper to determine score state\n   */\n  var determineScoreState = function() {\n\n    //Initialize vars\n    var change = true;\n    var curState, newState, adjacent, b, w, a, x, y;\n\n    //Loop while there is change\n    while (change) {\n\n      //Set to false\n      change = false;\n\n      //Go through the whole position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get current state at position\n          curState = this.stones.get(x, y);\n\n          //Unknown or candiates?\n          if (\n            curState === scoreState.UNKNOWN ||\n            curState === scoreState.BLACK_CANDIDATE ||\n            curState === scoreState.WHITE_CANDIDATE\n          ) {\n\n            //Get state in adjacent positions\n            adjacent = [\n              this.stones.get(x - 1, y),\n              this.stones.get(x, y - 1),\n              this.stones.get(x + 1, y),\n              this.stones.get(x, y + 1)\n            ];\n\n            //Reset\n            b = w = false;\n\n            //Loop adjacent squares\n            for (a = 0; a < 4; a++) {\n              if (\n                adjacent[a] === scoreState.BLACK_STONE ||\n                adjacent[a] === scoreState.BLACK_CANDIDATE\n              ) {\n                b = true;\n              }\n              else if (\n                adjacent[a] === scoreState.WHITE_STONE ||\n                adjacent[a] === scoreState.WHITE_CANDIDATE\n              ) {\n                w = true;\n              }\n              else if (adjacent[a] === scoreState.NEUTRAL) {\n                b = w = true;\n              }\n            }\n\n            //Determine new state\n            if (b && w) {\n              newState = scoreState.NEUTRAL;\n            }\n            else if (b) {\n              newState = scoreState.BLACK_CANDIDATE;\n            }\n            else if (w) {\n              newState = scoreState.WHITE_CANDIDATE;\n            }\n            else {\n              newState = false;\n            }\n\n            //Change?\n            if (newState !== false && newState !== curState) {\n              change = true;\n              this.stones.set(x, y, newState);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * this.game scorer class\n   */\n  var GameScorer = {\n\n    //Game to score\n    game: null,\n\n    //Score\n    score: null,\n\n    //Stones, captures and points grids\n    stones: null,\n    captures: null,\n    points: null,\n\n    /**\n     * Load a game to score\n     */\n    load: function(game) {\n\n      //Reset score\n      this.score = new GameScore();\n\n      //Remember\n      this.game = game;\n\n      //Clone position to work with\n      this.stones = this.game.position.stones.clone();\n\n      //Create grids\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n    },\n\n    /**\n     * Get the calculated score\n     */\n    getScore: function() {\n      return this.score;\n    },\n\n    /**\n     * Get the points grid\n     */\n    getPoints: function() {\n      return this.points;\n    },\n\n    /**\n     * Get the captures grid\n     */\n    getCaptures: function() {\n      return this.captures;\n    },\n\n    /**\n     * Run score calculation routine\n     */\n    calculate: function() {\n\n      //No game?\n      if (!this.game) {\n        console.warn('No game loaded in game scorer, can\\'t calutlate score.');\n        return;\n      }\n\n      //Empty grids\n      this.points.empty();\n      this.captures.empty();\n\n      //Determine score state\n      determineScoreState.call(this);\n\n      //Get komi and captures\n      var komi = this.game.get('game.komi');\n      var captures = this.game.getCaptureCount();\n\n      //Reset score\n      this.score.reset();\n\n      //Set captures and komi\n      this.score.black.captures = captures[StoneColor.B];\n      this.score.white.captures = captures[StoneColor.W];\n      this.score.black.komi = komi < 0 ? komi : 0;\n      this.score.white.komi = komi > 0 ? komi : 0;\n\n      //Init helper vars\n      var x, y, state, color;\n\n      //Loop position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get state and color on original position\n          state = this.stones.get(x, y);\n          color = this.game.position.stones.get(x, y);\n\n          //Black stone\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\n            this.score.black.stones++;\n            continue;\n          }\n\n          //White stone\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\n            this.score.white.stones++;\n            continue;\n          }\n\n          //Black candidate\n          if (state === scoreState.BLACK_CANDIDATE) {\n            this.score.black.territory++;\n            this.points.set(x, y, StoneColor.B);\n\n            //White stone underneath?\n            if (color === StoneColor.W) {\n              this.score.black.captures++;\n              this.captures.set(x, y, StoneColor.W);\n            }\n            continue;\n          }\n\n          //White candidate\n          if (state === scoreState.WHITE_CANDIDATE) {\n            this.score.white.territory++;\n            this.points.set(x, y, StoneColor.W);\n\n            //Black stone underneath?\n            if (color === StoneColor.B) {\n              this.score.white.captures++;\n              this.captures.set(x, y, StoneColor.B);\n            }\n            continue;\n          }\n        }\n      }\n    },\n\n    /**\n     * Mark stones dead or alive\n     */\n    mark: function(x, y) {\n\n      //Get color of original position and state of the count position\n      var color = this.game.position.stones.get(x, y);\n      var state = this.stones.get(x, y);\n\n      //White stone\n      if (color === StoneColor.W) {\n\n        //Was white, mark it and any territory it's in as black's\n        if (state === scoreState.WHITE_STONE) {\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\n        }\n\n        //Was marked as not white, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n\n      //Black stone\n      else if (color === StoneColor.B) {\n\n        //Was black, mark it and any territory it's in as white's\n        if (state === scoreState.BLACK_STONE) {\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\n        }\n\n        //Was marked as not black, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n    }\n  };\n\n  //Return\n  return GameScorer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Directive', [\n  'ngGo.Board.Directive'\n])\n\n/**\n * Directive definition\n */\n.directive('player', ['Player', function(Player) {\n  return {\n    restrict: 'E',\n\n    /**\n     * Controller\n     */\n    controller: ['$scope', function($scope) {\n\n      //Set player in scope\n      if (!$scope.Player) {\n        $scope.Player = Player;\n      }\n    }],\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Link the element\n      Player.linkElement(element);\n\n      //Observe mode and tool attributes\n      attrs.$observe('mode', function(mode) {\n        Player.switchMode(mode);\n      });\n      attrs.$observe('tool', function(tool) {\n        Player.switchTool(tool);\n      });\n\n      //Observe other settings attributes\n      attrs.$observe('variationMarkup', function(attr) {\n        Player.setVariationMarkup(attr === 'true');\n      });\n      attrs.$observe('solutionPaths', function(attr) {\n        Player.toggleSolutionPaths(attr === 'true');\n      });\n      attrs.$observe('lastMoveMarker', function(attr) {\n        Player.setLastMoveMarker(attr);\n      });\n    }\n  };\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Player :: This class brings the board to life and allows a user to interact with it. It\n * handles user input, controls objects going to the board, can load game records, and allows the\n * user to manipulate the board according to the current player mode.\n * Unless you want to display static positions, this is the class you'd use by default.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Service', [\n  'ngGo',\n  'ngGo.Player.Directive',\n  'ngGo.Player.Mode.Common.Service',\n  'ngGo.Board.Service',\n  'ngGo.Game.Service',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Player', ['PlayerModes', 'PlayerTools', 'MarkupTypes', function(PlayerModes, PlayerTools, MarkupTypes) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default mode/tool\n    mode: PlayerModes.REPLAY,\n    tool: PlayerTools.MOVE,\n\n    //Keys/scrollwheel navigation\n    arrowKeysNavigation: true,\n    scrollWheelNavigation: true,\n\n    //Last move marker, leave empty for none\n    lastMoveMarker: MarkupTypes.LAST,\n\n    //Indicate variations with markup on the board, and show\n    //successor node variations or current node variations\n    variationMarkup: true,\n    variationChildren: true,\n    variationSiblings: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$document', 'Game', 'GameScorer', 'Board', 'PlayerTools', function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\n\n    /**\n     * Helper to append board grid coordinatess to the broadcast event object\n     */\n    var processMouseEvent = function(broadcastEvent, mouseEvent) {\n\n      //Can only do this with a board and mouse event\n      if (!this.board || !mouseEvent) {\n        broadcastEvent.x = -1;\n        broadcastEvent.y = -1;\n        return;\n      }\n\n      //Init\n      var x = 0;\n      var y = 0;\n\n      //Set x\n      if (typeof mouseEvent.offsetX !== 'undefined') {\n        x = mouseEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.layerX;\n      }\n\n      //Set y\n      if (typeof mouseEvent.offsetY !== 'undefined') {\n        y = mouseEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.layerY;\n      }\n\n      //Apply pixel ratio factor\n      x *= (window.devicePixelRatio || 1);\n      y *= (window.devicePixelRatio || 1);\n\n      //Append coords\n      broadcastEvent.x = this.board.getGridX(x);\n      broadcastEvent.y = this.board.getGridY(y);\n\n      //Did we drag?\n      if (mouseEvent.drag) {\n        broadcastEvent.drag = mouseEvent.drag;\n      }\n    };\n\n    /**\n     * Player class\n     */\n    var Player = {\n\n      //Player configuration\n      config: {},\n\n      //Board and game instances\n      board: null,\n      game: null,\n\n      //Available modes and tools\n      modes: {},\n      tools: [],\n\n      //Player mode and active tool\n      mode: '',\n      tool: '',\n\n      //Current path\n      path: null,\n\n      /**\n       * Initialization\n       */\n      init: function() {\n\n        //Unlink board instance, create new game\n        this.board = null;\n        this.game = new Game();\n\n        //Reset path\n        this.path = null;\n\n        //Player mode and active tool\n        this.mode = '';\n        this.tool = '';\n\n        //Arrow keys / scroll wheel navigation\n        this.arrowKeysNavigation = false;\n        this.scrollWheelNavigation = false;\n\n        //Last move marker\n        this.lastMoveMarker = '';\n\n        //Variation markup\n        this.variationMarkup = false;\n        this.variationChildren = false;\n        this.variationSiblings = false;\n\n        //Restricted nodes\n        this.restrictNodeStart = null;\n        this.restrictNodeEnd = null;\n\n        //Parse config\n        this.parseConfig();\n      },\n\n      /**\n       * Link the player to a HTML element\n       */\n      linkElement: function(element) {\n\n        //Set element\n        this.element = element;\n\n        //Register document event\n        this.registerElementEvent('keydown', $document);\n\n        //Register element events\n        this.registerElementEvent('click');\n        this.registerElementEvent('mousedown');\n        this.registerElementEvent('mouseup');\n        this.registerElementEvent('mousemove');\n        this.registerElementEvent('mouseout');\n        this.registerElementEvent('mousewheel');\n        this.registerElementEvent('wheel');\n      },\n\n      /*****************************************************************************\n       * Configuration\n       ***/\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, defaultConfig, config || {});\n\n        //Process settings\n        this.switchMode(this.config.mode);\n        this.switchTool(this.config.tool);\n        this.setArrowKeysNavigation(this.config.arrowKeysNavigation);\n        this.setScrollWheelNavigation(this.config.scrollWheelNavigation);\n        this.setLastMoveMarker(this.config.lastMoveMarker);\n        this.setVariationMarkup(\n          this.config.variationMarkup,\n          this.config.variationChildren,\n          this.config.variationSiblings\n        );\n\n        //Let the modes parse their config\n        for (var mode in this.modes) {\n          if (this.modes[mode].parseConfig) {\n            this.modes[mode].parseConfig.call(this, this.config);\n          }\n        }\n      },\n\n      /**\n       * Set arrow keys navigation\n       */\n      setArrowKeysNavigation: function(arrowKeys) {\n        if (arrowKeys !== this.arrowKeysNavigation) {\n          this.arrowKeysNavigation = arrowKeys;\n          this.broadcast('settingChange', 'arrowKeysNavigation');\n        }\n      },\n\n      /**\n       * Set scroll wheel navigation\n       */\n      setScrollWheelNavigation: function(scrollWheel) {\n        if (scrollWheel !== this.scrollWheelNavigation) {\n          this.scrollWheelNavigation = scrollWheel;\n          this.broadcast('settingChange', 'scrollWheelNavigation');\n        }\n      },\n\n      /**\n       * Set the last move marker\n       */\n      setLastMoveMarker: function(lastMoveMarker) {\n        if (lastMoveMarker !== this.lastMoveMarker) {\n          this.lastMoveMarker = lastMoveMarker;\n          this.broadcast('settingChange', 'lastMoveMarker');\n        }\n      },\n\n      /**\n       * Set variation markup on the board\n       */\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\n\n        //One change event for these three settings\n        var change = false;\n\n        //Markup setting change?\n        if (variationMarkup !== this.variationMarkup) {\n          this.variationMarkup = variationMarkup;\n          change = true;\n        }\n\n        //Children setting change?\n        if (\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\n        ) {\n          this.variationChildren = variationChildren;\n          change = true;\n        }\n\n        //Siblings setting change?\n        if (\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\n        ) {\n          this.variationSiblings = variationSiblings;\n          change = true;\n        }\n\n        //Did anything change?\n        if (change) {\n          this.broadcast('settingChange', 'variationMarkup');\n        }\n      },\n\n      /*****************************************************************************\n       * Mode and tool handling\n       ***/\n\n      /**\n       * Register a player mode\n       */\n      registerMode: function(mode, PlayerMode) {\n\n        //Register the mode and let it parse the configuration\n        this.modes[mode] = PlayerMode;\n\n        //Parse config if we have a handler\n        if (this.modes[mode].parseConfig) {\n          this.modes[mode].parseConfig.call(this, this.config);\n        }\n\n        //Force switch the mode now, if it matches the initial mode\n        if (this.mode === mode) {\n          this.switchMode(this.mode, true);\n          this.switchTool(this.tool, true);\n        }\n      },\n\n      /**\n       * Set available tools\n       */\n      setTools: function(tools) {\n        this.tools = tools || [PlayerTools.NONE];\n      },\n\n      /**\n       * Check if we have a player mode\n       */\n      hasMode: function(mode) {\n        return this.modes[mode] ? true : false;\n      },\n\n      /**\n       * Check if we have a player tool\n       */\n      hasTool: function(tool) {\n        return (this.tools.indexOf(tool) !== -1);\n      },\n\n      /**\n       * Switch player mode\n       */\n      switchMode: function(mode, force) {\n\n        //No change?\n        if (!force && (!mode || this.mode === mode)) {\n          return false;\n        }\n\n        //Broadcast mode exit\n        if (this.mode) {\n          this.broadcast('modeExit', this.mode);\n        }\n\n        //Set mode, reset tools and active tool\n        this.mode = mode;\n        this.tools = [];\n        this.tool = PlayerTools.NONE;\n\n        //Broadcast mode entry\n        this.broadcast('modeEnter', this.mode);\n        return true;\n      },\n\n      /**\n       * Switch player tool\n       */\n      switchTool: function(tool, force) {\n\n        //No change?\n        if (!force && (!tool || this.tool === tool)) {\n          return false;\n        }\n\n        //Validate tool switch (only when there is a mode)\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\n          return false;\n        }\n\n        //Change tool\n        this.tool = tool;\n        this.broadcast('toolSwitch', this.tool);\n        return true;\n      },\n\n      /**\n       * Save the full player state\n       */\n      saveState: function() {\n\n        //Save player state\n        this.playerState = {\n          mode: this.mode,\n          tool: this.tool,\n          restrictNodeStart: this.restrictNodeStart,\n          restrictNodeEnd: this.restrictNodeEnd\n        };\n\n        //Save game state\n        this.saveGameState();\n      },\n\n      /**\n       * Restore to the saved player state\n       */\n      restoreState: function() {\n\n        //Must have player state\n        if (!this.playerState) {\n          return;\n        }\n\n        //Restore\n        this.switchMode(this.playerState.mode);\n        this.switchTool(this.playerState.tool);\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\n\n        //Restore game state\n        this.restoreGameState();\n      },\n\n      /*****************************************************************************\n       * Game record handling\n       ***/\n\n      /**\n       * Load game record\n       */\n      load: function(data, allowPlayerConfig) {\n\n        //Try to load the game record data\n        try {\n          this.game.load(data);\n        }\n        catch (error) {\n          throw error;\n        }\n\n        //Reset path\n        this.path = null;\n\n        //Parse configuration from JGF if allowed\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\n          this.parseConfig(this.game.get('settings'));\n        }\n\n        //Dispatch game loaded event\n        this.broadcast('gameLoaded', this.game);\n\n        //Board present?\n        if (this.board) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n\n        //Loaded ok\n        return true;\n      },\n\n      /**\n       * Reload the existing game record\n       */\n      reload: function() {\n\n        //Must have game\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reload game\n        this.game.reload();\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Save the current state\n       */\n      saveGameState: function() {\n        if (this.game && this.game.isLoaded()) {\n          this.gameState = this.game.getState();\n        }\n      },\n\n      /**\n       * Restore to the saved state\n       */\n      restoreGameState: function() {\n\n        //Must have game and saved state\n        if (!this.game || !this.gameState) {\n          return;\n        }\n\n        //Restore state\n        this.game.restoreState(this.gameState);\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /*****************************************************************************\n       * Navigation\n       ***/\n\n      /**\n       * Go to the next position\n       */\n      next: function(i) {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.next(i);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position\n       */\n      previous: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previous();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the last position\n       */\n      last: function() {\n        if (this.game) {\n          this.game.last();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the first position\n       */\n      first: function() {\n        if (this.game) {\n          this.game.first();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to a specific move number, tree path or named node\n       */\n      goto: function(target) {\n        if (this.game && target) {\n          this.game.goto(target);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the previous fork\n       */\n      previousFork: function() {\n        if (this.game) {\n          this.game.previousFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next fork\n       */\n      nextFork: function() {\n        if (this.game) {\n          this.game.nextFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next position with a comment\n       */\n      nextComment: function() {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.nextComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position with a comment\n       */\n      previousComment: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previousComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Restrict navigation to the current node\n       */\n      restrictNode: function(end) {\n\n        //Must have game and node\n        if (!this.game || !this.game.node) {\n          return;\n        }\n\n        //Restrict to current node\n        if (end) {\n          this.restrictNodeEnd = this.game.node;\n        }\n        else {\n          this.restrictNodeStart = this.game.node;\n        }\n      },\n\n      /**\n       * Process a new game position\n       */\n      processPosition: function() {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Get current node and game position\n        var node = this.game.getNode();\n        var path = this.game.getPath();\n        var position = this.game.getPosition();\n        var pathChanged = !path.compare(this.path);\n\n        //Update board\n        this.updateBoard(node, position, pathChanged);\n\n        //Path change?\n        if (pathChanged) {\n\n          //Copy new path and broadcast path change\n          this.path = path.clone();\n          this.broadcast('pathChange', node);\n\n          //Named node reached? Broadcast event\n          if (node.name) {\n            this.broadcast('reachedNode.' + node.name, node);\n          }\n        }\n\n        //Passed?\n        if (node.move && node.move.pass) {\n          this.broadcast('movePassed', node);\n        }\n      },\n\n      /**\n       * Show move numbers\n       */\n      showMoveNumbers: function(fromMove, toMove) {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Use sensible defaults if no from/to moves given\n        fromMove = fromMove || 1;\n        toMove = toMove || this.game.getMove();\n\n        //Get nodes for these moves\n        var nodes = this.game.getMoveNodes(fromMove, toMove);\n        var move = fromMove;\n\n        //Loop nodes\n        angular.forEach(nodes, function(node) {\n          this.board.add('markup', node.move.x, node.move.y, {\n            type: MarkupTypes.LABEL,\n            text: move++\n          });\n        }, this);\n\n        //Redraw board markup\n        this.board.redraw('markup');\n      },\n\n      /*****************************************************************************\n       * Game handling\n       ***/\n\n      /**\n       * Start a new game\n       */\n      newGame: function() {\n        this.game = new Game();\n        this.processPosition();\n      },\n\n      /**\n       * Score the current game position\n       */\n      scoreGame: function() {\n\n        //Calculate score\n        GameScorer.calculate();\n\n        //Get score, points and captures\n        var score = GameScorer.getScore();\n        var points = GameScorer.getPoints();\n        var captures = GameScorer.getCaptures();\n\n        //Remove all markup, and set captures and points\n        this.board.layers.markup.removeAll();\n        this.board.layers.score.setAll(points, captures);\n\n        //Broadcast score\n        this.broadcast('scoreCalculated', score);\n      },\n\n      /*****************************************************************************\n       * Board handling\n       ***/\n\n      /**\n       * Get the board\n       */\n      getBoard: function() {\n        return this.board;\n      },\n\n      /**\n       * Set the board\n       */\n      setBoard: function(Board) {\n\n        //Set the board\n        this.board = Board;\n\n        //Board ready\n        if (this.board) {\n          this.broadcast('boardReady', this.board);\n        }\n\n        //If a game has been loaded already, parse config and update the board\n        if (this.game && this.game.isLoaded()) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Update the board\n       */\n      updateBoard: function(node, position, pathChanged) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Update board with new position\n        this.board.updatePosition(position, pathChanged);\n\n        //Mark last move\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\n        }\n\n        //Broadcast board update event\n        this.broadcast('boardUpdate', node);\n      },\n\n      /*****************************************************************************\n       * Event handling\n       ***/\n\n      /**\n       * Register an element event\n       */\n      registerElementEvent: function(event, element) {\n\n        //Which element to use\n        if (typeof element === 'undefined' || !element.on) {\n          element = this.element;\n        }\n\n        //Remove any existing event listener and apply new one\n        //TODO: Namespacing events doesn't work with Angular's jqLite\n        element.off(event/* + '.ngGo.player'*/);\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\n      },\n\n      /**\n       * Event listener\n       */\n      on: function(type, listener, mode, $scope) {\n\n        //Must have valid listener\n        if (typeof listener !== 'function') {\n          console.warn('Listener is not a function:', listener);\n          return;\n        }\n\n        //Scope given as 3rd parameter?\n        if (mode && mode.$parent) {\n          $scope = mode;\n          mode = '';\n        }\n\n        //Multiple events?\n        if (type.indexOf(' ') !== -1) {\n          var types = type.split(' ');\n          for (var t = 0; t < types.length; t++) {\n            this.on(types[t], listener, mode, $scope);\n          }\n          return;\n        }\n\n        //Get self and determine scope to use\n        var self = this;\n        var scope = $scope || $rootScope;\n\n        //Create listener and return de-registration function\n        return scope.$on('ngGo.player.' + type, function() {\n\n          //Filter on mode\n          if (mode) {\n            if (\n              (typeof mode === 'string' && mode !== self.mode) ||\n              mode.indexOf(self.mode) === -1\n            ) {\n              return;\n            }\n          }\n\n          //Inside a text field?\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\n            return;\n          }\n\n          //Append grid coordinates for mouse events\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\n            processMouseEvent.call(self, arguments[0], arguments[1]);\n          }\n\n          //Dragging? Prevent click events from firing\n          if (self.preventClickEvent && type === 'click') {\n            delete self.preventClickEvent;\n            return;\n          }\n          else if (type === 'mousedrag') {\n            self.preventClickEvent = true;\n          }\n\n          //Call listener\n          listener.apply(self, arguments);\n        });\n      },\n\n      /**\n       * Event broadcaster\n       */\n      broadcast: function(type, args) {\n\n        //Must have type\n        if (!type) {\n          return;\n        }\n\n        //Make sure we are in a digest cycle\n        if (!$rootScope.$$phase) {\n          $rootScope.$apply(function() {\n            $rootScope.$broadcast('ngGo.player.' + type, args);\n          });\n        }\n        else {\n          $rootScope.$broadcast('ngGo.player.' + type, args);\n        }\n      }\n    };\n\n    //Initialize\n    Player.init();\n\n    //Return object\n    return Player;\n  }];\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Blank.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('KifuBlank', ['ngGo', function(ngGo) {\n\n  /**\n   * Blank JGF\n   */\n  var blankJgf = {\n    record: {\n      application: ngGo.name + ' v' + ngGo.version,\n      version: 1,\n      charset: 'UTF-8'\n    },\n    game: {\n      type: 'go',\n      players: [\n        {\n          color: 'black',\n          name: 'Black'\n        },\n        {\n          color: 'white',\n          name: 'White'\n        }\n      ]\n    },\n    board: {\n      width: 19,\n      height: 19\n    },\n    tree: []\n  };\n\n  /**\n   * Blank SGF\n   */\n  var blankSgf = {\n    AP: ngGo.name + ':' + ngGo.version,\n    CA: 'UTF-8',\n    FF: '4',\n    GM: '1',\n    SZ: '19',\n    PB: 'Black',\n    PW: 'White'\n  };\n\n  /**\n   * Blank JGF/SGF container\n   */\n  var KifuBlank = {\n\n    /**\n     * Get blank JGF\n     */\n    jgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankJgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    },\n\n    /**\n     * Get blank SGF\n     */\n    sgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankSgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = base[p];\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    }\n  };\n\n  //Return object\n  return KifuBlank;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\n * constants used by the parsers to aid conversion.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parser.Service', [\n  'ngGo',\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service'\n])\n\n/**\n * SGF/JGF aliases constant for conversion between the two formats\n * Note: not all properties can be translated directly, so some are\n * not present here in this constant\n */\n.constant('sgfAliases', {\n\n  //Record properties\n  'AP': 'record.application',\n  'CA': 'record.charset',\n  'CP': 'record.copyright',\n  'SO': 'record.source',\n  'US': 'record.transcriber',\n  'AN': 'record.annotator',\n\n  //Game properties\n  'GM': 'game.type',\n  'GN': 'game.name',\n  'KM': 'game.komi',\n  'HA': 'game.handicap',\n  'RE': 'game.result',\n  'RU': 'game.rules',\n  'TM': 'game.time.main',\n  'OT': 'game.time.overtime',\n  'DT': 'game.dates',\n  'PC': 'game.location',\n  'EV': 'game.event',\n  'RO': 'game.round',\n  'ON': 'game.opening',\n  'GC': 'game.comment',\n\n  //Player info properties\n  'PB': 'name',\n  'PW': 'name',\n  'BT': 'team',\n  'WT': 'team',\n  'BR': 'rank',\n  'WR': 'rank',\n\n  //Node annotation\n  'N': 'name',\n  'C': 'comments',\n  'CR': 'circle',\n  'TR': 'triangle',\n  'SQ': 'square',\n  'MA': 'mark',\n  'SL': 'select',\n  'LB': 'label'\n})\n\n/**\n * SGF game definitions\n */\n.constant('sgfGames', {\n  1: 'go',\n  2: 'othello',\n  3: 'chess',\n  4: 'renju',\n  6: 'backgammon',\n  7: 'chinese chess',\n  8: 'shogi'\n})\n\n/**\n * Factory definition\n */\n.factory('KifuParser', ['Gib2Jgf', 'Sgf2Jgf', 'Jgf2Sgf', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\n\n  /**\n   * Parser wrapper class\n   */\n  var KifuParser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    gib2jgf: function(gib, stringified) {\n      return Gib2Jgf.parse(gib, stringified);\n    },\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    sgf2jgf: function(sgf, stringified) {\n      return Sgf2Jgf.parse(sgf, stringified);\n    },\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    jgf2sgf: function(jgf) {\n      return Jgf2Sgf.parse(jgf);\n    }\n  };\n\n  //Return object\n  return KifuParser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\n * gridlines, starpoints and coordinates via the Coordinates class.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Coordinates.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GridLayer', ['BoardLayer', 'Coordinates', function(BoardLayer, Coordinates) {\n\n  /**\n   * Helper for drawing starpoints\n   */\n  var drawStarPoint = function(gridX, gridY, starRadius, starColor) {\n\n    //Don't draw if it falls outsize of the board grid\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\n      return;\n    }\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\n      return;\n    }\n\n    //Get absolute coordinates and star point radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n\n    //Draw star point\n    this.context.beginPath();\n    this.context.fillStyle = starColor;\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\n    this.context.fill();\n  };\n\n  /**\n   * Constructor\n   */\n  var GridLayer = function(board, context) {\n\n    //Set coordinates setting\n    this.coordinates = false;\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Show or hide the coordinates.\n   */\n  GridLayer.prototype.setCoordinates = function(show) {\n    this.coordinates = show;\n  };\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Get all has nothing to return\n   */\n  GridLayer.prototype.getAll = function() {\n    return null;\n  };\n\n  /**\n   * Set all has nothing to set\n   */\n  GridLayer.prototype.setAll = function(/*grid*/) {\n    return;\n  };\n\n  /**\n   * Remove all has nothing to remove\n   */\n  GridLayer.prototype.removeAll = function() {\n    return;\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw method\n   */\n  GridLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Determine top x and y margin\n    var tx = this.board.drawMarginHor;\n    var ty = this.board.drawMarginVer;\n\n    //Get theme properties\n    var cellSize = this.board.getCellSize();\n    var lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\n    var lineCap = this.board.theme.get('grid.lineCap');\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', cellSize);\n    var starColor = this.board.theme.get('grid.star.color');\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n    this.context.strokeStyle = strokeStyle;\n\n    //Helper vars\n    var i, x, y;\n\n    //Draw vertical lines\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\n      x = this.board.getAbsX(i);\n      this.context.moveTo(x, ty);\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\n    }\n\n    //Draw horizontal lines\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\n      y = this.board.getAbsY(i);\n      this.context.moveTo(tx, y);\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\n    }\n\n    //Draw grid lines\n    this.context.stroke();\n\n    //Star points defined?\n    for (i = 0; i < starPoints.length; i++) {\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n\n    //Draw coordinates\n    if (this.coordinates) {\n      Coordinates.draw.call(this);\n    }\n  };\n\n  /**\n   * Clear a square cell area on the grid\n   */\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Clear rectangle\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Redraw a square cell area on the grid\n   */\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', s);\n    var starColor = this.board.theme.get('grid.star.color');\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n\n    //Determine draw coordinates\n    var x1 = (gridX === 0) ? x : x - r;\n    var x2 = (gridX === this.board.width - 1) ? x : x + r;\n    var y1 = (gridY === 0) ? y : y - r;\n    var y2 = (gridY === this.board.height - 1) ? y : y + r;\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Patch up grid lines\n    this.context.moveTo(x1, y);\n    this.context.lineTo(x2, y);\n    this.context.moveTo(x, y1);\n    this.context.lineTo(x, y2);\n    this.context.stroke();\n\n    //Check if we need to draw a star point here\n    for (var i in starPoints) {\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\n      }\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  //Return\n  return GridLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('HoverLayer', ['BoardLayer', 'Markup', 'StoneFaded', function(BoardLayer, Markup, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var HoverLayer = function(board, context) {\n\n    //Container for items to restore\n    this.restore = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add hover item\n   */\n  HoverLayer.prototype.add = function(x, y, hover) {\n\n    //Validate coordinates\n    if (!this.grid.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Remove any previous item at this position\n    this.remove(x, y);\n\n    //Create hover object\n    hover.object = {\n      x: x,\n      y: y\n    };\n\n    //Stones\n    if (hover.type === 'stones') {\n      hover.objectClass = StoneFaded;\n      hover.object.color = hover.value;\n    }\n\n    //Markup\n    else if (hover.type === 'markup') {\n      hover.objectClass = Markup;\n      if (typeof hover.value === 'object') {\n        hover.object = angular.extend(hover.object, hover.value);\n      }\n      else {\n        hover.object.type = hover.value;\n      }\n    }\n\n    //Unknown\n    else {\n      console.warn('Unknown hover type', hover.type);\n      return;\n    }\n\n    //Check if we need to hide something on layers underneath\n    if (this.board.has(hover.type, x, y)) {\n      this.restore.push({\n        x: x,\n        y: y,\n        layer: hover.type,\n        value: this.board.get(hover.type, x, y)\n      });\n      this.board.remove(hover.type, x, y);\n    }\n\n    //Add to stack\n    this.grid.set(x, y, hover);\n\n    //Draw item\n    if (hover.objectClass && hover.objectClass.draw) {\n      hover.objectClass.draw.call(this, hover.object);\n    }\n  };\n\n  /**\n   * Remove the hover object\n   */\n  HoverLayer.prototype.remove = function(x, y) {\n\n    //Validate coordinates\n    if (!this.grid.has(x, y)) {\n      return;\n    }\n\n    //Get object and clear it\n    var hover = this.grid.get(x, y);\n    if (hover.objectClass && hover.objectClass.clear) {\n      hover.objectClass.clear.call(this, hover.object);\n    }\n\n    //Other objects to restore?\n    for (var i = 0; i < this.restore.length; i++) {\n      if (this.restore[i].x === x && this.restore[i].y === y) {\n        this.board.add(\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n        );\n        this.restore.splice(i, 1);\n      }\n    }\n  };\n\n  /**\n   * Remove all hover objects\n   */\n  HoverLayer.prototype.removeAll = function() {\n\n    //Anything to do?\n    if (this.grid.isEmpty()) {\n      return;\n    }\n\n    //Get all item as objects\n    var i;\n    var hover = this.grid.all('layer');\n\n    //Clear them\n    for (i = 0; i < hover.length; i++) {\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\n        hover[i].objectClass.clear.call(this, hover[i].object);\n      }\n    }\n\n    //Clear layer and empty grid\n    this.clear();\n    this.grid.empty();\n\n    //Restore objects on other layers\n    for (i = 0; i < this.restore.length; i++) {\n      this.board.add(\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n      );\n    }\n\n    //Clear restore array\n    this.restore = [];\n  };\n\n  /**\n   * Draw layer\n   */\n  HoverLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Loop objects and clear them\n    var hover = this.grid.all('hover');\n    for (var i = 0; i < hover.length; i++) {\n      if (hover.objectClass && hover.objectClass.draw) {\n        hover.objectClass.draw.call(this, hover.object);\n      }\n    }\n  };\n\n  //Return\n  return HoverLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('MarkupLayer', ['BoardLayer', 'Markup', function(BoardLayer, Markup) {\n\n  /**\n   * Constructor\n   */\n  var MarkupLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all markup at once\n   */\n  MarkupLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'type');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Markup.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Markup.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  MarkupLayer.prototype.removeAll = function() {\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Clear them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.clear.call(this, markup[i]);\n    }\n\n    //Empty the grid now\n    this.grid.empty();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  MarkupLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Draw them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.draw.call(this, markup[i]);\n    }\n  };\n\n  /**\n   * Draw cell\n   */\n  MarkupLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  MarkupLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  //Return\n  return MarkupLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ScoreLayer', ['BoardLayer', 'StoneMini', 'StoneFaded', function(BoardLayer, StoneMini, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var ScoreLayer = function(board, context) {\n\n    //Points and captures\n    this.points = [];\n    this.captures = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set points and captures\n   */\n  ScoreLayer.prototype.setAll = function(points, captures) {\n\n    //Remove all existing stuff first\n    this.removeAll();\n\n    //Set new stuff\n    this.points = points.all('color');\n    this.captures = captures.all('color');\n\n    //Draw\n    this.draw();\n  };\n\n  /**\n   * Remove all scoring\n   */\n  ScoreLayer.prototype.removeAll = function() {\n\n    //If there are captures, draw them back onto the stones layer\n    for (var i = 0; i < this.captures.length; i++) {\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\n    }\n\n    //Clear the layer\n    this.clear();\n\n    //Remove all stuff\n    this.points = [];\n    this.captures = [];\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  ScoreLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Init\n    var i;\n\n    //Draw captures first (removing stones from the stones layer)\n    for (i = 0; i < this.captures.length; i++) {\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\n      StoneFaded.draw.call(this, this.captures[i]);\n    }\n\n    //Draw points on top of it\n    for (i = 0; i < this.points.length; i++) {\n      StoneMini.draw.call(this, this.points[i]);\n    }\n  };\n\n  //Return\n  return ScoreLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneShadow.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ShadowLayer', ['BoardLayer', 'StoneShadow', function(BoardLayer, StoneShadow) {\n\n  /**\n   * Constructor\n   */\n  var ShadowLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add a stone\n   */\n  ShadowLayer.prototype.add = function(stone) {\n\n    //Don't add if no shadow\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\n      return;\n    }\n\n    //Already have a stone here?\n    if (this.grid.has(stone.x, stone.y)) {\n      return;\n    }\n\n    //Add to grid\n    this.grid.set(stone.x, stone.y, stone.color);\n\n    //Draw it if there is a context\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\n      StoneShadow.draw.call(this, stone);\n    }\n  };\n\n  /**\n   * Remove a stone\n   */\n  ShadowLayer.prototype.remove = function(stone) {\n\n    //Remove from grid\n    this.grid.unset(stone.x, stone.y);\n\n    //Redraw whole layer\n    this.redraw();\n  };\n\n  /**\n   * Draw layer\n   */\n  ShadowLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get shadowsize from theme\n    var shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\n\n    //Apply shadow transformation\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      StoneShadow.draw.call(this, stones[i]);\n    }\n  };\n\n  //Return\n  return ShadowLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StonesLayer', ['BoardLayer', 'Stone', 'StoneColor', function(BoardLayer, Stone, StoneColor) {\n\n  /**\n   * Constructor\n   */\n  var StonesLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n\n    //Set empty value for grid\n    this.grid.whenEmpty(StoneColor.EMPTY);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all stones at once\n   */\n  StonesLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'color');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Stone.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Stone.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  StonesLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      Stone.draw.call(this, stones[i]);\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  StonesLayer.prototype.redraw = function() {\n\n    //Clear shadows layer\n    this.board.removeAll('shadow');\n\n    //Redraw ourselves\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  StonesLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  StonesLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  //Return\n  return StonesLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Coordinates :: This class is used for drawing board coordinates\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Coordinates.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('Coordinates', function() {\n\n  //Kanji\n  var kanji = [\n    '一', '二', '三', '四', '五', '六', '七', '八', '九', '十',\n    '十一', '十二', '十三', '十四', '十五', '十六', '十七', '十八', '十九', '二十',\n    '二十一', '二十二', '二十三', '二十四', '二十五', '二十六', '二十七', '二十八', '二十九', '三十',\n    '三十一', '三十二', '三十三', '三十四', '三十五', '三十六', '三十七', '三十八', '三十九', '四十'\n  ];\n\n  //Character codes\n  var aChar = 'A'.charCodeAt(0);\n  var aCharLc = 'a'.charCodeAt(0);\n\n  /**\n   * Coordinate generators\n   */\n  var coordinates = {\n\n    //Kanji coordinates\n    kanji: function(i) {\n      return kanji[i] || '';\n    },\n\n    //Numbers from 1\n    numbers: function(i) {\n      return i + 1;\n    },\n\n    //Capital letters from A\n    letters: function(i) {\n\n      //Initialize\n      var ch = '';\n\n      //Beyond Z? Prepend with A\n      if (i >= 25) {\n        ch = 'A';\n        i -= 25;\n      }\n\n      //The letter I is ommitted\n      if (i >= 8) {\n        i++;\n      }\n\n      //Return\n      return ch + String.fromCharCode(aChar + i);\n    },\n\n    //JGF coordinates (e.g. 0, 1, ...)\n    jgf: function(i) {\n      return i;\n    },\n\n    //SGF coordinates (e.g. a, b, ...)\n    sgf: function(i) {\n      var ch;\n      if (i < 26) {\n        ch = aCharLc + i;\n      }\n      else {\n        ch = aChar + i;\n      }\n      return String.fromCharCode(ch);\n    }\n  };\n\n  /**\n   * Coordinates object\n   */\n  var Coordinates = {\n\n    /**\n     * Draw\n     */\n    draw: function() {\n\n      //Can only draw when we have context and dimensions\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Get cell size\n      var cellSize = this.board.getCellSize();\n\n      //Get boundary coordinates\n      var xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\n      var xr = this.board.drawWidth - xl;\n      var yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\n      var yb = this.board.drawHeight - yt;\n\n      //Get theme properties\n      var fillStyle = this.board.theme.get('coordinates.color');\n      var vertical = {\n        font: this.board.theme.get('coordinates.vertical.font'),\n        size: this.board.theme.get('coordinates.vertical.size'),\n        style: this.board.theme.get('coordinates.vertical.style'),\n        inverse: this.board.theme.get('coordinates.vertical.inverse')\n      };\n      var horizontal = {\n        font: this.board.theme.get('coordinates.horizontal.font'),\n        size: this.board.theme.get('coordinates.horizontal.size'),\n        style: this.board.theme.get('coordinates.horizontal.style'),\n        inverse: this.board.theme.get('coordinates.horizontal.inverse')\n      };\n\n      //Configure context\n      this.context.fillStyle = fillStyle;\n      this.context.textBaseline = 'middle';\n      this.context.textAlign = 'center';\n\n      //Helper vars\n      var i, j, x, y, ch;\n\n      //Draw vertical coordinates\n      for (i = 0; i < this.board.height; i++) {\n\n        //Inverse?\n        j = i;\n        if (vertical.inverse) {\n          j = this.board.height - i - 1;\n        }\n\n        //Get character\n        if (typeof vertical.style === 'function') {\n          ch = vertical.style.call(this, j);\n        }\n        else if (coordinates[vertical.style]) {\n          ch = coordinates[vertical.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        y = this.board.getAbsY(i);\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\n        this.context.fillText(ch, xl, y);\n        this.context.fillText(ch, xr, y);\n      }\n\n      //Draw horizontal coordinates\n      for (i = 0; i < this.board.width; i++) {\n\n        //Inverse?\n        j = i;\n        if (horizontal.inverse) {\n          j = this.board.width - i - 1;\n        }\n\n        //Get character\n        if (typeof horizontal.style === 'function') {\n          ch = horizontal.style.call(this, j);\n        }\n        else if (coordinates[horizontal.style]) {\n          ch = coordinates[horizontal.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        x = this.board.getAbsX(i);\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\n        this.context.fillText(ch, x, yt);\n        this.context.fillText(ch, x, yb);\n      }\n    }\n  };\n\n  //Return\n  return Coordinates;\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Markup :: This class is used for drawing markup\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Markup.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Markup', ['MarkupTypes', 'BoardObject', function(MarkupTypes, BoardObject) {\n\n  /**\n   * Math constants\n   */\n  var cosPi4 = Math.cos(Math.PI / 4);\n  var cosPi6 = Math.cos(Math.PI / 6);\n\n  /**\n   * Triangle draw handler\n   */\n  var drawTriangle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y - r);\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.closePath();\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Square draw handler\n   */\n  var drawSquare = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw circle handler\n   */\n  var drawCircle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw mark handler\n   */\n  var drawMark = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x - rcos, y - rcos);\n    this.context.lineTo(x + rcos, y + rcos);\n    this.context.moveTo(x + rcos, y - rcos);\n    this.context.lineTo(x - rcos, y + rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw select handler\n   */\n  var drawSelect = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Last move draw handler\n   */\n  var drawLast = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(s);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y);\n    this.context.lineTo(x + r, y);\n    this.context.lineTo(x, y + r);\n    this.context.closePath();\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw happy smiley handler\n   */\n  var drawHappySmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 8);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw sad smiley handler\n   */\n  var drawSadSmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw label\n   */\n  var drawLabel = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var font = markup.font || this.board.theme.get('markup.label.font') || '';\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //First, clear grid square below for clarity\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.clearCell(markup.x, markup.y);\n    }\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.textBaseline = 'middle';\n    this.context.textAlign = 'center';\n\n    //Convert to text\n    if (typeof markup.text === 'number') {\n      markup.text = markup.text.toString();\n    }\n\n    //Determine font size\n    if (markup.text.length === 1) {\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\n    }\n    else if (markup.text.length === 2) {\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\n    }\n    else {\n      this.context.font = r + 'px ' + font;\n    }\n\n    //Draw element\n    this.context.beginPath();\n    this.context.fillText(markup.text, x, y, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Clear label\n   */\n  var clearLabel = function(markup) {\n\n    //No stone on location? Redraw the grid square, if we cleared it\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\n    }\n  };\n\n  /**\n   * Markup class\n   */\n  var Markup = {\n\n    /**\n     * Draw\n     */\n    draw: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Drawing depends on type\n      switch (markup.type) {\n\n        //Triangle\n        case MarkupTypes.TRIANGLE:\n          drawTriangle.call(this, markup);\n          break;\n\n        //Square\n        case MarkupTypes.SQUARE:\n          drawSquare.call(this, markup);\n          break;\n\n        //Circle\n        case MarkupTypes.CIRCLE:\n          drawCircle.call(this, markup);\n          break;\n\n        //Mark\n        case MarkupTypes.MARK:\n          drawMark.call(this, markup);\n          break;\n\n        //Select\n        case MarkupTypes.SELECT:\n          drawSelect.call(this, markup);\n          break;\n\n        //happy\n        case MarkupTypes.HAPPY:\n          drawHappySmiley.call(this, markup);\n          break;\n\n        //Sad\n        case MarkupTypes.SAD:\n          drawSadSmiley.call(this, markup);\n          break;\n\n        //Last move marker\n        case MarkupTypes.LAST:\n          drawLast.call(this, markup);\n          break;\n\n        //Label\n        case MarkupTypes.LABEL:\n          markup.text = markup.text || '';\n          drawLabel.call(this, markup);\n          break;\n      }\n    },\n\n    /**\n     * Clear\n     */\n    clear: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, markup);\n\n      //Special handling for label\n      if (markup.type === MarkupTypes.LABEL) {\n        clearLabel.call(this, markup);\n      }\n    }\n  };\n\n  //Return\n  return Markup;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Stone :: This class is used for drawing stones on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Stone.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n  'ngGo.Board.ShellPattern.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Stone', ['$injector', 'BoardObject', 'StoneColor', 'ShellPattern', function($injector, BoardObject, StoneColor, ShellPattern) {\n\n  /**\n   * Shell random seed\n   */\n  var shellSeed;\n\n  /**\n   * Mono colored stones\n   */\n  var drawMono = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Don't draw shadow\n    stone.shadow = false;\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\n    var fillStyle = this.board.theme.get('stone.mono.color', color);\n    var strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Configure context\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Draw outline\n    this.context.stroke();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Glass stones\n   */\n  var drawGlass = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Begin path\n    this.context.beginPath();\n\n    //Determine stone texture\n    if (color === StoneColor.W) {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#fff');\n      this.context.fillStyle.addColorStop(1, '#aaa');\n    }\n    else {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#666');\n      this.context.fillStyle.addColorStop(1, '#111');\n    }\n\n    //Complete drawing\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Slate and shell stones\n   */\n  var drawSlateShell = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Get random seed\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var shellTypes = this.board.theme.get('stone.shell.types');\n    var fillStyle = this.board.theme.get('stone.shell.color', color);\n    var strokeStyle = this.board.theme.get('stone.shell.stroke');\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fillStyle = fillStyle;\n    this.context.fill();\n\n    //Shell stones\n    if (color === StoneColor.W) {\n\n      //Get random shell type\n      var type =\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\n\n      //Determine random angle\n      var z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\n      var angle = (2 / z) * (shellSeed % z);\n\n      //Draw shell pattern\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Slate stones\n    else {\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Constructor\n   */\n  var Stone = {\n\n    /**\n     * Draw a stone\n     */\n    draw: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Determine style of stone\n      var style = this.board.theme.get('stone.style');\n\n      //Draw using the appropriate handler\n      switch (style) {\n\n        //Slate and shell\n        case 'shell':\n          drawSlateShell.call(this, stone);\n          break;\n\n        //Glass stones\n        case 'glass':\n          drawGlass.call(this, stone);\n          break;\n\n        //Mono stones\n        case 'mono':\n          drawMono.call(this, stone);\n          break;\n\n        //Custom type\n        default:\n          var handler = $injector.get(style);\n          if (handler) {\n            handler.call(this, stone);\n          }\n      }\n\n      //Add shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.add(stone);\n      }\n    },\n\n    /**\n     * Clear a stone\n     */\n    clear: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, stone);\n\n      //Remove shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.remove(stone);\n      }\n    }\n  };\n\n  //Return\n  return Stone;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneFaded', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneFaded = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.faded.scale');\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneFaded;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\n * (for scoring).\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneMini.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneMini', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneMini = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.mini.scale');\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneMini;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneShadow :: This class is used for drawing stone shadows on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneShadow', function() {\n\n  /**\n   * Constructor\n   */\n  var StoneShadow = {\n\n    /**\n     * Draw a stone shadow\n     */\n    draw: function(stone) {\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\n\n      //Apply scaling factor?\n      if (stone.scale) {\n        r = Math.round(r * stone.scale);\n      }\n\n      //Get theme properties\n      var blur = this.board.theme.get('shadow.blur', s);\n      var offsetX = this.board.theme.get('shadow.offsetX', s);\n      var offsetY = this.board.theme.get('shadow.offsetY', s);\n      var shadowColor = this.board.theme.get('shadow.color');\n\n      //Configure context\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\n      );\n      this.context.fillStyle.addColorStop(0, shadowColor);\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n\n      //Draw shadow\n      this.context.beginPath();\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\n      this.context.fill();\n    },\n\n    /**\n     * Clear a stone shadow\n     */\n    clear: function(stone) {\n\n      //Note: this method is currently not in use due to the overlapping shadows\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\n      //appropriate either, so for now we will leave it at this.\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = this.board.theme.get('stone.radius', s);\n\n      //Clear a generous rectangle\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\n    }\n  };\n\n  //Return\n  return StoneShadow;\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeCommon :: This class governs common event handling of the player shared by\n * various player modes. It's basically an abstract player mode and it can't be actively set.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Common.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Run block\n */\n.run(['Player', 'PlayerModes', 'PlayerModeCommon', function(Player, PlayerModes, PlayerModeCommon) {\n\n  /**\n   * Register common event handlers\n   */\n  Player.on('keydown', PlayerModeCommon.keyDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n}])\n\n/**\n * Factory definition\n */\n.factory('PlayerModeCommon', ['Player', 'PlayerTools', 'GameScorer', 'KeyCodes', function(Player, PlayerTools, GameScorer, KeyCodes) {\n\n  /**\n   * Helper to build drag object\n   */\n  var dragObject = function(event) {\n\n    //Initialize drag object\n    var drag = {\n      start: {\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y\n      },\n      stop: {\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y\n      }\n    };\n\n    //Fix boundaries\n    if (drag.start.x < 0) {\n      drag.start.x = 0;\n    }\n    if (drag.start.y < 0) {\n      drag.start.y = 0;\n    }\n    if (drag.stop.x > this.board.width - 1) {\n      drag.stop.x = this.board.width - 1;\n    }\n    if (drag.stop.y > this.board.height - 1) {\n      drag.stop.y = this.board.height - 1;\n    }\n\n    //Return\n    return drag;\n  };\n\n  /**\n   * Normalize the mousewheel event helper\n   */\n  function normalizeMousewheelEvent(event) {\n\n    //Initialize vars\n    var deltaX = 0;\n    var deltaY = 0;\n\n    //Old school scrollwheel delta\n    if ('detail' in event) {\n      deltaY = event.detail * -1;\n    }\n    if ('wheelDelta' in event) {\n      deltaY = event.wheelDelta;\n    }\n    if ('wheelDeltaY' in event) {\n      deltaY = event.wheelDeltaY;\n    }\n    if ('wheelDeltaX' in event) {\n      deltaX = event.wheelDeltaX * -1;\n    }\n\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\n      deltaX = deltaY * -1;\n      deltaY = 0;\n    }\n\n    //New type wheel delta (WheelEvent)\n    if ('deltaY' in event) {\n      deltaY = event.deltaY * -1;\n    }\n    if ('deltaX' in event) {\n      deltaX = event.deltaX;\n    }\n\n    //Set in event (have to use different property name because of strict mode)\n    event.mouseWheelX = deltaX;\n    event.mouseWheelY = deltaY;\n\n    //Return\n    return event;\n  }\n\n  /**\n   * Player extension\n   */\n  angular.extend(Player, {\n\n    /**\n     * Mouse coordinate helper vars\n     */\n    mouse: {\n\n      //Drag start\n      dragStart: null,\n\n      //Last grid coordinates\n      lastX: -1,\n      lastY: -1\n    }\n  });\n\n  /**\n   * Player mode definition\n   */\n  var PlayerMode = {\n\n    /**\n     * Handler for keydown events\n     */\n    keyDown: function(event, keyboardEvent) {\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Switch key code\n      switch (keyboardEvent.keyCode) {\n\n        //ESC\n        case KeyCodes.ESC:\n\n          //Cancel drag event, and prevent click event as well\n          this.mouse.dragStart = null;\n          this.preventClickEvent = true;\n          break;\n\n        //Right arrow\n        case KeyCodes.RIGHT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Advance to the next move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\n              this.next();\n            }\n          }\n          break;\n\n        //Left arrow\n        case KeyCodes.LEFT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Go to the previous move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\n              this.previous();\n            }\n          }\n          break;\n\n        //Up arrow\n        case KeyCodes.UP:\n          break;\n\n        //Down arrow\n        case KeyCodes.DOWN:\n          break;\n      }\n    },\n\n    /**\n     * Handler for mousewheel events\n     */\n    mouseWheel: function(event, mouseEvent) {\n\n      //Disabled or not using move tool?\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\n        return true;\n      }\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return true;\n      }\n\n      //Normalize mousewheel event\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\n\n      //Find delta\n      var delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\n\n      //Next move\n      if (delta < 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.next();\n      }\n\n      //Previous move\n      else if (delta > 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.previous();\n      }\n\n      //Don't scroll the window\n      if (delta !== 0) {\n        mouseEvent.preventDefault();\n      }\n    },\n\n    /**\n     * Mouse out handler\n     */\n    mouseOut: function() {\n      if (this.board) {\n        this.board.removeAll('hover');\n      }\n    },\n\n    /**\n     * Mouse move handler\n     */\n    mouseMove: function(event, mouseEvent) {\n\n      //Attach drag object to events\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n      }\n\n      //Nothing else to do?\n      if (!this.board || !this.board.layers.hover) {\n        return;\n      }\n\n      //Last coordinates are the same?\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\n        return;\n      }\n\n      //Remember last coordinates\n      this.mouse.lastX = event.x;\n      this.mouse.lastY = event.y;\n\n      //Broadcast hover event\n      this.broadcast('hover', mouseEvent);\n    },\n\n    /**\n     * Mouse down handler\n     */\n    mouseDown: function(event) {\n      this.mouse.dragStart = {\n        x: event.x,\n        y: event.y\n      };\n    },\n\n    /**\n     * Mouse up handler\n     */\n    mouseUp: function(event, mouseEvent) {\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n        this.broadcast('mousedrag', mouseEvent);\n      }\n      this.mouse.dragStart = null;\n    }\n  };\n\n  //Return\n  return PlayerMode;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\n * a game record and its board positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Edit.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Setup tools\n */\n.constant('SetupTools', {\n  BLACK: 'black',\n  WHITE: 'white',\n  CLEAR: 'clear'\n})\n\n/**\n * Markup tools\n */\n.constant('MarkupTools', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  SAD: 'sad',\n  HAPPY: 'happy',\n  TEXT: 'text',\n  NUMBER: 'number',\n  CLEAR: 'clear'\n})\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeEdit', function(Player, PlayerModes, PlayerModeEdit) {\n\n  //Register event handlers\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\n\n  //Register mode\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeEdit', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['Player', 'PlayerTools', 'SetupTools', 'MarkupTools', 'MarkupTypes', 'GameScorer', 'StoneColor', function(\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\n  ) {\n\n    //Character codes\n    var aChar = 'A'.charCodeAt(0);\n    var aCharLc = 'a'.charCodeAt(0);\n\n    /**\n     * Update hover mark at specific coordinates\n     */\n    var updateHoverMark = function(x, y, isDrag) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Setup tool\n        case PlayerTools.SETUP:\n\n          //Clear tool\n          if (this.setupTool === SetupTools.CLEAR) {\n\n            //Stone present? Can remove it\n            if (this.game.hasStone(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Stone color tool\n          else {\n\n            //Add or overwrite stone if no stone present of the given color\n            if (!this.game.hasStone(x, y, this.setupToolColor())) {\n              this.board.add('hover', x, y, {\n                type: 'stones',\n                value: this.setupToolColor()\n              });\n            }\n\n            //Stone present of same color? Can remove it if we're not dragging\n            else if (!isDrag) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n          break;\n\n        //Markup tool\n        case PlayerTools.MARKUP:\n\n          //Clear tool, or already markup in place?\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\n            if (this.game.hasMarkup(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Text or number\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: {\n                type: MarkupTypes.LABEL,\n                text: this.markupLabel\n              }\n            });\n          }\n\n          //Other markup\n          else {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: this.markupTool\n            });\n          }\n          break;\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to set markup\n     */\n    var setMarkup = function(x, y) {\n\n      //Already markup in place? Remove it first\n      if (this.game.hasMarkup(x, y)) {\n\n        //Check what markup there is\n        var markup = this.game.getMarkup(x, y);\n\n        //Label? Also remove from our labels list\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\n          var i = this.markupLabels.indexOf(markup.text);\n          if (i !== -1) {\n            this.markupLabels.splice(i, 1);\n          }\n        }\n\n        //Remove from game\n        this.game.removeMarkup(x, y);\n        return;\n      }\n\n      //Clear tool used? Done\n      if (this.markupTool === MarkupTools.CLEAR) {\n        return;\n      }\n\n      //Text\n      else if (this.markupTool === MarkupTools.TEXT) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next text label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Number\n      else if (this.markupTool === MarkupTools.NUMBER) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next number label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Other markup\n      else {\n        this.game.addMarkup(x, y, this.markupTool);\n      }\n    };\n\n    /**\n     * Helper to set a stone\n     */\n    var setStone = function(x, y, isDrag) {\n\n      //Get the stone color\n      var color = this.setupToolColor();\n\n      //Trying to remove a stone\n      if (color === StoneColor.EMPTY) {\n        this.game.removeStone(x, y);\n      }\n\n      //Adding a stone\n      else {\n\n        //A stone there already of the same color? Just remove if not dragging\n        if (!isDrag && this.game.hasStone(x, y, color)) {\n          this.game.removeStone(x, y);\n          return;\n        }\n\n        //Any stone present?\n        else if (this.game.hasStone(x, y)) {\n          this.game.removeStone(x, y);\n        }\n\n        //Add stone now\n        this.game.addStone(x, y, color);\n      }\n\n      //Redraw markup\n      this.board.layers.markup.redrawCell(x, y);\n    };\n\n    /**\n     * Find all markup labels in current position\n     */\n    var findAllMarkupLabels = function() {\n\n      //Clear\n      this.markupLabels = [];\n\n      //Must have game\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get all markup from position\n      var markup = this.game.position.markup.all('type');\n      for (var i = 0; i < markup.length; i++) {\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\n          this.markupLabels.push(markup[i].text);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Active setup tool and markup tool\n      setupTool: SetupTools.BLACK,\n      markupTool: MarkupTools.TRIANGLE,\n\n      //Current markup labels on the board and current markup label\n      markupLabels: [],\n      markupLabel: '',\n\n      /**\n       * Set the setup tool\n       */\n      switchSetupTool: function(tool) {\n        this.setupTool = tool;\n      },\n\n      /**\n       * Set the markup tool\n       */\n      switchMarkupTool: function(tool) {\n        this.markupTool = tool;\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          this.determineMarkupLabel();\n        }\n      },\n\n      /**\n       * Conversion of setup tool to stone color\n       */\n      setupToolColor: function() {\n        switch (this.setupTool) {\n          case SetupTools.BLACK:\n            return StoneColor.B;\n          case SetupTools.WHITE:\n            return StoneColor.W;\n          default:\n            return StoneColor.EMPTY;\n        }\n      },\n\n      /**\n       * Set the new text markup label\n       */\n      setMarkupLabel: function(label) {\n        if (label) {\n          this.markupLabel = label;\n        }\n      },\n\n      /**\n       * Determine the new text markup label\n       */\n      determineMarkupLabel: function() {\n\n        //Clear\n        this.markupLabel = '';\n\n        //Check what tool we're using\n        switch (this.markupTool) {\n\n          //Text tool?\n          case MarkupTools.TEXT:\n            var i = 0;\n\n            //Loop while the label is present\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n\n              //A-Z\n              if (i < 26) {\n                this.markupLabel = String.fromCharCode(aChar + i);\n              }\n\n              //a-z\n              else if (i < 52) {\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\n              }\n\n              //AA, AB, AC, etc.\n              else {\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\n                  String.fromCharCode(aChar + (i % 26));\n              }\n\n              //Keep going\n              i++;\n            }\n            break;\n\n          //Number tool?\n          case MarkupTools.NUMBER:\n            this.markupLabel = 0;\n\n            //Loop while the label is present\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n              this.markupLabel++;\n            }\n            break;\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeEdit = {\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Remove all hover items\n        this.board.removeAll('hover');\n\n        //Single coordinate?\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //No dragging for labels\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //Loop area\n        for (var x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n          for (var y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n            updateHoverMark.call(this, x, y, true);\n          }\n        }\n      },\n\n      /**\n       * Keydown handler\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //TODO: tool switching via keyboard input\n        }\n      },\n\n      /**\n       * Click handler\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        this.board.removeAll('hover');\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Try to play the move\n            if (!this.game.play(event.x, event.y)) {\n              return;\n            }\n            this.processPosition();\n            break;\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Set stone and update board\n            setStone.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Set markup and update board\n            setMarkup.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Mouse drag handler\n       */\n      mouseDrag: function(event) {\n\n        //Initialize vars\n        var x, y;\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setStone.call(this, x, y, true);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Don't do this for labels\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n              break;\n            }\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setMarkup.call(this, x, y);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Path change\n       */\n      pathChange: function() {\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SETUP,\n          PlayerTools.MARKUP,\n          PlayerTools.SCORE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Find all markup labels in the current game position\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeEdit;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\n * through an existing game record without the ability to deviate from the tree or its variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Replay.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeReplay', function(Player, PlayerModes, PlayerModeReplay) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\n\n  //Register the mode\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeReplay', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Auto play delay\n    autoPlayDelay: 1000\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$interval', 'Player', 'PlayerModes', 'PlayerTools', 'MarkupTypes', 'GameScorer', function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show move variations on the board\n     */\n    var showMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n\n        //Auto variation markup should never overwrite existing markup\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\n          continue;\n        }\n\n        //Add to board\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n          type: this.board.theme.get('markup.variation.type'),\n          text: this.board.theme.get('markup.variation.text', i),\n          color: this.board.theme.get('markup.variation.color')\n        });\n      }\n    };\n\n    /**\n     * Helper to hide move variations from the board\n     */\n    var hideMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) move variations on the board\n     */\n    var drawMoveVariations = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get the current node\n      var node = this.game.getNode();\n      var variations;\n      if (!node) {\n        return;\n      }\n\n      //Child variations?\n      if (this.variationChildren && node.hasMoveVariations()) {\n        variations = node.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n\n      //Sibling variations?\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\n        variations = node.parent.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Auto play vars\n      autoPlaying: false,\n      autoPlayDelay: 1000,\n      autoPlayPromise: null,\n\n      /**\n       * Set auto play delay\n       */\n      setAutoPlayDelay: function(delay) {\n        if (this.autoPlayDelay !== delay) {\n          this.autoPlayDelay = delay;\n          this.broadcast('settingChange', 'autoPlayDelay');\n        }\n      },\n\n      /**\n       * Start auto play with a given delay\n       */\n      start: function(delay) {\n\n        //Not in replay mode or already auto playing?\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\n          return;\n        }\n\n        //Already auto playing, no game or no move children?\n        if (!this.game || !this.game.node.hasChildren()) {\n          return;\n        }\n\n        //Get self\n        var self = this;\n\n        //Determine delay\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\n\n        //Switch tool\n        this.switchTool(PlayerTools.NONE);\n\n        //Create interval\n        this.autoPlaying = true;\n        this.autoPlayPromise = $interval(function() {\n\n          //Advance to the next node\n          self.next(0, true);\n\n          //Ran out of children?\n          if (!self.game.node.hasChildren()) {\n            self.stop();\n          }\n        }, delay);\n\n        //Broadcast event\n        this.broadcast('autoPlayStarted', this.game.node);\n      },\n\n      /**\n       * Stop auto play\n       */\n      stop: function() {\n\n        //Not in replay mode or not auto playing?\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\n          return;\n        }\n\n        //Cancel interval\n        if (this.autoPlayPromise) {\n          $interval.cancel(this.autoPlayPromise);\n        }\n\n        //Clear flags\n        this.autoPlayPromise = null;\n        this.autoPlaying = false;\n\n        //Broadcast event\n        this.broadcast('autoPlayStopped', this.game.node);\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeReplay = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.setAutoPlayDelay(this.config.autoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'variationMarkup') {\n          drawMoveVariations.call(this, this.variationMarkup);\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Check if we clicked a move variation, advance to the next position if so\n            if (this.game.isMoveVariation(event.x, event.y)) {\n              this.next(this.game.getMoveVariation(event.x, event.y));\n            }\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeReplay.hover.call(this, event);\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SCORE,\n          PlayerTools.NONE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Stop auto playing\n        if (this.autoPlaying) {\n          this.stop();\n        }\n\n        //Hide move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, false);\n        }\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeReplay;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\n * go problems and finding the right move or variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Solve.Service', [\n  'ngGo'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeSolve', function(Player, PlayerModes, PlayerModeSolve) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\n\n  //Register mode\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeSolve', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Player color\n    playerColor: StoneColor.B,\n\n    //Show solution paths\n    solutionPaths: false,\n\n    //Auto play settings\n    solveAutoPlay: true,\n    solveAutoPlayDelay: 500\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$timeout', 'Player', 'PlayerModes', 'PlayerTools', 'KeyCodes', function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\n\n    /**\n     * Check if we can make a move\n     */\n    var canMakeMove = function() {\n\n      //We can make a move when...\n\n      //...there is no auto play going on\n      if (!this.solveAutoPlay) {\n        return true;\n      }\n\n      //...we solved the puzzle already\n      if (this.problemSolved) {\n        return true;\n      }\n\n      //...we are off path\n      if (this.problemOffPath) {\n        return true;\n      }\n\n      //...it's our turn\n      if (this.game.getTurn() === this.playerColor) {\n        return true;\n      }\n\n      //Otherwise, we can't make a move\n      return false;\n    };\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show solution paths\n     */\n    var showSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        if (variations[i].solution === true) {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.valid.type'),\n            text: this.board.theme.get('markup.solution.valid.text', i),\n            scale: this.board.theme.get('markup.solution.valid.scale'),\n            color: this.board.theme.get('markup.solution.valid.color')\n          });\n        }\n        else {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.invalid.type'),\n            text: this.board.theme.get('markup.solution.invalid.text', i),\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\n            color: this.board.theme.get('markup.solution.invalid.color')\n          });\n        }\n      }\n    };\n\n    /**\n     * Helper to hide solution paths\n     */\n    var hideSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) solution paths\n     */\n    var drawSolutionPaths = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get node and variations\n      var node = this.game.getNode();\n      var variations = node.getMoveVariations();\n\n      //When showing, make sure it's not during the auto solver's move\n      if (show && !this.problemSolved && this.solveAutoPlay) {\n        if (this.game.getTurn() !== this.playerColor) {\n          hideSolutionPaths.call(this, variations);\n          return;\n        }\n      }\n\n      //Call helper\n      if (show) {\n        showSolutionPaths.call(this, variations);\n      }\n      else {\n        hideSolutionPaths.call(this, variations);\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Solved and off-path flags\n      problemSolved: false,\n      problemOffPath: false,\n\n      //Problem start path\n      problemStartPath: null,\n\n      //The player color\n      playerColor: 0,\n\n      //Solution paths\n      solutionPaths: false,\n\n      //Auto play vars\n      solveAutoPlay: true,\n      solveAutoPlayDelay: 500,\n\n      //Navigation blocked flag\n      solveNavigationBlocked: false,\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlay: function(autoPlay) {\n        if (this.solveAutoPlay !== autoPlay) {\n          this.solveAutoPlay = autoPlay;\n          this.broadcast('settingChange', 'solveAutoPlay');\n        }\n      },\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlayDelay: function(delay) {\n        if (this.solveAutoPlayDelay !== delay) {\n          this.solveAutoPlayDelay = delay;\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\n        }\n      },\n\n      /**\n       * Set player color\n       */\n      setPlayerColor: function(color) {\n        if (this.playerColor !== color) {\n          this.playerColor = color;\n          this.broadcast('settingChange', 'playerColor');\n        }\n      },\n\n      /**\n       * Get player color\n       */\n      getPlayerColor: function(asOnBoard) {\n        if (asOnBoard && this.board) {\n          return this.board.colorMultiplier * this.playerColor;\n        }\n        return this.playerColor;\n      },\n\n      /**\n       * Toggle solution paths\n       */\n      toggleSolutionPaths: function(solutionPaths) {\n\n        //Toggle if not given\n        if (typeof solutionPaths === 'undefined') {\n          solutionPaths = !this.solutionPaths;\n        }\n\n        //Change?\n        if (solutionPaths !== this.solutionPaths) {\n          this.solutionPaths = solutionPaths;\n          this.broadcast('settingChange', 'solutionPaths');\n        }\n      },\n\n      /**\n       * Auto play next move\n       */\n      autoPlayNext: function(immediately) {\n\n        //Must have game and children\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\n          return;\n        }\n\n        //Init vars\n        var children = [];\n        var self = this;\n        var i;\n\n        //When picking a child node, we always prefer to pick a valid solution\n        for (i = 0; i < this.game.node.children.length; i++) {\n          if (this.game.node.children[i].solution) {\n            children.push(this.game.node.children[i]);\n          }\n        }\n\n        //No solution nodes? Just use all nodes then.\n        if (children.length === 0) {\n          children = this.game.node.children;\n        }\n\n        //Pick a random child node\n        i = Math.floor(Math.random() * children.length);\n\n        //No delay?\n        if (immediately || !this.solveAutoPlayDelay) {\n          this.next(children[i]);\n          return;\n        }\n\n        //Block navigation and run the timeout\n        this.solveNavigationBlocked = true;\n        $timeout(function() {\n\n          //Move to next move and unblock navigation\n          self.next(children[i]);\n          self.solveNavigationBlocked = false;\n\n        }, this.solveAutoPlayDelay);\n      },\n\n      /**\n       * Start solving from the current game node\n       */\n      solve: function() {\n\n        //Must have a game\n        if (!this.game || !this.game.isLoaded()) {\n          return false;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Remember problem start path\n        this.problemStartPath = this.game.getPath(true);\n\n        //Restrict start of navigation to the current node\n        this.restrictNode();\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      },\n\n      /**\n       * Restart the problem\n       */\n      restartProblem: function() {\n\n        //Must be in solve mode, must have game\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Go back to the start path\n        if (this.problemStartPath) {\n          this.goto(this.problemStartPath);\n        }\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeSolve = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.toggleSolutionPaths(this.config.solutionPaths);\n        this.setPlayerColor(this.config.playerColor);\n        this.setSolveAutoPlay(this.config.solveAutoPlay);\n        this.setSolveAutoPlayDelay(this.config.solveAutoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'solutionPaths') {\n          drawSolutionPaths.call(this, this.solutionPaths);\n        }\n\n        //Player color changed?\n        if (setting === 'playerColor') {\n\n          //Draw (or hide) solution paths\n          drawSolutionPaths.call(this, this.solutionPaths);\n\n          //Make an auto play move if it's not our turn\n          if (\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\n          ) {\n            this.autoPlayNext(true);\n          }\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this, event.x, event.y);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for keydown events\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //Right arrow\n          case KeyCodes.RIGHT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\n\n                //Go forward one move if solved\n                if (this.problemSolved) {\n                  this.next();\n                }\n              }\n            }\n            break;\n\n          //Left arrow\n          case KeyCodes.LEFT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked and not reached the start?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\n\n                //Go back one move\n                this.previous();\n\n                //Go back one more if this is not the player's turn and if\n                //the problem hasn't been solved yet\n                if (\n                  !this.problemSolved && this.solveAutoPlay &&\n                  this.game.getTurn() === -this.playerColor\n                ) {\n                  this.previous();\n                }\n              }\n            }\n            break;\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //A valid variation\n        if (this.game.isMoveVariation(event.x, event.y)) {\n\n          //Get the node\n          var i = this.game.getMoveVariation(event.x, event.y);\n\n          //Advance to the next position and get the next node\n          this.next(i);\n          var node = this.game.getNode();\n\n          //No children left? Check if we solved it or not\n          if (node.children.length === 0) {\n            if (node.solution === true) {\n              this.problemSolved = true;\n              this.broadcast('solutionFound', node);\n            }\n            else {\n              this.broadcast('solutionWrong', node);\n            }\n          }\n\n          //Auto-play next move?\n          else if (!this.problemSolved && this.solveAutoPlay) {\n            this.autoPlayNext();\n          }\n        }\n\n        //Unknown variation, try to play\n        else if (this.game.play(event.x, event.y)) {\n          this.problemOffPath = true;\n          this.processPosition();\n          this.broadcast('solutionOffPath', this.game.getNode());\n        }\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Draw solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Hide any solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, false);\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeSolve;\n  }];\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Gib2Jgf', ['ngGo', 'KifuBlank', function(ngGo, KifuBlank) {\n\n  /**\n   * Regular expressions\n   */\n  var regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\n  var regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\n  var regKomi = /GAMEGONGJE=([0-9]+)/gi;\n  var regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\n  var regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\n  var regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\n\n  /**\n   * Player parser function\n   */\n  var parsePlayer = function(jgf, match) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\n\n    //Create player object\n    var player = {\n      color: color,\n      name: match[2],\n      rank: match[3].toLowerCase()\n    };\n\n    //Check if player of this color already exists, if so, overwrite\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p] = player;\n        return;\n      }\n    }\n\n    //Player of this color not found, push\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, match) {\n    jgf.game.komi = parseFloat(match[1] / 10);\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, match) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Push date\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\n  };\n\n  /**\n   * Result parser function\n   */\n  var parseResult = function(jgf, match) {\n\n    //Winner color\n    var result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\n    result += '+';\n\n    //Win condition\n    if (match[2].match(/res/i)) {\n      result += 'R';\n    }\n    else if (match[2].match(/time/i)) {\n      result += 'T';\n    }\n    else {\n      result += match[2];\n    }\n\n    //Set in JGF\n    jgf.game.result = result;\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, match) {\n\n    //Determine player color\n    var color = match[2];\n    if (color === 1) {\n      color = 'B';\n    }\n    else if (color === 2) {\n      color = 'W';\n    }\n    else {\n      return;\n    }\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (false) {\n\n    }\n\n    //Regular move\n    else {\n      node.move[color] = [match[3] * 1, match[4] * 1];\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    parse: function(gib, stringified) {\n\n      //Get new JGF object\n      var jgf = KifuBlank.jgf();\n\n      //Initialize\n      var match;\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find player information\n      while ((match = regPlayer.exec(gib))) {\n        parsePlayer(jgf, match);\n      }\n\n      //Find komi\n      if ((match = regKomi.exec(gib))) {\n        parseKomi(jgf, match);\n      }\n\n      //Find game date\n      if ((match = regDate.exec(gib))) {\n        parseDate(jgf, match);\n      }\n\n      //Find game result\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\n        parseResult(jgf, match);\n      }\n\n      //Find moves\n      while ((match = regMove.exec(gib))) {\n\n        //Create new node\n        node = {};\n\n        //Parse move\n        parseMove(jgf, node, match);\n\n        //Push node to container\n        container.push(node);\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Jgf2Sgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Flip SGF alias map and create JGF alias map\n   */\n  var jgfAliases = {};\n  for (var sgfProp in sgfAliases) {\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\n    }\n  }\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert to SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Helper to escape SGF info\n   */\n  var escapeSgf = function(text) {\n    if (typeof text === 'string') {\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\n    }\n    return text;\n  };\n\n  /**\n   * Helper to write an SGF group\n   */\n  var writeGroup = function(prop, values, output, escape) {\n    if (values.length) {\n      output.sgf += prop;\n      for (var i = 0; i < values.length; i++) {\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\n      }\n    }\n  };\n\n  /**\n   * Move parser\n   */\n  var parseMove = function(move, output) {\n\n    //Determine and validate color\n    var color = move.B ? 'B' : (move.W ? 'W' : '');\n    if (color === '') {\n      return;\n    }\n\n    //Determine move\n    var coords = (move[color] === 'pass') ? '' : move[color];\n\n    //Append to SGF\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\n  };\n\n  /**\n   * Setup parser\n   */\n  var parseSetup = function(setup, output) {\n\n    //Loop colors\n    for (var color in setup) {\n      if (setup.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < setup[color].length; i++) {\n          setup[color][i] = convertCoordinates(setup[color][i]);\n        }\n\n        //Write as group\n        writeGroup('A' + color, setup[color], output);\n      }\n    }\n  };\n\n  /**\n   * Score parser\n   */\n  var parseScore = function(score, output) {\n\n    //Loop colors\n    for (var color in score) {\n      if (score.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < score[color].length; i++) {\n          score[color][i] = convertCoordinates(score[color][i]);\n        }\n\n        //Write as group\n        writeGroup('T' + color, score[color], output);\n      }\n    }\n  };\n\n  /**\n   * Markup parser\n   */\n  var parseMarkup = function(markup, output) {\n\n    //Loop markup types\n    for (var type in markup) {\n      if (markup.hasOwnProperty(type)) {\n        var i;\n\n        //Label type has the label text appended to the coords\n        if (type === 'label') {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\n          }\n        }\n        else {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]);\n          }\n        }\n\n        //Convert type\n        if (typeof jgfAliases[type] !== 'undefined') {\n          type = jgfAliases[type];\n        }\n\n        //Write as group\n        writeGroup(type, markup[type], output);\n      }\n    }\n  };\n\n  /**\n   * Turn parser\n   */\n  var parseTurn = function(turn, output) {\n    output.sgf += 'PL[' + turn + ']';\n  };\n\n  /**\n   * Comments parser\n   */\n  var parseComments = function(comments, output) {\n\n    //Determine key\n    var key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\n\n    //Flatten comment objects\n    var flatComments = [];\n    for (var c = 0; c < comments.length; c++) {\n      if (typeof comments[c] === 'string') {\n        flatComments.push(comments[c]);\n      }\n      else if (comments[c].comment) {\n        flatComments.push(comments[c].comment);\n      }\n    }\n\n    //Write as group\n    writeGroup(key, flatComments, output, true);\n  };\n\n  /**\n   * Node name parser\n   */\n  var parseNodeName = function(nodeName, output) {\n    var key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\n  };\n\n  /**\n   * Game parser\n   */\n  var parseGame = function(game) {\n\n    //Loop SGF game definitions\n    for (var i in sgfGames) {\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\n        return i;\n      }\n    }\n\n    //Not found\n    return 0;\n  };\n\n  /**\n   * Application parser\n   */\n  var parseApplication = function(application) {\n    var parts = application.split(' v');\n    if (parts.length > 1) {\n      return parts[0] + ':' + parts[1];\n    }\n    return application;\n  };\n\n  /**\n   * Player instructions parser\n   */\n  var parsePlayer = function(player, rootProperties) {\n\n    //Variation handling\n    var st = 0;\n    if (!player.variationMarkup) {\n      st += 2;\n    }\n    if (player.variationSiblings) {\n      st += 1;\n    }\n\n    //Set in root properties\n    rootProperties.ST = st;\n  };\n\n  /**\n   * Board parser\n   */\n  var parseBoard = function(board, rootProperties) {\n\n    //Both width and height should be given\n    if (board.width && board.height) {\n\n      //Same dimensions?\n      if (board.width === board.height) {\n        rootProperties.SZ = board.width;\n      }\n\n      //Different dimensions are not supported by SGF, but OGS uses the\n      //format w:h, so we will stick with that for anyone who supports it.\n      else {\n        rootProperties.SZ = board.width + ':' + board.height;\n      }\n    }\n\n    //Otherwise, check if only width or height were given at least\n    else if (board.width) {\n      rootProperties.SZ = board.width;\n    }\n    else if (board.height) {\n      rootProperties.SZ = board.height;\n    }\n\n    //Can't determine size\n    else {\n      rootProperties.SZ = '';\n    }\n  };\n\n  /**\n   * Players parser\n   */\n  var parsePlayers = function(players, rootProperties) {\n\n    //Loop players\n    for (var p = 0; p < players.length; p++) {\n\n      //Validate color\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\n        continue;\n      }\n\n      //Get SGF color\n      var color = (players[p].color === 'black') ? 'B' : 'W';\n\n      //Name given?\n      if (players[p].name) {\n        rootProperties['P' + color] = players[p].name;\n      }\n\n      //Rank given?\n      if (players[p].rank) {\n        rootProperties[color + 'R'] = players[p].rank;\n      }\n\n      //Team given?\n      if (players[p].team) {\n        rootProperties[color + 'T'] = players[p].team;\n      }\n    }\n  };\n\n  /**\n   * Parse function to property mapper\n   */\n  var parsingMap = {\n\n    //Node properties\n    'move': parseMove,\n    'setup': parseSetup,\n    'score': parseScore,\n    'markup': parseMarkup,\n    'turn': parseTurn,\n    'comments': parseComments,\n    'name': parseNodeName,\n\n    //Info properties\n    'record.application': parseApplication,\n    'player': parsePlayer,\n    'board': parseBoard,\n    'game.type': parseGame,\n    'game.players': parsePlayers\n  };\n\n  /*****************************************************************************\n   * Parser functions\n   ***/\n\n  /**\n   * Helper to write a JGF tree to SGF\n   */\n  var writeTree = function(tree, output) {\n\n    //Loop nodes in the tree\n    for (var i = 0; i < tree.length; i++) {\n      var node = tree[i];\n\n      //Array? That means a variation\n      if (angular.isArray(node)) {\n        for (var j = 0; j < node.length; j++) {\n          output.sgf += '(\\n;';\n          writeTree(node[j], output);\n          output.sgf += '\\n)';\n        }\n\n        //Continue\n        continue;\n      }\n\n      //Loop node properties\n      for (var key in node) {\n        if (node.hasOwnProperty(key)) {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[key] !== 'undefined') {\n            parsingMap[key](node[key], output);\n            continue;\n          }\n\n          //Other object, can't handle it\n          if (typeof node[key] === 'object') {\n            continue;\n          }\n\n          //Anything else, append it\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\n        }\n      }\n\n      //More to come?\n      if ((i + 1) < tree.length) {\n        output.sgf += '\\n;';\n      }\n    }\n  };\n\n  /**\n   * Helper to extract all SGF root properties from a JGF object\n   */\n  var extractRootProperties = function(jgf, rootProperties, key) {\n\n    //Initialize key\n    if (typeof key === 'undefined') {\n      key = '';\n    }\n\n    //Loop properties of jgf node\n    for (var subKey in jgf) {\n      if (jgf.hasOwnProperty(subKey)) {\n\n        //Skip SGF signature (as we keep our own)\n        if (subKey === 'sgf') {\n          continue;\n        }\n\n        //Build jgf key\n        var jgfKey = (key === '') ? subKey : key + '.' + subKey;\n\n        //If the item is an object, handle separately\n        if (typeof jgf[subKey] === 'object') {\n\n          //Handler for this object present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\n          }\n\n          //Otherwise, just flatten and call this function recursively\n          else {\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\n          }\n          continue;\n        }\n\n        //Check if it's a known key, if so, append the value to the root\n        var value;\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            value = parsingMap[jgfKey](jgf[subKey]);\n          }\n          else {\n            value = escapeSgf(jgf[subKey]);\n          }\n\n          //Set in root properties\n          rootProperties[jgfAliases[jgfKey]] = value;\n        }\n      }\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    parse: function(jgf) {\n\n      //String given?\n      if (typeof jgf === 'string') {\n        jgf = angular.fromJson(jgf);\n      }\n\n      //Must have moves tree\n      if (!jgf.tree) {\n        console.error('No moves tree in JGF object');\n        return;\n      }\n\n      //Initialize output (as object, so it remains a reference) and root properties container\n      var output = {sgf: '(\\n;'};\n      var root = angular.copy(jgf);\n      var rootProperties = KifuBlank.sgf();\n\n      //The first node of the JGF tree is the root node, and it can contain comments,\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\n      //and attach it to the root\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\n        root = angular.extend(root, jgf.tree[0]);\n        delete root.root;\n        delete jgf.tree[0];\n      }\n\n      //Set root properties\n      delete root.tree;\n      extractRootProperties(root, rootProperties);\n\n      //Write root properties\n      for (var key in rootProperties) {\n        if (rootProperties[key]) {\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\n        }\n      }\n\n      //Write game tree\n      writeTree(jgf.tree, output);\n\n      //Close SGF and return\n      output.sgf += ')';\n      return output.sgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Sgf2Jgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Regular expressions for SGF data\n   */\n  var regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\n  var regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\n  var regProperty = /[A-Z]+/;\n  var regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Application parser function (doesn't overwrite existing signature)\n   */\n  var parseApp = function(jgf, node, key, value) {\n    if (!jgf.record.application) {\n      var app = value[0].split(':');\n      if (app.length > 1) {\n        jgf.record.application = app[0] + ' v' + app[1];\n      }\n      else {\n        jgf.record.application = app[0];\n      }\n    }\n  };\n\n  /**\n   * SGF format parser\n   */\n  var parseSgfFormat = function() {\n    return;\n  };\n\n  /**\n   * Game type parser function\n   */\n  var parseGame = function(jgf, node, key, value) {\n    var game = value[0];\n    if (typeof sgfGames[game] !== 'undefined') {\n      jgf.game.type = sgfGames[game];\n    }\n    else {\n      jgf.game.type = value[0];\n    }\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, key, value) {\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\n      node.move[key] = 'pass';\n    }\n\n    //Regular move\n    else {\n      node.move[key] = convertCoordinates(value[0]);\n    }\n  };\n\n  /**\n   * Comment parser function\n   */\n  var parseComment = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Node name parser function\n   */\n  var parseNodeName = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value[0];\n  };\n\n  /**\n   * Board setup parser function\n   */\n  var parseSetup = function(jgf, node, key, value) {\n\n    //Initialize setup container on node\n    if (typeof node.setup === 'undefined') {\n      node.setup = {};\n    }\n\n    //Remove \"A\" from setup key\n    key = key.charAt(1);\n\n    //Initialize setup container of this type\n    if (typeof node.setup[key] === 'undefined') {\n      node.setup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.setup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Scoring parser function\n   */\n  var parseScore = function(jgf, node, key, value) {\n\n    //Initialize score container on node\n    if (typeof node.score === 'undefined') {\n      node.score = {\n        B: [],\n        W: []\n      };\n    }\n\n    //Remove \"T\" from setup key\n    key = key.charAt(1);\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.score[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Turn parser function\n   */\n  var parseTurn = function(jgf, node, key, value) {\n    node.turn = value[0];\n  };\n\n  /**\n   * Label parser function\n   */\n  var parseLabel = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n\n      //Split off coordinates and add label contents\n      var coords = convertCoordinates(value[i].substr(0, 2));\n      coords.push(value[i].substr(3));\n\n      //Add to node\n      node.markup[key].push(coords);\n    }\n  };\n\n  /**\n   * Markup parser function\n   */\n  var parseMarkup = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.markup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Size parser function\n   */\n  var parseSize = function(jgf, node, key, value) {\n\n    //Initialize board container\n    if (typeof jgf.board === 'undefined') {\n      jgf.board = {};\n    }\n\n    //Add size property (can be width:height or just a single size)\n    var size = value[0].split(':');\n    if (size.length > 1) {\n      jgf.board.width = parseInt(size[0]);\n      jgf.board.height = parseInt(size[1]);\n    }\n    else {\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\n    }\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, node, key, value) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Explode dates\n    var dates = value[0].split(',');\n    for (var d = 0; d < dates.length; d++) {\n      jgf.game.dates.push(dates[d]);\n    }\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, node, key, value) {\n    jgf.game.komi = parseFloat(value[0]);\n  };\n\n  /**\n   * Variations handling parser function\n   */\n  var parseVariations = function(jgf, node, key, value) {\n\n    //Initialize display property\n    if (typeof jgf.player === 'undefined') {\n      jgf.player = {};\n    }\n\n    //Initialize variation display settings\n    jgf.player.variationMarkup = false;\n    jgf.player.variationChildren = false;\n    jgf.player.variationSiblings = false;\n\n    //Parse as integer\n    var st = parseInt(value[0]);\n\n    //Determine what we want (see SGF specs for details)\n    switch (st) {\n      case 0:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationChildren = true;\n        break;\n      case 1:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationSiblings = true;\n        break;\n      case 2:\n        jgf.player.variationChildren = true;\n        break;\n      case 3:\n        jgf.player.variationSiblings = true;\n        break;\n    }\n  };\n\n  /**\n   * Player info parser function\n   */\n  var parsePlayer = function(jgf, node, key, value) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Check if player of this color already exists\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p][key] = value[0];\n        return;\n      }\n    }\n\n    //Player of this color not found, initialize\n    var player = {color: color};\n    player[key] = value[0];\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Parsing function to property mapper\n   */\n  var parsingMap = {\n\n    //Application, game type, board size, komi, date\n    'AP': parseApp,\n    'FF': parseSgfFormat,\n    'GM': parseGame,\n    'SZ': parseSize,\n    'KM': parseKomi,\n    'DT': parseDate,\n\n    //Variations handling\n    'ST': parseVariations,\n\n    //Player info handling\n    'PB': parsePlayer,\n    'PW': parsePlayer,\n    'BT': parsePlayer,\n    'WT': parsePlayer,\n    'BR': parsePlayer,\n    'WR': parsePlayer,\n\n    //Moves\n    'B': parseMove,\n    'W': parseMove,\n\n    //Node annotation\n    'C': parseComment,\n    'N': parseNodeName,\n\n    //Board setup\n    'AB': parseSetup,\n    'AW': parseSetup,\n    'AE': parseSetup,\n    'PL': parseTurn,\n    'TW': parseScore,\n    'TB': parseScore,\n\n    //Markup\n    'CR': parseMarkup,\n    'SQ': parseMarkup,\n    'TR': parseMarkup,\n    'MA': parseMarkup,\n    'SL': parseMarkup,\n    'LB': parseLabel\n  };\n\n  /**\n   * These properties need a node object\n   */\n  var needsNode = [\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB'\n  ];\n\n  /*****************************************************************************\n   * Parser helpers\n   ***/\n\n  /**\n   * Set info in the JGF tree at a certain position\n   */\n  var setInfo = function(jgf, position, value) {\n\n    //Position given must be an array\n    if (typeof position !== 'object') {\n      return;\n    }\n\n    //Initialize node to attach value to\n    var node = jgf;\n    var key;\n\n    //Loop the position\n    for (var p = 0; p < position.length; p++) {\n\n      //Get key\n      key = position[p];\n\n      //Last key reached? Done\n      if ((p + 1) === position.length) {\n        break;\n      }\n\n      //Create container if not set\n      if (typeof node[key] !== 'object') {\n        node[key] = {};\n      }\n\n      //Move up in tree\n      node = node[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    parse: function(sgf, stringified) {\n\n      //Get new JGF object (with SGF node as a base)\n      var jgf = KifuBlank.jgf({record: {sgf: {}}});\n\n      //Initialize\n      var stack = [];\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find sequence of elements\n      var sequence = sgf.match(regSequence);\n\n      //Loop sequence items\n      for (var i = 0; i < sequence.length; i++) {\n\n        //Push stack if new variation found\n        if (sequence[i] === '(') {\n\n          //First encounter, this defines the main tree branch, so skip\n          if (i === 0 || i === '0') {\n            continue;\n          }\n\n          //Push the current container to the stack\n          stack.push(container);\n\n          //Create variation container if it doesn't exist yet\n          if (!angular.isArray(container[container.length - 1])) {\n            container.push([]);\n          }\n\n          //Use variation container\n          container = container[container.length - 1];\n\n          //Now create moves container\n          container.push([]);\n          container = container[container.length - 1];\n          continue;\n        }\n\n        //Grab last container from stack if end of variation reached\n        else if (sequence[i] === ')') {\n          if (stack.length) {\n            container = stack.pop();\n          }\n          continue;\n        }\n\n        //Make array of properties within this sequence\n        var properties = sequence[i].match(regNode) || [];\n\n        //Loop them\n        for (var j = 0; j < properties.length; j++) {\n\n          //Get property's key and separate values\n          var key = regProperty.exec(properties[j])[0].toUpperCase();\n          var values = properties[j].match(regValues);\n\n          //Remove additional braces [ and ]\n          for (var k = 0; k < values.length; k++) {\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\n          }\n\n          //SGF parser present for this key? Call it, and we're done\n          if (typeof parsingMap[key] !== 'undefined') {\n\n            //Does this type of property need a node?\n            if (needsNode.indexOf(key) !== -1) {\n\n              //If no node object present, create a new node\n              //For moves, always a new node is created\n              if (!node || key === 'B' || key === 'W') {\n                node = {};\n                container.push(node);\n              }\n            }\n\n            //Apply parsing function on node\n            parsingMap[key](jgf, node, key, values);\n            continue;\n          }\n\n          //No SGF parser present, we continue with regular property handling\n\n          //If there is only one value, simplify array\n          if (values.length === 1) {\n            values = values[0];\n          }\n\n          //SGF alias known? Then this is an info element and we handle it accordingly\n          if (typeof sgfAliases[key] !== 'undefined') {\n\n            //The position in the JGF object is represented by dot separated strings\n            //in the sgfAliases array. Split the position and use the setInfo helper\n            //to set the info on the JGF object\n            setInfo(jgf, sgfAliases[key].split('.'), values);\n            continue;\n          }\n\n          //No SGF alias present either, just append the data\n\n          //Save in node\n          if (node) {\n            node[key] = values;\n          }\n\n          //Save in root\n          else {\n            jgf[key] = values;\n          }\n        }\n\n        //Reset node, unless this was the root node\n        if (node && !node.root) {\n          node = null;\n        }\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n","/**\n * ng-go - v1.2.7 - 2-11-2015\n * https://github.com/adambuczynski/ngGo\n *\n * Copyright (c) 2015 Adam Buczynski <me@adambuczynski.com>\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n/**\n * ngGo\n *\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\n * refactored to fit the Angular framework, as well as having been linted, properly commented\n * and generally cleaned up.\n *\n * Copyright (c) 2013 Jan Prokop (WGo)\n * Copyright (c) 2014-2015 Adam Buczynski (ngGo)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo', [])\n\n/**\n * ngGo constants\n */\n.constant('ngGo', {\n  name: 'ngGo',\n  version: '1.2.7',\n  error: {\n\n    //Position errors\n    POSITION_OUT_OF_BOUNDS: 1,\n    POSITION_ALREADY_HAS_STONE: 2,\n    POSITION_IS_SUICIDE: 3,\n    POSITION_IS_REPEATING: 4,\n\n    //Data loading errors\n    NO_DATA: 5,\n    UNKNOWN_DATA: 6,\n    INVALID_SGF: 7,\n    INVALID_GIB: 8,\n    INVALID_JGF_JSON: 9,\n    INVALID_JGF_TREE_JSON: 10\n  }\n})\n\n/**\n * Stone colors\n */\n.constant('StoneColor', {\n  E: 0,\n  EMPTY: 0,\n  B: 1,\n  BLACK: 1,\n  W: -1,\n  WHITE: -1\n})\n\n/**\n * Markup types\n */\n.constant('MarkupTypes', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  LABEL: 'label',\n  LAST: 'last',\n  SAD: 'sad',\n  HAPPY: 'happy'\n})\n\n/**\n * Player modes\n */\n.constant('PlayerModes', {\n  PLAY: 'play',\n  REPLAY: 'replay',\n  EDIT: 'edit',\n  SOLVE: 'solve'\n})\n\n/**\n * Player tools\n */\n.constant('PlayerTools', {\n  NONE: 'none',\n  MOVE: 'move',\n  SCORE: 'score',\n  SETUP: 'setup',\n  MARKUP: 'markup'\n})\n\n/**\n * Key codes\n */\n.constant('KeyCodes', {\n  LEFT: 37,\n  RIGHT: 39,\n  UP: 38,\n  DOWN: 40,\n  ESC: 27,\n  ENTER: 13,\n  SPACE: 32,\n  TAB: 9,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  HOME: 36,\n  END: 35,\n  PAGEUP: 33,\n  PAGEDOWN: 34\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Directive', [\n  'ngGo.Board.Service'\n])\n\n/**\n * Directive definition\n */\n.directive('board', ['$window', 'Board', function($window, Board) {\n\n  //Get pixel ratio\n  var pixelRatio = window.pixelRatio || 1;\n\n  /**\n   * Helper to create a layer canvas\n   */\n  var createLayerCanvas = function(name) {\n\n    //Create canvas element and get context\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    //Scale context depending on pixel ratio\n    if (pixelRatio > 1) {\n      context.scale(pixelRatio, pixelRatio);\n    }\n\n    //Set class\n    canvas.className = name;\n\n    //Set initial canvas width/height based on our own size\n    canvas.width = this.clientWidth * pixelRatio;\n    canvas.height = this.clientHeight * pixelRatio;\n\n    //Append to element now and return context\n    this.appendChild(canvas);\n    return context;\n  };\n\n  /**\n   * Helper to determine draw size\n   */\n  var determineDrawSize = function(scope, availableWidth, availableHeight) {\n\n    //Init vars\n    var drawWidth, drawHeight, cellSize;\n\n    //Stretch available height to width if zero\n    if (availableHeight === 0 && availableWidth > 0) {\n      availableHeight = availableWidth;\n    }\n\n    //Grid size known?\n    if (scope.Board.width && scope.Board.height) {\n\n      //Determine smallest cell size\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\n\n      //Set draw size\n      drawWidth = Math.floor(cellSize * scope.Board.width);\n      drawHeight = Math.floor(cellSize * scope.Board.height);\n    }\n\n    //Otherwise, use the lesser of the available width/height\n    else {\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\n    }\n\n    //Broadcast new size if changed\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\n      scope.lastDrawWidth = drawWidth;\n      scope.lastDrawHeight = drawHeight;\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\n      return true;\n    }\n\n    //No change\n    return false;\n  };\n\n  /**\n   * Directive\n   */\n  return {\n    restrict: 'E',\n    scope: {\n      instance: '&'\n    },\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Init vars\n      var i, context, layer, playerElement;\n      var parent = element.parent();\n      var sizingElement = element[0];\n      var existingInstance = true;\n\n      //Remember last draw width/height\n      scope.lastDrawWidth = 0;\n      scope.lastDrawHeight = 0;\n\n      //Get board instance\n      scope.Board = scope.instance();\n\n      //Function given?\n      if (typeof scope.Board === 'function') {\n        scope.Board = scope.Board();\n      }\n\n      //Instantiate board if not present in scope\n      if (!scope.Board) {\n        existingInstance = false;\n        scope.Board = new Board();\n      }\n\n      //Link element\n      scope.Board.linkElement(element);\n\n      //Find player element\n      if (parent[0].tagName === 'PLAYER') {\n        playerElement = parent;\n        sizingElement = parent.parent()[0];\n      }\n\n      //Listen for board drawsize events\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\n\n        //First set the new dimensions on the canvas elements\n        var canvas = element.find('canvas');\n        for (i = 0; i < canvas.length; i++) {\n          canvas[i].width = width * pixelRatio;\n          canvas[i].height = height * pixelRatio;\n        }\n\n        //Set on the element if we're using a player element and if there is a size\n        if (playerElement || attrs.forceSize === 'true') {\n          element.css({width: width + 'px', height: height + 'px'});\n        }\n\n        //Next set it on the board itself\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\n      });\n\n      //Determine initial draw size\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n\n      //On window resize, determine the draw size again\n      angular.element($window).on('resize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On manual resize, determine draw size again\n      scope.$on('ngGo.board.determineDrawSize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On board grid resize, determine the draw size again\n      scope.$on('ngGo.board.resize', function(event, board) {\n\n        //Only relevent if this was our own board\n        if (board !== scope.Board) {\n          return;\n        }\n\n        //If the draw size didn't change, the draw size event won't be triggered.\n        //However, that means we should call the resized() method now manually because\n        //it won't be called with the setDrawSize() call.\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\n          scope.Board.resized();\n        }\n      });\n\n      //Static board\n      if (attrs.static && attrs.static === 'true') {\n\n        //Add static class and make the board static\n        element.addClass('static');\n        scope.Board.makeStatic();\n\n        //Create single canvas and link to all relevant layer service classes\n        context = createLayerCanvas.call(element[0], 'static');\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Dynamic board\n      else {\n\n        //Create individual layer canvasses and link the canvas context to the layer service class\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          context = createLayerCanvas.call(element[0], layer);\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Observe the board size attribute\n      attrs.$observe('size', function(size) {\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\n          size = size.split('x');\n          scope.Board.setSize(size[0], size[1]);\n        }\n        else {\n          scope.Board.setSize(size, size);\n        }\n      });\n\n      //Observe the coordinates attribute\n      attrs.$observe('coordinates', function(attr) {\n        scope.Board.toggleCoordinates(attr === 'true');\n      });\n\n      //Observe the cutoff attribute\n      attrs.$observe('cutoff', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.setCutoff(attr.split(','));\n        }\n      });\n\n      //Observe color multiplier\n      attrs.$observe('colorMultiplier', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.swapColors(attr);\n        }\n      });\n\n      //Link board to player if present in parent scope\n      if (scope.$parent.Player) {\n        scope.$parent.Player.setBoard(scope.Board);\n      }\n\n      //Redraw board if we had an existing instance (it might contain data)\n      if (existingInstance) {\n        scope.Board.redraw();\n      }\n    }\n  };\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\n * and is used for placing and removing objects on the board. The class has helpers to figure out\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\n * responsible for drawing all layers on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Service', [\n  'ngGo',\n  'ngGo.Board.Directive',\n  'ngGo.Board.Theme.Service',\n  'ngGo.Board.Layer.GridLayer.Service',\n  'ngGo.Board.Layer.ShadowLayer.Service',\n  'ngGo.Board.Layer.StonesLayer.Service',\n  'ngGo.Board.Layer.MarkupLayer.Service',\n  'ngGo.Board.Layer.ScoreLayer.Service',\n  'ngGo.Board.Layer.HoverLayer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.Stone.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Board', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Width and height\n    width: 0,\n    height: 0,\n\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\n    cutoff: [],\n\n    //Section of board to display\n    section: {top: 0, right: 0, bottom: 0, left: 0},\n\n    //Show coordinates?\n    coordinates: false,\n\n    //Color multiplier (use -1 to swap colors)\n    colorMultiplier: 1\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$injector', 'BoardTheme', function($rootScope, $injector, BoardTheme) {\n\n    /**\n     * Board constructor\n     */\n    var Board = function(config) {\n\n      //Initialize board\n      this.init();\n\n      //Parse config\n      this.parseConfig(config || {});\n    };\n\n    /**\n     * Initialize board\n     */\n    Board.prototype.init = function() {\n\n      //Remove everything\n      this.removeAll();\n\n      //Set board theme\n      this.theme = new BoardTheme();\n\n      //Initialize board draw dimensions in pixels\n      this.cellSize = 0;\n      this.drawWidth = 0;\n      this.drawHeight = 0;\n      this.drawMarginHor = 0;\n      this.drawMarginVer = 0;\n      this.gridDrawWidth = 0;\n      this.gridDrawHeight = 0;\n\n      //Set layer order\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\n\n      //Initialize layers\n      this.layers = {};\n      for (var l = 0; l < this.layerOrder.length; l++) {\n        var layer = this.layerOrder[l];\n        var layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\n        var LayerClass = $injector.get(layerClass);\n        this.layers[layer] = new LayerClass(this);\n      }\n\n      //Static board flag\n      this.static = false;\n\n      //Get margin from theme\n      this.margin = this.theme.get('board.margin');\n\n      //Color multiplier (to allow color swapping)\n      this.colorMultiplier = 1;\n\n      //Turn off coordinates\n      this.coordinates = false;\n      this.layers.grid.setCoordinates(false);\n\n      //Initialize grid size\n      this.width = 0;\n      this.height = 0;\n\n      //Initialize cutoff\n      this.cutoff = {\n        top: false,\n        left: false,\n        right: false,\n        bottom: false\n      };\n\n      //Initialize section\n      this.section = {\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    };\n\n    /**\n     * Link the board to a HTML element\n     */\n    Board.prototype.linkElement = function(element) {\n      this.element = element;\n    };\n\n    /**\n     * Make this board static (one canvas layer, only grid, stones and markup)\n     */\n    Board.prototype.makeStatic = function() {\n      this.static = true;\n      this.layerOrder = ['grid', 'stones', 'markup'];\n    };\n\n    /*****************************************************************************\n     * Configuration\n     ***/\n\n    /**\n     * Parse config instructions\n     */\n    Board.prototype.parseConfig = function(config) {\n\n      //Validate\n      if (typeof config !== 'object') {\n        return;\n      }\n\n      //Extend from default config\n      config = angular.extend({}, defaultConfig, config);\n\n      //Process settigns\n      this.toggleCoordinates(config.coordinates);\n      this.swapColors(config.colorMultiplier);\n      this.setCutoff(config.cutoff);\n      this.setSection(config.section);\n      this.setSize(config.width, config.height);\n    };\n\n    /**\n     * Set margin\n     */\n    Board.prototype.setMargin = function(margin) {\n\n      //Reset when not defined\n      if (typeof margin === 'undefined') {\n        margin = this.theme.get('board.margin');\n      }\n\n      //Set margin if changed\n      if (this.margin !== margin) {\n        this.margin = margin;\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set grid cut-off\n     */\n    Board.prototype.setCutoff = function(cutoff) {\n\n      //Nothing given? Reset cutoff\n      if (!cutoff || !angular.isArray(cutoff)) {\n        cutoff = [];\n      }\n\n      //Init\n      var changes = false;\n\n      //Check if there's a change\n      for (var side in this.cutoff) {\n        if (this.cutoff.hasOwnProperty(side)) {\n          if (cutoff.indexOf(side) !== -1) {\n            if (!this.cutoff[side]) {\n              this.cutoff[side] = true;\n              changes = true;\n            }\n          }\n          else {\n            if (this.cutoff[side]) {\n              this.cutoff[side] = false;\n              changes = true;\n            }\n          }\n        }\n      }\n\n      //Trigger resized if there were changes\n      if (changes) {\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set section of the board to be displayed\n     */\n    Board.prototype.setSection = function(section) {\n\n      //Nothing given?\n      if (!section || typeof section !== 'object') {\n        return this;\n      }\n\n      //Expand on default\n      section = angular.extend({\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      }, section);\n\n      //No changes?\n      if (\n        this.section.top === section.top && this.section.bottom === section.bottom &&\n        this.section.left === section.left && this.section.right === section.right\n      ) {\n        return this;\n      }\n\n      //Set section and call resized handler\n      this.section = section;\n      this.resized();\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set board size. This will clear the board objects.\n     */\n    Board.prototype.setSize = function(width, height) {\n\n      //Check what's given\n      width = parseInt(width || height || 0);\n      height = parseInt(height || width || 0);\n\n      //Invalid?\n      if (isNaN(width) || isNaN(height)) {\n        return;\n      }\n\n      //Changing?\n      if (width !== this.width || height !== this.height) {\n\n        //Remember size\n        this.width = width;\n        this.height = height;\n\n        //Set size in layers\n        for (var layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].setSize(width, height);\n          }\n        }\n\n        //Broadcast event (no call to resized, as that is handled in the directive)\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set new draw size\n     */\n    Board.prototype.setDrawSize = function(width, height) {\n      if (width !== this.drawWidth || height !== this.drawHeight) {\n        this.drawWidth = width;\n        this.drawHeight = height;\n        this.resized();\n      }\n    };\n\n    /**\n     * Toggle the coordinates\n     */\n    Board.prototype.toggleCoordinates = function(show) {\n\n      //Set or toggle\n      if (typeof show !== 'undefined') {\n        this.coordinates = show;\n      }\n      else {\n        this.coordinates = !this.coordinates;\n      }\n\n      //Set in grid layer\n      this.layers.grid.setCoordinates(this.coordinates);\n\n      //Set the proper board margin\n      if (this.coordinates) {\n        this.setMargin(this.theme.get('coordinates.margin'));\n      }\n      else {\n        this.setMargin(this.theme.get('board.margin'));\n      }\n    };\n\n    /**\n     * Swap colors on the board\n     */\n    Board.prototype.swapColors = function(multiplier) {\n\n      //Multiplier not given? Set to inverse of current value\n      if (typeof multiplier === 'undefined') {\n        multiplier = -this.colorMultiplier;\n      }\n      else {\n        multiplier = parseInt(multiplier);\n        if (isNaN(multiplier)) {\n          return;\n        }\n      }\n\n      //No change?\n      if (multiplier === this.colorMultiplier) {\n        return;\n      }\n\n      //Set new value\n      this.colorMultiplier = multiplier;\n\n      //For static board, redraw the whole thing\n      if (this.static) {\n        this.redraw();\n      }\n\n      //For a dynamic board, only these layers\n      else {\n        this.redraw('stones');\n        this.redraw('markup');\n      }\n    };\n\n    /*****************************************************************************\n     * Theme handling\n     ***/\n\n    /**\n     * Get the current theme object\n     */\n    Board.prototype.getTheme = function() {\n      return this.theme;\n    };\n\n    /**\n     * Set the theme object\n     */\n    Board.prototype.setTheme = function(theme) {\n      this.theme = theme;\n      return this;\n    };\n\n    /*****************************************************************************\n     * Object handling\n     ***/\n\n    /**\n     * Add an object to a board layer\n     */\n    Board.prototype.add = function(layer, x, y, value) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].add(x, y, value);\n      }\n    };\n\n    /**\n     * Remove an object from a board layer\n     */\n    Board.prototype.remove = function(layer, x, y) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].remove(x, y);\n      }\n    };\n\n    /**\n     * Get something from a board layer\n     */\n    Board.prototype.get = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].get(x, y));\n    };\n\n    /**\n     * Check if we have something at given coordinates for a given layer\n     */\n    Board.prototype.has = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].has(x, y));\n    };\n\n    /**\n     * Set all objects (grid) for a given layer\n     */\n    Board.prototype.setAll = function(layer, grid) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].setAll(grid);\n      }\n    };\n\n    /**\n     * Remove all objects from the board, optionally for a given layer\n     */\n    Board.prototype.removeAll = function(layer) {\n      if (layer) {\n        if (typeof this.layers[layer] !== 'undefined') {\n          this.layers[layer].removeAll();\n        }\n      }\n      else {\n        for (layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].removeAll();\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Position handling\n     ***/\n\n    /**\n     * Update the board with a new position\n     */\n    Board.prototype.updatePosition = function(position, pathChanged) {\n\n      //If we have no grid size yet, use what's in the position\n      if (!this.width || !this.height) {\n        this.setSize(position.width, position.height);\n      }\n\n      //Remove markup if path changed\n      if (pathChanged) {\n        this.removeAll('markup');\n      }\n\n      //Set new stones and markup grids\n      this.setAll('stones', position.stones);\n      this.setAll('markup', position.markup);\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state (list of objects per layer)\n     */\n    Board.prototype.getState = function(layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          return this.layers[layer].getAll();\n        }\n        return null;\n      }\n\n      //All layers\n      var state = {};\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          var grid = this.layers[layer].getAll();\n          if (grid && !grid.isEmpty()) {\n            state[layer] = grid;\n          }\n        }\n      }\n      return state;\n    };\n\n    /**\n     * Restore the board state from given state object\n     */\n    Board.prototype.restoreState = function(state, layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          this.layers[layer].setAll(state);\n        }\n        return;\n      }\n\n      //All layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].removeAll();\n          if (state[layer]) {\n            this.layers[layer].setAll(state[layer]);\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing control\n     ***/\n\n    /**\n     * Clear the whole board\n     */\n    Board.prototype.clear = function(layer) {\n\n      //Just clearing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Clear the layer\n        this.layers[layer].clear();\n        return;\n      }\n\n      //Static? One clear is enough\n      if (this.static) {\n        this.layers.stones.clear();\n        return;\n      }\n\n      //Clear all layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].clear();\n        }\n      }\n    };\n\n    /**\n     * Redraw everything or just a single layer\n     */\n    Board.prototype.redraw = function(layer) {\n\n      //The board can only be redrawn when there is a grid size and a draw size\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Just redrawing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Redraw the layer\n        this.layers[layer].redraw();\n        return;\n      }\n\n      //Clear the board first\n      this.clear();\n\n      //Now draw all layers again in the correct order\n      for (var i = 0; i < this.layerOrder.length; i++) {\n        layer = this.layerOrder[i];\n        this.layers[layer].draw();\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing helpers\n     ***/\n\n    /**\n     * Called after a board size change, draw size change, section change or margin change\n     */\n    Board.prototype.resized = function() {\n\n      //Determine the new grid\n      this.grid = {\n        xLeft: 0 + this.section.left,\n        xRight: this.width - 1 - this.section.right,\n        yTop: 0 + this.section.top,\n        yBot: this.height - 1 - this.section.bottom\n      };\n\n      //Only redraw when there is sensible data\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Determine number of cells horizontall and vertically\n      //The margin is a factor of the cell size, so let's add it to the number of cells\n      var noCellsHor = this.width + this.margin;\n      var noCellsVer = this.height + this.margin;\n\n      //Are we cutting off parts of the grid? Add half a cell of draw size\n      for (var side in this.cutoff) {\n        if (this.cutoff[side]) {\n          if (side === 'top' || side === 'bottom') {\n            noCellsVer += 0.5;\n          }\n          else {\n            noCellsHor += 0.5;\n          }\n        }\n      }\n\n      //Determine cell size now\n      this.cellSize = Math.floor(Math.min(\n        this.drawWidth / noCellsHor,\n        this.drawHeight / noCellsVer\n      ));\n\n      //Determine actual grid draw size (taking off the margin again)\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\n\n      //Determine draw margins\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\n\n      //Redraw\n      this.redraw();\n    };\n\n    /**\n     * Get the current cell size\n     */\n    Board.prototype.getCellSize = function() {\n      return this.cellSize;\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsX = function(gridX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsY = function(gridY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridX = function(absX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridY = function(absY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\n    };\n\n    /**\n     * Check if given grid coordinates are on board\n     */\n    Board.prototype.isOnBoard = function(gridX, gridY) {\n      return (\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\n      );\n    };\n\n    //Return object\n    return Board;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\n * a small rectangular area on the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('DefaultClearHandler', function() {\n\n  /**\n   * Clear handler definition\n   *\n   * All external handlers are called from the context of the layer that contains the object.\n   * First parameter is the canvas2d context, second parameter is the object itself.\n   */\n  return function(context, obj) {\n\n    //No context?\n    if (!context) {\n      return;\n    }\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(obj.x);\n    var y = this.board.getAbsY(obj.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Clear rectangle the size of the stone radius\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\n  };\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\n * stone color values for the game position class. It has built in validation of coordinates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Grid.Service', [\n  'ngGo',\n  'ngGo.Board.GridChanges.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGrid', ['BoardGridChanges', function(BoardGridChanges) {\n\n  /**\n   * Helper to convert a value at given coordinates to an object\n   */\n  var toObject = function(x, y, valueKey) {\n\n    //Create coordinates object\n    var obj = {\n      x: x,\n      y: y\n    };\n\n    //Already an object?\n    if (typeof this.grid[x][y] === 'object') {\n      return angular.extend(obj, this.grid[x][y]);\n    }\n\n    //Not an object, set value with given value key and return\n    obj[valueKey] = this.grid[x][y];\n    return obj;\n  };\n\n  /**\n   * Constructor\n   */\n  var BoardGrid = function(width, height, emptyValue) {\n\n    //Initialize size and grid array\n    this.width = 0;\n    this.height = 0;\n    this.grid = [];\n    this.emptyValue = null;\n\n    //Set empty value if given\n    if (typeof emptyValue !== 'undefined') {\n      this.emptyValue = emptyValue;\n    }\n\n    //Size given? Set it\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set a value\n   */\n  BoardGrid.prototype.set = function(x, y, value) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = value;\n    }\n  };\n\n  /**\n   * Unset a value\n   */\n  BoardGrid.prototype.unset = function(x, y) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = this.emptyValue;\n    }\n  };\n\n  /**\n   * Check if we have a non null value on the coordinates\n   */\n  BoardGrid.prototype.has = function(x, y) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\n  };\n\n  /**\n   * Check if we have a specific value on the coordinates\n   */\n  BoardGrid.prototype.is = function(x, y, value) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\n  };\n\n  /**\n   * Get a value, or an object with coordinates and the value in the given value key\n   */\n  BoardGrid.prototype.get = function(x, y, valueKey) {\n\n    //Validate\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\n      return this.emptyValue;\n    }\n\n    //Return as is?\n    if (!valueKey) {\n      return this.grid[x][y];\n    }\n\n    //Return as object\n    return toObject.call(this, x, y, valueKey);\n  };\n\n  /*****************************************************************************\n   * Mass operations\n   ***/\n\n  /**\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\n   * and the value in the given value key will be returned.\n   */\n  BoardGrid.prototype.all = function(valueKey) {\n\n    //Just get the grid?\n    if (!valueKey) {\n      return this.grid;\n    }\n\n    //Initialize objects list\n    var objects = [];\n\n    //Loop coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          objects.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return objects list\n    return objects;\n  };\n\n  /**\n   * Check if there is anything\n   */\n  BoardGrid.prototype.isEmpty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Populate the whole grid with a given value\n   */\n  BoardGrid.prototype.populate = function(value) {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = value;\n      }\n    }\n  };\n\n  /**\n   * Empty the grid\n   */\n  BoardGrid.prototype.empty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Clone ourselves\n   */\n  BoardGrid.prototype.clone = function() {\n\n    //Create new instance\n    var newGrid = new BoardGrid();\n\n    //Manually set vars for maximum efficiency\n    newGrid.grid = angular.copy(this.grid);\n    newGrid.emptyValue = this.emptyValue;\n    newGrid.width = this.width;\n    newGrid.height = this.height;\n\n    //Return\n    return newGrid;\n  };\n\n  /*****************************************************************************\n   * Comparison\n   ***/\n\n  /**\n   * Checks if a given grid is the same as the current grid\n   */\n  BoardGrid.prototype.isSameAs = function(grid) {\n\n    //Must have the same size\n    if (this.width !== grid.width || this.height !== grid.height) {\n      return false;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== grid[x][y]) {\n          return false;\n        }\n      }\n    }\n\n    //No differences found\n    return true;\n  };\n\n  /**\n   * Compares this position with another position and return change object\n   */\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\n\n    //Initialize board grid changes object\n    var changes = new BoardGridChanges();\n\n    //Must have the same size\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\n      console.warn('Trying to compare grids of a different size');\n      return changes;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n\n        //Something to add?\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\n        }\n\n        //Something to remove?\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.remove.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return changes grid\n    return changes;\n  };\n\n  /*****************************************************************************\n   * Helpers\n   ***/\n\n  /**\n   * Helper to validate coordinates (first param can be an object)\n   */\n  BoardGrid.prototype.isOnGrid = function(x, y) {\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\n  };\n\n  /**\n   * Helper to set the empty value\n   */\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\n    this.emptyValue = emptyValue;\n  };\n\n  /**\n   * Set the grid size\n   */\n  BoardGrid.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Create grid array\n    this.grid = [];\n    for (var x = 0; x < this.width; x++) {\n      this.grid[x] = [];\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Get the grid size object\n   */\n  BoardGrid.prototype.getSize = function() {\n    return {width: this.width, height: this.height};\n  };\n\n  //Return\n  return BoardGrid;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\n * grids. It simply keeps track of what was added and what was removed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.GridChanges.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGridChanges', function() {\n\n  /**\n   * Helper to subtract sets\n   */\n  var setSubtract = function(a, b) {\n    var n = [];\n    var q;\n    for (var i = 0; i < a.length; i++) {\n      q = true;\n      for (var j in b) {\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\n          q = false;\n          break;\n        }\n      }\n      if (q) {\n        n.push(a[i]);\n      }\n    }\n    return n;\n  };\n\n  /**\n   * Game position constructor\n   */\n  return function() {\n\n    /**\n     * Containers\n     */\n    this.add = [];\n    this.remove = [];\n\n    /**\n     * Concatenation helper\n     */\n    this.concat = function(newChanges) {\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\n    };\n\n    /**\n     * Check if there are changes\n     */\n    this.has = function() {\n      return !!(this.add.length || this.remove.length);\n    };\n  };\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\n * for drawing itself as well as its objects onto the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardLayer', ['BoardGrid', function(BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var BoardLayer = function(board, context) {\n\n    //Remember board reference and 2d canvas context\n    this.board = board;\n    this.context = context;\n\n    //Initialize grid for board objects\n    this.grid = new BoardGrid();\n  };\n\n  /*****************************************************************************\n   * Generic grid and object handling\n   ***/\n\n  /**\n   * Set grid size\n   */\n  BoardLayer.prototype.setSize = function(width, height) {\n\n    //Note: since this method is usually only called upon a global board resize,\n    //which also triggers the redraw method for layers, the layer is not cleared\n    //here, as it will happen anyway during the redraw cycle.\n\n    //Set it in the grid (removing all objects in the process)\n    this.grid.setSize(width, height);\n  };\n\n  /**\n   * Get all items\n   */\n  BoardLayer.prototype.getAll = function() {\n    return this.grid.clone();\n  };\n\n  /**\n   * Set all items at once\n   */\n  BoardLayer.prototype.setAll = function(grid) {\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  BoardLayer.prototype.removeAll = function() {\n    this.clear();\n    this.grid.empty();\n  };\n\n  /**\n   * Add a single item\n   */\n  BoardLayer.prototype.add = function(x, y, value) {\n    this.clearCell(x, y);\n    this.grid.set(x, y, value);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Remove a single item\n   */\n  BoardLayer.prototype.remove = function(x, y) {\n    this.clearCell(x, y);\n    this.grid.unset(x, y);\n  };\n\n  /**\n   * Get an item\n   */\n  BoardLayer.prototype.get = function(x, y) {\n    return this.grid.get(x, y);\n  };\n\n  /**\n   * Check if there is an item\n   */\n  BoardLayer.prototype.has = function(x, y) {\n    return this.grid.has(x, y);\n  };\n\n  /*****************************************************************************\n   * Generic drawing methods\n   ***/\n\n  /**\n   * Draw layer\n   */\n  BoardLayer.prototype.draw = function() {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\n   */\n  BoardLayer.prototype.clear = function() {\n    if (this.context) {\n      this.context.clearRect(\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\n      );\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  BoardLayer.prototype.redraw = function() {\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear cell\n   */\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\n    //Clearing method to be implemented in specific layer class\n  };\n\n  /**\n   * Redraw cell\n   */\n  BoardLayer.prototype.redrawCell = function(x, y) {\n    this.clearCell(x, y);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Set the canvas2d context\n   */\n  BoardLayer.prototype.setContext = function(context) {\n    this.context = context;\n  };\n\n  /**\n   * Get the canvas2d context\n   */\n  BoardLayer.prototype.getContext = function() {\n    return this.context;\n  };\n\n  //Return\n  return BoardLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardObject :: Base class for drawing board objects\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Service', [\n  'ngGo',\n  'ngGo.Board.DefaultClearHandler.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardObject', ['DefaultClearHandler', function(DefaultClearHandler) {\n\n  /**\n   * Constructor\n   */\n  var BoardObject = {\n\n    /**\n     * Draw method\n     */\n    draw: function(/*obj*/) {\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n    },\n\n    /**\n     * Clear method\n     */\n    clear: function(obj) {\n      DefaultClearHandler.call(this, this.context, obj);\n    }\n  };\n\n  //Return\n  return BoardObject;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.ShellPattern.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('ShellPattern', function() {\n\n  /**\n   * Helper to draw a shell line\n   */\n  var shellLine = function(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\n\n    //Initialize\n    ctx.shadowBlur = 2;\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = (radius / 30) * this.thickness;\n    ctx.beginPath();\n\n    //Lower radius\n    radius -= Math.max(1, ctx.lineWidth);\n\n    //Determine coordinates\n    var x1 = x + radius * Math.cos(startAngle * Math.PI);\n    var y1 = y + radius * Math.sin(startAngle * Math.PI);\n    var x2 = x + radius * Math.cos(endAngle * Math.PI);\n    var y2 = y + radius * Math.sin(endAngle * Math.PI);\n\n    //Math magic\n    var m, angle;\n    if (x2 > x1) {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m);\n    }\n    else if (x2 === x1) {\n      angle = Math.PI / 2;\n    }\n    else {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m) - Math.PI;\n    }\n\n    //Curvature factor\n    var c = this.factor * radius;\n    var dx = Math.sin(angle) * c;\n    var dy = Math.cos(angle) * c;\n\n    //Curvature coordinates\n    var bx1 = x1 + dx;\n    var by1 = y1 - dy;\n    var bx2 = x2 + dx;\n    var by2 = y2 - dy;\n\n    //Draw shell stroke\n    ctx.moveTo(x1, y1);\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\n    ctx.stroke();\n  };\n\n  /**\n   * Shell pattern drawer\n   */\n  return function(ctx, x, y, radius, angle, strokeStyle) {\n\n    //Initialize start and end angle\n    var startAngle = angle;\n    var endAngle = angle;\n\n    //Loop lines\n    for (var i = 0; i < this.lines.length; i++) {\n      startAngle += this.lines[i];\n      endAngle -= this.lines[i];\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\n    }\n  };\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\n * use static values or dynamic values depending on other properties, like the grid cell size.\n * Using the provider, the theme can be configured globally at application launch.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Theme.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.provider('BoardTheme', ['StoneColor', 'MarkupTypes', function(StoneColor, MarkupTypes) {\n\n  /**\n   * Default theme\n   */\n  var defaultTheme = {\n\n    //Board\n    board: {\n\n      //Board margin factor\n      margin: 0.25\n    },\n\n    //Stones\n    stone: {\n\n      //Stone style can be shell, glass, mono, or specify a custom handler service\n      style: 'shell',\n      shadow: true,\n      radius: function(cellSize) {\n        return Math.floor(cellSize / 2);\n      },\n\n      //Shell stones\n      shell: {\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#111';\n          }\n          return '#BFBFBA';\n        },\n        stroke: 'rgba(128,128,128,0.15)',\n        types: [\n          {\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\n            factor: 0.15,\n            thickness: 1.75\n          },\n          {\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\n            factor: 0.1,\n            thickness: 1.5\n          },\n          {\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\n            factor: 0.05,\n            thickness: 1.75\n          },\n          {\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\n            factor: 0.1,\n            thickness: 2\n          }\n        ]\n      },\n\n      //Mono stones\n      mono: {\n        lineWidth: 1,\n        lineColor: function() {\n          return '#000';\n        },\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#000';\n          }\n          return '#fff';\n        }\n      },\n\n      //Mini stones\n      mini: {\n        scale: 0.5,\n        alpha: 1\n      },\n\n      //Faded stones\n      faded: {\n        scale: 1,\n        alpha: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return 0.3;\n          }\n          return 0.4;\n        }\n      }\n    },\n\n    //Shadows\n    shadow: {\n\n      //Shadow gradient colors\n      color: 'rgba(40,30,20,0.5)',\n\n      //Shadow size\n      size: function(cellSize) {\n        return Math.floor(cellSize / 20);\n      },\n\n      //Shadow blur size\n      blur: function(cellSize) {\n        return cellSize / 20;\n      },\n\n      //Shadow offset\n      offsetX: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      },\n      offsetY: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      }\n    },\n\n    //Markup\n    markup: {\n\n      //Standard color\n      color: function(stoneColor) {\n        if (stoneColor === StoneColor.B) {\n          return 'rgba(255,255,255,0.9)';\n        }\n        return 'rgba(0,0,0,0.9)';\n      },\n\n      //Line width\n      lineWidth: function(cellSize) {\n        return Math.max(1, Math.floor(cellSize / 16));\n      },\n\n      //Triangle\n      triangle: {\n        scale: 0.85\n      },\n\n      //Square\n      square: {\n        scale: 0.85\n      },\n\n      //Cricle\n      circle: {\n        scale: 0.55\n      },\n\n      //Mark\n      mark: {\n        lineCap: 'square',\n        scale: 0.75\n      },\n\n      //Last\n      last: {\n        scale: 0.7\n      },\n\n      //Smiley\n      smiley: {\n        lineCap: 'round',\n        scale: 0.85\n      },\n\n      //Label\n      label: {\n        font: 'Arial'\n      },\n\n      //Variation markup\n      variation: {\n        type: MarkupTypes.LABEL,\n        text: function(i) {\n          return String.fromCharCode(65 + i);\n        },\n        color: 'rgba(86,114,30,0.9)'\n      },\n\n      //Solution paths markup\n      solution: {\n        valid: {\n          type: MarkupTypes.SELECT,\n          text: null,\n          color: 'rgba(86,114,30,1)',\n          scale: 0.5\n        },\n        invalid: {\n          type: MarkupTypes.MARK,\n          text: null,\n          color: 'rgba(237,9,15,1)',\n          scale: 0.3\n        }\n      }\n    },\n\n    //Grid\n    grid: {\n\n      //Line properties\n      lineColor: 'rgba(60,40,15,1)',\n      lineWidth: function(cellSize) {\n        if (cellSize > 60) {\n          return 2;\n        }\n        else if (cellSize > 50) {\n          return 1.5;\n        }\n        return 1;\n      },\n      lineCap: 'square',\n\n      //Star points\n      star: {\n\n        //Color and radius\n        color: 'rgba(60,40,15,1)',\n        radius: function(cellSize) {\n          if (cellSize > 50) {\n            return Math.floor((cellSize / 16) + 1);\n          }\n          else if (cellSize > 30) {\n            return 3;\n          }\n          else if (cellSize > 15) {\n            return 2;\n          }\n          else if (cellSize > 5) {\n            return 1.5;\n          }\n          return 1;\n        },\n\n        //Locations\n        points: function(width, height) {\n\n          //19x19\n          if (width === height && width === 19) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15,y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15,y: 9 },\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15,y: 15 }\n            ];\n          }\n\n          //13x13\n          if (width === height && width === 13) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }\n            ];\n          }\n\n          //9x9\n          if (width === height && width === 9) {\n            return [\n              { x: 4, y: 4}, { x: 2, y: 2},\n              { x: 2, y: 6}, { x: 6, y: 2},\n              { x: 6, y: 6}\n            ];\n          }\n\n          //No star points\n          return [];\n        }\n      }\n    },\n\n    //Coordinates\n    coordinates: {\n\n      //Color\n      color: 'rgba(101,69,37,0.5)',\n\n      //Board margin factor when showing coordinates\n      margin: 1.25,\n\n      //Vertical coordinates style\n      vertical: {\n        font: 'Arial',\n        style: 'numbers',\n        inverse: true,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      },\n\n      //Horizontal coordinates style\n      horizontal: {\n        font: 'Arial',\n        style: 'letters',\n        inverse: false,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      }\n    }\n  };\n\n  /**\n   * Set global default theme\n   */\n  this.setTheme = function(theme) {\n    if (theme) {\n      defaultTheme = angular.merge(defaultTheme, theme);\n    }\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function() {\n\n    /**\n     * Board theme constructor\n     */\n    var BoardTheme = function(theme) {\n\n      //Remember the given instance theme settings and (re)set the theme\n      this.instanceTheme = theme;\n      this.reset();\n    };\n\n    /**\n     * Reset the theme to defaults\n     */\n    BoardTheme.prototype.reset = function() {\n\n      //Use default theme as a base\n      this.theme = angular.copy(defaultTheme);\n\n      //Add any instance theme properties\n      if (this.instanceTheme) {\n        angular.merge(this.theme, this.instanceTheme);\n      }\n    };\n\n    /**\n     * Get a theme property\n     */\n    BoardTheme.prototype.get = function(property) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Can't find the property?\n        if (typeof prop[path[i]] === 'undefined') {\n          console.warn('Could not find theme property', property);\n          return null;\n        }\n\n        //Advance further in the object\n        prop = prop[path[i]];\n      }\n\n      //Found what we're looking for\n      if (typeof prop !== 'function') {\n        return prop;\n      }\n\n      //Prepare arguments\n      var args = [];\n      if (arguments.length > 1) {\n        for (var a = 1; a < arguments.length; a++) {\n          args.push(arguments[a]);\n        }\n      }\n\n      //Call function\n      return prop.apply(this, args);\n    };\n\n    /**\n     * Change a theme property dynamically (accepts handler function as value)\n     */\n    BoardTheme.prototype.set = function(property, value) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Time to set?\n        if ((i + 1) === path.length) {\n          prop[path[i]] = value;\n          break;\n        }\n\n        //Not set?\n        if (typeof prop[path[i]] === 'undefined') {\n          prop[path[i]] = {};\n        }\n\n        //Move on\n        prop = prop[path[i]];\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\n     */\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\n\n      //If no linewidth specified, use the grid line width as a reference\n      //to make sure stuff is aligned to the grid\n      if (typeof lineWidth === 'undefined') {\n        lineWidth = this.get('grid.lineWidth');\n      }\n\n      //Return a translation for uneven widths\n      return (lineWidth % 2) * 0.5;\n    };\n\n    //Return\n    return BoardTheme;\n  };\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidDataError :: Error class to handle invalid data.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidDataError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidDataError', ['ngGo', function(ngGo) {\n\n  /**\n   * Define error\n   */\n  var InvalidDataError = function(code) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidDataError';\n    this.message = 'Invalid data: ';\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.NO_DATA:\n        this.message += 'no data to process.';\n        break;\n      case ngGo.error.UNKNOWN_DATA:\n        this.message += 'unknown data format.';\n        break;\n      case ngGo.error.INVALID_GIB:\n        this.message += 'unable to parse GIB data.';\n        break;\n      case ngGo.error.INVALID_SGF:\n        this.message += 'unable to parse SGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_JSON:\n        this.message += 'unable to parse JGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_TREE_JSON:\n        this.message += 'unable to parse the JGF tree data.';\n        break;\n      default:\n        this.message += 'unable to parse the data.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidDataError.prototype = new Error();\n  InvalidDataError.prototype.constructor = InvalidDataError;\n\n  //Return object\n  return InvalidDataError;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidPositionError :: Error class to handle invalid moves.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidPositionError', ['ngGo', 'StoneColor', function(ngGo, StoneColor) {\n\n  /**\n   * Define error\n   */\n  var InvalidPositionError = function(code, x, y, color) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidPositionError';\n    this.message = 'Invalid position detected.';\n\n    //Add position data\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\n        ' stone on (' + x + ', ' + y + ')';\n    }\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\n        this.message += ', but these coordinates are not on the board.';\n        break;\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\n        this.message += ', but there is already a stone on those coordinates.';\n        break;\n      case ngGo.error.POSTITION_IS_SUICIDE:\n        this.message += ', but that would be suicide.';\n        break;\n      case ngGo.error.POSTITION_IS_REPEATING:\n        this.message += ', but this position already occured.';\n        break;\n      default:\n        this.message += '.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidPositionError.prototype = new Error();\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\n\n  //Return object\n  return InvalidPositionError;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Game :: This class represents a game record or a game that is being played/edited. The class\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\n * The class also keeps a stack of all board positions in memory and can validate moves to make\n * sure they are not repeating or suicide.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Service', [\n  'ngGo',\n  'ngGo.Game.Path.Service',\n  'ngGo.Game.Node.Service',\n  'ngGo.Game.Position.Service',\n  'ngGo.Kifu.Blank.Service',\n  'ngGo.Kifu.Parser.Service',\n  'ngGo.Errors.InvalidDataError.Service',\n  'ngGo.Errors.InvalidPositionError.Service'\n])\n\n/**\n * Factory definition\n */\n.provider('Game', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default size of board\n    defaultSize: 0,\n\n    //Default komi and handicap\n    defaultKomi: 0,\n    defaultHandicap: 0,\n\n    //Remember last selected variation when traversing nodes\n    rememberPath: true,\n\n    //Check for repeating positions? (KO / ALL / empty)\n    checkRepeat: 'KO',\n\n    //Allow suicide?\n    allowSuicide: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['ngGo', 'StoneColor', 'GamePath', 'GameNode', 'GamePosition', 'KifuParser', 'KifuBlank', 'InvalidDataError', 'InvalidPositionError', function(\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\n    KifuBlank, InvalidDataError, InvalidPositionError\n  ) {\n\n    /*****************************************************************************\n     * General helpers\n     ***/\n\n    /**\n     * Validate the info we have to make sure the properties exist\n     */\n    var validateInfo = function() {\n\n      //Set board info if not set\n      if (!this.info.board) {\n        this.info.board = {};\n      }\n\n      //Set game info if not set\n      if (!this.info.game) {\n        this.info.game = {};\n      }\n\n      //Set defaults\n      if (typeof this.info.board.width === 'undefined') {\n        this.info.board.width = this.config.defaultSize;\n      }\n      if (typeof this.info.board.height === 'undefined') {\n        this.info.board.height = this.config.defaultSize;\n      }\n      if (typeof this.info.game.komi === 'undefined') {\n        this.info.game.komi = this.config.defaultKomi;\n      }\n      if (typeof this.info.game.handicap === 'undefined') {\n        this.info.game.handicap = this.config.defaultHandicap;\n      }\n    };\n\n    /*****************************************************************************\n     * Node navigation helpers\n     ***/\n\n    /**\n     * Navigate to the next node\n     */\n    var nextNode = function(i) {\n\n      //Check if we have children\n      if (this.node.children.length === 0) {\n        return false;\n      }\n\n      //Remembered the path we took earlier?\n      if (i === undefined) {\n        i = this.node._remembered_path;\n      }\n\n      //Determine which child node to process\n      i = i || 0;\n      if (i === -1) {\n        i = 0;\n      }\n\n      //Validate\n      if (i >= this.node.children.length || !this.node.children[i]) {\n        return false;\n      }\n\n      //Advance path\n      this.path.advance(i);\n\n      //Set pointer of current node\n      this.node = this.node.children[i];\n      return true;\n    };\n\n    /**\n     * Navigate to the previous node\n     */\n    var previousNode = function() {\n\n      //No parent node?\n      if (!this.node.parent) {\n        return false;\n      }\n\n      //Retreat path\n      this.path.retreat();\n\n      //Set pointer of current node\n      this.node = this.node.parent;\n      return true;\n    };\n\n    /**\n     * Navigate to the first node\n     */\n    var firstNode = function() {\n\n      //Reset path\n      this.path.reset();\n\n      //Set node pointer back to root\n      this.node = this.root;\n\n      //Set the initial turn depending on handicap\n      //Can be overwritten by game record instructions\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\n    };\n\n    /*****************************************************************************\n     * Position history helpers\n     ***/\n\n    /**\n     * Clear the position history and initialize with a blank position\n     */\n    var initializeHistory = function() {\n\n      //Already at beginning?\n      if (this.history.length === 1) {\n        return;\n      }\n\n      //Clear positions stack and create new blank position\n      this.history = [];\n      this.history.push(new GamePosition());\n\n      //Set board size if we have the info\n      if (this.info.board) {\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\n      }\n    };\n\n    /**\n     * Add position to stack. If position isn't specified current position is\n     * cloned and stacked. Pointer of actual position is moved to the new position.\n     */\n    var pushPosition = function(newPosition) {\n\n      //Position not given?\n      if (!newPosition) {\n        newPosition = this.position.clone();\n      }\n\n      //Push\n      this.history.push(newPosition);\n      return newPosition;\n    };\n\n    /**\n     * Remove current position from stack\n     */\n    var popPosition = function() {\n\n      //Nothing left?\n      if (this.history.length === 0) {\n        return null;\n      }\n\n      //Get old position\n      return this.history.pop();\n    };\n\n    /**\n     * Replace the current position in the stack\n     */\n    var replacePosition = function(newPosition) {\n      if (newPosition) {\n        this.history.pop();\n        this.history.push(newPosition);\n      }\n    };\n\n    /*****************************************************************************\n     * Execution helpers\n     ***/\n\n    /**\n     * Execute the current node\n     */\n    var executeNode = function() {\n\n      //Remember last selected node if we have a parent\n      if (this.node.parent) {\n        this.node.parent._remembered_path = this.node.parent.children.indexOf(this.node);\n      }\n\n      //Initialize new position\n      var i;\n      var newPosition = this.position.clone();\n\n      //Handle moves\n      if (this.node.move) {\n        if (this.node.move.pass) {\n          newPosition.setTurn(-this.node.move.color);\n        }\n        else {\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\n        }\n      }\n\n      //Handle turn instructions\n      if (this.node.turn) {\n        newPosition.setTurn(this.node.turn);\n      }\n\n      //Handle setup instructions\n      if (this.node.setup) {\n        for (i in this.node.setup) {\n          if (this.node.setup.hasOwnProperty(i)) {\n            newPosition.stones.set(\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\n            );\n          }\n        }\n      }\n\n      //Handle markup\n      if (this.node.markup) {\n        for (i in this.node.markup) {\n          if (this.node.markup.hasOwnProperty(i)) {\n            newPosition.markup.set(\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\n            );\n          }\n        }\n      }\n\n      //Push the new position into the history now\n      pushPosition.call(this, newPosition);\n    };\n\n    /*****************************************************************************\n     * Game class\n     ***/\n\n    /**\n     * Constructor\n     */\n    var Game = function(data, config) {\n\n      //Extend config\n      this.config = angular.extend({}, defaultConfig, config || {});\n\n      //Define property getter/setter for position\n      Object.defineProperty(this, 'position', {\n\n        //Getter returns the last position from the stack\n        get: function() {\n          return this.history[this.history.length - 1];\n        },\n\n        //Setter adds a new position to the stack\n        set: function(newPosition) {\n          this.history[this.history.length] = newPosition;\n        }\n      });\n\n      //Load data\n      if (data) {\n        this.load(data);\n      }\n      else {\n        this.init();\n      }\n    };\n\n    /**\n     * Initialize\n     */\n    Game.prototype.init = function() {\n\n      //Info properties\n      this.info = {};\n\n      //The rood node and pointer to the current node\n      this.root = null;\n      this.node = null;\n\n      //Game path\n      this.path = new GamePath();\n\n      //JGF record we loaded from\n      this.jgf = null;\n\n      //Positions history stack\n      this.history = [];\n    };\n\n    /**\n     * Load game record data\n     */\n    Game.prototype.load = function(data) {\n\n      //Initialize\n      this.init();\n\n      //Try to load game record data\n      try {\n        this.fromData(data);\n      }\n      catch (errorCode) {\n\n        //Just initialize our history with a blank position\n        initializeHistory.call(this);\n\n        //Wrap error code in error object\n        throw new InvalidDataError(errorCode);\n      }\n\n      //Go to the first move\n      this.first();\n    };\n\n    /**\n     * Reload game record\n     */\n    Game.prototype.reload = function() {\n      if (this.jgf) {\n        this.load(this.jgf);\n      }\n    };\n\n    /**\n     * Check if we managed to load a valid game record\n     */\n    Game.prototype.isLoaded = function() {\n      return this.root !== null;\n    };\n\n    /*****************************************************************************\n     * Game cloning and conversion\n     ***/\n\n    /**\n     * Clone this game\n     */\n    Game.prototype.clone = function() {\n\n      //Create new kifu object and get properties\n      var clone = new Game();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy all properties\n      for (var p = 0; p < props.length; p++) {\n        clone[p] = angular.copy(this[p]);\n      }\n\n      //Return clone\n      return clone;\n    };\n\n    /**\n     * Load from an unknown data source\n     */\n    Game.prototype.fromData = function(data) {\n\n      //No data, can't do much\n      if (!data) {\n        throw ngGo.error.NO_DATA;\n      }\n\n      //String given, could be stringified JGF, an SGF or GIB file\n      if (typeof data === 'string') {\n        var c = data.charAt(0);\n        if (c === '(') {\n          return this.fromSgf(data);\n        }\n        else if (c === '{' || c === '[') {\n          return this.fromJgf(data);\n        }\n        else if (c === '\\\\') {\n          return this.fromGib(data);\n        }\n        else {\n          throw ngGo.error.UNKNOWN_DATA;\n        }\n      }\n\n      //Object given? Probably a JGF object\n      else if (typeof data === 'object') {\n        this.fromJgf(data);\n      }\n\n      //Something else?\n      else {\n        throw ngGo.error.UNKNOWN_DATA;\n      }\n    };\n\n    /**\n     * Load from GIB data\n     */\n    Game.prototype.fromGib = function(gib) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.gib2jgf(gib);\n      if (!jgf) {\n        throw ngGo.error.INVALID_GIB;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from SGF data\n     */\n    Game.prototype.fromSgf = function(sgf) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.sgf2jgf(sgf);\n      if (!jgf) {\n        throw ngGo.error.INVALID_SGF;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from JGF data\n     */\n    Game.prototype.fromJgf = function(jgf) {\n\n      //Parse jgf string\n      if (typeof jgf === 'string') {\n        try {\n          jgf = angular.fromJson(jgf);\n        }\n        catch (error) {\n          throw ngGo.error.INVALID_JGF_JSON;\n        }\n      }\n\n      //If array given, convert to object with only tree\n      if (angular.isArray(jgf)) {\n        jgf = {\n          tree: jgf\n        };\n      }\n\n      //Parse tree string\n      if (typeof jgf.tree === 'string') {\n        if (jgf.tree.charAt(0) === '[') {\n          try {\n            jgf.tree = angular.fromJson(jgf.tree);\n          }\n          catch (error) {\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\n          }\n        }\n        else {\n          jgf.tree = [];\n        }\n      }\n\n      //Copy all properties except moves tree\n      for (var i in jgf) {\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\n          this.info[i] = angular.copy(jgf[i]);\n        }\n      }\n\n      //Validate info\n      validateInfo.call(this);\n\n      //Create root node\n      this.root = new GameNode();\n\n      //Tree given? Load all the moves\n      if (jgf.tree) {\n        this.root.fromJgf(jgf.tree);\n      }\n\n      //Remember JGF\n      this.jgf = jgf;\n    };\n\n    /**\n     * Convert to SGF\n     */\n    Game.prototype.toSgf = function() {\n      return KifuParser.jgf2sgf(this.toJgf());\n    };\n\n    /**\n     * Convert to JGF (optionally stringified)\n     */\n    Game.prototype.toJgf = function(stringify) {\n\n      //Initialize JGF and get properties\n      var jgf = KifuBlank.jgf();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy properties\n      for (var p = 0; p < props.length; p++) {\n\n        //Skip root\n        if (p === 'root') {\n          continue;\n        }\n\n        //Already present on JGF object? Extend\n        if (jgf[p]) {\n          jgf[p] = angular.extend(jgf[p], this[p]);\n        }\n\n        //Otherwise copy\n        else {\n          jgf[p] = angular.copy(this[p]);\n        }\n      }\n\n      //Build tree\n      jgf.tree = this.root.toJgf();\n\n      //Return\n      return stringify ? angular.toJson(jgf) : jgf;\n    };\n\n    /*****************************************************************************\n     * Getters\n     ***/\n\n    /**\n     * Get current node\n     */\n    Game.prototype.getNode = function() {\n      return this.node;\n    };\n\n    /**\n     * Get node for a certain move\n     */\n    Game.prototype.getMoveNodeAt = function(move) {\n\n      //Must have a move number\n      move = move || 1;\n\n      //Initialize node to process\n      var node = this.root;\n      var moveNo = 0;\n\n      //Process children\n      while (node) {\n\n        //Get child node\n        node = node.getChild(node._remembered_path);\n        if (node && node.move) {\n          moveNo++;\n        }\n\n        //Reached move?\n        if (moveNo === move) {\n          return node;\n        }\n      }\n\n      //No move node found\n      return null;\n    };\n\n    /**\n     * Get move nodes restricted by given move numbers\n     */\n    Game.prototype.getMoveNodes = function(fromMove, toMove) {\n\n      //Use sensible defaults if no from/to moves given\n      fromMove = fromMove || 1;\n      toMove = toMove || this.getMoveCount();\n\n      //Get the first node\n      var node = this.getMoveNodeAt(fromMove);\n      if (!node) {\n        return [];\n      }\n\n      //Initialize nodes array and counter\n      var nodes = [node];\n      var move = fromMove;\n\n      //Loop nodes\n      while (node && move < toMove) {\n\n        //Get node child\n        node = node.getChild(node._remembered_path);\n        if (!node || !node.move) {\n          continue;\n        }\n\n        //Add count and add to array\n        move++;\n        nodes.push(node);\n      }\n\n      //Return array of nodes\n      return nodes;\n    };\n\n    /**\n     * Get the current game position\n     */\n    Game.prototype.getPosition = function() {\n      return this.position;\n    };\n\n    /**\n     * Get the game path\n     */\n    Game.prototype.getPath = function(clone) {\n      if (clone) {\n        return this.path.clone();\n      }\n      return this.path;\n    };\n\n    /**\n     * Clone the current game path\n     */\n    Game.prototype.clonePath = function() {\n      return this.path.clone();\n    };\n\n    /**\n     * Get the game path to a certain named node\n     */\n    Game.prototype.getPathToNode = function(nodeName) {\n      return GamePath.findNode(nodeName, this.root);\n    };\n\n    /**\n     * Get the game komi\n     */\n    Game.prototype.getKomi = function() {\n      var komi = this.get('game.komi', 0);\n      return parseFloat(komi);\n    };\n\n    /**\n     * Set the game komi\n     */\n    Game.prototype.setKomi = function(komi) {\n      if (typeof komi === 'undefined') {\n        komi = this.config.defaultKomi;\n      }\n      this.info.game.komi = parseFloat(komi);\n    };\n\n    /**\n     * Get the game name\n     */\n    Game.prototype.getName = function() {\n      return this.get('game.name', '');\n    };\n\n    /**\n     * Get the game result\n     */\n    Game.prototype.getResult = function() {\n      return this.get('game.result', '');\n    };\n\n    /**\n     * Get the player turn for this position\n     */\n    Game.prototype.getTurn = function() {\n\n      //Must have a position\n      if (!this.history.length) {\n        return StoneColor.B;\n      }\n\n      //Get from position\n      return this.position.getTurn();\n    };\n\n    /**\n     * Set the player turn for the current position\n     */\n    Game.prototype.setTurn = function(color) {\n\n      //Must have a position\n      if (!this.history.length) {\n        return;\n      }\n\n      //Set in position\n      this.position.setTurn(color);\n    };\n\n    /**\n     * Get the total capture count up to the current position\n     */\n    Game.prototype.getCaptureCount = function() {\n\n      //Initialize\n      var captures = {};\n      captures[StoneColor.B] = 0;\n      captures[StoneColor.W] = 0;\n\n      //Loop all positions and increment capture count\n      for (var i = 0; i < this.history.length; i++) {\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\n      }\n\n      //Return\n      return captures;\n    };\n\n    /**\n     * Get the move variation for given coordinates\n     */\n    Game.prototype.getMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.getMoveVariation(x, y);\n      }\n      return -1;\n    };\n\n    /**\n     * Get current move number\n     */\n    Game.prototype.getMove = function() {\n      return this.path.getMove();\n    };\n\n    /**\n     * Get the number of moves in the main branch\n     */\n    Game.prototype.getMoveCount = function() {\n\n      //Initialize node to process\n      var node = this.root;\n      var noMoves = 0;\n\n      //Process children\n      while (node) {\n        node = node.getChild(node._remembered_path);\n        if (node && node.move) {\n          noMoves++;\n        }\n      }\n\n      //Return move count\n      return noMoves;\n    };\n\n    /**\n     * Get an info property\n     */\n    Game.prototype.get = function(property, defaultValue) {\n\n      //Must have a property\n      if (!property) {\n        return;\n      }\n\n      //The item's property in the object is given by dot separated strings\n      if (typeof property === 'string') {\n        property = property.split('.');\n      }\n\n      //Initialize object we're getting info from\n      var obj = this.info;\n      var key;\n\n      //Loop the properties\n      for (var p = 0; p < property.length; p++) {\n\n        //Get actual key\n        key = property[p];\n\n        //Last key reached? Done, get value\n        if ((p + 1) === property.length) {\n          if (typeof obj[key] === 'undefined') {\n            return defaultValue;\n          }\n          return obj[key];\n        }\n\n        //Must be object container\n        if (typeof obj[key] !== 'object') {\n          console.warn('Game info property', key, 'is not an object');\n          return defaultValue;\n        }\n\n        //Move up in tree\n        obj = obj[key];\n      }\n    };\n\n    /*****************************************************************************\n     * Checkers\n     ***/\n\n    /**\n     * Check if coordinates are on the board\n     */\n    Game.prototype.isOnBoard = function(x, y) {\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\n    };\n\n    /**\n     * Check if given coordinates are one of the next child node coordinates\n     */\n    Game.prototype.isMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.isMoveVariation(x, y);\n      }\n      return false;\n    };\n\n    /**\n     * Check if a given position is repeating within this game\n     */\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\n\n      //Init\n      var stop;\n\n      //Check for ko only? (Last two positions)\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\n        stop = this.history.length - 2;\n      }\n\n      //Check all history?\n      else if (this.checkRepeat === 'ALL') {\n        stop = 0;\n      }\n\n      //Not repeating\n      else {\n        return false;\n      }\n\n      //Loop history of positions to check\n      for (var i = this.history.length - 2; i >= stop; i--) {\n        if (checkPosition.isSameAs(this.history[i])) {\n          return true;\n        }\n      }\n\n      //Not repeating\n      return false;\n    };\n\n    /**\n     * Wrapper for validateMove() returning a boolean and catching any errors\n     */\n    Game.prototype.isValidMove = function(x, y, color) {\n      try {\n        this.validateMove(x, y, color);\n        return true;\n      }\n      catch (error) {\n        return false;\n      }\n    };\n\n    /**\n     * Check if a move is valid. If valid, the new game position object is returned.\n     * You can supply a pre-created position to use, or the current position is cloned.\n     */\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Something already here?\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\n      }\n\n      //Set color of move to make\n      color = color || this.position.getTurn();\n\n      //Determine position to use\n      newPosition = newPosition || this.position.clone();\n\n      //Place the stone\n      newPosition.stones.set(x, y, color);\n\n      //Capture adjacent stones if possible\n      var captures = newPosition.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created?\n        if (!newPosition.hasLiberties(x, y)) {\n\n          //Capture the group if it's allowed\n          if (this.allowSuicide) {\n            newPosition.captureGroup(x, y);\n          }\n\n          //Invalid move\n          else {\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\n          }\n        }\n      }\n\n      //Check history for repeating moves\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\n      }\n\n      //Set proper turn\n      newPosition.setTurn(-color);\n\n      //Move is valid\n      return newPosition;\n    };\n\n    /**\n     * Check if a stone (setup) placement is valid.\n     */\n    Game.prototype.validatePlacement = function(x, y, color, position) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Place the stone\n      position.stones.set(x, y, color);\n\n      //Empty spot? Don't need to check for captures\n      if (color === StoneColor.EMPTY) {\n        return;\n      }\n\n      //Capture adjacent stones if possible\n      var captures = position.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created? Capture it\n        if (!position.hasLiberties(x, y)) {\n          position.captureGroup(x, y);\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Stone and markup handling\n     ***/\n\n    /**\n     * Add a stone\n     */\n    Game.prototype.addStone = function(x, y, color) {\n\n      //Check if there's anything to do at all\n      if (this.position.stones.is(x, y, color)) {\n        return;\n      }\n\n      //Create temporary position\n      var tempPosition = this.position.clone();\n\n      //Validate placement on temp position\n      this.validatePlacement(x, y, color, tempPosition);\n\n      //No setup instructions container in this node?\n      if (typeof this.node.setup === 'undefined') {\n\n        //Is this a move node?\n        if (this.node.move) {\n\n          //Clone our position\n          pushPosition.call(this);\n\n          //Create new node\n          var node = new GameNode();\n\n          //Append it to the current node and change the pointer\n          var i = node.appendTo(this.node);\n          this.node = node;\n\n          //Advance path to the added node index\n          this.path.advance(i);\n        }\n\n        //Create setup container in this node\n        this.node.setup = [];\n      }\n\n      //Replace current position\n      replacePosition.call(this, tempPosition);\n\n      //Add setup instructions to node\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\n    };\n\n    /**\n     * Add markup\n     */\n    Game.prototype.addMarkup = function(x, y, markup) {\n\n      //No markup instructions container in this node?\n      if (typeof this.node.markup === 'undefined') {\n        this.node.markup = [];\n      }\n\n      //Add markup to game position\n      this.position.markup.set(x, y, markup);\n\n      //Add markup instructions to node\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\n    };\n\n    /**\n     * Remove a stone\n     */\n    Game.prototype.removeStone = function(x, y) {\n\n      //Check if the stone is found in setup instructions\n      var foundInSetup = false;\n\n      //Remove from node setup instruction\n      if (typeof this.node.setup !== 'undefined') {\n        for (var i = 0; i < this.node.setup.length; i++) {\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\n\n            //Remove from node and unset in position\n            this.node.setup.splice(i, 1);\n            this.position.stones.unset(x, y);\n\n            //Mark as found\n            foundInSetup = true;\n            break;\n          }\n        }\n      }\n\n      //Not found in setup? Add as no stone color\n      if (!foundInSetup) {\n        this.addStone(x, y, StoneColor.EMPTY);\n      }\n    };\n\n    /**\n     * Remove markup\n     */\n    Game.prototype.removeMarkup = function(x, y) {\n\n      //Remove from node\n      if (typeof this.node.markup !== 'undefined') {\n        for (var i = 0; i < this.node.markup.length; i++) {\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\n            this.node.markup.splice(i, 1);\n            this.position.markup.unset(x, y);\n            break;\n          }\n        }\n      }\n    };\n\n    /**\n     * Check if there is a stone at the given coordinates for the current position\n     */\n    Game.prototype.hasStone = function(x, y, color) {\n      if (typeof color !== 'undefined') {\n        return this.position.stones.is(x, y, color);\n      }\n      return this.position.stones.has(x, y);\n    };\n\n    /**\n     * Check if there is markup at the given coordinate for the current position\n     */\n    Game.prototype.hasMarkup = function(x, y, type) {\n      if (typeof type !== 'undefined') {\n        return this.position.markup.is(x, y, type);\n      }\n      return this.position.markup.has(x, y);\n    };\n\n    /**\n     * Get stone on coordinates\n     */\n    Game.prototype.getStone = function(x, y) {\n      return this.position.stones.get(x, y);\n    };\n\n    /**\n     * Get markup on coordinates\n     */\n    Game.prototype.getMarkup = function(x, y) {\n      return this.position.markup.get(x, y);\n    };\n\n    /*****************************************************************************\n     * Move handling\n     ***/\n\n    /**\n     * Play move\n     */\n    Game.prototype.play = function(x, y, color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Validate move and get new position\n      var newPosition = this.validateMove(x, y, color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          x: x,\n          y: y,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node._remembered_path = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n\n      //Valid move\n      return true;\n    };\n\n    /**\n     * Play pass\n     */\n    Game.prototype.pass = function(color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Initialize new position and switch the turn\n      var newPosition = this.position.clone();\n      newPosition.setTurn(-color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          pass: true,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node._remembered_path = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n    };\n\n    /*****************************************************************************\n     * Game tree navigation\n     ***/\n\n    /**\n     * Go to the next position\n     */\n    Game.prototype.next = function(i) {\n\n      //Object (node) given as parameter? Find index\n      if (typeof i === 'object') {\n        i = this.node.children.indexOf(i);\n      }\n\n      //Go to the next node\n      if (nextNode.call(this, i)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n          return true;\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n\n      //Didn't go to next position\n      return false;\n    };\n\n    /**\n     * Go to the previous position\n     */\n    Game.prototype.previous = function() {\n\n      //Go to the previous node\n      if (previousNode.call(this)) {\n        popPosition.call(this);\n        return true;\n      }\n\n      //Didn't go to previous position\n      return false;\n    };\n\n    /**\n     * Go to the last position\n     */\n    Game.prototype.last = function() {\n\n      //Keep going to the next node until we reach the end\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the first position\n     */\n    Game.prototype.first = function() {\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      executeNode.call(this);\n    };\n\n    /**\n     * Go to position specified by a path object, a numeric move numer, or a node name string\n     */\n    Game.prototype.goto = function(target) {\n\n      //Must have a tree\n      if (this.root === null) {\n        return;\n      }\n\n      //Nothing given?\n      if (typeof target === 'undefined') {\n        return;\n      }\n\n      //Function given? Call now\n      if (typeof target === 'function') {\n        target = target.call(this);\n      }\n\n      //Initialize path\n      var path;\n\n      //Simple move number? Convert to path object\n      if (typeof target === 'number') {\n        path = this.path.clone();\n        path.setMove(target);\n      }\n\n      //String? Named node\n      else if (typeof target === 'string') {\n\n        //Already here?\n        if (this.node.name === target) {\n          return;\n        }\n\n        //Find path to node\n        path = this.getPathToNode(target);\n        if (path === null) {\n          return;\n        }\n      }\n\n      //Otherwise assume path object\n      else {\n        path = target;\n      }\n\n      //Already here?\n      if (this.path.compare(path)) {\n        return;\n      }\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      pushPosition.call(this);\n      executeNode.call(this);\n\n      //Loop path\n      var n = path.getMove();\n      for (var i = 0; i < n; i++) {\n\n        //Try going to the next node\n        if (!nextNode.call(this, path.nodeAt(i))) {\n          break;\n        }\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the next fork\n     */\n    Game.prototype.nextFork = function() {\n\n      //Keep going to the next node until we reach one with multiple children\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Have multiple children?\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous fork\n     */\n    Game.prototype.previousFork = function() {\n\n      //Loop until we find a node with more than one child\n      while (previousNode.call(this)) {\n        popPosition.call(this);\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the next move with comments\n     */\n    Game.prototype.nextComment = function() {\n\n      //Keep going to the next node until we find one with comments\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous move with comments\n     */\n    Game.prototype.previousComment = function() {\n\n      //Go back until we find a node with comments\n      while (previousNode.call(this)) {\n\n        //Pop the position\n        popPosition.call(this);\n\n        //Comments found?\n        if (this.node.hasComments()) {\n          break;\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state\n     */\n    Game.prototype.getState = function() {\n\n      //Can only create when we have a JGF and path\n      if (!this.jgf || !this.path) {\n        return null;\n      }\n\n      //Create state\n      var state = {\n        jgf: this.jgf,\n        path: this.path.clone()\n      };\n\n      //Return\n      return state;\n    };\n\n    /**\n     * Restore the game state\n     */\n    Game.prototype.restoreState = function(state) {\n\n      //Must have jgf and path\n      if (!state || !state.jgf || !state.path) {\n        return;\n      }\n\n      //Restore state\n      this.load(state.jgf);\n      this.goto(state.path);\n    };\n\n    //Return object\n    return Game;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GameNode :: This class represents a single node in the game moves tree. It contains\n * properties like the x and y grid coordinates, the move played, board setup instructions,\n * markup, player turn and comments. The moves tree in the game record is represented by a\n * string of GameNodes, each with pointers to their parent and children. Each node can have\n * multiple children (move variations), but only one parent.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Node.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameNode', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /**\n   * Helper to construct a coordinates base object\n   */\n  var coordinatesObject = function(coords, baseObject) {\n    baseObject = baseObject || {};\n    if (coords === '' || coords === 'pass') {\n      baseObject.pass = true;\n    }\n    else {\n\n      //Backwards compatibility with SGF string coordinates in JGF\n      if (typeof coords === 'string') {\n        coords = convertCoordinates(coords);\n      }\n\n      //Append coordinates\n      baseObject.x = coords[0] * 1;\n      baseObject.y = coords[1] * 1;\n    }\n    return baseObject;\n  };\n\n  /**\n   * Convert a numeric color value (color constant) to a string\n   */\n  var toStringColor = function(color) {\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\n  };\n\n  /**\n   * Convert a string color value to a numeric color constant\n   */\n  var toColorConstant = function(color) {\n    if (color === 'B') {\n      return StoneColor.B;\n    }\n    else if (color === 'W') {\n      return StoneColor.W;\n    }\n    return StoneColor.E;\n  };\n\n  /*****************************************************************************\n   * Helpers for conversion between JGF / KIFU format\n   ***/\n\n  /**\n   * Convert move object to JGF format\n   */\n  var convertMoveToJgf = function(move) {\n\n    //Initialize JGF move object and determine color\n    var jgfMove = angular.copy(move);\n    var color = toStringColor(move.color);\n\n    //No color?\n    if (color === '') {\n      return null;\n    }\n\n    //Pass move?\n    if (move.pass === true) {\n      jgfMove[color] = 'pass';\n    }\n\n    //Regular move\n    else {\n      jgfMove[color] = [move.x, move.y];\n    }\n\n    //Delete coordinates and color\n    delete jgfMove.x;\n    delete jgfMove.y;\n    delete jgfMove.color;\n\n    //Return move\n    return jgfMove;\n  };\n\n  /**\n   * Convert move from JGF format\n   */\n  var convertMoveFromJgf = function(move) {\n\n    //Prepare color, coordinates\n    var color, coords;\n\n    //Check whose move it was\n    if (move.W) {\n      color = 'W';\n      coords = move.W;\n    }\n    else if (move.B) {\n      color = 'B';\n      coords = move.B;\n    }\n\n    //No coordinates?\n    if (!coords) {\n      return null;\n    }\n\n    //Return coordinates object\n    return coordinatesObject(coords, {\n      color: toColorConstant(color)\n    });\n  };\n\n  /**\n   * Convert setup object to JGF format\n   */\n  var convertSetupToJgf = function(setup) {\n\n    //Initialize variables\n    var i, color;\n    var jgfSetup = {};\n\n    //Loop setup objects\n    for (i in setup) {\n      if (setup.hasOwnProperty(i)) {\n\n        //Get color\n        color = toStringColor(setup[i].color) || 'E';\n\n        //Initialize array\n        if (typeof jgfSetup[color] === 'undefined') {\n          jgfSetup[color] = [];\n        }\n\n        //Add coordinates\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\n      }\n    }\n\n    //Return\n    return jgfSetup;\n  };\n\n  /**\n   * Convert setup from JGF format\n   */\n  var convertSetupFromJgf = function(setup) {\n\n    //Initialize variables\n    var c, key, color;\n    var gameSetup = [];\n\n    //Loop setup\n    for (key in setup) {\n      if (setup.hasOwnProperty(key)) {\n\n        //Get color constant\n        color = toColorConstant(key);\n\n        //Loop coordinates\n        for (c in setup[key]) {\n          if (setup[key].hasOwnProperty(c)) {\n            gameSetup.push(coordinatesObject(setup[key][c], {\n              color: color\n            }));\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameSetup;\n  };\n\n  /**\n   * Convert markup object to JGF format\n   */\n  var convertMarkupToJgf = function(markup) {\n\n    //Initialize variables\n    var i, type;\n    var jgfMarkup = {};\n\n    //Loop setup objects\n    for (i in markup) {\n      if (markup.hasOwnProperty(i)) {\n\n        //Get type\n        type = markup[i].type;\n\n        //Initialize array\n        if (typeof jgfMarkup[type] === 'undefined') {\n          jgfMarkup[type] = [];\n        }\n\n        //Label?\n        if (type === 'label') {\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\n        }\n        else {\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\n        }\n      }\n    }\n\n    //Return\n    return jgfMarkup;\n  };\n\n  /**\n   * Convert markup from JGF format\n   */\n  var convertMarkupFromJgf = function(markup) {\n\n    //Initialize variables\n    var l, type;\n    var gameMarkup = [];\n\n    //Loop markup types\n    for (type in markup) {\n      if (markup.hasOwnProperty(type)) {\n\n        //Label?\n        if (type === 'label') {\n          for (l = 0; l < markup[type].length; l++) {\n\n            //Validate\n            if (!angular.isArray(markup[type][l])) {\n              continue;\n            }\n\n            //SGF type coordinates?\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\n              var text = markup[type][l][1];\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\n              markup[type][l].push(text);\n            }\n\n            //Validate length\n            if (markup[type][l].length < 3) {\n              continue;\n            }\n\n            //Add to stack\n            gameMarkup.push(coordinatesObject(markup[type][l], {\n              type: type,\n              text: markup[type][l][2]\n            }));\n          }\n        }\n        else {\n\n          //Loop coordinates\n          for (l in markup[type]) {\n            if (markup[type].hasOwnProperty(l)) {\n              gameMarkup.push(coordinatesObject(markup[type][l], {\n                type: type\n              }));\n            }\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameMarkup;\n  };\n\n  /**\n   * Convert turn object to JGF format\n   */\n  var convertTurnToJgf = function(turn) {\n    switch (turn) {\n      case StoneColor.W:\n        return 'W';\n      case StoneColor.B:\n        return 'B';\n      default:\n        return '';\n    }\n  };\n\n  /**\n   * Convert turn from JGF format\n   */\n  var convertTurnFromJgf = function(turn) {\n    switch (turn) {\n      case 'W':\n        return StoneColor.W;\n      case 'B':\n        return StoneColor.B;\n      default:\n        return StoneColor.EMPTY;\n    }\n  };\n\n  /**\n   * Conversions map\n   */\n  var conversionMap = {\n    toJgf: {\n      move: convertMoveToJgf,\n      setup: convertSetupToJgf,\n      markup: convertMarkupToJgf,\n      turn: convertTurnToJgf\n    },\n    fromJgf: {\n      move: convertMoveFromJgf,\n      setup: convertSetupFromJgf,\n      markup: convertMarkupFromJgf,\n      turn: convertTurnFromJgf\n    }\n  };\n\n  /**\n   * Constructor\n   */\n  var GameNode = function(properties, parent) {\n\n    //Set parent and children\n    this.parent = parent || null;\n    this.children = [];\n\n    //Save properties\n    if (properties) {\n      for (var key in properties) {\n        if (properties.hasOwnProperty(key)) {\n          this[key] = properties[key];\n        }\n      }\n    }\n  };\n\n  /**\n   * Get node's child specified by index or null if doesn't exist\n   */\n  GameNode.prototype.getChild = function(i) {\n    i = i || 0;\n    if (this.children[i]) {\n      return this.children[i];\n    }\n    return null;\n  };\n\n  /**\n   * Get all the children\n   */\n  GameNode.prototype.getChildren = function() {\n    return this.children;\n  };\n\n  /**\n   * Check if the node has any chilren\n   */\n  GameNode.prototype.hasChildren = function() {\n    return (this.children.length > 0);\n  };\n\n  /**\n   * Check if the node has more than one move variation\n   */\n  GameNode.prototype.hasMoveVariations = function() {\n\n    //Less than two child nodes?\n    if (this.children.length <= 1) {\n      return false;\n    }\n\n    //Loop children\n    var moveVariations = 0;\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].move) {\n        moveVariations++;\n      }\n\n      //More than one move node present?\n      if (moveVariations > 1) {\n        return true;\n      }\n    }\n\n    //No move variations\n    return false;\n  };\n\n  /**\n   * Get all the move variation nodes\n   */\n  GameNode.prototype.getMoveVariations = function() {\n\n    //No child nodes?\n    if (this.children.length === 0) {\n      return false;\n    }\n\n    //Initialize\n    var moveVariations = [];\n\n    //Loop child nodes\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].move) {\n        moveVariations.push(this.children[i]);\n      }\n    }\n\n    //Return\n    return moveVariations;\n  };\n\n  /**\n   * Get the move variation for given coordinates\n   */\n  GameNode.prototype.getMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return i;\n      }\n    }\n\n    //Not found\n    return -1;\n  };\n\n  /**\n   * Check if given coordinates are one of the next child node coordinates\n   */\n  GameNode.prototype.isMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return true;\n      }\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Check if we have comments\n   */\n  GameNode.prototype.hasComments = function() {\n    return (this.comments && this.comments.length > 0);\n  };\n\n  /*****************************************************************************\n   * Node manipulation\n   ***/\n\n  /**\n   * Remove this node from its parent\n   */\n  GameNode.prototype.remove = function() {\n\n    //Can't remove if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found remove it\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1) {\n      this.parent.children.splice(i, 1);\n    }\n\n    //Clear parent reference\n    this.parent = null;\n  };\n\n  /**\n   * Move the node up in the parent's child tree\n   */\n  GameNode.prototype.moveUp = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i > 0) {\n      var temp = this.parent.children[i - 1];\n      this.parent.children[i - 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Move the node down in the parent's child tree\n   */\n  GameNode.prototype.moveDown = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\n      var temp = this.parent.children[i + 1];\n      this.parent.children[i + 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Append this node to another node\n   */\n  GameNode.prototype.appendTo = function(node) {\n\n    //Remove from existing parent\n    this.remove();\n\n    //Set new parent\n    this.parent = node;\n    node.children.push(this);\n    return node.children.length - 1;\n  };\n\n  /**\n   * Append child node to this node.\n   */\n  GameNode.prototype.appendChild = function(node) {\n    node.parent = this;\n    this.children.push(node);\n    return this.children.length - 1;\n  };\n\n  /**\n   * Insert another node after this one\n   */\n  GameNode.prototype.insertNode = function(node) {\n\n    //Loop our children and change parent node\n    for (var i = 0; i < this.children.length; i++) {\n      this.children[i].parent = node;\n    }\n\n    //Merge children, set this node as the parent of given node\n    node.children = node.children.concat(this.children);\n    node.parent = this;\n\n    //Set given node as the child of this node\n    this.children = [node];\n  };\n\n  /*****************************************************************************\n   * JGF conversion\n   ***/\n\n  /**\n   * Build a Game Node from a given JGF tree\n   */\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\n\n    //Root JGF file given?\n    if (typeof jgf.tree !== 'undefined') {\n      return GameNode.fromJgf(jgf.tree, gameNode);\n    }\n\n    //Initialize helper vars\n    var variationNode, nextNode, i, j;\n\n    //Node to work with given? Otherwise, work with ourselves\n    gameNode = gameNode || this;\n\n    //Loop moves in the JGF tree\n    for (i = 0; i < jgf.length; i++) {\n\n      //Array? That means a variation branch\n      if (angular.isArray(jgf[i])) {\n\n        //Loop variation stacks\n        for (j = 0; j < jgf[i].length; j++) {\n\n          //Build the variation node\n          variationNode = new GameNode();\n          variationNode.fromJgf(jgf[i][j]);\n\n          //Append to working node\n          gameNode.appendChild(variationNode);\n        }\n      }\n\n      //Regular node\n      else {\n\n        //Get properties to copy\n        var properties = Object.getOwnPropertyNames(jgf[i]);\n\n        //Copy node properties\n        for (var key in properties) {\n          if (properties.hasOwnProperty(key)) {\n            var prop = properties[key];\n\n            //Conversion function present?\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\n            }\n            else if (typeof jgf[i][prop] === 'object') {\n              gameNode[prop] = angular.copy(jgf[i][prop]);\n            }\n            else {\n              gameNode[prop] = jgf[i][prop];\n            }\n          }\n        }\n      }\n\n      //Next element is a regular node? Prepare new working node\n      //Otherwise, if there are no more nodes or if the next element is\n      //an array (e.g. variations), we keep our working node as the current one\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\n        nextNode = new GameNode();\n        gameNode.appendChild(nextNode);\n        gameNode = nextNode;\n      }\n    }\n  };\n\n  /**\n   * Convert this node to a JGF node container\n   */\n  GameNode.prototype.toJgf = function(container) {\n\n    //Initialize container to add nodes to\n    container = container || [];\n\n    //Initialize node and get properties\n    var node = {};\n    var properties = Object.getOwnPropertyNames(this);\n\n    //Copy node properties\n    for (var key in properties) {\n      if (properties.hasOwnProperty(key)) {\n        var prop = properties[key];\n\n        //Skip some properties\n        if (prop === 'parent' || prop === 'children') {\n          continue;\n        }\n\n        //Conversion function present?\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\n        }\n        else if (typeof this[prop] === 'object') {\n          node[prop] = angular.copy(this[prop]);\n        }\n        else {\n          node[prop] = this[prop];\n        }\n      }\n    }\n\n    //Add node to container\n    container.push(node);\n\n    //Variations present?\n    if (this.children.length > 1) {\n\n      //Create variations container\n      var variationsContainer = [];\n      container.push(variationsContainer);\n\n      //Loop child (variation) nodes\n      for (var i = 0; i < this.children.length; i++) {\n\n        //Create container for this variation\n        var variationContainer = [];\n        variationsContainer.push(variationContainer);\n\n        //Call child node converter\n        this.children[i].toJgf(variationContainer);\n      }\n    }\n\n    //Just one child?\n    else if (this.children.length === 1) {\n      this.children[0].toJgf(container);\n    }\n\n    //Return container\n    return container;\n  };\n\n  //Return object\n  return GameNode;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePath :: A simple class that keeps track of a path taken in a game.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Path.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePath', function() {\n\n  /**\n   * Constructor\n   */\n  var GamePath = function() {\n    this.reset();\n  };\n\n  /**\n   * Reset\n   */\n  GamePath.prototype.reset = function() {\n    this.move = 0;\n    this.path = {};\n    this.branches = 0;\n    return this;\n  };\n\n  /**\n   * Advance a move\n   */\n  GamePath.prototype.advance = function(i) {\n\n    //Different child variation chosen? Remember\n    if (i > 0) {\n      this.path[this.move] = 1;\n      this.branches++;\n    }\n\n    //Increment move\n    this.move++;\n    return this;\n  };\n\n  /**\n   * Retreat a move\n   */\n  GamePath.prototype.retreat = function() {\n\n    //At start?\n    if (this.move === 0) {\n      return;\n    }\n\n    //Delete path choice\n    if (this.path[this.move]) {\n      delete this.path[this.move];\n      this.branches--;\n    }\n\n    //Decrement move\n    this.move--;\n    return this;\n  };\n\n  /**\n   * Go to a specific move number\n   */\n  GamePath.prototype.setMove = function(no) {\n\n    //Less than our current move? We need to erase any paths above the move number\n    if (no < this.move) {\n      for (var i in this.path) {\n        if (i > no) {\n          delete this.path[i];\n          this.branches--;\n        }\n      }\n    }\n\n    //Set move number\n    this.move = no;\n    return this;\n  };\n\n  /**\n   * Get the move number\n   */\n  GamePath.prototype.getMove = function() {\n    return this.move;\n  };\n\n  /**\n   * Get the node choice at a specific move number\n   */\n  GamePath.prototype.nodeAt = function(no) {\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\n  };\n\n  /**\n   * Compare to another path\n   */\n  GamePath.prototype.compare = function(otherPath) {\n\n    //Invalid object?\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\n      return;\n    }\n\n    //Different move number or path length?\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\n      return false;\n    }\n\n    //Check path\n    for (var i in this.path) {\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\n        return false;\n      }\n    }\n\n    //Same path!\n    return true;\n  };\n\n  /**\n   * Clone\n   */\n  GamePath.prototype.clone = function() {\n\n    //Create new instance\n    var newPath = new GamePath();\n\n    //Set vars\n    newPath.move = this.move;\n    newPath.branches = this.branches;\n    newPath.path = angular.copy(this.path);\n\n    //Return\n    return newPath;\n  };\n\n  /**\n   * Helper to find node name recursively\n   */\n  var findNodeName = function(node, nodeName, path) {\n\n    //Found in this node?\n    if (node.name && node.name === nodeName) {\n      return true;\n    }\n\n    //Loop children\n    for (var i = 0; i < node.children.length; i++) {\n\n      //Advance path\n      path.advance(i);\n\n      //Found in child node?\n      if (findNodeName(node.children[i], nodeName, path)) {\n        return true;\n      }\n\n      //Not found in this child node, retreat path\n      path.retreat();\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Static helper to create a path object to reach a certain node\n   */\n  GamePath.findNode = function(nodeName, rootNode) {\n\n    //Create new instance\n    var path = new GamePath();\n\n    //Find the node name\n    if (findNodeName(rootNode, nodeName, path)) {\n      return path;\n    }\n\n    //Not found\n    return null;\n  };\n\n  //Return\n  return GamePath;\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\n * markup on the board in this position, as well as any captures that were made and which player's\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\n * compare changes to other positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Position.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePosition', ['StoneColor', 'BoardGrid', function(StoneColor, BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var GamePosition = function(width, height) {\n\n    //Initialize\n    this.error = 0;\n    this.width = 0;\n    this.height = 0;\n    this.stones = new BoardGrid();\n    this.markup = new BoardGrid();\n    this.turn = StoneColor.B;\n\n    //Initialize captures\n    this.captures = {};\n    this.captures[StoneColor.B] = [];\n    this.captures[StoneColor.W] = [];\n\n    //Set empty value for stones grid\n    this.stones.whenEmpty(StoneColor.EMPTY);\n\n    //Set size\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set the grid size\n   */\n  GamePosition.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Set in grids\n    this.stones.setSize(width, height);\n    this.markup.setSize(width, height);\n\n    //Empty the position\n    this.empty();\n  };\n\n  /**\n   * Clear the whole position\n   */\n  GamePosition.prototype.empty = function() {\n    this.stones.empty();\n    this.markup.empty();\n  };\n\n  /**\n   * Sets stone color at given coordinates.\n   */\n  GamePosition.prototype.setStone = function(x, y, color) {\n    this.stones.set(x, y, color);\n  };\n\n  /**\n   * Sets markup type at given coordinates.\n   */\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\n    this.markup.set(x, y, markup);\n  };\n\n  /*****************************************************************************\n   * Liberties and capturing\n   ***/\n\n  /**\n   * Check if a group of given color has liberties, starting at the given coordinates\n   */\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\n\n    //Out of bounds? No liberties outside of the board\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Initialize tested grid if needed\n    tested = tested || new BoardGrid(this.width, this.height);\n\n    //See what color is present on the coordinates\n    var color = this.stones.get(x, y);\n\n    //If no group color was given, use what's on the position\n    groupColor = groupColor || color;\n\n    //Already tested, or enemy stone? Not giving any liberties\n    if (tested.get(x, y) === true || color === -groupColor) {\n      return false;\n    }\n\n    //Empty? That's a liberty\n    if (color === StoneColor.EMPTY) {\n      return true;\n    }\n\n    //Mark this position as tested now\n    tested.set(x, y, true);\n\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\n    //If we get at least one true, we have a liberty\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\n        this.hasLiberties(x + 1, y, groupColor, tested);\n  };\n\n  /**\n   * Helper to capture adjacent groups\n   */\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    friendlyColor = friendlyColor || this.stones.get(x, y);\n\n    //Can't capture empty spots\n    if (friendlyColor === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Flag to see if we captured stuff\n    var captured = false;\n\n    //Check adjacent positions now, capturing stones in the process if possible\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n\n    //Return\n    return captured;\n  };\n\n  /**\n   * Helper if we can capture a certain group\n   */\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\n\n    //Out of bounds? Nothing to capture\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Empty spot? Can't capture\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //We need to have a stone of matching group color in order to be able to capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //There is a capturable stone, let's see if it has any liberties left\n    if (this.hasLiberties(x, y, enemyColor)) {\n      return false;\n    }\n\n    //No liberties left, the group is capturable. Capture if we want to\n    if (doCapture) {\n      this.captureGroup(x, y, enemyColor);\n    }\n\n    //Capturable\n    return true;\n  };\n\n  /**\n   * Capture a group of certain color, starting at the given coordinates\n   */\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //If no group color was given, use what's on the position\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //Stone at position does not match the given group color? Can't capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //Capture the stone\n    this.captureStone(x, y);\n\n    //Capture the rest of the group\n    this.captureGroup(x, y - 1, enemyColor);\n    this.captureGroup(x, y + 1, enemyColor);\n    this.captureGroup(x - 1, y, enemyColor);\n    this.captureGroup(x + 1, y, enemyColor);\n\n    //At least one stone was captured\n    return true;\n  };\n\n  /**\n   * Capture a stone at given coordinates\n   */\n  GamePosition.prototype.captureStone = function(x, y) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Get color\n    var color = this.stones.get(x, y);\n\n    //Empty?\n    if (color === StoneColor.EMPTY) {\n      return;\n    }\n\n    //Ok, stone present, capture it\n    this.stones.set(x, y, StoneColor.EMPTY);\n    this.captures[color].push({x: x, y: y});\n  };\n\n  /**\n   * Set captures for a color (expects array with capture object coordinates)\n   */\n  GamePosition.prototype.setCaptures = function(color, captures) {\n    this.captures[color] = captures;\n  };\n\n  /**\n   * Get captures for a color\n   */\n  GamePosition.prototype.getCaptures = function(color) {\n    return this.captures[color] || [];\n  };\n\n  /**\n   * Get the capture count for a color (= the number of captures of the opposing color)\n   */\n  GamePosition.prototype.getCaptureCount = function(color) {\n    return this.captures[-color].length;\n  };\n\n  /*****************************************************************************\n   * Turn control\n   ***/\n\n  /**\n   * Set color for whose move it is at this position\n   */\n  GamePosition.prototype.setTurn = function(color) {\n    this.turn = color;\n  };\n\n  /**\n   * Get color for whose move it is at this position\n   */\n  GamePosition.prototype.getTurn = function() {\n    return this.turn;\n  };\n\n  /**\n   * Switch the player turn on this position\n   */\n  GamePosition.prototype.switchTurn = function() {\n    this.turn = -this.turn;\n  };\n\n  /*****************************************************************************\n   * Cloning and comparison\n   ***/\n\n  /**\n   * Clones the whole position except turn and captures\n   */\n  GamePosition.prototype.clone = function() {\n\n    //Create a new position\n    var newPosition = new GamePosition();\n\n    //Set vars manually for maximum efficiency\n    newPosition.turn = this.turn;\n    newPosition.width = this.width;\n    newPosition.height = this.height;\n    newPosition.stones = this.stones.clone();\n    newPosition.markup = new BoardGrid(this.width, this.height);\n\n    //Return\n    return newPosition;\n  };\n\n  /**\n   * Checks if a given position is the same as the current position\n   */\n  GamePosition.prototype.isSameAs = function(newPosition) {\n\n    //Must have the same size\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\n      return false;\n    }\n\n    //Compare the grids\n    return this.stones.isSameAs(newPosition.stones);\n  };\n\n  //Return\n  return GamePosition;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScore :: A simple class that contains a game score\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Score.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScore', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Helper to calculate the total points\n   */\n  var calcTotal = function() {\n    return parseInt(this.stones) + parseInt(this.territory) +\n      parseInt(this.captures) + parseInt(this.komi);\n  };\n\n  /**\n   * Constructor\n   */\n  var GameScore = function() {\n\n    //Get self\n    var self = this;\n\n    //Setup score containers\n    this.black = {};\n    this.white = {};\n\n    //Initialize\n    this.reset();\n\n    //Add total handlers\n    this.black.total = function() {\n      return calcTotal.call(self.black);\n    };\n    this.white.total = function() {\n      return calcTotal.call(self.white);\n    };\n  };\n\n  /**\n   * Reset the game score\n   */\n  GameScore.prototype.reset = function() {\n\n    //Get properties to loop\n    var props = ['stones', 'territory', 'captures', 'komi'];\n\n    //Score for black player\n    for (var i = 0; i < props.length; i++) {\n      this.black[props[i]] = 0;\n      this.white[props[i]] = 0;\n    }\n  };\n\n  /**\n   * Get the winner\n   */\n  GameScore.prototype.winner = function() {\n\n    //Get totals\n    var b = this.black.total();\n    var w = this.white.total();\n\n    //Determine winner\n    if (w > b) {\n      return StoneColor.W;\n    }\n    else if (b > w) {\n      return StoneColor.B;\n    }\n    return StoneColor.E;\n  };\n\n  //Return\n  return GameScore;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScorer :: This class is used to determine the score of a certain game position. It also\n * provides handling of manual adjustment of dead / living groups.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Scorer.Service', [\n  'ngGo',\n  'ngGo.Game.Score.Service',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScorer', ['GameScore', 'StoneColor', 'BoardGrid', function(GameScore, StoneColor, BoardGrid) {\n\n  /**\n   * Possible score states\n   */\n  var scoreState = {\n    UNKNOWN: StoneColor.EMPTY,\n    BLACK_STONE: StoneColor.B,\n    WHITE_STONE: StoneColor.W,\n    BLACK_CANDIDATE: StoneColor.B * 2,\n    WHITE_CANDIDATE: StoneColor.W * 2,\n    NEUTRAL: StoneColor.B * 3\n  };\n\n  /**\n   * Helper to set territory\n   */\n  var territorySet = function(x, y, candidateColor, boundaryColor) {\n\n    //Get color at given position\n    var posColor = this.stones.get(x, y);\n    var origColor = this.game.position.stones.get(x, y);\n\n    //If border reached, or a position which is already this color, or boundary color, can't set\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\n      return;\n    }\n\n    //Don't turn stones which are already this color into candidates, instead\n    //reset their color to what they were\n    if (origColor * 2 === candidateColor) {\n      this.stones.set(x, y, origColor);\n    }\n\n    //Otherwise, mark as candidate\n    else {\n      this.stones.set(x, y, candidateColor);\n    }\n\n    //Set adjacent squares\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\n  };\n\n  /**\n   * Helper to reset territory\n   */\n  var territoryReset = function(x, y) {\n\n    //Get original color from this position\n    var origColor = this.game.position.stones.get(x, y);\n\n    //Not on grid, or already this color?\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\n      return;\n    }\n\n    //Reset the color\n    this.stones.set(x, y, origColor);\n\n    //Set adjacent squares\n    territoryReset.call(this, x - 1, y);\n    territoryReset.call(this, x, y - 1);\n    territoryReset.call(this, x + 1, y);\n    territoryReset.call(this, x, y + 1);\n  };\n\n  /**\n   * Helper to determine score state\n   */\n  var determineScoreState = function() {\n\n    //Initialize vars\n    var change = true;\n    var curState, newState, adjacent, b, w, a, x, y;\n\n    //Loop while there is change\n    while (change) {\n\n      //Set to false\n      change = false;\n\n      //Go through the whole position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get current state at position\n          curState = this.stones.get(x, y);\n\n          //Unknown or candiates?\n          if (\n            curState === scoreState.UNKNOWN ||\n            curState === scoreState.BLACK_CANDIDATE ||\n            curState === scoreState.WHITE_CANDIDATE\n          ) {\n\n            //Get state in adjacent positions\n            adjacent = [\n              this.stones.get(x - 1, y),\n              this.stones.get(x, y - 1),\n              this.stones.get(x + 1, y),\n              this.stones.get(x, y + 1)\n            ];\n\n            //Reset\n            b = w = false;\n\n            //Loop adjacent squares\n            for (a = 0; a < 4; a++) {\n              if (\n                adjacent[a] === scoreState.BLACK_STONE ||\n                adjacent[a] === scoreState.BLACK_CANDIDATE\n              ) {\n                b = true;\n              }\n              else if (\n                adjacent[a] === scoreState.WHITE_STONE ||\n                adjacent[a] === scoreState.WHITE_CANDIDATE\n              ) {\n                w = true;\n              }\n              else if (adjacent[a] === scoreState.NEUTRAL) {\n                b = w = true;\n              }\n            }\n\n            //Determine new state\n            if (b && w) {\n              newState = scoreState.NEUTRAL;\n            }\n            else if (b) {\n              newState = scoreState.BLACK_CANDIDATE;\n            }\n            else if (w) {\n              newState = scoreState.WHITE_CANDIDATE;\n            }\n            else {\n              newState = false;\n            }\n\n            //Change?\n            if (newState !== false && newState !== curState) {\n              change = true;\n              this.stones.set(x, y, newState);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * this.game scorer class\n   */\n  var GameScorer = {\n\n    //Game to score\n    game: null,\n\n    //Score\n    score: null,\n\n    //Stones, captures and points grids\n    stones: null,\n    captures: null,\n    points: null,\n\n    /**\n     * Load a game to score\n     */\n    load: function(game) {\n\n      //Reset score\n      this.score = new GameScore();\n\n      //Remember\n      this.game = game;\n\n      //Clone position to work with\n      this.stones = this.game.position.stones.clone();\n\n      //Create grids\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n    },\n\n    /**\n     * Get the calculated score\n     */\n    getScore: function() {\n      return this.score;\n    },\n\n    /**\n     * Get the points grid\n     */\n    getPoints: function() {\n      return this.points;\n    },\n\n    /**\n     * Get the captures grid\n     */\n    getCaptures: function() {\n      return this.captures;\n    },\n\n    /**\n     * Run score calculation routine\n     */\n    calculate: function() {\n\n      //No game?\n      if (!this.game) {\n        console.warn('No game loaded in game scorer, can\\'t calutlate score.');\n        return;\n      }\n\n      //Empty grids\n      this.points.empty();\n      this.captures.empty();\n\n      //Determine score state\n      determineScoreState.call(this);\n\n      //Get komi and captures\n      var komi = this.game.get('game.komi');\n      var captures = this.game.getCaptureCount();\n\n      //Reset score\n      this.score.reset();\n\n      //Set captures and komi\n      this.score.black.captures = captures[StoneColor.B];\n      this.score.white.captures = captures[StoneColor.W];\n      this.score.black.komi = komi < 0 ? komi : 0;\n      this.score.white.komi = komi > 0 ? komi : 0;\n\n      //Init helper vars\n      var x, y, state, color;\n\n      //Loop position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get state and color on original position\n          state = this.stones.get(x, y);\n          color = this.game.position.stones.get(x, y);\n\n          //Black stone\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\n            this.score.black.stones++;\n            continue;\n          }\n\n          //White stone\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\n            this.score.white.stones++;\n            continue;\n          }\n\n          //Black candidate\n          if (state === scoreState.BLACK_CANDIDATE) {\n            this.score.black.territory++;\n            this.points.set(x, y, StoneColor.B);\n\n            //White stone underneath?\n            if (color === StoneColor.W) {\n              this.score.black.captures++;\n              this.captures.set(x, y, StoneColor.W);\n            }\n            continue;\n          }\n\n          //White candidate\n          if (state === scoreState.WHITE_CANDIDATE) {\n            this.score.white.territory++;\n            this.points.set(x, y, StoneColor.W);\n\n            //Black stone underneath?\n            if (color === StoneColor.B) {\n              this.score.white.captures++;\n              this.captures.set(x, y, StoneColor.B);\n            }\n            continue;\n          }\n        }\n      }\n    },\n\n    /**\n     * Mark stones dead or alive\n     */\n    mark: function(x, y) {\n\n      //Get color of original position and state of the count position\n      var color = this.game.position.stones.get(x, y);\n      var state = this.stones.get(x, y);\n\n      //White stone\n      if (color === StoneColor.W) {\n\n        //Was white, mark it and any territory it's in as black's\n        if (state === scoreState.WHITE_STONE) {\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\n        }\n\n        //Was marked as not white, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n\n      //Black stone\n      else if (color === StoneColor.B) {\n\n        //Was black, mark it and any territory it's in as white's\n        if (state === scoreState.BLACK_STONE) {\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\n        }\n\n        //Was marked as not black, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n    }\n  };\n\n  //Return\n  return GameScorer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Directive', [\n  'ngGo.Board.Directive'\n])\n\n/**\n * Directive definition\n */\n.directive('player', ['Player', function(Player) {\n  return {\n    restrict: 'E',\n\n    /**\n     * Controller\n     */\n    controller: ['$scope', function($scope) {\n\n      //Set player in scope\n      if (!$scope.Player) {\n        $scope.Player = Player;\n      }\n    }],\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Link the element\n      Player.linkElement(element);\n\n      //Observe mode and tool attributes\n      attrs.$observe('mode', function(mode) {\n        Player.switchMode(mode);\n      });\n      attrs.$observe('tool', function(tool) {\n        Player.switchTool(tool);\n      });\n\n      //Observe other settings attributes\n      attrs.$observe('variationMarkup', function(attr) {\n        Player.setVariationMarkup(attr === 'true');\n      });\n      attrs.$observe('solutionPaths', function(attr) {\n        Player.toggleSolutionPaths(attr === 'true');\n      });\n      attrs.$observe('lastMoveMarker', function(attr) {\n        Player.setLastMoveMarker(attr);\n      });\n    }\n  };\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Player :: This class brings the board to life and allows a user to interact with it. It\n * handles user input, controls objects going to the board, can load game records, and allows the\n * user to manipulate the board according to the current player mode.\n * Unless you want to display static positions, this is the class you'd use by default.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Service', [\n  'ngGo',\n  'ngGo.Player.Directive',\n  'ngGo.Player.Mode.Common.Service',\n  'ngGo.Board.Service',\n  'ngGo.Game.Service',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Player', ['PlayerModes', 'PlayerTools', 'MarkupTypes', function(PlayerModes, PlayerTools, MarkupTypes) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default mode/tool\n    mode: PlayerModes.REPLAY,\n    tool: PlayerTools.MOVE,\n\n    //Keys/scrollwheel navigation\n    arrowKeysNavigation: true,\n    scrollWheelNavigation: true,\n\n    //Last move marker, leave empty for none\n    lastMoveMarker: MarkupTypes.LAST,\n\n    //Indicate variations with markup on the board, and show\n    //successor node variations or current node variations\n    variationMarkup: true,\n    variationChildren: true,\n    variationSiblings: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$document', 'Game', 'GameScorer', 'Board', 'PlayerTools', function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\n\n    /**\n     * Helper to append board grid coordinatess to the broadcast event object\n     */\n    var processMouseEvent = function(broadcastEvent, mouseEvent) {\n\n      //Can only do this with a board and mouse event\n      if (!this.board || !mouseEvent) {\n        broadcastEvent.x = -1;\n        broadcastEvent.y = -1;\n        return;\n      }\n\n      //Init\n      var x = 0;\n      var y = 0;\n\n      //Set x\n      if (typeof mouseEvent.offsetX !== 'undefined') {\n        x = mouseEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.layerX;\n      }\n\n      //Set y\n      if (typeof mouseEvent.offsetY !== 'undefined') {\n        y = mouseEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.layerY;\n      }\n\n      //Apply pixel ratio factor\n      x *= (window.devicePixelRatio || 1);\n      y *= (window.devicePixelRatio || 1);\n\n      //Append coords\n      broadcastEvent.x = this.board.getGridX(x);\n      broadcastEvent.y = this.board.getGridY(y);\n\n      //Did we drag?\n      if (mouseEvent.drag) {\n        broadcastEvent.drag = mouseEvent.drag;\n      }\n    };\n\n    /**\n     * Player class\n     */\n    var Player = {\n\n      //Player configuration\n      config: {},\n\n      //Board and game instances\n      board: null,\n      game: null,\n\n      //Available modes and tools\n      modes: {},\n      tools: [],\n\n      //Player mode and active tool\n      mode: '',\n      tool: '',\n\n      //Current path\n      path: null,\n\n      /**\n       * Initialization\n       */\n      init: function() {\n\n        //Unlink board instance, create new game\n        this.board = null;\n        this.game = new Game();\n\n        //Reset path\n        this.path = null;\n\n        //Player mode and active tool\n        this.mode = '';\n        this.tool = '';\n\n        //Arrow keys / scroll wheel navigation\n        this.arrowKeysNavigation = false;\n        this.scrollWheelNavigation = false;\n\n        //Last move marker\n        this.lastMoveMarker = '';\n\n        //Variation markup\n        this.variationMarkup = false;\n        this.variationChildren = false;\n        this.variationSiblings = false;\n\n        //Restricted nodes\n        this.restrictNodeStart = null;\n        this.restrictNodeEnd = null;\n\n        //Parse config\n        this.parseConfig();\n      },\n\n      /**\n       * Link the player to a HTML element\n       */\n      linkElement: function(element) {\n\n        //Set element\n        this.element = element;\n\n        //Register document event\n        this.registerElementEvent('keydown', $document);\n\n        //Register element events\n        this.registerElementEvent('click');\n        this.registerElementEvent('mousedown');\n        this.registerElementEvent('mouseup');\n        this.registerElementEvent('mousemove');\n        this.registerElementEvent('mouseout');\n        this.registerElementEvent('mousewheel');\n        this.registerElementEvent('wheel');\n      },\n\n      /*****************************************************************************\n       * Configuration\n       ***/\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, defaultConfig, config || {});\n\n        //Process settings\n        this.switchMode(this.config.mode);\n        this.switchTool(this.config.tool);\n        this.setArrowKeysNavigation(this.config.arrowKeysNavigation);\n        this.setScrollWheelNavigation(this.config.scrollWheelNavigation);\n        this.setLastMoveMarker(this.config.lastMoveMarker);\n        this.setVariationMarkup(\n          this.config.variationMarkup,\n          this.config.variationChildren,\n          this.config.variationSiblings\n        );\n\n        //Let the modes parse their config\n        for (var mode in this.modes) {\n          if (this.modes[mode].parseConfig) {\n            this.modes[mode].parseConfig.call(this, this.config);\n          }\n        }\n      },\n\n      /**\n       * Set arrow keys navigation\n       */\n      setArrowKeysNavigation: function(arrowKeys) {\n        if (arrowKeys !== this.arrowKeysNavigation) {\n          this.arrowKeysNavigation = arrowKeys;\n          this.broadcast('settingChange', 'arrowKeysNavigation');\n        }\n      },\n\n      /**\n       * Set scroll wheel navigation\n       */\n      setScrollWheelNavigation: function(scrollWheel) {\n        if (scrollWheel !== this.scrollWheelNavigation) {\n          this.scrollWheelNavigation = scrollWheel;\n          this.broadcast('settingChange', 'scrollWheelNavigation');\n        }\n      },\n\n      /**\n       * Set the last move marker\n       */\n      setLastMoveMarker: function(lastMoveMarker) {\n        if (lastMoveMarker !== this.lastMoveMarker) {\n          this.lastMoveMarker = lastMoveMarker;\n          this.broadcast('settingChange', 'lastMoveMarker');\n        }\n      },\n\n      /**\n       * Set variation markup on the board\n       */\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\n\n        //One change event for these three settings\n        var change = false;\n\n        //Markup setting change?\n        if (variationMarkup !== this.variationMarkup) {\n          this.variationMarkup = variationMarkup;\n          change = true;\n        }\n\n        //Children setting change?\n        if (\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\n        ) {\n          this.variationChildren = variationChildren;\n          change = true;\n        }\n\n        //Siblings setting change?\n        if (\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\n        ) {\n          this.variationSiblings = variationSiblings;\n          change = true;\n        }\n\n        //Did anything change?\n        if (change) {\n          this.broadcast('settingChange', 'variationMarkup');\n        }\n      },\n\n      /*****************************************************************************\n       * Mode and tool handling\n       ***/\n\n      /**\n       * Register a player mode\n       */\n      registerMode: function(mode, PlayerMode) {\n\n        //Register the mode and let it parse the configuration\n        this.modes[mode] = PlayerMode;\n\n        //Parse config if we have a handler\n        if (this.modes[mode].parseConfig) {\n          this.modes[mode].parseConfig.call(this, this.config);\n        }\n\n        //Force switch the mode now, if it matches the initial mode\n        if (this.mode === mode) {\n          this.switchMode(this.mode, true);\n          this.switchTool(this.tool, true);\n        }\n      },\n\n      /**\n       * Set available tools\n       */\n      setTools: function(tools) {\n        this.tools = tools || [PlayerTools.NONE];\n      },\n\n      /**\n       * Check if we have a player mode\n       */\n      hasMode: function(mode) {\n        return this.modes[mode] ? true : false;\n      },\n\n      /**\n       * Check if we have a player tool\n       */\n      hasTool: function(tool) {\n        return (this.tools.indexOf(tool) !== -1);\n      },\n\n      /**\n       * Switch player mode\n       */\n      switchMode: function(mode, force) {\n\n        //No change?\n        if (!force && (!mode || this.mode === mode)) {\n          return false;\n        }\n\n        //Broadcast mode exit\n        if (this.mode) {\n          this.broadcast('modeExit', this.mode);\n        }\n\n        //Set mode, reset tools and active tool\n        this.mode = mode;\n        this.tools = [];\n        this.tool = PlayerTools.NONE;\n\n        //Broadcast mode entry\n        this.broadcast('modeEnter', this.mode);\n        return true;\n      },\n\n      /**\n       * Switch player tool\n       */\n      switchTool: function(tool, force) {\n\n        //No change?\n        if (!force && (!tool || this.tool === tool)) {\n          return false;\n        }\n\n        //Validate tool switch (only when there is a mode)\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\n          return false;\n        }\n\n        //Change tool\n        this.tool = tool;\n        this.broadcast('toolSwitch', this.tool);\n        return true;\n      },\n\n      /**\n       * Save the full player state\n       */\n      saveState: function() {\n\n        //Save player state\n        this.playerState = {\n          mode: this.mode,\n          tool: this.tool,\n          restrictNodeStart: this.restrictNodeStart,\n          restrictNodeEnd: this.restrictNodeEnd\n        };\n\n        //Save game state\n        this.saveGameState();\n      },\n\n      /**\n       * Restore to the saved player state\n       */\n      restoreState: function() {\n\n        //Must have player state\n        if (!this.playerState) {\n          return;\n        }\n\n        //Restore\n        this.switchMode(this.playerState.mode);\n        this.switchTool(this.playerState.tool);\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\n\n        //Restore game state\n        this.restoreGameState();\n      },\n\n      /*****************************************************************************\n       * Game record handling\n       ***/\n\n      /**\n       * Load game record\n       */\n      load: function(data, allowPlayerConfig) {\n\n        //Try to load the game record data\n        try {\n          this.game.load(data);\n        }\n        catch (error) {\n          throw error;\n        }\n\n        //Reset path\n        this.path = null;\n\n        //Parse configuration from JGF if allowed\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\n          this.parseConfig(this.game.get('settings'));\n        }\n\n        //Dispatch game loaded event\n        this.broadcast('gameLoaded', this.game);\n\n        //Board present?\n        if (this.board) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n\n        //Loaded ok\n        return true;\n      },\n\n      /**\n       * Reload the existing game record\n       */\n      reload: function() {\n\n        //Must have game\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reload game\n        this.game.reload();\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Save the current state\n       */\n      saveGameState: function() {\n        if (this.game && this.game.isLoaded()) {\n          this.gameState = this.game.getState();\n        }\n      },\n\n      /**\n       * Restore to the saved state\n       */\n      restoreGameState: function() {\n\n        //Must have game and saved state\n        if (!this.game || !this.gameState) {\n          return;\n        }\n\n        //Restore state\n        this.game.restoreState(this.gameState);\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /*****************************************************************************\n       * Navigation\n       ***/\n\n      /**\n       * Go to the next position\n       */\n      next: function(i) {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.next(i);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position\n       */\n      previous: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previous();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the last position\n       */\n      last: function() {\n        if (this.game) {\n          this.game.last();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the first position\n       */\n      first: function() {\n        if (this.game) {\n          this.game.first();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to a specific move number, tree path or named node\n       */\n      goto: function(target) {\n        if (this.game && target) {\n          this.game.goto(target);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the previous fork\n       */\n      previousFork: function() {\n        if (this.game) {\n          this.game.previousFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next fork\n       */\n      nextFork: function() {\n        if (this.game) {\n          this.game.nextFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next position with a comment\n       */\n      nextComment: function() {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.nextComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position with a comment\n       */\n      previousComment: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previousComment();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Restrict navigation to the current node\n       */\n      restrictNode: function(end) {\n\n        //Must have game and node\n        if (!this.game || !this.game.node) {\n          return;\n        }\n\n        //Restrict to current node\n        if (end) {\n          this.restrictNodeEnd = this.game.node;\n        }\n        else {\n          this.restrictNodeStart = this.game.node;\n        }\n      },\n\n      /**\n       * Process a new game position\n       */\n      processPosition: function() {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Get current node and game position\n        var node = this.game.getNode();\n        var path = this.game.getPath();\n        var position = this.game.getPosition();\n        var pathChanged = !path.compare(this.path);\n\n        //Update board\n        this.updateBoard(node, position, pathChanged);\n\n        //Path change?\n        if (pathChanged) {\n\n          //Copy new path and broadcast path change\n          this.path = path.clone();\n          this.broadcast('pathChange', node);\n\n          //Named node reached? Broadcast event\n          if (node.name) {\n            this.broadcast('reachedNode.' + node.name, node);\n          }\n        }\n\n        //Passed?\n        if (node.move && node.move.pass) {\n          this.broadcast('movePassed', node);\n        }\n      },\n\n      /**\n       * Show move numbers\n       */\n      showMoveNumbers: function(fromMove, toMove) {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Use sensible defaults if no from/to moves given\n        fromMove = fromMove || 1;\n        toMove = toMove || this.game.getMove();\n\n        //Get nodes for these moves\n        var nodes = this.game.getMoveNodes(fromMove, toMove);\n        var move = fromMove;\n\n        //Loop nodes\n        angular.forEach(nodes, function(node) {\n          this.board.add('markup', node.move.x, node.move.y, {\n            type: MarkupTypes.LABEL,\n            text: move++\n          });\n        }, this);\n\n        //Redraw board markup\n        this.board.redraw('markup');\n      },\n\n      /*****************************************************************************\n       * Game handling\n       ***/\n\n      /**\n       * Start a new game\n       */\n      newGame: function() {\n        this.game = new Game();\n        this.processPosition();\n      },\n\n      /**\n       * Score the current game position\n       */\n      scoreGame: function() {\n\n        //Calculate score\n        GameScorer.calculate();\n\n        //Get score, points and captures\n        var score = GameScorer.getScore();\n        var points = GameScorer.getPoints();\n        var captures = GameScorer.getCaptures();\n\n        //Remove all markup, and set captures and points\n        this.board.layers.markup.removeAll();\n        this.board.layers.score.setAll(points, captures);\n\n        //Broadcast score\n        this.broadcast('scoreCalculated', score);\n      },\n\n      /*****************************************************************************\n       * Board handling\n       ***/\n\n      /**\n       * Get the board\n       */\n      getBoard: function() {\n        return this.board;\n      },\n\n      /**\n       * Set the board\n       */\n      setBoard: function(Board) {\n\n        //Set the board\n        this.board = Board;\n\n        //Board ready\n        if (this.board) {\n          this.broadcast('boardReady', this.board);\n        }\n\n        //If a game has been loaded already, parse config and update the board\n        if (this.game && this.game.isLoaded()) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Update the board\n       */\n      updateBoard: function(node, position, pathChanged) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Update board with new position\n        this.board.updatePosition(position, pathChanged);\n\n        //Mark last move\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\n        }\n\n        //Broadcast board update event\n        this.broadcast('boardUpdate', node);\n      },\n\n      /*****************************************************************************\n       * Event handling\n       ***/\n\n      /**\n       * Register an element event\n       */\n      registerElementEvent: function(event, element) {\n\n        //Which element to use\n        if (typeof element === 'undefined' || !element.on) {\n          element = this.element;\n        }\n\n        //Remove any existing event listener and apply new one\n        //TODO: Namespacing events doesn't work with Angular's jqLite\n        element.off(event/* + '.ngGo.player'*/);\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\n      },\n\n      /**\n       * Event listener\n       */\n      on: function(type, listener, mode, $scope) {\n\n        //Must have valid listener\n        if (typeof listener !== 'function') {\n          console.warn('Listener is not a function:', listener);\n          return;\n        }\n\n        //Scope given as 3rd parameter?\n        if (mode && mode.$parent) {\n          $scope = mode;\n          mode = '';\n        }\n\n        //Multiple events?\n        if (type.indexOf(' ') !== -1) {\n          var types = type.split(' ');\n          for (var t = 0; t < types.length; t++) {\n            this.on(types[t], listener, mode, $scope);\n          }\n          return;\n        }\n\n        //Get self and determine scope to use\n        var self = this;\n        var scope = $scope || $rootScope;\n\n        //Create listener and return de-registration function\n        return scope.$on('ngGo.player.' + type, function() {\n\n          //Filter on mode\n          if (mode) {\n            if (\n              (typeof mode === 'string' && mode !== self.mode) ||\n              mode.indexOf(self.mode) === -1\n            ) {\n              return;\n            }\n          }\n\n          //Inside a text field?\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\n            return;\n          }\n\n          //Append grid coordinates for mouse events\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\n            processMouseEvent.call(self, arguments[0], arguments[1]);\n          }\n\n          //Dragging? Prevent click events from firing\n          if (self.preventClickEvent && type === 'click') {\n            delete self.preventClickEvent;\n            return;\n          }\n          else if (type === 'mousedrag') {\n            self.preventClickEvent = true;\n          }\n\n          //Call listener\n          listener.apply(self, arguments);\n        });\n      },\n\n      /**\n       * Event broadcaster\n       */\n      broadcast: function(type, args) {\n\n        //Must have type\n        if (!type) {\n          return;\n        }\n\n        //Make sure we are in a digest cycle\n        if (!$rootScope.$$phase) {\n          $rootScope.$apply(function() {\n            $rootScope.$broadcast('ngGo.player.' + type, args);\n          });\n        }\n        else {\n          $rootScope.$broadcast('ngGo.player.' + type, args);\n        }\n      }\n    };\n\n    //Initialize\n    Player.init();\n\n    //Return object\n    return Player;\n  }];\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Blank.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('KifuBlank', ['ngGo', function(ngGo) {\n\n  /**\n   * Blank JGF\n   */\n  var blankJgf = {\n    record: {\n      application: ngGo.name + ' v' + ngGo.version,\n      version: 1,\n      charset: 'UTF-8'\n    },\n    game: {\n      type: 'go',\n      players: [\n        {\n          color: 'black',\n          name: 'Black'\n        },\n        {\n          color: 'white',\n          name: 'White'\n        }\n      ]\n    },\n    board: {\n      width: 19,\n      height: 19\n    },\n    tree: []\n  };\n\n  /**\n   * Blank SGF\n   */\n  var blankSgf = {\n    AP: ngGo.name + ':' + ngGo.version,\n    CA: 'UTF-8',\n    FF: '4',\n    GM: '1',\n    SZ: '19',\n    PB: 'Black',\n    PW: 'White'\n  };\n\n  /**\n   * Blank JGF/SGF container\n   */\n  var KifuBlank = {\n\n    /**\n     * Get blank JGF\n     */\n    jgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankJgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    },\n\n    /**\n     * Get blank SGF\n     */\n    sgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankSgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = base[p];\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    }\n  };\n\n  //Return object\n  return KifuBlank;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\n * constants used by the parsers to aid conversion.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parser.Service', [\n  'ngGo',\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service'\n])\n\n/**\n * SGF/JGF aliases constant for conversion between the two formats\n * Note: not all properties can be translated directly, so some are\n * not present here in this constant\n */\n.constant('sgfAliases', {\n\n  //Record properties\n  'AP': 'record.application',\n  'CA': 'record.charset',\n  'CP': 'record.copyright',\n  'SO': 'record.source',\n  'US': 'record.transcriber',\n  'AN': 'record.annotator',\n\n  //Game properties\n  'GM': 'game.type',\n  'GN': 'game.name',\n  'KM': 'game.komi',\n  'HA': 'game.handicap',\n  'RE': 'game.result',\n  'RU': 'game.rules',\n  'TM': 'game.time.main',\n  'OT': 'game.time.overtime',\n  'DT': 'game.dates',\n  'PC': 'game.location',\n  'EV': 'game.event',\n  'RO': 'game.round',\n  'ON': 'game.opening',\n  'GC': 'game.comment',\n\n  //Player info properties\n  'PB': 'name',\n  'PW': 'name',\n  'BT': 'team',\n  'WT': 'team',\n  'BR': 'rank',\n  'WR': 'rank',\n\n  //Node annotation\n  'N': 'name',\n  'C': 'comments',\n  'CR': 'circle',\n  'TR': 'triangle',\n  'SQ': 'square',\n  'MA': 'mark',\n  'SL': 'select',\n  'LB': 'label'\n})\n\n/**\n * SGF game definitions\n */\n.constant('sgfGames', {\n  1: 'go',\n  2: 'othello',\n  3: 'chess',\n  4: 'renju',\n  6: 'backgammon',\n  7: 'chinese chess',\n  8: 'shogi'\n})\n\n/**\n * Factory definition\n */\n.factory('KifuParser', ['Gib2Jgf', 'Sgf2Jgf', 'Jgf2Sgf', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\n\n  /**\n   * Parser wrapper class\n   */\n  var KifuParser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    gib2jgf: function(gib, stringified) {\n      return Gib2Jgf.parse(gib, stringified);\n    },\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    sgf2jgf: function(sgf, stringified) {\n      return Sgf2Jgf.parse(sgf, stringified);\n    },\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    jgf2sgf: function(jgf) {\n      return Jgf2Sgf.parse(jgf);\n    }\n  };\n\n  //Return object\n  return KifuParser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\n * gridlines, starpoints and coordinates via the Coordinates class.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Coordinates.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GridLayer', ['BoardLayer', 'Coordinates', function(BoardLayer, Coordinates) {\n\n  /**\n   * Helper for drawing starpoints\n   */\n  var drawStarPoint = function(gridX, gridY, starRadius, starColor) {\n\n    //Don't draw if it falls outsize of the board grid\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\n      return;\n    }\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\n      return;\n    }\n\n    //Get absolute coordinates and star point radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n\n    //Draw star point\n    this.context.beginPath();\n    this.context.fillStyle = starColor;\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\n    this.context.fill();\n  };\n\n  /**\n   * Constructor\n   */\n  var GridLayer = function(board, context) {\n\n    //Set coordinates setting\n    this.coordinates = false;\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Show or hide the coordinates.\n   */\n  GridLayer.prototype.setCoordinates = function(show) {\n    this.coordinates = show;\n  };\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Get all has nothing to return\n   */\n  GridLayer.prototype.getAll = function() {\n    return null;\n  };\n\n  /**\n   * Set all has nothing to set\n   */\n  GridLayer.prototype.setAll = function(/*grid*/) {\n    return;\n  };\n\n  /**\n   * Remove all has nothing to remove\n   */\n  GridLayer.prototype.removeAll = function() {\n    return;\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw method\n   */\n  GridLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Determine top x and y margin\n    var tx = this.board.drawMarginHor;\n    var ty = this.board.drawMarginVer;\n\n    //Get theme properties\n    var cellSize = this.board.getCellSize();\n    var lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\n    var lineCap = this.board.theme.get('grid.lineCap');\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', cellSize);\n    var starColor = this.board.theme.get('grid.star.color');\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n    this.context.strokeStyle = strokeStyle;\n\n    //Helper vars\n    var i, x, y;\n\n    //Draw vertical lines\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\n      x = this.board.getAbsX(i);\n      this.context.moveTo(x, ty);\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\n    }\n\n    //Draw horizontal lines\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\n      y = this.board.getAbsY(i);\n      this.context.moveTo(tx, y);\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\n    }\n\n    //Draw grid lines\n    this.context.stroke();\n\n    //Star points defined?\n    for (i = 0; i < starPoints.length; i++) {\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n\n    //Draw coordinates\n    if (this.coordinates) {\n      Coordinates.draw.call(this);\n    }\n  };\n\n  /**\n   * Clear a square cell area on the grid\n   */\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Clear rectangle\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Redraw a square cell area on the grid\n   */\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', s);\n    var starColor = this.board.theme.get('grid.star.color');\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n\n    //Determine draw coordinates\n    var x1 = (gridX === 0) ? x : x - r;\n    var x2 = (gridX === this.board.width - 1) ? x : x + r;\n    var y1 = (gridY === 0) ? y : y - r;\n    var y2 = (gridY === this.board.height - 1) ? y : y + r;\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Patch up grid lines\n    this.context.moveTo(x1, y);\n    this.context.lineTo(x2, y);\n    this.context.moveTo(x, y1);\n    this.context.lineTo(x, y2);\n    this.context.stroke();\n\n    //Check if we need to draw a star point here\n    for (var i in starPoints) {\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\n      }\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  //Return\n  return GridLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('HoverLayer', ['BoardLayer', 'Markup', 'StoneFaded', function(BoardLayer, Markup, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var HoverLayer = function(board, context) {\n\n    //Container for items to restore\n    this.restore = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add hover item\n   */\n  HoverLayer.prototype.add = function(x, y, hover) {\n\n    //Validate coordinates\n    if (!this.grid.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Remove any previous item at this position\n    this.remove(x, y);\n\n    //Create hover object\n    hover.object = {\n      x: x,\n      y: y\n    };\n\n    //Stones\n    if (hover.type === 'stones') {\n      hover.objectClass = StoneFaded;\n      hover.object.color = hover.value;\n    }\n\n    //Markup\n    else if (hover.type === 'markup') {\n      hover.objectClass = Markup;\n      if (typeof hover.value === 'object') {\n        hover.object = angular.extend(hover.object, hover.value);\n      }\n      else {\n        hover.object.type = hover.value;\n      }\n    }\n\n    //Unknown\n    else {\n      console.warn('Unknown hover type', hover.type);\n      return;\n    }\n\n    //Check if we need to hide something on layers underneath\n    if (this.board.has(hover.type, x, y)) {\n      this.restore.push({\n        x: x,\n        y: y,\n        layer: hover.type,\n        value: this.board.get(hover.type, x, y)\n      });\n      this.board.remove(hover.type, x, y);\n    }\n\n    //Add to stack\n    this.grid.set(x, y, hover);\n\n    //Draw item\n    if (hover.objectClass && hover.objectClass.draw) {\n      hover.objectClass.draw.call(this, hover.object);\n    }\n  };\n\n  /**\n   * Remove the hover object\n   */\n  HoverLayer.prototype.remove = function(x, y) {\n\n    //Validate coordinates\n    if (!this.grid.has(x, y)) {\n      return;\n    }\n\n    //Get object and clear it\n    var hover = this.grid.get(x, y);\n    if (hover.objectClass && hover.objectClass.clear) {\n      hover.objectClass.clear.call(this, hover.object);\n    }\n\n    //Other objects to restore?\n    for (var i = 0; i < this.restore.length; i++) {\n      if (this.restore[i].x === x && this.restore[i].y === y) {\n        this.board.add(\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n        );\n        this.restore.splice(i, 1);\n      }\n    }\n  };\n\n  /**\n   * Remove all hover objects\n   */\n  HoverLayer.prototype.removeAll = function() {\n\n    //Anything to do?\n    if (this.grid.isEmpty()) {\n      return;\n    }\n\n    //Get all item as objects\n    var i;\n    var hover = this.grid.all('layer');\n\n    //Clear them\n    for (i = 0; i < hover.length; i++) {\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\n        hover[i].objectClass.clear.call(this, hover[i].object);\n      }\n    }\n\n    //Clear layer and empty grid\n    this.clear();\n    this.grid.empty();\n\n    //Restore objects on other layers\n    for (i = 0; i < this.restore.length; i++) {\n      this.board.add(\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n      );\n    }\n\n    //Clear restore array\n    this.restore = [];\n  };\n\n  /**\n   * Draw layer\n   */\n  HoverLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Loop objects and clear them\n    var hover = this.grid.all('hover');\n    for (var i = 0; i < hover.length; i++) {\n      if (hover.objectClass && hover.objectClass.draw) {\n        hover.objectClass.draw.call(this, hover.object);\n      }\n    }\n  };\n\n  //Return\n  return HoverLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('MarkupLayer', ['BoardLayer', 'Markup', function(BoardLayer, Markup) {\n\n  /**\n   * Constructor\n   */\n  var MarkupLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all markup at once\n   */\n  MarkupLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'type');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Markup.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Markup.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  MarkupLayer.prototype.removeAll = function() {\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Clear them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.clear.call(this, markup[i]);\n    }\n\n    //Empty the grid now\n    this.grid.empty();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  MarkupLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Draw them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.draw.call(this, markup[i]);\n    }\n  };\n\n  /**\n   * Draw cell\n   */\n  MarkupLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  MarkupLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  //Return\n  return MarkupLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ScoreLayer', ['BoardLayer', 'StoneMini', 'StoneFaded', function(BoardLayer, StoneMini, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var ScoreLayer = function(board, context) {\n\n    //Points and captures\n    this.points = [];\n    this.captures = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set points and captures\n   */\n  ScoreLayer.prototype.setAll = function(points, captures) {\n\n    //Remove all existing stuff first\n    this.removeAll();\n\n    //Set new stuff\n    this.points = points.all('color');\n    this.captures = captures.all('color');\n\n    //Draw\n    this.draw();\n  };\n\n  /**\n   * Remove all scoring\n   */\n  ScoreLayer.prototype.removeAll = function() {\n\n    //If there are captures, draw them back onto the stones layer\n    for (var i = 0; i < this.captures.length; i++) {\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\n    }\n\n    //Clear the layer\n    this.clear();\n\n    //Remove all stuff\n    this.points = [];\n    this.captures = [];\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  ScoreLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Init\n    var i;\n\n    //Draw captures first (removing stones from the stones layer)\n    for (i = 0; i < this.captures.length; i++) {\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\n      StoneFaded.draw.call(this, this.captures[i]);\n    }\n\n    //Draw points on top of it\n    for (i = 0; i < this.points.length; i++) {\n      StoneMini.draw.call(this, this.points[i]);\n    }\n  };\n\n  //Return\n  return ScoreLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneShadow.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ShadowLayer', ['BoardLayer', 'StoneShadow', function(BoardLayer, StoneShadow) {\n\n  /**\n   * Constructor\n   */\n  var ShadowLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add a stone\n   */\n  ShadowLayer.prototype.add = function(stone) {\n\n    //Don't add if no shadow\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\n      return;\n    }\n\n    //Already have a stone here?\n    if (this.grid.has(stone.x, stone.y)) {\n      return;\n    }\n\n    //Add to grid\n    this.grid.set(stone.x, stone.y, stone.color);\n\n    //Draw it if there is a context\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\n      StoneShadow.draw.call(this, stone);\n    }\n  };\n\n  /**\n   * Remove a stone\n   */\n  ShadowLayer.prototype.remove = function(stone) {\n\n    //Remove from grid\n    this.grid.unset(stone.x, stone.y);\n\n    //Redraw whole layer\n    this.redraw();\n  };\n\n  /**\n   * Draw layer\n   */\n  ShadowLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get shadowsize from theme\n    var shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\n\n    //Apply shadow transformation\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      StoneShadow.draw.call(this, stones[i]);\n    }\n  };\n\n  //Return\n  return ShadowLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StonesLayer', ['BoardLayer', 'Stone', 'StoneColor', function(BoardLayer, Stone, StoneColor) {\n\n  /**\n   * Constructor\n   */\n  var StonesLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n\n    //Set empty value for grid\n    this.grid.whenEmpty(StoneColor.EMPTY);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all stones at once\n   */\n  StonesLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'color');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Stone.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Stone.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  StonesLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      Stone.draw.call(this, stones[i]);\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  StonesLayer.prototype.redraw = function() {\n\n    //Clear shadows layer\n    this.board.removeAll('shadow');\n\n    //Redraw ourselves\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  StonesLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  StonesLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  //Return\n  return StonesLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Coordinates :: This class is used for drawing board coordinates\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Coordinates.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('Coordinates', function() {\n\n  //Kanji\n  var kanji = [\n    '一', '二', '三', '四', '五', '六', '七', '八', '九', '十',\n    '十一', '十二', '十三', '十四', '十五', '十六', '十七', '十八', '十九', '二十',\n    '二十一', '二十二', '二十三', '二十四', '二十五', '二十六', '二十七', '二十八', '二十九', '三十',\n    '三十一', '三十二', '三十三', '三十四', '三十五', '三十六', '三十七', '三十八', '三十九', '四十'\n  ];\n\n  //Character codes\n  var aChar = 'A'.charCodeAt(0);\n  var aCharLc = 'a'.charCodeAt(0);\n\n  /**\n   * Coordinate generators\n   */\n  var coordinates = {\n\n    //Kanji coordinates\n    kanji: function(i) {\n      return kanji[i] || '';\n    },\n\n    //Numbers from 1\n    numbers: function(i) {\n      return i + 1;\n    },\n\n    //Capital letters from A\n    letters: function(i) {\n\n      //Initialize\n      var ch = '';\n\n      //Beyond Z? Prepend with A\n      if (i >= 25) {\n        ch = 'A';\n        i -= 25;\n      }\n\n      //The letter I is ommitted\n      if (i >= 8) {\n        i++;\n      }\n\n      //Return\n      return ch + String.fromCharCode(aChar + i);\n    },\n\n    //JGF coordinates (e.g. 0, 1, ...)\n    jgf: function(i) {\n      return i;\n    },\n\n    //SGF coordinates (e.g. a, b, ...)\n    sgf: function(i) {\n      var ch;\n      if (i < 26) {\n        ch = aCharLc + i;\n      }\n      else {\n        ch = aChar + i;\n      }\n      return String.fromCharCode(ch);\n    }\n  };\n\n  /**\n   * Coordinates object\n   */\n  var Coordinates = {\n\n    /**\n     * Draw\n     */\n    draw: function() {\n\n      //Can only draw when we have context and dimensions\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Get cell size\n      var cellSize = this.board.getCellSize();\n\n      //Get boundary coordinates\n      var xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\n      var xr = this.board.drawWidth - xl;\n      var yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\n      var yb = this.board.drawHeight - yt;\n\n      //Get theme properties\n      var fillStyle = this.board.theme.get('coordinates.color');\n      var vertical = {\n        font: this.board.theme.get('coordinates.vertical.font'),\n        size: this.board.theme.get('coordinates.vertical.size'),\n        style: this.board.theme.get('coordinates.vertical.style'),\n        inverse: this.board.theme.get('coordinates.vertical.inverse')\n      };\n      var horizontal = {\n        font: this.board.theme.get('coordinates.horizontal.font'),\n        size: this.board.theme.get('coordinates.horizontal.size'),\n        style: this.board.theme.get('coordinates.horizontal.style'),\n        inverse: this.board.theme.get('coordinates.horizontal.inverse')\n      };\n\n      //Configure context\n      this.context.fillStyle = fillStyle;\n      this.context.textBaseline = 'middle';\n      this.context.textAlign = 'center';\n\n      //Helper vars\n      var i, j, x, y, ch;\n\n      //Draw vertical coordinates\n      for (i = 0; i < this.board.height; i++) {\n\n        //Inverse?\n        j = i;\n        if (vertical.inverse) {\n          j = this.board.height - i - 1;\n        }\n\n        //Get character\n        if (typeof vertical.style === 'function') {\n          ch = vertical.style.call(this, j);\n        }\n        else if (coordinates[vertical.style]) {\n          ch = coordinates[vertical.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        y = this.board.getAbsY(i);\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\n        this.context.fillText(ch, xl, y);\n        this.context.fillText(ch, xr, y);\n      }\n\n      //Draw horizontal coordinates\n      for (i = 0; i < this.board.width; i++) {\n\n        //Inverse?\n        j = i;\n        if (horizontal.inverse) {\n          j = this.board.width - i - 1;\n        }\n\n        //Get character\n        if (typeof horizontal.style === 'function') {\n          ch = horizontal.style.call(this, j);\n        }\n        else if (coordinates[horizontal.style]) {\n          ch = coordinates[horizontal.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        x = this.board.getAbsX(i);\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\n        this.context.fillText(ch, x, yt);\n        this.context.fillText(ch, x, yb);\n      }\n    }\n  };\n\n  //Return\n  return Coordinates;\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Markup :: This class is used for drawing markup\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Markup.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Markup', ['MarkupTypes', 'BoardObject', function(MarkupTypes, BoardObject) {\n\n  /**\n   * Math constants\n   */\n  var cosPi4 = Math.cos(Math.PI / 4);\n  var cosPi6 = Math.cos(Math.PI / 6);\n\n  /**\n   * Triangle draw handler\n   */\n  var drawTriangle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y - r);\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.closePath();\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Square draw handler\n   */\n  var drawSquare = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw circle handler\n   */\n  var drawCircle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw mark handler\n   */\n  var drawMark = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x - rcos, y - rcos);\n    this.context.lineTo(x + rcos, y + rcos);\n    this.context.moveTo(x + rcos, y - rcos);\n    this.context.lineTo(x - rcos, y + rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw select handler\n   */\n  var drawSelect = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Last move draw handler\n   */\n  var drawLast = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(s);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y);\n    this.context.lineTo(x + r, y);\n    this.context.lineTo(x, y + r);\n    this.context.closePath();\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw happy smiley handler\n   */\n  var drawHappySmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 8);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw sad smiley handler\n   */\n  var drawSadSmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw label\n   */\n  var drawLabel = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var font = markup.font || this.board.theme.get('markup.label.font') || '';\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //First, clear grid square below for clarity\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.clearCell(markup.x, markup.y);\n    }\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.textBaseline = 'middle';\n    this.context.textAlign = 'center';\n\n    //Convert to text\n    if (typeof markup.text === 'number') {\n      markup.text = markup.text.toString();\n    }\n\n    //Determine font size\n    if (markup.text.length === 1) {\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\n    }\n    else if (markup.text.length === 2) {\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\n    }\n    else {\n      this.context.font = r + 'px ' + font;\n    }\n\n    //Draw element\n    this.context.beginPath();\n    this.context.fillText(markup.text, x, y, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Clear label\n   */\n  var clearLabel = function(markup) {\n\n    //No stone on location? Redraw the grid square, if we cleared it\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\n    }\n  };\n\n  /**\n   * Markup class\n   */\n  var Markup = {\n\n    /**\n     * Draw\n     */\n    draw: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Drawing depends on type\n      switch (markup.type) {\n\n        //Triangle\n        case MarkupTypes.TRIANGLE:\n          drawTriangle.call(this, markup);\n          break;\n\n        //Square\n        case MarkupTypes.SQUARE:\n          drawSquare.call(this, markup);\n          break;\n\n        //Circle\n        case MarkupTypes.CIRCLE:\n          drawCircle.call(this, markup);\n          break;\n\n        //Mark\n        case MarkupTypes.MARK:\n          drawMark.call(this, markup);\n          break;\n\n        //Select\n        case MarkupTypes.SELECT:\n          drawSelect.call(this, markup);\n          break;\n\n        //happy\n        case MarkupTypes.HAPPY:\n          drawHappySmiley.call(this, markup);\n          break;\n\n        //Sad\n        case MarkupTypes.SAD:\n          drawSadSmiley.call(this, markup);\n          break;\n\n        //Last move marker\n        case MarkupTypes.LAST:\n          drawLast.call(this, markup);\n          break;\n\n        //Label\n        case MarkupTypes.LABEL:\n          markup.text = markup.text || '';\n          drawLabel.call(this, markup);\n          break;\n      }\n    },\n\n    /**\n     * Clear\n     */\n    clear: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, markup);\n\n      //Special handling for label\n      if (markup.type === MarkupTypes.LABEL) {\n        clearLabel.call(this, markup);\n      }\n    }\n  };\n\n  //Return\n  return Markup;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Stone :: This class is used for drawing stones on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Stone.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n  'ngGo.Board.ShellPattern.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Stone', ['$injector', 'BoardObject', 'StoneColor', 'ShellPattern', function($injector, BoardObject, StoneColor, ShellPattern) {\n\n  /**\n   * Shell random seed\n   */\n  var shellSeed;\n\n  /**\n   * Mono colored stones\n   */\n  var drawMono = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Don't draw shadow\n    stone.shadow = false;\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\n    var fillStyle = this.board.theme.get('stone.mono.color', color);\n    var strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Configure context\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Draw outline\n    this.context.stroke();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Glass stones\n   */\n  var drawGlass = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Begin path\n    this.context.beginPath();\n\n    //Determine stone texture\n    if (color === StoneColor.W) {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#fff');\n      this.context.fillStyle.addColorStop(1, '#aaa');\n    }\n    else {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#666');\n      this.context.fillStyle.addColorStop(1, '#111');\n    }\n\n    //Complete drawing\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Slate and shell stones\n   */\n  var drawSlateShell = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Get random seed\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var shellTypes = this.board.theme.get('stone.shell.types');\n    var fillStyle = this.board.theme.get('stone.shell.color', color);\n    var strokeStyle = this.board.theme.get('stone.shell.stroke');\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fillStyle = fillStyle;\n    this.context.fill();\n\n    //Shell stones\n    if (color === StoneColor.W) {\n\n      //Get random shell type\n      var type =\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\n\n      //Determine random angle\n      var z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\n      var angle = (2 / z) * (shellSeed % z);\n\n      //Draw shell pattern\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Slate stones\n    else {\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Constructor\n   */\n  var Stone = {\n\n    /**\n     * Draw a stone\n     */\n    draw: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Determine style of stone\n      var style = this.board.theme.get('stone.style');\n\n      //Draw using the appropriate handler\n      switch (style) {\n\n        //Slate and shell\n        case 'shell':\n          drawSlateShell.call(this, stone);\n          break;\n\n        //Glass stones\n        case 'glass':\n          drawGlass.call(this, stone);\n          break;\n\n        //Mono stones\n        case 'mono':\n          drawMono.call(this, stone);\n          break;\n\n        //Custom type\n        default:\n          var handler = $injector.get(style);\n          if (handler) {\n            handler.call(this, stone);\n          }\n      }\n\n      //Add shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.add(stone);\n      }\n    },\n\n    /**\n     * Clear a stone\n     */\n    clear: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, stone);\n\n      //Remove shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.remove(stone);\n      }\n    }\n  };\n\n  //Return\n  return Stone;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneFaded', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneFaded = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.faded.scale');\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneFaded;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\n * (for scoring).\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneMini.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneMini', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneMini = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.mini.scale');\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneMini;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneShadow :: This class is used for drawing stone shadows on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneShadow', function() {\n\n  /**\n   * Constructor\n   */\n  var StoneShadow = {\n\n    /**\n     * Draw a stone shadow\n     */\n    draw: function(stone) {\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\n\n      //Apply scaling factor?\n      if (stone.scale) {\n        r = Math.round(r * stone.scale);\n      }\n\n      //Get theme properties\n      var blur = this.board.theme.get('shadow.blur', s);\n      var offsetX = this.board.theme.get('shadow.offsetX', s);\n      var offsetY = this.board.theme.get('shadow.offsetY', s);\n      var shadowColor = this.board.theme.get('shadow.color');\n\n      //Configure context\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\n      );\n      this.context.fillStyle.addColorStop(0, shadowColor);\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n\n      //Draw shadow\n      this.context.beginPath();\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\n      this.context.fill();\n    },\n\n    /**\n     * Clear a stone shadow\n     */\n    clear: function(stone) {\n\n      //Note: this method is currently not in use due to the overlapping shadows\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\n      //appropriate either, so for now we will leave it at this.\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = this.board.theme.get('stone.radius', s);\n\n      //Clear a generous rectangle\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\n    }\n  };\n\n  //Return\n  return StoneShadow;\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeCommon :: This class governs common event handling of the player shared by\n * various player modes. It's basically an abstract player mode and it can't be actively set.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Common.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Run block\n */\n.run(['Player', 'PlayerModes', 'PlayerModeCommon', function(Player, PlayerModes, PlayerModeCommon) {\n\n  /**\n   * Register common event handlers\n   */\n  Player.on('keydown', PlayerModeCommon.keyDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n}])\n\n/**\n * Factory definition\n */\n.factory('PlayerModeCommon', ['Player', 'PlayerTools', 'GameScorer', 'KeyCodes', function(Player, PlayerTools, GameScorer, KeyCodes) {\n\n  /**\n   * Helper to build drag object\n   */\n  var dragObject = function(event) {\n\n    //Initialize drag object\n    var drag = {\n      start: {\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y\n      },\n      stop: {\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y\n      }\n    };\n\n    //Fix boundaries\n    if (drag.start.x < 0) {\n      drag.start.x = 0;\n    }\n    if (drag.start.y < 0) {\n      drag.start.y = 0;\n    }\n    if (drag.stop.x > this.board.width - 1) {\n      drag.stop.x = this.board.width - 1;\n    }\n    if (drag.stop.y > this.board.height - 1) {\n      drag.stop.y = this.board.height - 1;\n    }\n\n    //Return\n    return drag;\n  };\n\n  /**\n   * Normalize the mousewheel event helper\n   */\n  function normalizeMousewheelEvent(event) {\n\n    //Initialize vars\n    var deltaX = 0;\n    var deltaY = 0;\n\n    //Old school scrollwheel delta\n    if ('detail' in event) {\n      deltaY = event.detail * -1;\n    }\n    if ('wheelDelta' in event) {\n      deltaY = event.wheelDelta;\n    }\n    if ('wheelDeltaY' in event) {\n      deltaY = event.wheelDeltaY;\n    }\n    if ('wheelDeltaX' in event) {\n      deltaX = event.wheelDeltaX * -1;\n    }\n\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\n      deltaX = deltaY * -1;\n      deltaY = 0;\n    }\n\n    //New type wheel delta (WheelEvent)\n    if ('deltaY' in event) {\n      deltaY = event.deltaY * -1;\n    }\n    if ('deltaX' in event) {\n      deltaX = event.deltaX;\n    }\n\n    //Set in event (have to use different property name because of strict mode)\n    event.mouseWheelX = deltaX;\n    event.mouseWheelY = deltaY;\n\n    //Return\n    return event;\n  }\n\n  /**\n   * Player extension\n   */\n  angular.extend(Player, {\n\n    /**\n     * Mouse coordinate helper vars\n     */\n    mouse: {\n\n      //Drag start\n      dragStart: null,\n\n      //Last grid coordinates\n      lastX: -1,\n      lastY: -1\n    }\n  });\n\n  /**\n   * Player mode definition\n   */\n  var PlayerMode = {\n\n    /**\n     * Handler for keydown events\n     */\n    keyDown: function(event, keyboardEvent) {\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Switch key code\n      switch (keyboardEvent.keyCode) {\n\n        //ESC\n        case KeyCodes.ESC:\n\n          //Cancel drag event, and prevent click event as well\n          this.mouse.dragStart = null;\n          this.preventClickEvent = true;\n          break;\n\n        //Right arrow\n        case KeyCodes.RIGHT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Advance to the next move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\n              this.next();\n            }\n          }\n          break;\n\n        //Left arrow\n        case KeyCodes.LEFT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Go to the previous move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\n              this.previous();\n            }\n          }\n          break;\n\n        //Up arrow\n        case KeyCodes.UP:\n          break;\n\n        //Down arrow\n        case KeyCodes.DOWN:\n          break;\n      }\n    },\n\n    /**\n     * Handler for mousewheel events\n     */\n    mouseWheel: function(event, mouseEvent) {\n\n      //Disabled or not using move tool?\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\n        return true;\n      }\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return true;\n      }\n\n      //Normalize mousewheel event\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\n\n      //Find delta\n      var delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\n\n      //Next move\n      if (delta < 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.next();\n      }\n\n      //Previous move\n      else if (delta > 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.previous();\n      }\n\n      //Don't scroll the window\n      if (delta !== 0) {\n        mouseEvent.preventDefault();\n      }\n    },\n\n    /**\n     * Mouse out handler\n     */\n    mouseOut: function() {\n      if (this.board) {\n        this.board.removeAll('hover');\n      }\n    },\n\n    /**\n     * Mouse move handler\n     */\n    mouseMove: function(event, mouseEvent) {\n\n      //Attach drag object to events\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n      }\n\n      //Nothing else to do?\n      if (!this.board || !this.board.layers.hover) {\n        return;\n      }\n\n      //Last coordinates are the same?\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\n        return;\n      }\n\n      //Remember last coordinates\n      this.mouse.lastX = event.x;\n      this.mouse.lastY = event.y;\n\n      //Broadcast hover event\n      this.broadcast('hover', mouseEvent);\n    },\n\n    /**\n     * Mouse down handler\n     */\n    mouseDown: function(event) {\n      this.mouse.dragStart = {\n        x: event.x,\n        y: event.y\n      };\n    },\n\n    /**\n     * Mouse up handler\n     */\n    mouseUp: function(event, mouseEvent) {\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n        this.broadcast('mousedrag', mouseEvent);\n      }\n      this.mouse.dragStart = null;\n    }\n  };\n\n  //Return\n  return PlayerMode;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\n * a game record and its board positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Edit.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Setup tools\n */\n.constant('SetupTools', {\n  BLACK: 'black',\n  WHITE: 'white',\n  CLEAR: 'clear'\n})\n\n/**\n * Markup tools\n */\n.constant('MarkupTools', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  SAD: 'sad',\n  HAPPY: 'happy',\n  TEXT: 'text',\n  NUMBER: 'number',\n  CLEAR: 'clear'\n})\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeEdit', function(Player, PlayerModes, PlayerModeEdit) {\n\n  //Register event handlers\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\n\n  //Register mode\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeEdit', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['Player', 'PlayerTools', 'SetupTools', 'MarkupTools', 'MarkupTypes', 'GameScorer', 'StoneColor', function(\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\n  ) {\n\n    //Character codes\n    var aChar = 'A'.charCodeAt(0);\n    var aCharLc = 'a'.charCodeAt(0);\n\n    /**\n     * Update hover mark at specific coordinates\n     */\n    var updateHoverMark = function(x, y, isDrag) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Setup tool\n        case PlayerTools.SETUP:\n\n          //Clear tool\n          if (this.setupTool === SetupTools.CLEAR) {\n\n            //Stone present? Can remove it\n            if (this.game.hasStone(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Stone color tool\n          else {\n\n            //Add or overwrite stone if no stone present of the given color\n            if (!this.game.hasStone(x, y, this.setupToolColor())) {\n              this.board.add('hover', x, y, {\n                type: 'stones',\n                value: this.setupToolColor()\n              });\n            }\n\n            //Stone present of same color? Can remove it if we're not dragging\n            else if (!isDrag) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n          break;\n\n        //Markup tool\n        case PlayerTools.MARKUP:\n\n          //Clear tool, or already markup in place?\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\n            if (this.game.hasMarkup(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Text or number\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: {\n                type: MarkupTypes.LABEL,\n                text: this.markupLabel\n              }\n            });\n          }\n\n          //Other markup\n          else {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: this.markupTool\n            });\n          }\n          break;\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to set markup\n     */\n    var setMarkup = function(x, y) {\n\n      //Already markup in place? Remove it first\n      if (this.game.hasMarkup(x, y)) {\n\n        //Check what markup there is\n        var markup = this.game.getMarkup(x, y);\n\n        //Label? Also remove from our labels list\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\n          var i = this.markupLabels.indexOf(markup.text);\n          if (i !== -1) {\n            this.markupLabels.splice(i, 1);\n          }\n        }\n\n        //Remove from game\n        this.game.removeMarkup(x, y);\n        return;\n      }\n\n      //Clear tool used? Done\n      if (this.markupTool === MarkupTools.CLEAR) {\n        return;\n      }\n\n      //Text\n      else if (this.markupTool === MarkupTools.TEXT) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next text label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Number\n      else if (this.markupTool === MarkupTools.NUMBER) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next number label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Other markup\n      else {\n        this.game.addMarkup(x, y, this.markupTool);\n      }\n    };\n\n    /**\n     * Helper to set a stone\n     */\n    var setStone = function(x, y, isDrag) {\n\n      //Get the stone color\n      var color = this.setupToolColor();\n\n      //Trying to remove a stone\n      if (color === StoneColor.EMPTY) {\n        this.game.removeStone(x, y);\n      }\n\n      //Adding a stone\n      else {\n\n        //A stone there already of the same color? Just remove if not dragging\n        if (!isDrag && this.game.hasStone(x, y, color)) {\n          this.game.removeStone(x, y);\n          return;\n        }\n\n        //Any stone present?\n        else if (this.game.hasStone(x, y)) {\n          this.game.removeStone(x, y);\n        }\n\n        //Add stone now\n        this.game.addStone(x, y, color);\n      }\n\n      //Redraw markup\n      this.board.layers.markup.redrawCell(x, y);\n    };\n\n    /**\n     * Find all markup labels in current position\n     */\n    var findAllMarkupLabels = function() {\n\n      //Clear\n      this.markupLabels = [];\n\n      //Must have game\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get all markup from position\n      var markup = this.game.position.markup.all('type');\n      for (var i = 0; i < markup.length; i++) {\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\n          this.markupLabels.push(markup[i].text);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Active setup tool and markup tool\n      setupTool: SetupTools.BLACK,\n      markupTool: MarkupTools.TRIANGLE,\n\n      //Current markup labels on the board and current markup label\n      markupLabels: [],\n      markupLabel: '',\n\n      /**\n       * Set the setup tool\n       */\n      switchSetupTool: function(tool) {\n        this.setupTool = tool;\n      },\n\n      /**\n       * Set the markup tool\n       */\n      switchMarkupTool: function(tool) {\n        this.markupTool = tool;\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          this.determineMarkupLabel();\n        }\n      },\n\n      /**\n       * Conversion of setup tool to stone color\n       */\n      setupToolColor: function() {\n        switch (this.setupTool) {\n          case SetupTools.BLACK:\n            return StoneColor.B;\n          case SetupTools.WHITE:\n            return StoneColor.W;\n          default:\n            return StoneColor.EMPTY;\n        }\n      },\n\n      /**\n       * Set the new text markup label\n       */\n      setMarkupLabel: function(label) {\n        if (label) {\n          this.markupLabel = label;\n        }\n      },\n\n      /**\n       * Determine the new text markup label\n       */\n      determineMarkupLabel: function() {\n\n        //Clear\n        this.markupLabel = '';\n\n        //Check what tool we're using\n        switch (this.markupTool) {\n\n          //Text tool?\n          case MarkupTools.TEXT:\n            var i = 0;\n\n            //Loop while the label is present\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n\n              //A-Z\n              if (i < 26) {\n                this.markupLabel = String.fromCharCode(aChar + i);\n              }\n\n              //a-z\n              else if (i < 52) {\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\n              }\n\n              //AA, AB, AC, etc.\n              else {\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\n                  String.fromCharCode(aChar + (i % 26));\n              }\n\n              //Keep going\n              i++;\n            }\n            break;\n\n          //Number tool?\n          case MarkupTools.NUMBER:\n            this.markupLabel = 0;\n\n            //Loop while the label is present\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n              this.markupLabel++;\n            }\n            break;\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeEdit = {\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Remove all hover items\n        this.board.removeAll('hover');\n\n        //Single coordinate?\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //No dragging for labels\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //Loop area\n        for (var x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n          for (var y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n            updateHoverMark.call(this, x, y, true);\n          }\n        }\n      },\n\n      /**\n       * Keydown handler\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //TODO: tool switching via keyboard input\n        }\n      },\n\n      /**\n       * Click handler\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        this.board.removeAll('hover');\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Try to play the move\n            if (!this.game.play(event.x, event.y)) {\n              return;\n            }\n            this.processPosition();\n            break;\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Set stone and update board\n            setStone.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Set markup and update board\n            setMarkup.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Mouse drag handler\n       */\n      mouseDrag: function(event) {\n\n        //Initialize vars\n        var x, y;\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setStone.call(this, x, y, true);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Don't do this for labels\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n              break;\n            }\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setMarkup.call(this, x, y);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Path change\n       */\n      pathChange: function() {\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SETUP,\n          PlayerTools.MARKUP,\n          PlayerTools.SCORE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Find all markup labels in the current game position\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeEdit;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\n * through an existing game record without the ability to deviate from the tree or its variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Replay.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeReplay', function(Player, PlayerModes, PlayerModeReplay) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\n\n  //Register the mode\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeReplay', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Auto play delay\n    autoPlayDelay: 1000\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$interval', 'Player', 'PlayerModes', 'PlayerTools', 'MarkupTypes', 'GameScorer', function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show move variations on the board\n     */\n    var showMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n\n        //Auto variation markup should never overwrite existing markup\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\n          continue;\n        }\n\n        //Add to board\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n          type: this.board.theme.get('markup.variation.type'),\n          text: this.board.theme.get('markup.variation.text', i),\n          color: this.board.theme.get('markup.variation.color')\n        });\n      }\n    };\n\n    /**\n     * Helper to hide move variations from the board\n     */\n    var hideMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) move variations on the board\n     */\n    var drawMoveVariations = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get the current node\n      var node = this.game.getNode();\n      var variations;\n      if (!node) {\n        return;\n      }\n\n      //Child variations?\n      if (this.variationChildren && node.hasMoveVariations()) {\n        variations = node.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n\n      //Sibling variations?\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\n        variations = node.parent.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Auto play vars\n      autoPlaying: false,\n      autoPlayDelay: 1000,\n      autoPlayPromise: null,\n\n      /**\n       * Set auto play delay\n       */\n      setAutoPlayDelay: function(delay) {\n        if (this.autoPlayDelay !== delay) {\n          this.autoPlayDelay = delay;\n          this.broadcast('settingChange', 'autoPlayDelay');\n        }\n      },\n\n      /**\n       * Start auto play with a given delay\n       */\n      start: function(delay) {\n\n        //Not in replay mode or already auto playing?\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\n          return;\n        }\n\n        //Already auto playing, no game or no move children?\n        if (!this.game || !this.game.node.hasChildren()) {\n          return;\n        }\n\n        //Get self\n        var self = this;\n\n        //Determine delay\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\n\n        //Switch tool\n        this.switchTool(PlayerTools.NONE);\n\n        //Create interval\n        this.autoPlaying = true;\n        this.autoPlayPromise = $interval(function() {\n\n          //Advance to the next node\n          self.next(0, true);\n\n          //Ran out of children?\n          if (!self.game.node.hasChildren()) {\n            self.stop();\n          }\n        }, delay);\n\n        //Broadcast event\n        this.broadcast('autoPlayStarted', this.game.node);\n      },\n\n      /**\n       * Stop auto play\n       */\n      stop: function() {\n\n        //Not in replay mode or not auto playing?\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\n          return;\n        }\n\n        //Cancel interval\n        if (this.autoPlayPromise) {\n          $interval.cancel(this.autoPlayPromise);\n        }\n\n        //Clear flags\n        this.autoPlayPromise = null;\n        this.autoPlaying = false;\n\n        //Broadcast event\n        this.broadcast('autoPlayStopped', this.game.node);\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeReplay = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.setAutoPlayDelay(this.config.autoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'variationMarkup') {\n          drawMoveVariations.call(this, this.variationMarkup);\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Check if we clicked a move variation, advance to the next position if so\n            if (this.game.isMoveVariation(event.x, event.y)) {\n              this.next(this.game.getMoveVariation(event.x, event.y));\n            }\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeReplay.hover.call(this, event);\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SCORE,\n          PlayerTools.NONE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Stop auto playing\n        if (this.autoPlaying) {\n          this.stop();\n        }\n\n        //Hide move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, false);\n        }\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeReplay;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\n * go problems and finding the right move or variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Solve.Service', [\n  'ngGo'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeSolve', function(Player, PlayerModes, PlayerModeSolve) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\n\n  //Register mode\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeSolve', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Player color\n    playerColor: StoneColor.B,\n\n    //Show solution paths\n    solutionPaths: false,\n\n    //Auto play settings\n    solveAutoPlay: true,\n    solveAutoPlayDelay: 500\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$timeout', 'Player', 'PlayerModes', 'PlayerTools', 'KeyCodes', function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\n\n    /**\n     * Check if we can make a move\n     */\n    var canMakeMove = function() {\n\n      //We can make a move when...\n\n      //...there is no auto play going on\n      if (!this.solveAutoPlay) {\n        return true;\n      }\n\n      //...we solved the puzzle already\n      if (this.problemSolved) {\n        return true;\n      }\n\n      //...we are off path\n      if (this.problemOffPath) {\n        return true;\n      }\n\n      //...it's our turn\n      if (this.game.getTurn() === this.playerColor) {\n        return true;\n      }\n\n      //Otherwise, we can't make a move\n      return false;\n    };\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show solution paths\n     */\n    var showSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        if (variations[i].solution === true) {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.valid.type'),\n            text: this.board.theme.get('markup.solution.valid.text', i),\n            scale: this.board.theme.get('markup.solution.valid.scale'),\n            color: this.board.theme.get('markup.solution.valid.color')\n          });\n        }\n        else {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.invalid.type'),\n            text: this.board.theme.get('markup.solution.invalid.text', i),\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\n            color: this.board.theme.get('markup.solution.invalid.color')\n          });\n        }\n      }\n    };\n\n    /**\n     * Helper to hide solution paths\n     */\n    var hideSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) solution paths\n     */\n    var drawSolutionPaths = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get node and variations\n      var node = this.game.getNode();\n      var variations = node.getMoveVariations();\n\n      //When showing, make sure it's not during the auto solver's move\n      if (show && !this.problemSolved && this.solveAutoPlay) {\n        if (this.game.getTurn() !== this.playerColor) {\n          hideSolutionPaths.call(this, variations);\n          return;\n        }\n      }\n\n      //Call helper\n      if (show) {\n        showSolutionPaths.call(this, variations);\n      }\n      else {\n        hideSolutionPaths.call(this, variations);\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Solved and off-path flags\n      problemSolved: false,\n      problemOffPath: false,\n\n      //Problem start path\n      problemStartPath: null,\n\n      //The player color\n      playerColor: 0,\n\n      //Solution paths\n      solutionPaths: false,\n\n      //Auto play vars\n      solveAutoPlay: true,\n      solveAutoPlayDelay: 500,\n\n      //Navigation blocked flag\n      solveNavigationBlocked: false,\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlay: function(autoPlay) {\n        if (this.solveAutoPlay !== autoPlay) {\n          this.solveAutoPlay = autoPlay;\n          this.broadcast('settingChange', 'solveAutoPlay');\n        }\n      },\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlayDelay: function(delay) {\n        if (this.solveAutoPlayDelay !== delay) {\n          this.solveAutoPlayDelay = delay;\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\n        }\n      },\n\n      /**\n       * Set player color\n       */\n      setPlayerColor: function(color) {\n        if (this.playerColor !== color) {\n          this.playerColor = color;\n          this.broadcast('settingChange', 'playerColor');\n        }\n      },\n\n      /**\n       * Get player color\n       */\n      getPlayerColor: function(asOnBoard) {\n        if (asOnBoard && this.board) {\n          return this.board.colorMultiplier * this.playerColor;\n        }\n        return this.playerColor;\n      },\n\n      /**\n       * Toggle solution paths\n       */\n      toggleSolutionPaths: function(solutionPaths) {\n\n        //Toggle if not given\n        if (typeof solutionPaths === 'undefined') {\n          solutionPaths = !this.solutionPaths;\n        }\n\n        //Change?\n        if (solutionPaths !== this.solutionPaths) {\n          this.solutionPaths = solutionPaths;\n          this.broadcast('settingChange', 'solutionPaths');\n        }\n      },\n\n      /**\n       * Auto play next move\n       */\n      autoPlayNext: function(immediately) {\n\n        //Must have game and children\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\n          return;\n        }\n\n        //Init vars\n        var children = [];\n        var self = this;\n        var i;\n\n        //When picking a child node, we always prefer to pick a valid solution\n        for (i = 0; i < this.game.node.children.length; i++) {\n          if (this.game.node.children[i].solution) {\n            children.push(this.game.node.children[i]);\n          }\n        }\n\n        //No solution nodes? Just use all nodes then.\n        if (children.length === 0) {\n          children = this.game.node.children;\n        }\n\n        //Pick a random child node\n        i = Math.floor(Math.random() * children.length);\n\n        //No delay?\n        if (immediately || !this.solveAutoPlayDelay) {\n          this.next(children[i]);\n          return;\n        }\n\n        //Block navigation and run the timeout\n        this.solveNavigationBlocked = true;\n        $timeout(function() {\n\n          //Move to next move and unblock navigation\n          self.next(children[i]);\n          self.solveNavigationBlocked = false;\n\n        }, this.solveAutoPlayDelay);\n      },\n\n      /**\n       * Start solving from the current game node\n       */\n      solve: function() {\n\n        //Must have a game\n        if (!this.game || !this.game.isLoaded()) {\n          return false;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Remember problem start path\n        this.problemStartPath = this.game.getPath(true);\n\n        //Restrict start of navigation to the current node\n        this.restrictNode();\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      },\n\n      /**\n       * Restart the problem\n       */\n      restartProblem: function() {\n\n        //Must be in solve mode, must have game\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Go back to the start path\n        if (this.problemStartPath) {\n          this.goto(this.problemStartPath);\n        }\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeSolve = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.toggleSolutionPaths(this.config.solutionPaths);\n        this.setPlayerColor(this.config.playerColor);\n        this.setSolveAutoPlay(this.config.solveAutoPlay);\n        this.setSolveAutoPlayDelay(this.config.solveAutoPlayDelay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'solutionPaths') {\n          drawSolutionPaths.call(this, this.solutionPaths);\n        }\n\n        //Player color changed?\n        if (setting === 'playerColor') {\n\n          //Draw (or hide) solution paths\n          drawSolutionPaths.call(this, this.solutionPaths);\n\n          //Make an auto play move if it's not our turn\n          if (\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\n          ) {\n            this.autoPlayNext(true);\n          }\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this, event.x, event.y);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for keydown events\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //Right arrow\n          case KeyCodes.RIGHT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\n\n                //Go forward one move if solved\n                if (this.problemSolved) {\n                  this.next();\n                }\n              }\n            }\n            break;\n\n          //Left arrow\n          case KeyCodes.LEFT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked and not reached the start?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\n\n                //Go back one move\n                this.previous();\n\n                //Go back one more if this is not the player's turn and if\n                //the problem hasn't been solved yet\n                if (\n                  !this.problemSolved && this.solveAutoPlay &&\n                  this.game.getTurn() === -this.playerColor\n                ) {\n                  this.previous();\n                }\n              }\n            }\n            break;\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //A valid variation\n        if (this.game.isMoveVariation(event.x, event.y)) {\n\n          //Get the node\n          var i = this.game.getMoveVariation(event.x, event.y);\n\n          //Advance to the next position and get the next node\n          this.next(i);\n          var node = this.game.getNode();\n\n          //No children left? Check if we solved it or not\n          if (node.children.length === 0) {\n            if (node.solution === true) {\n              this.problemSolved = true;\n              this.broadcast('solutionFound', node);\n            }\n            else {\n              this.broadcast('solutionWrong', node);\n            }\n          }\n\n          //Auto-play next move?\n          else if (!this.problemSolved && this.solveAutoPlay) {\n            this.autoPlayNext();\n          }\n        }\n\n        //Unknown variation, try to play\n        else if (this.game.play(event.x, event.y)) {\n          this.problemOffPath = true;\n          this.processPosition();\n          this.broadcast('solutionOffPath', this.game.getNode());\n        }\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Draw solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Hide any solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, false);\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeSolve;\n  }];\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Gib2Jgf', ['ngGo', 'KifuBlank', function(ngGo, KifuBlank) {\n\n  /**\n   * Regular expressions\n   */\n  var regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\n  var regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\n  var regKomi = /GAMEGONGJE=([0-9]+)/gi;\n  var regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\n  var regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\n  var regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\n\n  /**\n   * Player parser function\n   */\n  var parsePlayer = function(jgf, match) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\n\n    //Create player object\n    var player = {\n      color: color,\n      name: match[2],\n      rank: match[3].toLowerCase()\n    };\n\n    //Check if player of this color already exists, if so, overwrite\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p] = player;\n        return;\n      }\n    }\n\n    //Player of this color not found, push\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, match) {\n    jgf.game.komi = parseFloat(match[1] / 10);\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, match) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Push date\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\n  };\n\n  /**\n   * Result parser function\n   */\n  var parseResult = function(jgf, match) {\n\n    //Winner color\n    var result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\n    result += '+';\n\n    //Win condition\n    if (match[2].match(/res/i)) {\n      result += 'R';\n    }\n    else if (match[2].match(/time/i)) {\n      result += 'T';\n    }\n    else {\n      result += match[2];\n    }\n\n    //Set in JGF\n    jgf.game.result = result;\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, match) {\n\n    //Determine player color\n    var color = match[2];\n    if (color === 1) {\n      color = 'B';\n    }\n    else if (color === 2) {\n      color = 'W';\n    }\n    else {\n      return;\n    }\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (false) {\n\n    }\n\n    //Regular move\n    else {\n      node.move[color] = [match[3] * 1, match[4] * 1];\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    parse: function(gib, stringified) {\n\n      //Get new JGF object\n      var jgf = KifuBlank.jgf();\n\n      //Initialize\n      var match;\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find player information\n      while ((match = regPlayer.exec(gib))) {\n        parsePlayer(jgf, match);\n      }\n\n      //Find komi\n      if ((match = regKomi.exec(gib))) {\n        parseKomi(jgf, match);\n      }\n\n      //Find game date\n      if ((match = regDate.exec(gib))) {\n        parseDate(jgf, match);\n      }\n\n      //Find game result\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\n        parseResult(jgf, match);\n      }\n\n      //Find moves\n      while ((match = regMove.exec(gib))) {\n\n        //Create new node\n        node = {};\n\n        //Parse move\n        parseMove(jgf, node, match);\n\n        //Push node to container\n        container.push(node);\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Jgf2Sgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Flip SGF alias map and create JGF alias map\n   */\n  var jgfAliases = {};\n  for (var sgfProp in sgfAliases) {\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\n    }\n  }\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert to SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Helper to escape SGF info\n   */\n  var escapeSgf = function(text) {\n    if (typeof text === 'string') {\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\n    }\n    return text;\n  };\n\n  /**\n   * Helper to write an SGF group\n   */\n  var writeGroup = function(prop, values, output, escape) {\n    if (values.length) {\n      output.sgf += prop;\n      for (var i = 0; i < values.length; i++) {\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\n      }\n    }\n  };\n\n  /**\n   * Move parser\n   */\n  var parseMove = function(move, output) {\n\n    //Determine and validate color\n    var color = move.B ? 'B' : (move.W ? 'W' : '');\n    if (color === '') {\n      return;\n    }\n\n    //Determine move\n    var coords = (move[color] === 'pass') ? '' : move[color];\n\n    //Append to SGF\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\n  };\n\n  /**\n   * Setup parser\n   */\n  var parseSetup = function(setup, output) {\n\n    //Loop colors\n    for (var color in setup) {\n      if (setup.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < setup[color].length; i++) {\n          setup[color][i] = convertCoordinates(setup[color][i]);\n        }\n\n        //Write as group\n        writeGroup('A' + color, setup[color], output);\n      }\n    }\n  };\n\n  /**\n   * Score parser\n   */\n  var parseScore = function(score, output) {\n\n    //Loop colors\n    for (var color in score) {\n      if (score.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < score[color].length; i++) {\n          score[color][i] = convertCoordinates(score[color][i]);\n        }\n\n        //Write as group\n        writeGroup('T' + color, score[color], output);\n      }\n    }\n  };\n\n  /**\n   * Markup parser\n   */\n  var parseMarkup = function(markup, output) {\n\n    //Loop markup types\n    for (var type in markup) {\n      if (markup.hasOwnProperty(type)) {\n        var i;\n\n        //Label type has the label text appended to the coords\n        if (type === 'label') {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\n          }\n        }\n        else {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]);\n          }\n        }\n\n        //Convert type\n        if (typeof jgfAliases[type] !== 'undefined') {\n          type = jgfAliases[type];\n        }\n\n        //Write as group\n        writeGroup(type, markup[type], output);\n      }\n    }\n  };\n\n  /**\n   * Turn parser\n   */\n  var parseTurn = function(turn, output) {\n    output.sgf += 'PL[' + turn + ']';\n  };\n\n  /**\n   * Comments parser\n   */\n  var parseComments = function(comments, output) {\n\n    //Determine key\n    var key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\n\n    //Flatten comment objects\n    var flatComments = [];\n    for (var c = 0; c < comments.length; c++) {\n      if (typeof comments[c] === 'string') {\n        flatComments.push(comments[c]);\n      }\n      else if (comments[c].comment) {\n        flatComments.push(comments[c].comment);\n      }\n    }\n\n    //Write as group\n    writeGroup(key, flatComments, output, true);\n  };\n\n  /**\n   * Node name parser\n   */\n  var parseNodeName = function(nodeName, output) {\n    var key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\n  };\n\n  /**\n   * Game parser\n   */\n  var parseGame = function(game) {\n\n    //Loop SGF game definitions\n    for (var i in sgfGames) {\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\n        return i;\n      }\n    }\n\n    //Not found\n    return 0;\n  };\n\n  /**\n   * Application parser\n   */\n  var parseApplication = function(application) {\n    var parts = application.split(' v');\n    if (parts.length > 1) {\n      return parts[0] + ':' + parts[1];\n    }\n    return application;\n  };\n\n  /**\n   * Player instructions parser\n   */\n  var parsePlayer = function(player, rootProperties) {\n\n    //Variation handling\n    var st = 0;\n    if (!player.variationMarkup) {\n      st += 2;\n    }\n    if (player.variationSiblings) {\n      st += 1;\n    }\n\n    //Set in root properties\n    rootProperties.ST = st;\n  };\n\n  /**\n   * Board parser\n   */\n  var parseBoard = function(board, rootProperties) {\n\n    //Both width and height should be given\n    if (board.width && board.height) {\n\n      //Same dimensions?\n      if (board.width === board.height) {\n        rootProperties.SZ = board.width;\n      }\n\n      //Different dimensions are not supported by SGF, but OGS uses the\n      //format w:h, so we will stick with that for anyone who supports it.\n      else {\n        rootProperties.SZ = board.width + ':' + board.height;\n      }\n    }\n\n    //Otherwise, check if only width or height were given at least\n    else if (board.width) {\n      rootProperties.SZ = board.width;\n    }\n    else if (board.height) {\n      rootProperties.SZ = board.height;\n    }\n\n    //Can't determine size\n    else {\n      rootProperties.SZ = '';\n    }\n  };\n\n  /**\n   * Players parser\n   */\n  var parsePlayers = function(players, rootProperties) {\n\n    //Loop players\n    for (var p = 0; p < players.length; p++) {\n\n      //Validate color\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\n        continue;\n      }\n\n      //Get SGF color\n      var color = (players[p].color === 'black') ? 'B' : 'W';\n\n      //Name given?\n      if (players[p].name) {\n        rootProperties['P' + color] = players[p].name;\n      }\n\n      //Rank given?\n      if (players[p].rank) {\n        rootProperties[color + 'R'] = players[p].rank;\n      }\n\n      //Team given?\n      if (players[p].team) {\n        rootProperties[color + 'T'] = players[p].team;\n      }\n    }\n  };\n\n  /**\n   * Parse function to property mapper\n   */\n  var parsingMap = {\n\n    //Node properties\n    'move': parseMove,\n    'setup': parseSetup,\n    'score': parseScore,\n    'markup': parseMarkup,\n    'turn': parseTurn,\n    'comments': parseComments,\n    'name': parseNodeName,\n\n    //Info properties\n    'record.application': parseApplication,\n    'player': parsePlayer,\n    'board': parseBoard,\n    'game.type': parseGame,\n    'game.players': parsePlayers\n  };\n\n  /*****************************************************************************\n   * Parser functions\n   ***/\n\n  /**\n   * Helper to write a JGF tree to SGF\n   */\n  var writeTree = function(tree, output) {\n\n    //Loop nodes in the tree\n    for (var i = 0; i < tree.length; i++) {\n      var node = tree[i];\n\n      //Array? That means a variation\n      if (angular.isArray(node)) {\n        for (var j = 0; j < node.length; j++) {\n          output.sgf += '(\\n;';\n          writeTree(node[j], output);\n          output.sgf += '\\n)';\n        }\n\n        //Continue\n        continue;\n      }\n\n      //Loop node properties\n      for (var key in node) {\n        if (node.hasOwnProperty(key)) {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[key] !== 'undefined') {\n            parsingMap[key](node[key], output);\n            continue;\n          }\n\n          //Other object, can't handle it\n          if (typeof node[key] === 'object') {\n            continue;\n          }\n\n          //Anything else, append it\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\n        }\n      }\n\n      //More to come?\n      if ((i + 1) < tree.length) {\n        output.sgf += '\\n;';\n      }\n    }\n  };\n\n  /**\n   * Helper to extract all SGF root properties from a JGF object\n   */\n  var extractRootProperties = function(jgf, rootProperties, key) {\n\n    //Initialize key\n    if (typeof key === 'undefined') {\n      key = '';\n    }\n\n    //Loop properties of jgf node\n    for (var subKey in jgf) {\n      if (jgf.hasOwnProperty(subKey)) {\n\n        //Skip SGF signature (as we keep our own)\n        if (subKey === 'sgf') {\n          continue;\n        }\n\n        //Build jgf key\n        var jgfKey = (key === '') ? subKey : key + '.' + subKey;\n\n        //If the item is an object, handle separately\n        if (typeof jgf[subKey] === 'object') {\n\n          //Handler for this object present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\n          }\n\n          //Otherwise, just flatten and call this function recursively\n          else {\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\n          }\n          continue;\n        }\n\n        //Check if it's a known key, if so, append the value to the root\n        var value;\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            value = parsingMap[jgfKey](jgf[subKey]);\n          }\n          else {\n            value = escapeSgf(jgf[subKey]);\n          }\n\n          //Set in root properties\n          rootProperties[jgfAliases[jgfKey]] = value;\n        }\n      }\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    parse: function(jgf) {\n\n      //String given?\n      if (typeof jgf === 'string') {\n        jgf = angular.fromJson(jgf);\n      }\n\n      //Must have moves tree\n      if (!jgf.tree) {\n        console.error('No moves tree in JGF object');\n        return;\n      }\n\n      //Initialize output (as object, so it remains a reference) and root properties container\n      var output = {sgf: '(\\n;'};\n      var root = angular.copy(jgf);\n      var rootProperties = KifuBlank.sgf();\n\n      //The first node of the JGF tree is the root node, and it can contain comments,\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\n      //and attach it to the root\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\n        root = angular.extend(root, jgf.tree[0]);\n        delete root.root;\n        delete jgf.tree[0];\n      }\n\n      //Set root properties\n      delete root.tree;\n      extractRootProperties(root, rootProperties);\n\n      //Write root properties\n      for (var key in rootProperties) {\n        if (rootProperties[key]) {\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\n        }\n      }\n\n      //Write game tree\n      writeTree(jgf.tree, output);\n\n      //Close SGF and return\n      output.sgf += ')';\n      return output.sgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Sgf2Jgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Regular expressions for SGF data\n   */\n  var regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\n  var regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\n  var regProperty = /[A-Z]+/;\n  var regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Application parser function (doesn't overwrite existing signature)\n   */\n  var parseApp = function(jgf, node, key, value) {\n    if (!jgf.record.application) {\n      var app = value[0].split(':');\n      if (app.length > 1) {\n        jgf.record.application = app[0] + ' v' + app[1];\n      }\n      else {\n        jgf.record.application = app[0];\n      }\n    }\n  };\n\n  /**\n   * SGF format parser\n   */\n  var parseSgfFormat = function() {\n    return;\n  };\n\n  /**\n   * Game type parser function\n   */\n  var parseGame = function(jgf, node, key, value) {\n    var game = value[0];\n    if (typeof sgfGames[game] !== 'undefined') {\n      jgf.game.type = sgfGames[game];\n    }\n    else {\n      jgf.game.type = value[0];\n    }\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, key, value) {\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\n      node.move[key] = 'pass';\n    }\n\n    //Regular move\n    else {\n      node.move[key] = convertCoordinates(value[0]);\n    }\n  };\n\n  /**\n   * Comment parser function\n   */\n  var parseComment = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Node name parser function\n   */\n  var parseNodeName = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value[0];\n  };\n\n  /**\n   * Board setup parser function\n   */\n  var parseSetup = function(jgf, node, key, value) {\n\n    //Initialize setup container on node\n    if (typeof node.setup === 'undefined') {\n      node.setup = {};\n    }\n\n    //Remove \"A\" from setup key\n    key = key.charAt(1);\n\n    //Initialize setup container of this type\n    if (typeof node.setup[key] === 'undefined') {\n      node.setup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.setup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Scoring parser function\n   */\n  var parseScore = function(jgf, node, key, value) {\n\n    //Initialize score container on node\n    if (typeof node.score === 'undefined') {\n      node.score = {\n        B: [],\n        W: []\n      };\n    }\n\n    //Remove \"T\" from setup key\n    key = key.charAt(1);\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.score[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Turn parser function\n   */\n  var parseTurn = function(jgf, node, key, value) {\n    node.turn = value[0];\n  };\n\n  /**\n   * Label parser function\n   */\n  var parseLabel = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n\n      //Split off coordinates and add label contents\n      var coords = convertCoordinates(value[i].substr(0, 2));\n      coords.push(value[i].substr(3));\n\n      //Add to node\n      node.markup[key].push(coords);\n    }\n  };\n\n  /**\n   * Markup parser function\n   */\n  var parseMarkup = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.markup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Size parser function\n   */\n  var parseSize = function(jgf, node, key, value) {\n\n    //Initialize board container\n    if (typeof jgf.board === 'undefined') {\n      jgf.board = {};\n    }\n\n    //Add size property (can be width:height or just a single size)\n    var size = value[0].split(':');\n    if (size.length > 1) {\n      jgf.board.width = parseInt(size[0]);\n      jgf.board.height = parseInt(size[1]);\n    }\n    else {\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\n    }\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, node, key, value) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Explode dates\n    var dates = value[0].split(',');\n    for (var d = 0; d < dates.length; d++) {\n      jgf.game.dates.push(dates[d]);\n    }\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, node, key, value) {\n    jgf.game.komi = parseFloat(value[0]);\n  };\n\n  /**\n   * Variations handling parser function\n   */\n  var parseVariations = function(jgf, node, key, value) {\n\n    //Initialize display property\n    if (typeof jgf.player === 'undefined') {\n      jgf.player = {};\n    }\n\n    //Initialize variation display settings\n    jgf.player.variationMarkup = false;\n    jgf.player.variationChildren = false;\n    jgf.player.variationSiblings = false;\n\n    //Parse as integer\n    var st = parseInt(value[0]);\n\n    //Determine what we want (see SGF specs for details)\n    switch (st) {\n      case 0:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationChildren = true;\n        break;\n      case 1:\n        jgf.player.variationMarkup = true;\n        jgf.player.variationSiblings = true;\n        break;\n      case 2:\n        jgf.player.variationChildren = true;\n        break;\n      case 3:\n        jgf.player.variationSiblings = true;\n        break;\n    }\n  };\n\n  /**\n   * Player info parser function\n   */\n  var parsePlayer = function(jgf, node, key, value) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Check if player of this color already exists\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p][key] = value[0];\n        return;\n      }\n    }\n\n    //Player of this color not found, initialize\n    var player = {color: color};\n    player[key] = value[0];\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Parsing function to property mapper\n   */\n  var parsingMap = {\n\n    //Application, game type, board size, komi, date\n    'AP': parseApp,\n    'FF': parseSgfFormat,\n    'GM': parseGame,\n    'SZ': parseSize,\n    'KM': parseKomi,\n    'DT': parseDate,\n\n    //Variations handling\n    'ST': parseVariations,\n\n    //Player info handling\n    'PB': parsePlayer,\n    'PW': parsePlayer,\n    'BT': parsePlayer,\n    'WT': parsePlayer,\n    'BR': parsePlayer,\n    'WR': parsePlayer,\n\n    //Moves\n    'B': parseMove,\n    'W': parseMove,\n\n    //Node annotation\n    'C': parseComment,\n    'N': parseNodeName,\n\n    //Board setup\n    'AB': parseSetup,\n    'AW': parseSetup,\n    'AE': parseSetup,\n    'PL': parseTurn,\n    'TW': parseScore,\n    'TB': parseScore,\n\n    //Markup\n    'CR': parseMarkup,\n    'SQ': parseMarkup,\n    'TR': parseMarkup,\n    'MA': parseMarkup,\n    'SL': parseMarkup,\n    'LB': parseLabel\n  };\n\n  /**\n   * These properties need a node object\n   */\n  var needsNode = [\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB'\n  ];\n\n  /*****************************************************************************\n   * Parser helpers\n   ***/\n\n  /**\n   * Set info in the JGF tree at a certain position\n   */\n  var setInfo = function(jgf, position, value) {\n\n    //Position given must be an array\n    if (typeof position !== 'object') {\n      return;\n    }\n\n    //Initialize node to attach value to\n    var node = jgf;\n    var key;\n\n    //Loop the position\n    for (var p = 0; p < position.length; p++) {\n\n      //Get key\n      key = position[p];\n\n      //Last key reached? Done\n      if ((p + 1) === position.length) {\n        break;\n      }\n\n      //Create container if not set\n      if (typeof node[key] !== 'object') {\n        node[key] = {};\n      }\n\n      //Move up in tree\n      node = node[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    parse: function(sgf, stringified) {\n\n      //Get new JGF object (with SGF node as a base)\n      var jgf = KifuBlank.jgf({record: {sgf: {}}});\n\n      //Initialize\n      var stack = [];\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find sequence of elements\n      var sequence = sgf.match(regSequence);\n\n      //Loop sequence items\n      for (var i = 0; i < sequence.length; i++) {\n\n        //Push stack if new variation found\n        if (sequence[i] === '(') {\n\n          //First encounter, this defines the main tree branch, so skip\n          if (i === 0 || i === '0') {\n            continue;\n          }\n\n          //Push the current container to the stack\n          stack.push(container);\n\n          //Create variation container if it doesn't exist yet\n          if (!angular.isArray(container[container.length - 1])) {\n            container.push([]);\n          }\n\n          //Use variation container\n          container = container[container.length - 1];\n\n          //Now create moves container\n          container.push([]);\n          container = container[container.length - 1];\n          continue;\n        }\n\n        //Grab last container from stack if end of variation reached\n        else if (sequence[i] === ')') {\n          if (stack.length) {\n            container = stack.pop();\n          }\n          continue;\n        }\n\n        //Make array of properties within this sequence\n        var properties = sequence[i].match(regNode) || [];\n\n        //Loop them\n        for (var j = 0; j < properties.length; j++) {\n\n          //Get property's key and separate values\n          var key = regProperty.exec(properties[j])[0].toUpperCase();\n          var values = properties[j].match(regValues);\n\n          //Remove additional braces [ and ]\n          for (var k = 0; k < values.length; k++) {\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\n          }\n\n          //SGF parser present for this key? Call it, and we're done\n          if (typeof parsingMap[key] !== 'undefined') {\n\n            //Does this type of property need a node?\n            if (needsNode.indexOf(key) !== -1) {\n\n              //If no node object present, create a new node\n              //For moves, always a new node is created\n              if (!node || key === 'B' || key === 'W') {\n                node = {};\n                container.push(node);\n              }\n            }\n\n            //Apply parsing function on node\n            parsingMap[key](jgf, node, key, values);\n            continue;\n          }\n\n          //No SGF parser present, we continue with regular property handling\n\n          //If there is only one value, simplify array\n          if (values.length === 1) {\n            values = values[0];\n          }\n\n          //SGF alias known? Then this is an info element and we handle it accordingly\n          if (typeof sgfAliases[key] !== 'undefined') {\n\n            //The position in the JGF object is represented by dot separated strings\n            //in the sgfAliases array. Split the position and use the setInfo helper\n            //to set the info on the JGF object\n            setInfo(jgf, sgfAliases[key].split('.'), values);\n            continue;\n          }\n\n          //No SGF alias present either, just append the data\n\n          //Save in node\n          if (node) {\n            node[key] = values;\n          }\n\n          //Save in root\n          else {\n            jgf[key] = values;\n          }\n        }\n\n        //Reset node, unless this was the root node\n        if (node && !node.root) {\n          node = null;\n        }\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n"],"sourceRoot":"/source/"}