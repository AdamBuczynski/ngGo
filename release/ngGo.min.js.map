{"version":3,"sources":["ngGo.js","board/board.directive.js","board/board.service.js","board/defaultClearHandler.service.js","board/grid.service.js","board/gridChanges.service.js","board/layer.service.js","board/object.service.js","board/shellPattern.service.js","board/theme.service.js","errors/invalidDataError.service.js","errors/invalidPositionError.service.js","game/game.service.js","game/node.service.js","game/path.service.js","game/position.service.js","game/score.service.js","game/scorer.service.js","kifu/blank.service.js","kifu/parser.service.js","player/player.directive.js","player/player.service.js","board/layer/gridLayer.service.js","board/layer/hoverLayer.service.js","board/layer/markupLayer.service.js","board/layer/scoreLayer.service.js","board/layer/shadowLayer.service.js","board/layer/stonesLayer.service.js","board/object/coordinates.service.js","board/object/markup.service.js","board/object/stone.service.js","board/object/stoneFaded.service.js","board/object/stoneMini.service.js","board/object/stoneShadow.service.js","kifu/parsers/gib2jgf.service.js","kifu/parsers/jgf2sgf.service.js","kifu/parsers/sgf2jgf.service.js","player/mode/common.service.js","player/mode/edit.service.js","player/mode/replay.service.js","player/mode/solve.service.js","ngGo.min.js"],"names":["window","angular","undefined","module","constant","name","version","error","POSITION_OUT_OF_BOUNDS","POSITION_ALREADY_HAS_STONE","POSITION_IS_SUICIDE","POSITION_IS_REPEATING","NO_DATA","UNKNOWN_DATA","INVALID_SGF","INVALID_GIB","INVALID_JGF_JSON","INVALID_JGF_TREE_JSON","E","EMPTY","B","BLACK","W","WHITE","TRIANGLE","CIRCLE","SQUARE","MARK","SELECT","LABEL","LAST","SAD","HAPPY","PLAY","REPLAY","EDIT","SOLVE","NONE","MOVE","SCORE","SETUP","MARKUP","LEFT","RIGHT","UP","DOWN","ESC","ENTER","SPACE","TAB","SHIFT","CTRL","ALT","HOME","END","PAGEUP","PAGEDOWN","directive","$window","Board","pixelRatio","createLayerCanvas","canvas","document","createElement","context","getContext","scale","className","width","this","clientWidth","height","clientHeight","appendChild","determineDrawSize","scope","availableWidth","availableHeight","drawWidth","drawHeight","cellSize","Math","min","floor","lastDrawWidth","lastDrawHeight","$broadcast","restrict","instance","link","element","attrs","i","layer","playerElement","parent","sizingElement","existingInstance","linkElement","tagName","$on","event","find","length","forceSize","css","setDrawSize","on","board","resized","addClass","makeStatic","call","layerOrder","layers","setContext","$observe","size","toLowerCase","indexOf","split","setSize","attr","toggleCoordinates","isDefined","setCutoff","swapColors","$parent","Player","setBoard","redraw","provider","defaultConfig","cutoff","section","top","right","bottom","left","coordinates","color_multiplier","setConfig","config","extend","$get","$rootScope","$injector","BoardTheme","init","parseConfig","prototype","removeAll","theme","drawMarginHor","drawMarginVer","gridDrawWidth","gridDrawHeight","l","layerClass","toUpperCase","substr","LayerClass","get","margin","colorMultiplier","grid","setCoordinates","setSection","setMargin","isArray","changes","side","hasOwnProperty","parseInt","isNaN","show","multiplier","getTheme","setTheme","add","x","y","value","remove","has","setAll","updatePosition","position","pathChanged","stones","markup","getState","getAll","state","isEmpty","restoreState","clear","draw","xLeft","xRight","yTop","yBot","noCellsHor","noCellsVer","getCellSize","getAbsX","gridX","offset","round","getAbsY","gridY","getGridX","absX","getGridY","absY","isOnBoard","factory","obj","s","r","clearRect","BoardGridChanges","toObject","valueKey","BoardGrid","emptyValue","set","isOnGrid","unset","is","all","objects","push","populate","empty","clone","newGrid","copy","isSameAs","compare","console","warn","whenEmpty","getSize","setSubtract","a","b","q","n","j","concat","newChanges","BoardLayer","clearCell","drawCell","redrawCell","DefaultClearHandler","BoardObject","drawheight","shellLine","ctx","radius","startAngle","endAngle","strokeStyle","shadowBlur","lineWidth","thickness","beginPath","max","m","angle","x1","cos","PI","y1","sin","x2","y2","atan","c","factor","dx","dy","bx1","by1","bx2","by2","moveTo","bezierCurveTo","stroke","lines","StoneColor","MarkupTypes","defaultTheme","stone","style","shadow","shell","color","stoneColor","types","mono","lineColor","mini","alpha","faded","blur","offsetX","ceil","offsetY","triangle","square","circle","mark","lineCap","last","smiley","label","font","variation","type","text","String","fromCharCode","solution","valid","invalid","star","points","vertical","inverse","ch","horizontal","merge","instanceTheme","reset","property","path","prop","args","arguments","apply","canvasTranslate","ngGo","InvalidDataError","code","message","Error","constructor","InvalidPositionError","POSTITION_OUT_OF_BOUNDS","POSTITION_ALREADY_HAS_STONE","POSTITION_IS_SUICIDE","POSTITION_IS_REPEATING","defaultSize","defaultKomi","defaultHandicap","rememberPath","checkRepeat","allowSuicide","GamePath","GameNode","GamePosition","KifuParser","KifuBlank","validateInfo","info","game","komi","handicap","nextNode","node","children","_remembered_path","advance","previousNode","retreat","firstNode","root","setTurn","initializeHistory","history","pushPosition","newPosition","popPosition","pop","replacePosition","executeNode","move","pass","validateMove","turn","setup","Game","data","Object","defineProperty","load","jgf","fromData","errorCode","first","reload","isLoaded","props","getOwnPropertyNames","p","charAt","fromSgf","fromJgf","fromGib","gib","gib2jgf","sgf","sgf2jgf","fromJson","tree","toSgf","jgf2sgf","toJgf","stringify","toJson","getNode","getPosition","getPath","clonePath","getPathToNode","nodeName","findNode","getKomi","parseFloat","setKomi","getTurn","getCaptureCount","captures","getMoveVariation","getMove","getMoveCount","noMoves","key","isMoveVariation","isRepeatingPosition","checkPosition","stop","isValidMove","captureAdjacent","hasLiberties","captureGroup","validatePlacement","addStone","tempPosition","appendTo","addMarkup","removeStone","foundInSetup","splice","removeMarkup","hasStone","hasMarkup","getStone","getMarkup","play","next","previous","target","setMove","nodeAt","previousFork","nextFork","aChar","charCodeAt","convertCoordinates","coords","coordinatesObject","baseObject","toStringColor","toColorConstant","convertMoveToJgf","jgfMove","convertMoveFromJgf","convertSetupToJgf","jgfSetup","convertSetupFromJgf","gameSetup","convertMarkupToJgf","jgfMarkup","convertMarkupFromJgf","gameMarkup","convertTurnToJgf","convertTurnFromJgf","conversionMap","properties","getChild","getChildren","hasChildren","hasMoveVariations","moveVariations","getMoveVariations","moveUp","temp","moveDown","insertNode","gameNode","variationNode","container","variationsContainer","variationContainer","branches","no","otherPath","newPath","findNodeName","rootNode","setStone","setMarkup","groupColor","tested","friendlyColor","captured","canCapture","enemyColor","doCapture","captureStone","setCaptures","getCaptures","switchTurn","calcTotal","territory","GameScore","self","black","white","total","winner","w","scoreState","UNKNOWN","BLACK_STONE","WHITE_STONE","BLACK_CANDIDATE","WHITE_CANDIDATE","NEUTRAL","territorySet","candidateColor","boundaryColor","posColor","origColor","territoryReset","determineScoreState","curState","newState","adjacent","change","GameScorer","score","getScore","getPoints","calculate","blankJgf","record","application","charset","players","blankSgf","AP","CA","FF","GM","SZ","PB","PW","base","blank","CP","SO","US","AN","GN","KM","HA","RE","RU","TM","OT","DT","PC","EV","RO","ON","GC","BT","WT","BR","WR","N","C","CR","TR","SQ","MA","SL","LB",1,2,3,4,6,7,8,"Gib2Jgf","Sgf2Jgf","Jgf2Sgf","stringified","parse","controller","$scope","mode","switchMode","tool","switchTool","setVariationMarkup","toggleSolutionPaths","setLastMoveMarker","PlayerModes","PlayerTools","arrow_keys_navigation","scroll_wheel_navigation","last_move_marker","variation_markup","variation_children","variation_siblings","$document","processMouseEvent","broadcastEvent","mouseEvent","originalEvent","layerX","layerY","devicePixelRatio","drag","modes","tools","arrowKeysNavigation","scrollWheelNavigation","lastMoveMarker","variationMarkup","variationChildren","variationSiblings","restrictNodeStart","restrictNodeEnd","registerElementEvent","setArrowKeysNavigation","setScrollWheelNavigation","arrowKeys","broadcast","scrollWheel","registerMode","PlayerMode","setTools","hasMode","hasTool","force","saveState","playerState","saveGameState","restoreGameState","allowPlayerConfig","processPosition","gameState","goto","restrictNode","end","updateBoard","newGame","scoreGame","getBoard","off","bind","listener","querySelector","preventClickEvent","t","$$phase","$apply","Coordinates","drawStarPoint","starRadius","starColor","fillStyle","arc","fill","GridLayer","tx","ty","starPoints","translate","lineTo","Markup","StoneFaded","HoverLayer","restore","hover","object","objectClass","MarkupLayer","StoneMini","ScoreLayer","StoneShadow","ShadowLayer","shadowSize","setTransform","Stone","StonesLayer","kanji","aCharLc","numbers","letters","xl","xr","yt","yb","textBaseline","textAlign","fillText","cosPi4","cosPi6","drawTriangle","closePath","drawSquare","rcos","rect","drawCircle","drawMark","drawSelect","drawLast","drawHappySmiley","drawSadSmiley","drawLabel","toString","clearLabel","ShellPattern","shellSeed","drawMono","globalAlpha","drawGlass","createRadialGradient","addColorStop","drawSlateShell","random","shellTypes","z","handler","shadowColor","regMove","regPlayer","regKomi","regDate","regResultMargin","regResultOther","parsePlayer","match","player","rank","parseKomi","parseDate","dates","parseResult","result","parseMove","Parser","exec","sgfAliases","sgfGames","jgfAliases","sgfProp","escapeSgf","replace","writeGroup","values","output","escape","parseSetup","parseScore","parseMarkup","parseTurn","parseComments","comments","flatComments","comment","parseNodeName","parseGame","parseApplication","parts","rootProperties","st","ST","parseBoard","parsePlayers","team","parsingMap","record.application","game.type","game.players","writeTree","extractRootProperties","subKey","jgfKey","regSequence","regNode","regProperty","regValues","parseApp","app","parseSgfFormat","parseComment","parseLabel","parseSize","d","parseVariations","AB","AW","AE","PL","TW","TB","needsNode","setInfo","stack","sequence","k","substring","run","PlayerModeCommon","keyDown","mouseWheel","mouseMove","mouseOut","mouseDown","mouseUp","KeyCodes","normalizeMousewheelEvent","deltaX","deltaY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","mouseWheelX","mouseWheelY","dragObject","start","mouse","dragStart","lastX","lastY","keyboardEvent","keyCode","preventDefault","delta","CLEAR","TEXT","NUMBER","PlayerModeEdit","pathChange","toolSwitch","modeEnter","mouseDrag","click","SetupTools","MarkupTools","updateHoverMark","isDrag","setupTool","setupToolColor","markupTool","markupLabel","markupLabels","determineMarkupLabel","findAllMarkupLabels","switchSetupTool","switchMarkupTool","setMarkupLabel","statePreScoring","PlayerModeReplay","settingChange","boardUpdate","modeExit","auto_play_delay","$interval","showMoveVariations","variations","hideMoveVariations","drawMoveVariations","autoPlaying","autoPlayDelay","autoPlayPromise","setAutoPlayDelay","delay","cancel","setting","PlayerModeSolve","player_color","solution_paths","solve_auto_play","solve_auto_play_delay","$timeout","canMakeMove","solveAutoPlay","problemSolved","problemOffPath","playerColor","showSolutionPaths","hideSolutionPaths","drawSolutionPaths","problemStartPath","solutionPaths","solveAutoPlayDelay","solveNavigationBlocked","setSolveAutoPlay","autoPlay","setSolveAutoPlayDelay","setPlayerColor","getPlayerColor","asOnBoard","autoPlayNext","immediately","solve","restartProblem"],"mappings":"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","file":"ngGo.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n/**\n * ngGo\n *\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\n * refactored to fit the Angular framework, as well as having been linted, properly commented\n * and generally cleaned up.\n *\n * Copyright (c) 2013 Jan Prokop (WGo)\n * Copyright (c) 2014-2015 Adam Buczynski (ngGo)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo', [])\n\n/**\n * ngGo constants\n */\n.constant('ngGo', {\n  name: 'ngGo',\n  version: '1.2.5',\n  error: {\n\n    //Position errors\n    POSITION_OUT_OF_BOUNDS: 1,\n    POSITION_ALREADY_HAS_STONE: 2,\n    POSITION_IS_SUICIDE: 3,\n    POSITION_IS_REPEATING: 4,\n\n    //Data loading errors\n    NO_DATA: 5,\n    UNKNOWN_DATA: 6,\n    INVALID_SGF: 7,\n    INVALID_GIB: 8,\n    INVALID_JGF_JSON: 9,\n    INVALID_JGF_TREE_JSON: 10\n  }\n})\n\n/**\n * Stone colors\n */\n.constant('StoneColor', {\n  E: 0,\n  EMPTY: 0,\n  B: 1,\n  BLACK: 1,\n  W: -1,\n  WHITE: -1\n})\n\n/**\n * Markup types\n */\n.constant('MarkupTypes', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  LABEL: 'label',\n  LAST: 'last',\n  SAD: 'sad',\n  HAPPY: 'happy'\n})\n\n/**\n * Player modes\n */\n.constant('PlayerModes', {\n  PLAY: 'play',\n  REPLAY: 'replay',\n  EDIT: 'edit',\n  SOLVE: 'solve'\n})\n\n/**\n * Player tools\n */\n.constant('PlayerTools', {\n  NONE: 'none',\n  MOVE: 'move',\n  SCORE: 'score',\n  SETUP: 'setup',\n  MARKUP: 'markup'\n})\n\n/**\n * Key codes\n */\n.constant('KeyCodes', {\n  LEFT: 37,\n  RIGHT: 39,\n  UP: 38,\n  DOWN: 40,\n  ESC: 27,\n  ENTER: 13,\n  SPACE: 32,\n  TAB: 9,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  HOME: 36,\n  END: 35,\n  PAGEUP: 33,\n  PAGEDOWN: 34\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Directive', [\n  'ngGo.Board.Service'\n])\n\n/**\n * Directive definition\n */\n.directive('board', ['$window', 'Board', function($window, Board) {\n\n  //Get pixel ratio\n  var pixelRatio = window.pixelRatio || 1;\n\n  /**\n   * Helper to create a layer canvas\n   */\n  var createLayerCanvas = function(name) {\n\n    //Create canvas element and get context\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    //Scale context depending on pixel ratio\n    if (pixelRatio > 1) {\n      context.scale(pixelRatio, pixelRatio);\n    }\n\n    //Set class\n    canvas.className = name;\n\n    //Set initial canvas width/height based on our own size\n    canvas.width = this.clientWidth * pixelRatio;\n    canvas.height = this.clientHeight * pixelRatio;\n\n    //Append to element now and return context\n    this.appendChild(canvas);\n    return context;\n  };\n\n  /**\n   * Helper to determine draw size\n   */\n  var determineDrawSize = function(scope, availableWidth, availableHeight) {\n\n    //Init vars\n    var drawWidth, drawHeight, cellSize;\n\n    //Stretch available height to width if zero\n    if (availableHeight === 0 && availableWidth > 0) {\n      availableHeight = availableWidth;\n    }\n\n    //Grid size known?\n    if (scope.Board.width && scope.Board.height) {\n\n      //Determine smallest cell size\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\n\n      //Set draw size\n      drawWidth = Math.floor(cellSize * scope.Board.width);\n      drawHeight = Math.floor(cellSize * scope.Board.height);\n    }\n\n    //Otherwise, use the lesser of the available width/height\n    else {\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\n    }\n\n    //Broadcast new size if changed\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\n      scope.lastDrawWidth = drawWidth;\n      scope.lastDrawHeight = drawHeight;\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\n      return true;\n    }\n\n    //No change\n    return false;\n  };\n\n  /**\n   * Directive\n   */\n  return {\n    restrict: 'E',\n    scope: {\n      instance: '&'\n    },\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Init vars\n      var i, context, layer, playerElement;\n      var parent = element.parent();\n      var sizingElement = element[0];\n      var existingInstance = true;\n\n      //Remember last draw width/height\n      scope.lastDrawWidth = 0;\n      scope.lastDrawHeight = 0;\n\n      //Get board instance\n      scope.Board = scope.instance();\n\n      //Function given?\n      if (typeof scope.Board === 'function') {\n        scope.Board = scope.Board();\n      }\n\n      //Instantiate board if not present in scope\n      if (!scope.Board) {\n        existingInstance = false;\n        scope.Board = new Board();\n      }\n\n      //Link element\n      scope.Board.linkElement(element);\n\n      //Find player element\n      if (parent[0].tagName === 'PLAYER') {\n        playerElement = parent;\n        sizingElement = parent.parent()[0];\n      }\n\n      //Listen for board drawsize events\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\n\n        //First set the new dimensions on the canvas elements\n        var canvas = element.find('canvas');\n        for (i = 0; i < canvas.length; i++) {\n          canvas[i].width = width * pixelRatio;\n          canvas[i].height = height * pixelRatio;\n        }\n\n        //Set on the element if we're using a player element and if there is a size\n        if (playerElement || attrs.forceSize === 'true') {\n          element.css({width: width + 'px', height: height + 'px'});\n        }\n\n        //Next set it on the board itself\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\n      });\n\n      //Determine initial draw size\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n\n      //On window resize, determine the draw size again\n      angular.element($window).on('resize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On manual resize, determine draw size again\n      scope.$on('ngGo.board.determineDrawSize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On board grid resize, determine the draw size again\n      scope.$on('ngGo.board.resize', function(event, board) {\n\n        //Only relevent if this was our own board\n        if (board !== scope.Board) {\n          return;\n        }\n\n        //If the draw size didn't change, the draw size event won't be triggered.\n        //However, that means we should call the resized() method now manually because\n        //it won't be called with the setDrawSize() call.\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\n          scope.Board.resized();\n        }\n      });\n\n      //Static board\n      if (attrs.static && attrs.static === 'true') {\n\n        //Add static class and make the board static\n        element.addClass('static');\n        scope.Board.makeStatic();\n\n        //Create single canvas and link to all relevant layer service classes\n        context = createLayerCanvas.call(element[0], 'static');\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Dynamic board\n      else {\n\n        //Create individual layer canvasses and link the canvas context to the layer service class\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          context = createLayerCanvas.call(element[0], layer);\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Observe the board size attribute\n      attrs.$observe('size', function(size) {\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\n          size = size.split('x');\n          scope.Board.setSize(size[0], size[1]);\n        }\n        else {\n          scope.Board.setSize(size, size);\n        }\n      });\n\n      //Observe the coordinates attribute\n      attrs.$observe('coordinates', function(attr) {\n        scope.Board.toggleCoordinates(attr === 'true');\n      });\n\n      //Observe the cutoff attribute\n      attrs.$observe('cutoff', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.setCutoff(attr.split(','));\n        }\n      });\n\n      //Observe color multiplier\n      attrs.$observe('colorMultiplier', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.swapColors(attr);\n        }\n      });\n\n      //Link board to player if present in parent scope\n      if (scope.$parent.Player) {\n        scope.$parent.Player.setBoard(scope.Board);\n      }\n\n      //Redraw board if we had an existing instance (it might contain data)\n      if (existingInstance) {\n        scope.Board.redraw();\n      }\n    }\n  };\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\n * and is used for placing and removing objects on the board. The class has helpers to figure out\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\n * responsible for drawing all layers on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Service', [\n  'ngGo',\n  'ngGo.Board.Directive',\n  'ngGo.Board.Theme.Service',\n  'ngGo.Board.Layer.GridLayer.Service',\n  'ngGo.Board.Layer.ShadowLayer.Service',\n  'ngGo.Board.Layer.StonesLayer.Service',\n  'ngGo.Board.Layer.MarkupLayer.Service',\n  'ngGo.Board.Layer.ScoreLayer.Service',\n  'ngGo.Board.Layer.HoverLayer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.Stone.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Board', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Width and height\n    width: 0,\n    height: 0,\n\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\n    cutoff: [],\n\n    //Section of board to display\n    section: {top: 0, right: 0, bottom: 0, left: 0},\n\n    //Show coordinates?\n    coordinates: false,\n\n    //Color multiplier (use -1 to swap colors)\n    color_multiplier: 1\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$injector', 'BoardTheme', function($rootScope, $injector, BoardTheme) {\n\n    /**\n     * Board constructor\n     */\n    var Board = function(config) {\n\n      //Initialize board\n      this.init();\n\n      //Parse config\n      this.parseConfig(config || {});\n    };\n\n    /**\n     * Initialize board\n     */\n    Board.prototype.init = function() {\n\n      //Remove everything\n      this.removeAll();\n\n      //Set board theme\n      this.theme = new BoardTheme();\n\n      //Initialize board draw dimensions in pixels\n      this.cellSize = 0;\n      this.drawWidth = 0;\n      this.drawHeight = 0;\n      this.drawMarginHor = 0;\n      this.drawMarginVer = 0;\n      this.gridDrawWidth = 0;\n      this.gridDrawHeight = 0;\n\n      //Set layer order\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\n\n      //Initialize layers\n      this.layers = {};\n      for (var l = 0; l < this.layerOrder.length; l++) {\n        var layer = this.layerOrder[l];\n        var layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\n        var LayerClass = $injector.get(layerClass);\n        this.layers[layer] = new LayerClass(this);\n      }\n\n      //Static board flag\n      this.static = false;\n\n      //Get margin from theme\n      this.margin = this.theme.get('board.margin');\n\n      //Color multiplier (to allow color swapping)\n      this.colorMultiplier = 1;\n\n      //Turn off coordinates\n      this.coordinates = false;\n      this.layers.grid.setCoordinates(false);\n\n      //Initialize grid size\n      this.width = 0;\n      this.height = 0;\n\n      //Initialize cutoff\n      this.cutoff = {\n        top: false,\n        left: false,\n        right: false,\n        bottom: false\n      };\n\n      //Initialize section\n      this.section = {\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    };\n\n    /**\n     * Link the board to a HTML element\n     */\n    Board.prototype.linkElement = function(element) {\n      this.element = element;\n    };\n\n    /**\n     * Make this board static (one canvas layer, only grid, stones and markup)\n     */\n    Board.prototype.makeStatic = function() {\n      this.static = true;\n      this.layerOrder = ['grid', 'stones', 'markup'];\n    };\n\n    /*****************************************************************************\n     * Configuration\n     ***/\n\n    /**\n     * Parse config instructions\n     */\n    Board.prototype.parseConfig = function(config) {\n\n      //Validate\n      if (typeof config !== 'object') {\n        return;\n      }\n\n      //Extend from default config\n      config = angular.extend({}, defaultConfig, config);\n\n      //Process settigns\n      this.toggleCoordinates(config.coordinates);\n      this.swapColors(config.color_multiplier);\n      this.setCutoff(config.cutoff);\n      this.setSection(config.section);\n      this.setSize(config.width, config.height);\n    };\n\n    /**\n     * Set margin\n     */\n    Board.prototype.setMargin = function(margin) {\n\n      //Reset when not defined\n      if (typeof margin === 'undefined') {\n        margin = this.theme.get('board.margin');\n      }\n\n      //Set margin if changed\n      if (this.margin !== margin) {\n        this.margin = margin;\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set grid cut-off\n     */\n    Board.prototype.setCutoff = function(cutoff) {\n\n      //Nothing given? Reset cutoff\n      if (!cutoff || !angular.isArray(cutoff)) {\n        cutoff = [];\n      }\n\n      //Init\n      var changes = false;\n\n      //Check if there's a change\n      for (var side in this.cutoff) {\n        if (this.cutoff.hasOwnProperty(side)) {\n          if (cutoff.indexOf(side) !== -1) {\n            if (!this.cutoff[side]) {\n              this.cutoff[side] = true;\n              changes = true;\n            }\n          }\n          else {\n            if (this.cutoff[side]) {\n              this.cutoff[side] = false;\n              changes = true;\n            }\n          }\n        }\n      }\n\n      //Trigger resized if there were changes\n      if (changes) {\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set section of the board to be displayed\n     */\n    Board.prototype.setSection = function(section) {\n\n      //Nothing given?\n      if (!section || typeof section !== 'object') {\n        return this;\n      }\n\n      //Expand on default\n      section = angular.extend({\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      }, section);\n\n      //No changes?\n      if (\n        this.section.top === section.top && this.section.bottom === section.bottom &&\n        this.section.left === section.left && this.section.right === section.right\n      ) {\n        return this;\n      }\n\n      //Set section and call resized handler\n      this.section = section;\n      this.resized();\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set board size. This will clear the board objects.\n     */\n    Board.prototype.setSize = function(width, height) {\n\n      //Check what's given\n      width = parseInt(width || height || 0);\n      height = parseInt(height || width || 0);\n\n      //Invalid?\n      if (isNaN(width) || isNaN(height)) {\n        return;\n      }\n\n      //Changing?\n      if (width !== this.width || height !== this.height) {\n\n        //Remember size\n        this.width = width;\n        this.height = height;\n\n        //Set size in layers\n        for (var layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].setSize(width, height);\n          }\n        }\n\n        //Broadcast event (no call to resized, as that is handled in the directive)\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set new draw size\n     */\n    Board.prototype.setDrawSize = function(width, height) {\n      if (width !== this.drawWidth || height !== this.drawHeight) {\n        this.drawWidth = width;\n        this.drawHeight = height;\n        this.resized();\n      }\n    };\n\n    /**\n     * Toggle the coordinates\n     */\n    Board.prototype.toggleCoordinates = function(show) {\n\n      //Set or toggle\n      if (typeof show !== 'undefined') {\n        this.coordinates = show;\n      }\n      else {\n        this.coordinates = !this.coordinates;\n      }\n\n      //Set in grid layer\n      this.layers.grid.setCoordinates(this.coordinates);\n\n      //Set the proper board margin\n      if (this.coordinates) {\n        this.setMargin(this.theme.get('coordinates.margin'));\n      }\n      else {\n        this.setMargin(this.theme.get('board.margin'));\n      }\n    };\n\n    /**\n     * Swap colors on the board\n     */\n    Board.prototype.swapColors = function(multiplier) {\n\n      //Multiplier not given? Set to inverse of current value\n      if (typeof multiplier === 'undefined') {\n        multiplier = -this.colorMultiplier;\n      }\n      else {\n        multiplier = parseInt(multiplier);\n        if (isNaN(multiplier)) {\n          return;\n        }\n      }\n\n      //No change?\n      if (multiplier === this.colorMultiplier) {\n        return;\n      }\n\n      //Set new value\n      this.colorMultiplier = multiplier;\n\n      //For static board, redraw the whole thing\n      if (this.static) {\n        this.redraw();\n      }\n\n      //For a dynamic board, only these layers\n      else {\n        this.redraw('stones');\n        this.redraw('markup');\n      }\n    };\n\n    /*****************************************************************************\n     * Theme handling\n     ***/\n\n    /**\n     * Get the current theme object\n     */\n    Board.prototype.getTheme = function() {\n      return this.theme;\n    };\n\n    /**\n     * Set the theme object\n     */\n    Board.prototype.setTheme = function(theme) {\n      this.theme = theme;\n      return this;\n    };\n\n    /*****************************************************************************\n     * Object handling\n     ***/\n\n    /**\n     * Add an object to a board layer\n     */\n    Board.prototype.add = function(layer, x, y, value) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].add(x, y, value);\n      }\n    };\n\n    /**\n     * Remove an object from a board layer\n     */\n    Board.prototype.remove = function(layer, x, y) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].remove(x, y);\n      }\n    };\n\n    /**\n     * Get something from a board layer\n     */\n    Board.prototype.get = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].get(x, y));\n    };\n\n    /**\n     * Check if we have something at given coordinates for a given layer\n     */\n    Board.prototype.has = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].has(x, y));\n    };\n\n    /**\n     * Set all objects (grid) for a given layer\n     */\n    Board.prototype.setAll = function(layer, grid) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].setAll(grid);\n      }\n    };\n\n    /**\n     * Remove all objects from the board, optionally for a given layer\n     */\n    Board.prototype.removeAll = function(layer) {\n      if (layer) {\n        if (typeof this.layers[layer] !== 'undefined') {\n          this.layers[layer].removeAll();\n        }\n      }\n      else {\n        for (layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].removeAll();\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Position handling\n     ***/\n\n    /**\n     * Update the board with a new position\n     */\n    Board.prototype.updatePosition = function(position, pathChanged) {\n\n      //If we have no grid size yet, use what's in the position\n      if (!this.width || !this.height) {\n        this.setSize(position.width, position.height);\n      }\n\n      //Remove markup if path changed\n      if (pathChanged) {\n        this.removeAll('markup');\n      }\n\n      //Set new stones and markup grids\n      this.setAll('stones', position.stones);\n      this.setAll('markup', position.markup);\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state (list of objects per layer)\n     */\n    Board.prototype.getState = function(layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          return this.layers[layer].getAll();\n        }\n        return null;\n      }\n\n      //All layers\n      var state = {};\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          var grid = this.layers[layer].getAll();\n          if (grid && !grid.isEmpty()) {\n            state[layer] = grid;\n          }\n        }\n      }\n      return state;\n    };\n\n    /**\n     * Restore the board state from given state object\n     */\n    Board.prototype.restoreState = function(state, layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          this.layers[layer].setAll(state);\n        }\n        return;\n      }\n\n      //All layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].removeAll();\n          if (state[layer]) {\n            this.layers[layer].setAll(state[layer]);\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing control\n     ***/\n\n    /**\n     * Clear the whole board\n     */\n    Board.prototype.clear = function(layer) {\n\n      //Just clearing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Clear the layer\n        this.layers[layer].clear();\n        return;\n      }\n\n      //Static? One clear is enough\n      if (this.static) {\n        this.layers.stones.clear();\n        return;\n      }\n\n      //Clear all layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].clear();\n        }\n      }\n    };\n\n    /**\n     * Redraw everything or just a single layer\n     */\n    Board.prototype.redraw = function(layer) {\n\n      //The board can only be redrawn when there is a grid size and a draw size\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Just redrawing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Redraw the layer\n        this.layers[layer].redraw();\n        return;\n      }\n\n      //Clear the board first\n      this.clear();\n\n      //Now draw all layers again in the correct order\n      for (var i = 0; i < this.layerOrder.length; i++) {\n        layer = this.layerOrder[i];\n        this.layers[layer].draw();\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing helpers\n     ***/\n\n    /**\n     * Called after a board size change, draw size change, section change or margin change\n     */\n    Board.prototype.resized = function() {\n\n      //Determine the new grid\n      this.grid = {\n        xLeft: 0 + this.section.left,\n        xRight: this.width - 1 - this.section.right,\n        yTop: 0 + this.section.top,\n        yBot: this.height - 1 - this.section.bottom\n      };\n\n      //Only redraw when there is sensible data\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Determine number of cells horizontall and vertically\n      //The margin is a factor of the cell size, so let's add it to the number of cells\n      var noCellsHor = this.width + this.margin;\n      var noCellsVer = this.height + this.margin;\n\n      //Are we cutting off parts of the grid? Add half a cell of draw size\n      for (var side in this.cutoff) {\n        if (this.cutoff[side]) {\n          if (side === 'top' || side === 'bottom') {\n            noCellsVer += 0.5;\n          }\n          else {\n            noCellsHor += 0.5;\n          }\n        }\n      }\n\n      //Determine cell size now\n      this.cellSize = Math.floor(Math.min(\n        this.drawWidth / noCellsHor,\n        this.drawHeight / noCellsVer\n      ));\n\n      //Determine actual grid draw size (taking off the margin again)\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\n\n      //Determine draw margins\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\n\n      //Redraw\n      this.redraw();\n    };\n\n    /**\n     * Get the current cell size\n     */\n    Board.prototype.getCellSize = function() {\n      return this.cellSize;\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsX = function(gridX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsY = function(gridY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridX = function(absX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridY = function(absY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\n    };\n\n    /**\n     * Check if given grid coordinates are on board\n     */\n    Board.prototype.isOnBoard = function(gridX, gridY) {\n      return (\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\n      );\n    };\n\n    //Return object\n    return Board;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\n * a small rectangular area on the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('DefaultClearHandler', function() {\n\n  /**\n   * Clear handler definition\n   *\n   * All external handlers are called from the context of the layer that contains the object.\n   * First parameter is the canvas2d context, second parameter is the object itself.\n   */\n  return function(context, obj) {\n\n    //No context?\n    if (!context) {\n      return;\n    }\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(obj.x);\n    var y = this.board.getAbsY(obj.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Clear rectangle the size of the stone radius\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\n * stone color values for the game position class. It has built in validation of coordinates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Grid.Service', [\n  'ngGo',\n  'ngGo.Board.GridChanges.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGrid', ['BoardGridChanges', function(BoardGridChanges) {\n\n  /**\n   * Helper to convert a value at given coordinates to an object\n   */\n  var toObject = function(x, y, valueKey) {\n\n    //Create coordinates object\n    var obj = {\n      x: x,\n      y: y\n    };\n\n    //Already an object?\n    if (typeof this.grid[x][y] === 'object') {\n      return angular.extend(obj, this.grid[x][y]);\n    }\n\n    //Not an object, set value with given value key and return\n    obj[valueKey] = this.grid[x][y];\n    return obj;\n  };\n\n  /**\n   * Constructor\n   */\n  var BoardGrid = function(width, height, emptyValue) {\n\n    //Initialize size and grid array\n    this.width = 0;\n    this.height = 0;\n    this.grid = [];\n    this.emptyValue = null;\n\n    //Set empty value if given\n    if (typeof emptyValue !== 'undefined') {\n      this.emptyValue = emptyValue;\n    }\n\n    //Size given? Set it\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set a value\n   */\n  BoardGrid.prototype.set = function(x, y, value) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = value;\n    }\n  };\n\n  /**\n   * Unset a value\n   */\n  BoardGrid.prototype.unset = function(x, y) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = this.emptyValue;\n    }\n  };\n\n  /**\n   * Check if we have a non null value on the coordinates\n   */\n  BoardGrid.prototype.has = function(x, y) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\n  };\n\n  /**\n   * Check if we have a specific value on the coordinates\n   */\n  BoardGrid.prototype.is = function(x, y, value) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\n  };\n\n  /**\n   * Get a value, or an object with coordinates and the value in the given value key\n   */\n  BoardGrid.prototype.get = function(x, y, valueKey) {\n\n    //Validate\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\n      return this.emptyValue;\n    }\n\n    //Return as is?\n    if (!valueKey) {\n      return this.grid[x][y];\n    }\n\n    //Return as object\n    return toObject.call(this, x, y, valueKey);\n  };\n\n  /*****************************************************************************\n   * Mass operations\n   ***/\n\n  /**\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\n   * and the value in the given value key will be returned.\n   */\n  BoardGrid.prototype.all = function(valueKey) {\n\n    //Just get the grid?\n    if (!valueKey) {\n      return this.grid;\n    }\n\n    //Initialize objects list\n    var objects = [];\n\n    //Loop coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          objects.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return objects list\n    return objects;\n  };\n\n  /**\n   * Check if there is anything\n   */\n  BoardGrid.prototype.isEmpty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Populate the whole grid with a given value\n   */\n  BoardGrid.prototype.populate = function(value) {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = value;\n      }\n    }\n  };\n\n  /**\n   * Empty the grid\n   */\n  BoardGrid.prototype.empty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Clone ourselves\n   */\n  BoardGrid.prototype.clone = function() {\n\n    //Create new instance\n    var newGrid = new BoardGrid();\n\n    //Manually set vars for maximum efficiency\n    newGrid.grid = angular.copy(this.grid);\n    newGrid.emptyValue = this.emptyValue;\n    newGrid.width = this.width;\n    newGrid.height = this.height;\n\n    //Return\n    return newGrid;\n  };\n\n  /*****************************************************************************\n   * Comparison\n   ***/\n\n  /**\n   * Checks if a given grid is the same as the current grid\n   */\n  BoardGrid.prototype.isSameAs = function(grid) {\n\n    //Must have the same size\n    if (this.width !== grid.width || this.height !== grid.height) {\n      return false;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== grid[x][y]) {\n          return false;\n        }\n      }\n    }\n\n    //No differences found\n    return true;\n  };\n\n  /**\n   * Compares this position with another position and return change object\n   */\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\n\n    //Initialize board grid changes object\n    var changes = new BoardGridChanges();\n\n    //Must have the same size\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\n      console.warn('Trying to compare grids of a different size');\n      return changes;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n\n        //Something to add?\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\n        }\n\n        //Something to remove?\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.remove.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return changes grid\n    return changes;\n  };\n\n  /*****************************************************************************\n   * Helpers\n   ***/\n\n  /**\n   * Helper to validate coordinates (first param can be an object)\n   */\n  BoardGrid.prototype.isOnGrid = function(x, y) {\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\n  };\n\n  /**\n   * Helper to set the empty value\n   */\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\n    this.emptyValue = emptyValue;\n  };\n\n  /**\n   * Set the grid size\n   */\n  BoardGrid.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Create grid array\n    this.grid = [];\n    for (var x = 0; x < this.width; x++) {\n      this.grid[x] = [];\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Get the grid size object\n   */\n  BoardGrid.prototype.getSize = function() {\n    return {width: this.width, height: this.height};\n  };\n\n  //Return\n  return BoardGrid;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\n * grids. It simply keeps track of what was added and what was removed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.GridChanges.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGridChanges', function() {\n\n  /**\n   * Helper to subtract sets\n   */\n  var setSubtract = function(a, b) {\n    var n = [];\n    var q;\n    for (var i = 0; i < a.length; i++) {\n      q = true;\n      for (var j in b) {\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\n          q = false;\n          break;\n        }\n      }\n      if (q) {\n        n.push(a[i]);\n      }\n    }\n    return n;\n  };\n\n  /**\n   * Game position constructor\n   */\n  return function() {\n\n    /**\n     * Containers\n     */\n    this.add = [];\n    this.remove = [];\n\n    /**\n     * Concatenation helper\n     */\n    this.concat = function(newChanges) {\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\n    };\n\n    /**\n     * Check if there are changes\n     */\n    this.has = function() {\n      return !!(this.add.length || this.remove.length);\n    };\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\n * for drawing itself as well as its objects onto the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardLayer', ['BoardGrid', function(BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var BoardLayer = function(board, context) {\n\n    //Remember board reference and 2d canvas context\n    this.board = board;\n    this.context = context;\n\n    //Initialize grid for board objects\n    this.grid = new BoardGrid();\n  };\n\n  /*****************************************************************************\n   * Generic grid and object handling\n   ***/\n\n  /**\n   * Set grid size\n   */\n  BoardLayer.prototype.setSize = function(width, height) {\n\n    //Note: since this method is usually only called upon a global board resize,\n    //which also triggers the redraw method for layers, the layer is not cleared\n    //here, as it will happen anyway during the redraw cycle.\n\n    //Set it in the grid (removing all objects in the process)\n    this.grid.setSize(width, height);\n  };\n\n  /**\n   * Get all items\n   */\n  BoardLayer.prototype.getAll = function() {\n    return this.grid.clone();\n  };\n\n  /**\n   * Set all items at once\n   */\n  BoardLayer.prototype.setAll = function(grid) {\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  BoardLayer.prototype.removeAll = function() {\n    this.clear();\n    this.grid.empty();\n  };\n\n  /**\n   * Add a single item\n   */\n  BoardLayer.prototype.add = function(x, y, value) {\n    this.clearCell(x, y);\n    this.grid.set(x, y, value);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Remove a single item\n   */\n  BoardLayer.prototype.remove = function(x, y) {\n    this.clearCell(x, y);\n    this.grid.unset(x, y);\n  };\n\n  /**\n   * Get an item\n   */\n  BoardLayer.prototype.get = function(x, y) {\n    return this.grid.get(x, y);\n  };\n\n  /**\n   * Check if there is an item\n   */\n  BoardLayer.prototype.has = function(x, y) {\n    return this.grid.has(x, y);\n  };\n\n  /*****************************************************************************\n   * Generic drawing methods\n   ***/\n\n  /**\n   * Draw layer\n   */\n  BoardLayer.prototype.draw = function() {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\n   */\n  BoardLayer.prototype.clear = function() {\n    if (this.context) {\n      this.context.clearRect(\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\n      );\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  BoardLayer.prototype.redraw = function() {\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear cell\n   */\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\n    //Clearing method to be implemented in specific layer class\n  };\n\n  /**\n   * Redraw cell\n   */\n  BoardLayer.prototype.redrawCell = function(x, y) {\n    this.clearCell(x, y);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Set the canvas2d context\n   */\n  BoardLayer.prototype.setContext = function(context) {\n    this.context = context;\n  };\n\n  /**\n   * Get the canvas2d context\n   */\n  BoardLayer.prototype.getContext = function() {\n    return this.context;\n  };\n\n  //Return\n  return BoardLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardObject :: Base class for drawing board objects\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Service', [\n  'ngGo',\n  'ngGo.Board.DefaultClearHandler.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardObject', ['DefaultClearHandler', function(DefaultClearHandler) {\n\n  /**\n   * Constructor\n   */\n  var BoardObject = {\n\n    /**\n     * Draw method\n     */\n    draw: function(/*obj*/) {\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n    },\n\n    /**\n     * Clear method\n     */\n    clear: function(obj) {\n      DefaultClearHandler.call(this, this.context, obj);\n    }\n  };\n\n  //Return\n  return BoardObject;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.ShellPattern.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('ShellPattern', function() {\n\n  /**\n   * Helper to draw a shell line\n   */\n  var shellLine = function(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\n\n    //Initialize\n    ctx.shadowBlur = 2;\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = (radius / 30) * this.thickness;\n    ctx.beginPath();\n\n    //Lower radius\n    radius -= Math.max(1, ctx.lineWidth);\n\n    //Determine coordinates\n    var x1 = x + radius * Math.cos(startAngle * Math.PI);\n    var y1 = y + radius * Math.sin(startAngle * Math.PI);\n    var x2 = x + radius * Math.cos(endAngle * Math.PI);\n    var y2 = y + radius * Math.sin(endAngle * Math.PI);\n\n    //Math magic\n    var m, angle;\n    if (x2 > x1) {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m);\n    }\n    else if (x2 === x1) {\n      angle = Math.PI / 2;\n    }\n    else {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m) - Math.PI;\n    }\n\n    //Curvature factor\n    var c = this.factor * radius;\n    var dx = Math.sin(angle) * c;\n    var dy = Math.cos(angle) * c;\n\n    //Curvature coordinates\n    var bx1 = x1 + dx;\n    var by1 = y1 - dy;\n    var bx2 = x2 + dx;\n    var by2 = y2 - dy;\n\n    //Draw shell stroke\n    ctx.moveTo(x1, y1);\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\n    ctx.stroke();\n  };\n\n  /**\n   * Shell pattern drawer\n   */\n  return function(ctx, x, y, radius, angle, strokeStyle) {\n\n    //Initialize start and end angle\n    var startAngle = angle;\n    var endAngle = angle;\n\n    //Loop lines\n    for (var i = 0; i < this.lines.length; i++) {\n      startAngle += this.lines[i];\n      endAngle -= this.lines[i];\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\n    }\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\n * use static values or dynamic values depending on other properties, like the grid cell size.\n * Using the provider, the theme can be configured globally at application launch.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Theme.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.provider('BoardTheme', ['StoneColor', 'MarkupTypes', function(StoneColor, MarkupTypes) {\n\n  /**\n   * Default theme\n   */\n  var defaultTheme = {\n\n    //Board\n    board: {\n\n      //Board margin factor\n      margin: 0.25\n    },\n\n    //Stones\n    stone: {\n\n      //Stone style can be shell, glass, mono, or specify a custom handler service\n      style: 'shell',\n      shadow: true,\n      radius: function(cellSize) {\n        return Math.floor(cellSize / 2);\n      },\n\n      //Shell stones\n      shell: {\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#111';\n          }\n          return '#BFBFBA';\n        },\n        stroke: 'rgba(128,128,128,0.15)',\n        types: [\n          {\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\n            factor: 0.15,\n            thickness: 1.75\n          },\n          {\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\n            factor: 0.1,\n            thickness: 1.5\n          },\n          {\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\n            factor: 0.05,\n            thickness: 1.75\n          },\n          {\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\n            factor: 0.1,\n            thickness: 2\n          }\n        ]\n      },\n\n      //Mono stones\n      mono: {\n        lineWidth: 1,\n        lineColor: function() {\n          return '#000';\n        },\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#000';\n          }\n          return '#fff';\n        }\n      },\n\n      //Mini stones\n      mini: {\n        scale: 0.5,\n        alpha: 1\n      },\n\n      //Faded stones\n      faded: {\n        scale: 1,\n        alpha: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return 0.3;\n          }\n          return 0.4;\n        }\n      }\n    },\n\n    //Shadows\n    shadow: {\n\n      //Shadow gradient colors\n      color: 'rgba(40,30,20,0.5)',\n\n      //Shadow size\n      size: function(cellSize) {\n        return Math.floor(cellSize / 20);\n      },\n\n      //Shadow blur size\n      blur: function(cellSize) {\n        return cellSize / 20;\n      },\n\n      //Shadow offset\n      offsetX: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      },\n      offsetY: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      }\n    },\n\n    //Markup\n    markup: {\n\n      //Standard color\n      color: function(stoneColor) {\n        if (stoneColor === StoneColor.B) {\n          return 'rgba(255,255,255,0.9)';\n        }\n        return 'rgba(0,0,0,0.9)';\n      },\n\n      //Line width\n      lineWidth: function(cellSize) {\n        return Math.max(1, Math.floor(cellSize / 16));\n      },\n\n      //Triangle\n      triangle: {\n        scale: 0.85\n      },\n\n      //Square\n      square: {\n        scale: 0.85\n      },\n\n      //Cricle\n      circle: {\n        scale: 0.55\n      },\n\n      //Mark\n      mark: {\n        lineCap: 'square',\n        scale: 0.75\n      },\n\n      //Last\n      last: {\n        scale: 0.7\n      },\n\n      //Smiley\n      smiley: {\n        lineCap: 'round',\n        scale: 0.85\n      },\n\n      //Label\n      label: {\n        font: 'Arial'\n      },\n\n      //Variation markup\n      variation: {\n        type: MarkupTypes.LABEL,\n        text: function(i) {\n          return String.fromCharCode(65 + i);\n        },\n        color: 'rgba(86,114,30,0.9)'\n      },\n\n      //Solution paths markup\n      solution: {\n        valid: {\n          type: MarkupTypes.SELECT,\n          text: null,\n          color: 'rgba(86,114,30,1)',\n          scale: 0.5\n        },\n        invalid: {\n          type: MarkupTypes.MARK,\n          text: null,\n          color: 'rgba(237,9,15,1)',\n          scale: 0.3\n        }\n      }\n    },\n\n    //Grid\n    grid: {\n\n      //Line properties\n      lineColor: 'rgba(60,40,15,1)',\n      lineWidth: function(cellSize) {\n        if (cellSize > 60) {\n          return 2;\n        }\n        else if (cellSize > 50) {\n          return 1.5;\n        }\n        return 1;\n      },\n      lineCap: 'square',\n\n      //Star points\n      star: {\n\n        //Color and radius\n        color: 'rgba(60,40,15,1)',\n        radius: function(cellSize) {\n          if (cellSize > 50) {\n            return Math.floor((cellSize / 16) + 1);\n          }\n          else if (cellSize > 30) {\n            return 3;\n          }\n          else if (cellSize > 15) {\n            return 2;\n          }\n          else if (cellSize > 5) {\n            return 1.5;\n          }\n          return 1;\n        },\n\n        //Locations\n        points: function(width, height) {\n\n          //19x19\n          if (width === height && width === 19) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15,y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15,y: 9 },\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15,y: 15 }\n            ];\n          }\n\n          //13x13\n          if (width === height && width === 13) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }\n            ];\n          }\n\n          //9x9\n          if (width === height && width === 9) {\n            return [\n              { x: 4, y: 4}, { x: 2, y: 2},\n              { x: 2, y: 6}, { x: 6, y: 2},\n              { x: 6, y: 6}\n            ];\n          }\n\n          //No star points\n          return [];\n        }\n      }\n    },\n\n    //Coordinates\n    coordinates: {\n\n      //Color\n      color: 'rgba(101,69,37,0.5)',\n\n      //Board margin factor when showing coordinates\n      margin: 1.25,\n\n      //Vertical coordinates style\n      vertical: {\n        font: 'Arial',\n        style: 'numbers',\n        inverse: true,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      },\n\n      //Horizontal coordinates style\n      horizontal: {\n        font: 'Arial',\n        style: 'letters',\n        inverse: false,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      }\n    }\n  };\n\n  /**\n   * Set global default theme\n   */\n  this.setTheme = function(theme) {\n    if (theme) {\n      defaultTheme = angular.merge(defaultTheme, theme);\n    }\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function() {\n\n    /**\n     * Board theme constructor\n     */\n    var BoardTheme = function(theme) {\n\n      //Remember the given instance theme settings and (re)set the theme\n      this.instanceTheme = theme;\n      this.reset();\n    };\n\n    /**\n     * Reset the theme to defaults\n     */\n    BoardTheme.prototype.reset = function() {\n\n      //Use default theme as a base\n      this.theme = angular.copy(defaultTheme);\n\n      //Add any instance theme properties\n      if (this.instanceTheme) {\n        angular.merge(this.theme, this.instanceTheme);\n      }\n    };\n\n    /**\n     * Get a theme property\n     */\n    BoardTheme.prototype.get = function(property) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Can't find the property?\n        if (typeof prop[path[i]] === 'undefined') {\n          console.warn('Could not find theme property', property);\n          return null;\n        }\n\n        //Advance further in the object\n        prop = prop[path[i]];\n      }\n\n      //Found what we're looking for\n      if (typeof prop !== 'function') {\n        return prop;\n      }\n\n      //Prepare arguments\n      var args = [];\n      if (arguments.length > 1) {\n        for (var a = 1; a < arguments.length; a++) {\n          args.push(arguments[a]);\n        }\n      }\n\n      //Call function\n      return prop.apply(this, args);\n    };\n\n    /**\n     * Change a theme property dynamically (accepts handler function as value)\n     */\n    BoardTheme.prototype.set = function(property, value) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Time to set?\n        if ((i + 1) === path.length) {\n          prop[path[i]] = value;\n          break;\n        }\n\n        //Not set?\n        if (typeof prop[path[i]] === 'undefined') {\n          prop[path[i]] = {};\n        }\n\n        //Move on\n        prop = prop[path[i]];\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\n     */\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\n\n      //If no linewidth specified, use the grid line width as a reference\n      //to make sure stuff is aligned to the grid\n      if (typeof lineWidth === 'undefined') {\n        lineWidth = this.get('grid.lineWidth');\n      }\n\n      //Return a translation for uneven widths\n      return (lineWidth % 2) * 0.5;\n    };\n\n    //Return\n    return BoardTheme;\n  };\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidDataError :: Error class to handle invalid data.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidDataError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidDataError', ['ngGo', function(ngGo) {\n\n  /**\n   * Define error\n   */\n  var InvalidDataError = function(code) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidDataError';\n    this.message = 'Invalid data: ';\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.NO_DATA:\n        this.message += 'no data to process.';\n        break;\n      case ngGo.error.UNKNOWN_DATA:\n        this.message += 'unknown data format.';\n        break;\n      case ngGo.error.INVALID_GIB:\n        this.message += 'unable to parse GIB data.';\n        break;\n      case ngGo.error.INVALID_SGF:\n        this.message += 'unable to parse SGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_JSON:\n        this.message += 'unable to parse JGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_TREE_JSON:\n        this.message += 'unable to parse the JGF tree data.';\n        break;\n      default:\n        this.message += 'unable to parse the data.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidDataError.prototype = new Error();\n  InvalidDataError.prototype.constructor = InvalidDataError;\n\n  //Return object\n  return InvalidDataError;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidPositionError :: Error class to handle invalid moves.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidPositionError', ['ngGo', 'StoneColor', function(ngGo, StoneColor) {\n\n  /**\n   * Define error\n   */\n  var InvalidPositionError = function(code, x, y, color) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidPositionError';\n    this.message = 'Invalid position detected.';\n\n    //Add position data\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\n        ' stone on (' + x + ', ' + y + ')';\n    }\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\n        this.message += ', but these coordinates are not on the board.';\n        break;\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\n        this.message += ', but there is already a stone on those coordinates.';\n        break;\n      case ngGo.error.POSTITION_IS_SUICIDE:\n        this.message += ', but that would be suicide.';\n        break;\n      case ngGo.error.POSTITION_IS_REPEATING:\n        this.message += ', but this position already occured.';\n        break;\n      default:\n        this.message += '.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidPositionError.prototype = new Error();\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\n\n  //Return object\n  return InvalidPositionError;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Game :: This class represents a game record or a game that is being played/edited. The class\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\n * The class also keeps a stack of all board positions in memory and can validate moves to make\n * sure they are not repeating or suicide.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Service', [\n  'ngGo',\n  'ngGo.Game.Path.Service',\n  'ngGo.Game.Node.Service',\n  'ngGo.Game.Position.Service',\n  'ngGo.Kifu.Blank.Service',\n  'ngGo.Kifu.Parser.Service',\n  'ngGo.Errors.InvalidDataError.Service',\n  'ngGo.Errors.InvalidPositionError.Service'\n])\n\n/**\n * Factory definition\n */\n.provider('Game', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default size of board\n    defaultSize: 0,\n\n    //Default komi and handicap\n    defaultKomi: 0,\n    defaultHandicap: 0,\n\n    //Remember last selected variation when traversing nodes\n    rememberPath: true,\n\n    //Check for repeating positions? (KO / ALL / empty)\n    checkRepeat: 'KO',\n\n    //Allow suicide?\n    allowSuicide: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['ngGo', 'StoneColor', 'GamePath', 'GameNode', 'GamePosition', 'KifuParser', 'KifuBlank', 'InvalidDataError', 'InvalidPositionError', function(\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\n    KifuBlank, InvalidDataError, InvalidPositionError\n  ) {\n\n    /*****************************************************************************\n     * General helpers\n     ***/\n\n    /**\n     * Validate the info we have to make sure the properties exist\n     */\n    var validateInfo = function() {\n\n      //Set board info if not set\n      if (!this.info.board) {\n        this.info.board = {};\n      }\n\n      //Set game info if not set\n      if (!this.info.game) {\n        this.info.game = {};\n      }\n\n      //Set defaults\n      if (typeof this.info.board.width === 'undefined') {\n        this.info.board.width = this.config.defaultSize;\n      }\n      if (typeof this.info.board.height === 'undefined') {\n        this.info.board.height = this.config.defaultSize;\n      }\n      if (typeof this.info.game.komi === 'undefined') {\n        this.info.game.komi = this.config.defaultKomi;\n      }\n      if (typeof this.info.game.handicap === 'undefined') {\n        this.info.game.handicap = this.config.defaultHandicap;\n      }\n    };\n\n    /*****************************************************************************\n     * Node navigation helpers\n     ***/\n\n    /**\n     * Navigate to the next node\n     */\n    var nextNode = function(i) {\n\n      //Check if we have children\n      if (this.node.children.length === 0) {\n        return false;\n      }\n\n      //Remembered the path we took earlier?\n      if (i === undefined) {\n        i = this.node._remembered_path;\n      }\n\n      //Determine which child node to process\n      i = i || 0;\n      if (i === -1) {\n        i = 0;\n      }\n\n      //Validate\n      if (i >= this.node.children.length || !this.node.children[i]) {\n        return false;\n      }\n\n      //Advance path\n      this.path.advance(i);\n\n      //Set pointer of current node\n      this.node = this.node.children[i];\n      return true;\n    };\n\n    /**\n     * Navigate to the previous node\n     */\n    var previousNode = function() {\n\n      //No parent node?\n      if (!this.node.parent) {\n        return false;\n      }\n\n      //Retreat path\n      this.path.retreat();\n\n      //Set pointer of current node\n      this.node = this.node.parent;\n      return true;\n    };\n\n    /**\n     * Navigate to the first node\n     */\n    var firstNode = function() {\n\n      //Reset path\n      this.path.reset();\n\n      //Set node pointer back to root\n      this.node = this.root;\n\n      //Set the initial turn depending on handicap (can be overwritten by game record instructions)\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\n    };\n\n    /*****************************************************************************\n     * Position history helpers\n     ***/\n\n    /**\n     * Clear the position history and initialize with a blank position\n     */\n    var initializeHistory = function() {\n\n      //Already at beginning?\n      if (this.history.length === 1) {\n        return;\n      }\n\n      //Clear positions stack and create new blank position\n      this.history = [];\n      this.history.push(new GamePosition());\n\n      //Set board size if we have the info\n      if (this.info.board) {\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\n      }\n    };\n\n    /**\n     * Add position to stack. If position isn't specified current position is\n     * cloned and stacked. Pointer of actual position is moved to the new position.\n     */\n    var pushPosition = function(newPosition) {\n\n      //Position not given?\n      if (!newPosition) {\n        newPosition = this.position.clone();\n      }\n\n      //Push\n      this.history.push(newPosition);\n      return newPosition;\n    };\n\n    /**\n     * Remove current position from stack\n     */\n    var popPosition = function() {\n\n      //Nothing left?\n      if (this.history.length === 0) {\n        return null;\n      }\n\n      //Get old position\n      return this.history.pop();\n    };\n\n    /**\n     * Replace the current position in the stack\n     */\n    var replacePosition = function(newPosition) {\n      if (newPosition) {\n        this.history.pop();\n        this.history.push(newPosition);\n      }\n    };\n\n    /*****************************************************************************\n     * Execution helpers\n     ***/\n\n    /**\n     * Execute the current node\n     */\n    var executeNode = function() {\n\n      //Remember last selected node if we have a parent\n      if (this.node.parent) {\n        this.node.parent._remembered_path = this.node.parent.children.indexOf(this.node);\n      }\n\n      //Initialize new position\n      var i;\n      var newPosition = this.position.clone();\n\n      //Handle moves\n      if (this.node.move) {\n        if (this.node.move.pass) {\n          newPosition.setTurn(-this.node.move.color);\n        }\n        else {\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\n        }\n      }\n\n      //Handle turn instructions\n      if (this.node.turn) {\n        newPosition.setTurn(this.node.turn);\n      }\n\n      //Handle setup instructions\n      if (this.node.setup) {\n        for (i in this.node.setup) {\n          if (this.node.setup.hasOwnProperty(i)) {\n            newPosition.stones.set(\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\n            );\n          }\n        }\n      }\n\n      //Handle markup\n      if (this.node.markup) {\n        for (i in this.node.markup) {\n          if (this.node.markup.hasOwnProperty(i)) {\n            newPosition.markup.set(\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\n            );\n          }\n        }\n      }\n\n      //Push the new position into the history now\n      pushPosition.call(this, newPosition);\n    };\n\n    /*****************************************************************************\n     * Game class\n     ***/\n\n    /**\n     * Constructor\n     */\n    var Game = function(data, config) {\n\n      //Extend config\n      this.config = angular.extend({}, defaultConfig, config || {});\n\n      //Define property getter/setter for position\n      Object.defineProperty(this, 'position', {\n\n        //Getter returns the last position from the stack\n        get: function() {\n          return this.history[this.history.length - 1];\n        },\n\n        //Setter adds a new position to the stack\n        set: function(newPosition) {\n          this.history[this.history.length] = newPosition;\n        }\n      });\n\n      //Load data\n      if (data) {\n        this.load(data);\n      }\n      else {\n        this.init();\n      }\n    };\n\n    /**\n     * Initialize\n     */\n    Game.prototype.init = function() {\n\n      //Info properties\n      this.info = {};\n\n      //The rood node and pointer to the current node\n      this.root = null;\n      this.node = null;\n\n      //Game path\n      this.path = new GamePath();\n\n      //JGF record we loaded from\n      this.jgf = null;\n\n      //Positions history stack\n      this.history = [];\n    };\n\n    /**\n     * Load game record data\n     */\n    Game.prototype.load = function(data) {\n\n      //Initialize\n      this.init();\n\n      //Try to load game record data\n      try {\n        this.fromData(data);\n      }\n      catch (errorCode) {\n\n        //Just initialize our history with a blank position\n        initializeHistory.call(this);\n\n        //Wrap error code in error object\n        throw new InvalidDataError(errorCode);\n      }\n\n      //Go to the first move\n      this.first();\n    };\n\n    /**\n     * Reload game record\n     */\n    Game.prototype.reload = function() {\n      if (this.jgf) {\n        this.load(this.jgf);\n      }\n    };\n\n    /**\n     * Check if we managed to load a valid game record\n     */\n    Game.prototype.isLoaded = function() {\n      return this.root !== null;\n    };\n\n    /*****************************************************************************\n     * Game cloning and conversion\n     ***/\n\n    /**\n     * Clone this game\n     */\n    Game.prototype.clone = function() {\n\n      //Create new kifu object and get properties\n      var clone = new Game();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy all properties\n      for (var p = 0; p < props.length; p++) {\n        clone[p] = angular.copy(this[p]);\n      }\n\n      //Return clone\n      return clone;\n    };\n\n    /**\n     * Load from an unknown data source\n     */\n    Game.prototype.fromData = function(data) {\n\n      //No data, can't do much\n      if (!data) {\n        throw ngGo.error.NO_DATA;\n      }\n\n      //String given, could be stringified JGF, an SGF or GIB file\n      if (typeof data === 'string') {\n        var c = data.charAt(0);\n        if (c === '(') {\n          return this.fromSgf(data);\n        }\n        else if (c === '{' || c === '[') {\n          return this.fromJgf(data);\n        }\n        else if (c === '\\\\') {\n          return this.fromGib(data);\n        }\n        else {\n          throw ngGo.error.UNKNOWN_DATA;\n        }\n      }\n\n      //Object given? Probably a JGF object\n      else if (typeof data === 'object') {\n        this.fromJgf(data);\n      }\n\n      //Something else?\n      else {\n        throw ngGo.error.UNKNOWN_DATA;\n      }\n    };\n\n    /**\n     * Load from GIB data\n     */\n    Game.prototype.fromGib = function(gib) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.gib2jgf(gib);\n      if (!jgf) {\n        throw ngGo.error.INVALID_GIB;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from SGF data\n     */\n    Game.prototype.fromSgf = function(sgf) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.sgf2jgf(sgf);\n      if (!jgf) {\n        throw ngGo.error.INVALID_SGF;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from JGF data\n     */\n    Game.prototype.fromJgf = function(jgf) {\n\n      //Parse jgf string\n      if (typeof jgf === 'string') {\n        try {\n          jgf = angular.fromJson(jgf);\n        }\n        catch (error) {\n          throw ngGo.error.INVALID_JGF_JSON;\n        }\n      }\n\n      //If array given, convert to object with only tree\n      if (angular.isArray(jgf)) {\n        jgf = {\n          tree: jgf\n        };\n      }\n\n      //Parse tree string\n      if (typeof jgf.tree === 'string') {\n        if (jgf.tree.charAt(0) === '[') {\n          try {\n            jgf.tree = angular.fromJson(jgf.tree);\n          }\n          catch (error) {\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\n          }\n        }\n        else {\n          jgf.tree = [];\n        }\n      }\n\n      //Copy all properties except moves tree\n      for (var i in jgf) {\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\n          this.info[i] = angular.copy(jgf[i]);\n        }\n      }\n\n      //Validate info\n      validateInfo.call(this);\n\n      //Create root node\n      this.root = new GameNode();\n\n      //Tree given? Load all the moves\n      if (jgf.tree) {\n        this.root.fromJgf(jgf.tree);\n      }\n\n      //Remember JGF\n      this.jgf = jgf;\n    };\n\n    /**\n     * Convert to SGF\n     */\n    Game.prototype.toSgf = function() {\n      return KifuParser.jgf2sgf(this.toJgf());\n    };\n\n    /**\n     * Convert to JGF (optionally stringified)\n     */\n    Game.prototype.toJgf = function(stringify) {\n\n      //Initialize JGF and get properties\n      var jgf = KifuBlank.jgf();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy properties\n      for (var p = 0; p < props.length; p++) {\n\n        //Skip root\n        if (p === 'root') {\n          continue;\n        }\n\n        //Already present on JGF object? Extend\n        if (jgf[p]) {\n          jgf[p] = angular.extend(jgf[p], this[p]);\n        }\n\n        //Otherwise copy\n        else {\n          jgf[p] = angular.copy(this[p]);\n        }\n      }\n\n      //Build tree\n      jgf.tree = this.root.toJgf();\n\n      //Return\n      return stringify ? angular.toJson(jgf) : jgf;\n    };\n\n    /*****************************************************************************\n     * Getters\n     ***/\n\n    /**\n     * Get current node\n     */\n    Game.prototype.getNode = function() {\n      return this.node;\n    };\n\n    /**\n     * Get the current game position\n     */\n    Game.prototype.getPosition = function() {\n      return this.position;\n    };\n\n    /**\n     * Get the game path\n     */\n    Game.prototype.getPath = function(clone) {\n      if (clone) {\n        return this.path.clone();\n      }\n      return this.path;\n    };\n\n    /**\n     * Clone the current game path\n     */\n    Game.prototype.clonePath = function() {\n      return this.path.clone();\n    };\n\n    /**\n     * Get the game path to a certain named node\n     */\n    Game.prototype.getPathToNode = function(nodeName) {\n      return GamePath.findNode(nodeName, this.root);\n    };\n\n    /**\n     * Get the game komi\n     */\n    Game.prototype.getKomi = function() {\n      if (!this.info.game.komi) {\n        return 0;\n      }\n      return parseFloat(this.info.game.komi);\n    };\n\n    /**\n     * Set the game komi\n     */\n    Game.prototype.setKomi = function(komi) {\n      this.info.game.komi = komi ? parseFloat(komi) : this.config.defaultKomi;\n    };\n\n    /**\n     * Get the player turn for this position\n     */\n    Game.prototype.getTurn = function() {\n\n      //Must have a position\n      if (!this.history.length) {\n        return StoneColor.B;\n      }\n\n      //Get from position\n      return this.position.getTurn();\n    };\n\n    /**\n     * Set the player turn for the current position\n     */\n    Game.prototype.setTurn = function(color) {\n\n      //Must have a position\n      if (!this.history.length) {\n        return;\n      }\n\n      //Set in position\n      this.position.setTurn(color);\n    };\n\n    /**\n     * Get the total capture count up to the current position\n     */\n    Game.prototype.getCaptureCount = function() {\n\n      //Initialize\n      var captures = {};\n      captures[StoneColor.B] = 0;\n      captures[StoneColor.W] = 0;\n\n      //Loop all positions and increment capture count\n      for (var i = 0; i < this.history.length; i++) {\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\n      }\n\n      //Return\n      return captures;\n    };\n\n    /**\n     * Get the move variation for given coordinates\n     */\n    Game.prototype.getMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.getMoveVariation(x, y);\n      }\n      return -1;\n    };\n\n    /**\n     * Get current move number\n     */\n    Game.prototype.getMove = function() {\n      return this.path.getMove();\n    };\n\n    /**\n     * Get the number of moves in the main branch\n     */\n    Game.prototype.getMoveCount = function() {\n\n      //Initialize node to process\n      var node = this.root;\n      var noMoves = 0;\n\n      //Process children\n      while (node.children.length > 0) {\n        node = node.children[0];\n        if (typeof node.move !== 'undefined') {\n          noMoves++;\n        }\n      }\n\n      //Return move count\n      return noMoves;\n    };\n\n    /**\n     * Get an info property\n     */\n    Game.prototype.get = function(position) {\n\n      //Must have a position\n      if (!position) {\n        return;\n      }\n\n      //The item's position in the object is given by dot separated strings\n      if (typeof position === 'string') {\n        position = position.split('.');\n      }\n\n      //Initialize object we're getting info from\n      var obj = this.info;\n      var key;\n\n      //Loop the position\n      for (var p = 0; p < position.length; p++) {\n\n        //Get actual key\n        key = position[p];\n\n        //Last key reached? Done, get value\n        if ((p + 1) === position.length) {\n          return obj[key];\n        }\n\n        //Must be object container\n        if (typeof obj[key] !== 'object') {\n          console.warn('Game property', key, 'is not an object');\n          return;\n        }\n\n        //Move up in tree\n        obj = obj[key];\n      }\n    };\n\n    /*****************************************************************************\n     * Checkers\n     ***/\n\n    /**\n     * Check if coordinates are on the board\n     */\n    Game.prototype.isOnBoard = function(x, y) {\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\n    };\n\n    /**\n     * Check if given coordinates are one of the next child node coordinates\n     */\n    Game.prototype.isMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.isMoveVariation(x, y);\n      }\n      return false;\n    };\n\n    /**\n     * Check if a given position is repeating within this game\n     */\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\n\n      //Init\n      var stop;\n\n      //Check for ko only? (Last two positions)\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\n        stop = this.history.length - 2;\n      }\n\n      //Check all history?\n      else if (this.checkRepeat === 'ALL') {\n        stop = 0;\n      }\n\n      //Not repeating\n      else {\n        return false;\n      }\n\n      //Loop history of positions to check\n      for (var i = this.history.length - 2; i >= stop; i--) {\n        if (checkPosition.isSameAs(this.history[i])) {\n          return true;\n        }\n      }\n\n      //Not repeating\n      return false;\n    };\n\n    /**\n     * Wrapper for validateMove() returning a boolean and catching any errors\n     */\n    Game.prototype.isValidMove = function(x, y, color) {\n      try {\n        this.validateMove(x, y, color);\n        return true;\n      }\n      catch (error) {\n        return false;\n      }\n    };\n\n    /**\n     * Check if a move is valid. If valid, the new game position object is returned.\n     * You can supply a pre-created position to use, or the current position is cloned.\n     */\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Something already here?\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\n      }\n\n      //Set color of move to make\n      color = color || this.position.getTurn();\n\n      //Determine position to use\n      newPosition = newPosition || this.position.clone();\n\n      //Place the stone\n      newPosition.stones.set(x, y, color);\n\n      //Capture adjacent stones if possible\n      var captures = newPosition.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created?\n        if (!newPosition.hasLiberties(x, y)) {\n\n          //Capture the group if it's allowed\n          if (this.allowSuicide) {\n            newPosition.captureGroup(x, y);\n          }\n\n          //Invalid move\n          else {\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\n          }\n        }\n      }\n\n      //Check history for repeating moves\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\n      }\n\n      //Set proper turn\n      newPosition.setTurn(-color);\n\n      //Move is valid\n      return newPosition;\n    };\n\n    /**\n     * Check if a stone (setup) placement is valid.\n     */\n    Game.prototype.validatePlacement = function(x, y, color, position) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Place the stone\n      position.stones.set(x, y, color);\n\n      //Empty spot? Don't need to check for captures\n      if (color === StoneColor.EMPTY) {\n        return;\n      }\n\n      //Capture adjacent stones if possible\n      var captures = position.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created? Capture it\n        if (!position.hasLiberties(x, y)) {\n          position.captureGroup(x, y);\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Stone and markup handling\n     ***/\n\n    /**\n     * Add a stone\n     */\n    Game.prototype.addStone = function(x, y, color) {\n\n      //Check if there's anything to do at all\n      if (this.position.stones.is(x, y, color)) {\n        return;\n      }\n\n      //Create temporary position\n      var tempPosition = this.position.clone();\n\n      //Validate placement on temp position\n      this.validatePlacement(x, y, color, tempPosition);\n\n      //No setup instructions container in this node?\n      if (typeof this.node.setup === 'undefined') {\n\n        //Is this a move node?\n        if (this.node.move) {\n\n          //Clone our position\n          pushPosition.call(this);\n\n          //Create new node\n          var node = new GameNode();\n\n          //Append it to the current node and change the pointer\n          var i = node.appendTo(this.node);\n          this.node = node;\n\n          //Advance path to the added node index\n          this.path.advance(i);\n        }\n\n        //Create setup container in this node\n        this.node.setup = [];\n      }\n\n      //Replace current position\n      replacePosition.call(this, tempPosition);\n\n      //Add setup instructions to node\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\n    };\n\n    /**\n     * Add markup\n     */\n    Game.prototype.addMarkup = function(x, y, markup) {\n\n      //No markup instructions container in this node?\n      if (typeof this.node.markup === 'undefined') {\n        this.node.markup = [];\n      }\n\n      //Add markup to game position\n      this.position.markup.set(x, y, markup);\n\n      //Add markup instructions to node\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\n    };\n\n    /**\n     * Remove a stone\n     */\n    Game.prototype.removeStone = function(x, y) {\n\n      //Check if the stone is found in setup instructions\n      var foundInSetup = false;\n\n      //Remove from node setup instruction\n      if (typeof this.node.setup !== 'undefined') {\n        for (var i = 0; i < this.node.setup.length; i++) {\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\n\n            //Remove from node and unset in position\n            this.node.setup.splice(i, 1);\n            this.position.stones.unset(x, y);\n\n            //Mark as found\n            foundInSetup = true;\n            break;\n          }\n        }\n      }\n\n      //Not found in setup? Add as no stone color\n      if (!foundInSetup) {\n        this.addStone(x, y, StoneColor.EMPTY);\n      }\n    };\n\n    /**\n     * Remove markup\n     */\n    Game.prototype.removeMarkup = function(x, y) {\n\n      //Remove from node\n      if (typeof this.node.markup !== 'undefined') {\n        for (var i = 0; i < this.node.markup.length; i++) {\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\n            this.node.markup.splice(i, 1);\n            this.position.markup.unset(x, y);\n            break;\n          }\n        }\n      }\n    };\n\n    /**\n     * Check if there is a stone at the given coordinates for the current position\n     */\n    Game.prototype.hasStone = function(x, y, color) {\n      if (typeof color !== 'undefined') {\n        return this.position.stones.is(x, y, color);\n      }\n      return this.position.stones.has(x, y);\n    };\n\n    /**\n     * Check if there is markup at the given coordinate for the current position\n     */\n    Game.prototype.hasMarkup = function(x, y, type) {\n      if (typeof type !== 'undefined') {\n        return this.position.markup.is(x, y, type);\n      }\n      return this.position.markup.has(x, y);\n    };\n\n    /**\n     * Get stone on coordinates\n     */\n    Game.prototype.getStone = function(x, y) {\n      return this.position.stones.get(x, y);\n    };\n\n    /**\n     * Get markup on coordinates\n     */\n    Game.prototype.getMarkup = function(x, y) {\n      return this.position.markup.get(x, y);\n    };\n\n    /*****************************************************************************\n     * Move handling\n     ***/\n\n    /**\n     * Play move\n     */\n    Game.prototype.play = function(x, y, color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Validate move and get new position\n      var newPosition = this.validateMove(x, y, color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          x: x,\n          y: y,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node._remembered_path = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n\n      //Valid move\n      return true;\n    };\n\n    /**\n     * Play pass\n     */\n    Game.prototype.pass = function(color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Initialize new position and switch the turn\n      var newPosition = this.position.clone();\n      newPosition.setTurn(-color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          pass: true,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node._remembered_path = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n    };\n\n    /*****************************************************************************\n     * Game tree navigation\n     ***/\n\n    /**\n     * Go to the next position\n     */\n    Game.prototype.next = function(i) {\n\n      //Object (node) given as parameter? Find index\n      if (typeof i === 'object') {\n        i = this.node.children.indexOf(i);\n      }\n\n      //Go to the next node\n      if (nextNode.call(this, i)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n          return true;\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n\n      //Didn't go to next position\n      return false;\n    };\n\n    /**\n     * Go to the previous position\n     */\n    Game.prototype.previous = function() {\n\n      //Go to the previous node\n      if (previousNode.call(this)) {\n        popPosition.call(this);\n        return true;\n      }\n\n      //Didn't go to previous position\n      return false;\n    };\n\n    /**\n     * Go to the last position\n     */\n    Game.prototype.last = function() {\n\n      //Keep going to the next node until we reach the end\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the first position\n     */\n    Game.prototype.first = function() {\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      executeNode.call(this);\n    };\n\n    /**\n     * Go to position specified by a path object, a numeric move numer, or a node name string\n     */\n    Game.prototype.goto = function(target) {\n\n      //Must have a tree\n      if (this.root === null) {\n        return;\n      }\n\n      //Nothing given?\n      if (typeof target === 'undefined') {\n        return;\n      }\n\n      //Function given? Call now\n      if (typeof target === 'function') {\n        target = target.call(this);\n      }\n\n      //Initialize path\n      var path;\n\n      //Simple move number? Convert to path object\n      if (typeof target === 'number') {\n        path = this.path.clone();\n        path.setMove(target);\n      }\n\n      //String? Named node\n      else if (typeof target === 'string') {\n\n        //Already here?\n        if (this.node.name === target) {\n          return;\n        }\n\n        //Find path to node\n        path = this.getPathToNode(target);\n        if (path === null) {\n          return;\n        }\n      }\n\n      //Otherwise assume path object\n      else {\n        path = target;\n      }\n\n      //Already here?\n      if (this.path.compare(path)) {\n        return;\n      }\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      pushPosition.call(this);\n      executeNode.call(this);\n\n      //Loop path\n      var n = path.getMove();\n      for (var i = 0; i < n; i++) {\n\n        //Try going to the next node\n        if (!nextNode.call(this, path.nodeAt(i))) {\n          break;\n        }\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous fork\n     */\n    Game.prototype.previousFork = function() {\n\n      //Loop until we find a node with more than one child\n      while (previousNode.call(this)) {\n        popPosition.call(this);\n\n        //Break when found a node with more than one child\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the next fork\n     */\n    Game.prototype.nextFork = function() {\n\n      //Keep going to the next node until we reach one with multiple children\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Have multiple children?\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state\n     */\n    Game.prototype.getState = function() {\n\n      //Can only create when we have a JGF and path\n      if (!this.jgf || !this.path) {\n        return null;\n      }\n\n      //Create state\n      var state = {\n        jgf: this.jgf,\n        path: this.path.clone()\n      };\n\n      //Return\n      return state;\n    };\n\n    /**\n     * Restore the game state\n     */\n    Game.prototype.restoreState = function(state) {\n\n      //Must have jgf and path\n      if (!state || !state.jgf || !state.path) {\n        return;\n      }\n\n      //Restore state\n      this.load(state.jgf);\n      this.goto(state.path);\n    };\n\n    //Return object\n    return Game;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GameNode :: This class represents a single node in the game moves tree. It contains\n * properties like the x and y grid coordinates, the move played, board setup instructions,\n * markup, player turn and comments. The moves tree in the game record is represented by a\n * string of GameNodes, each with pointers to their parent and children. Each node can have\n * multiple children (move variations), but only one parent.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Node.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameNode', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /**\n   * Helper to construct a coordinates base object\n   */\n  var coordinatesObject = function(coords, baseObject) {\n    baseObject = baseObject || {};\n    if (coords === '' || coords === 'pass') {\n      baseObject.pass = true;\n    }\n    else {\n\n      //Backwards compatibility with SGF string coordinates in JGF\n      if (typeof coords === 'string') {\n        coords = convertCoordinates(coords);\n      }\n\n      //Append coordinates\n      baseObject.x = coords[0] * 1;\n      baseObject.y = coords[1] * 1;\n    }\n    return baseObject;\n  };\n\n  /**\n   * Convert a numeric color value (color constant) to a string\n   */\n  var toStringColor = function(color) {\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\n  };\n\n  /**\n   * Convert a string color value to a numeric color constant\n   */\n  var toColorConstant = function(color) {\n    if (color === 'B') {\n      return StoneColor.B;\n    }\n    else if (color === 'W') {\n      return StoneColor.W;\n    }\n    return StoneColor.E;\n  };\n\n  /*****************************************************************************\n   * Helpers for conversion between JGF / KIFU format\n   ***/\n\n  /**\n   * Convert move object to JGF format\n   */\n  var convertMoveToJgf = function(move) {\n\n    //Initialize JGF move object and determine color\n    var jgfMove = angular.copy(move);\n    var color = toStringColor(move.color);\n\n    //No color?\n    if (color === '') {\n      return null;\n    }\n\n    //Pass move?\n    if (move.pass === true) {\n      jgfMove[color] = 'pass';\n    }\n\n    //Regular move\n    else {\n      jgfMove[color] = [move.x, move.y];\n    }\n\n    //Delete coordinates and color\n    delete jgfMove.x;\n    delete jgfMove.y;\n    delete jgfMove.color;\n\n    //Return move\n    return jgfMove;\n  };\n\n  /**\n   * Convert move from JGF format\n   */\n  var convertMoveFromJgf = function(move) {\n\n    //Prepare color, coordinates\n    var color, coords;\n\n    //Check whose move it was\n    if (move.W) {\n      color = 'W';\n      coords = move.W;\n    }\n    else if (move.B) {\n      color = 'B';\n      coords = move.B;\n    }\n\n    //No coordinates?\n    if (!coords) {\n      return null;\n    }\n\n    //Return coordinates object\n    return coordinatesObject(coords, {\n      color: toColorConstant(color)\n    });\n  };\n\n  /**\n   * Convert setup object to JGF format\n   */\n  var convertSetupToJgf = function(setup) {\n\n    //Initialize variables\n    var i, color;\n    var jgfSetup = {};\n\n    //Loop setup objects\n    for (i in setup) {\n      if (setup.hasOwnProperty(i)) {\n\n        //Get color\n        color = toStringColor(setup[i].color) || 'E';\n\n        //Initialize array\n        if (typeof jgfSetup[color] === 'undefined') {\n          jgfSetup[color] = [];\n        }\n\n        //Add coordinates\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\n      }\n    }\n\n    //Return\n    return jgfSetup;\n  };\n\n  /**\n   * Convert setup from JGF format\n   */\n  var convertSetupFromJgf = function(setup) {\n\n    //Initialize variables\n    var c, key, color;\n    var gameSetup = [];\n\n    //Loop setup\n    for (key in setup) {\n      if (setup.hasOwnProperty(key)) {\n\n        //Get color constant\n        color = toColorConstant(key);\n\n        //Loop coordinates\n        for (c in setup[key]) {\n          if (setup[key].hasOwnProperty(c)) {\n            gameSetup.push(coordinatesObject(setup[key][c], {\n              color: color\n            }));\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameSetup;\n  };\n\n  /**\n   * Convert markup object to JGF format\n   */\n  var convertMarkupToJgf = function(markup) {\n\n    //Initialize variables\n    var i, type;\n    var jgfMarkup = {};\n\n    //Loop setup objects\n    for (i in markup) {\n      if (markup.hasOwnProperty(i)) {\n\n        //Get type\n        type = markup[i].type;\n\n        //Initialize array\n        if (typeof jgfMarkup[type] === 'undefined') {\n          jgfMarkup[type] = [];\n        }\n\n        //Label?\n        if (type === 'label') {\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\n        }\n        else {\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\n        }\n      }\n    }\n\n    //Return\n    return jgfMarkup;\n  };\n\n  /**\n   * Convert markup from JGF format\n   */\n  var convertMarkupFromJgf = function(markup) {\n\n    //Initialize variables\n    var l, type;\n    var gameMarkup = [];\n\n    //Loop markup types\n    for (type in markup) {\n      if (markup.hasOwnProperty(type)) {\n\n        //Label?\n        if (type === 'label') {\n          for (l = 0; l < markup[type].length; l++) {\n\n            //Validate\n            if (!angular.isArray(markup[type][l])) {\n              continue;\n            }\n\n            //SGF type coordinates?\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\n              var text = markup[type][l][1];\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\n              markup[type][l].push(text);\n            }\n\n            //Validate length\n            if (markup[type][l].length < 3) {\n              continue;\n            }\n\n            //Add to stack\n            gameMarkup.push(coordinatesObject(markup[type][l], {\n              type: type,\n              text: markup[type][l][2]\n            }));\n          }\n        }\n        else {\n\n          //Loop coordinates\n          for (l in markup[type]) {\n            if (markup[type].hasOwnProperty(l)) {\n              gameMarkup.push(coordinatesObject(markup[type][l], {\n                type: type\n              }));\n            }\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameMarkup;\n  };\n\n  /**\n   * Convert turn object to JGF format\n   */\n  var convertTurnToJgf = function(turn) {\n    switch (turn) {\n      case StoneColor.W:\n        return 'W';\n      case StoneColor.B:\n        return 'B';\n      default:\n        return '';\n    }\n  };\n\n  /**\n   * Convert turn from JGF format\n   */\n  var convertTurnFromJgf = function(turn) {\n    switch (turn) {\n      case 'W':\n        return StoneColor.W;\n      case 'B':\n        return StoneColor.B;\n      default:\n        return StoneColor.EMPTY;\n    }\n  };\n\n  /**\n   * Conversions map\n   */\n  var conversionMap = {\n    toJgf: {\n      move: convertMoveToJgf,\n      setup: convertSetupToJgf,\n      markup: convertMarkupToJgf,\n      turn: convertTurnToJgf\n    },\n    fromJgf: {\n      move: convertMoveFromJgf,\n      setup: convertSetupFromJgf,\n      markup: convertMarkupFromJgf,\n      turn: convertTurnFromJgf\n    }\n  };\n\n  /**\n   * Constructor\n   */\n  var GameNode = function(properties, parent) {\n\n    //Set parent and children\n    this.parent = parent || null;\n    this.children = [];\n\n    //Save properties\n    if (properties) {\n      for (var key in properties) {\n        if (properties.hasOwnProperty(key)) {\n          this[key] = properties[key];\n        }\n      }\n    }\n  };\n\n  /**\n   * Get node's child specified by index or null if doesn't exist\n   */\n  GameNode.prototype.getChild = function(i) {\n    i = i || 0;\n    if (this.children[i]) {\n      return this.children[i];\n    }\n    return null;\n  };\n\n  /**\n   * Get all the children\n   */\n  GameNode.prototype.getChildren = function() {\n    return this.children;\n  };\n\n  /**\n   * Check if the node has any chilren\n   */\n  GameNode.prototype.hasChildren = function() {\n    return (this.children.length > 0);\n  };\n\n  /**\n   * Check if the node has more than one move variation\n   */\n  GameNode.prototype.hasMoveVariations = function() {\n\n    //Less than two child nodes?\n    if (this.children.length <= 1) {\n      return false;\n    }\n\n    //Loop children\n    var moveVariations = 0;\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].move) {\n        moveVariations++;\n      }\n\n      //More than one move node present?\n      if (moveVariations > 1) {\n        return true;\n      }\n    }\n\n    //No move variations\n    return false;\n  };\n\n  /**\n   * Get all the move variation nodes\n   */\n  GameNode.prototype.getMoveVariations = function() {\n\n    //No child nodes?\n    if (this.children.length === 0) {\n      return false;\n    }\n\n    //Initialize\n    var moveVariations = [];\n\n    //Loop child nodes\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].move) {\n        moveVariations.push(this.children[i]);\n      }\n    }\n\n    //Return\n    return moveVariations;\n  };\n\n  /**\n   * Get the move variation for given coordinates\n   */\n  GameNode.prototype.getMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return i;\n      }\n    }\n\n    //Not found\n    return -1;\n  };\n\n  /**\n   * Check if given coordinates are one of the next child node coordinates\n   */\n  GameNode.prototype.isMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return true;\n      }\n    }\n\n    //Not found\n    return false;\n  };\n\n  /*****************************************************************************\n   * Node manipulation\n   ***/\n\n  /**\n   * Remove this node from its parent\n   */\n  GameNode.prototype.remove = function() {\n\n    //Can't remove if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found remove it\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1) {\n      this.parent.children.splice(i, 1);\n    }\n\n    //Clear parent reference\n    this.parent = null;\n  };\n\n  /**\n   * Move the node up in the parent's child tree\n   */\n  GameNode.prototype.moveUp = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i > 0) {\n      var temp = this.parent.children[i - 1];\n      this.parent.children[i - 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Move the node down in the parent's child tree\n   */\n  GameNode.prototype.moveDown = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\n      var temp = this.parent.children[i + 1];\n      this.parent.children[i + 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Append this node to another node\n   */\n  GameNode.prototype.appendTo = function(node) {\n\n    //Remove from existing parent\n    this.remove();\n\n    //Set new parent\n    this.parent = node;\n    node.children.push(this);\n    return node.children.length - 1;\n  };\n\n  /**\n   * Append child node to this node.\n   */\n  GameNode.prototype.appendChild = function(node) {\n    node.parent = this;\n    this.children.push(node);\n    return this.children.length - 1;\n  };\n\n  /**\n   * Insert another node after this one\n   */\n  GameNode.prototype.insertNode = function(node) {\n\n    //Loop our children and change parent node\n    for (var i = 0; i < this.children.length; i++) {\n      this.children[i].parent = node;\n    }\n\n    //Merge children, set this node as the parent of given node\n    node.children = node.children.concat(this.children);\n    node.parent = this;\n\n    //Set given node as the child of this node\n    this.children = [node];\n  };\n\n  /*****************************************************************************\n   * JGF conversion\n   ***/\n\n  /**\n   * Build a Game Node from a given JGF tree\n   */\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\n\n    //Root JGF file given?\n    if (typeof jgf.tree !== 'undefined') {\n      return GameNode.fromJgf(jgf.tree, gameNode);\n    }\n\n    //Initialize helper vars\n    var variationNode, nextNode, i, j;\n\n    //Node to work with given? Otherwise, work with ourselves\n    gameNode = gameNode || this;\n\n    //Loop moves in the JGF tree\n    for (i = 0; i < jgf.length; i++) {\n\n      //Array? That means a variation branch\n      if (angular.isArray(jgf[i])) {\n\n        //Loop variation stacks\n        for (j = 0; j < jgf[i].length; j++) {\n\n          //Build the variation node\n          variationNode = new GameNode();\n          variationNode.fromJgf(jgf[i][j]);\n\n          //Append to working node\n          gameNode.appendChild(variationNode);\n        }\n      }\n\n      //Regular node\n      else {\n\n        //Get properties to copy\n        var properties = Object.getOwnPropertyNames(jgf[i]);\n\n        //Copy node properties\n        for (var key in properties) {\n          if (properties.hasOwnProperty(key)) {\n            var prop = properties[key];\n\n            //Conversion function present?\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\n            }\n            else if (typeof jgf[i][prop] === 'object') {\n              gameNode[prop] = angular.copy(jgf[i][prop]);\n            }\n            else {\n              gameNode[prop] = jgf[i][prop];\n            }\n          }\n        }\n      }\n\n      //Next element is a regular node? Prepare new working node\n      //Otherwise, if there are no more nodes or if the next element is\n      //an array (e.g. variations), we keep our working node as the current one\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\n        nextNode = new GameNode();\n        gameNode.appendChild(nextNode);\n        gameNode = nextNode;\n      }\n    }\n  };\n\n  /**\n   * Convert this node to a JGF node container\n   */\n  GameNode.prototype.toJgf = function(container) {\n\n    //Initialize container to add nodes to\n    container = container || [];\n\n    //Initialize node and get properties\n    var node = {};\n    var properties = Object.getOwnPropertyNames(this);\n\n    //Copy node properties\n    for (var key in properties) {\n      if (properties.hasOwnProperty(key)) {\n        var prop = properties[key];\n\n        //Skip some properties\n        if (prop === 'parent' || prop === 'children') {\n          continue;\n        }\n\n        //Conversion function present?\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\n        }\n        else if (typeof this[prop] === 'object') {\n          node[prop] = angular.copy(this[prop]);\n        }\n        else {\n          node[prop] = this[prop];\n        }\n      }\n    }\n\n    //Add node to container\n    container.push(node);\n\n    //Variations present?\n    if (this.children.length > 1) {\n\n      //Create variations container\n      var variationsContainer = [];\n      container.push(variationsContainer);\n\n      //Loop child (variation) nodes\n      for (var i = 0; i < this.children.length; i++) {\n\n        //Create container for this variation\n        var variationContainer = [];\n        variationsContainer.push(variationContainer);\n\n        //Call child node converter\n        this.children[i].toJgf(variationContainer);\n      }\n    }\n\n    //Just one child?\n    else if (this.children.length === 1) {\n      this.children[0].toJgf(container);\n    }\n\n    //Return container\n    return container;\n  };\n\n  //Return object\n  return GameNode;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePath :: A simple class that keeps track of a path taken in a game.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Path.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePath', function() {\n\n  /**\n   * Constructor\n   */\n  var GamePath = function() {\n    this.reset();\n  };\n\n  /**\n   * Reset\n   */\n  GamePath.prototype.reset = function() {\n    this.move = 0;\n    this.path = {};\n    this.branches = 0;\n    return this;\n  };\n\n  /**\n   * Advance a move\n   */\n  GamePath.prototype.advance = function(i) {\n\n    //Different child variation chosen? Remember\n    if (i > 0) {\n      this.path[this.move] = 1;\n      this.branches++;\n    }\n\n    //Increment move\n    this.move++;\n    return this;\n  };\n\n  /**\n   * Retreat a move\n   */\n  GamePath.prototype.retreat = function() {\n\n    //At start?\n    if (this.move === 0) {\n      return;\n    }\n\n    //Delete path choice\n    if (this.path[this.move]) {\n      delete this.path[this.move];\n      this.branches--;\n    }\n\n    //Decrement move\n    this.move--;\n    return this;\n  };\n\n  /**\n   * Go to a specific move number\n   */\n  GamePath.prototype.setMove = function(no) {\n\n    //Less than our current move? We need to erase any paths above the move number\n    if (no < this.move) {\n      for (var i in this.path) {\n        if (i > no) {\n          delete this.path[i];\n          this.branches--;\n        }\n      }\n    }\n\n    //Set move number\n    this.move = no;\n    return this;\n  };\n\n  /**\n   * Get the move number\n   */\n  GamePath.prototype.getMove = function() {\n    return this.move;\n  };\n\n  /**\n   * Get the node choice at a specific move number\n   */\n  GamePath.prototype.nodeAt = function(no) {\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\n  };\n\n  /**\n   * Compare to another path\n   */\n  GamePath.prototype.compare = function(otherPath) {\n\n    //Invalid object?\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\n      return;\n    }\n\n    //Different move number or path length?\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\n      return false;\n    }\n\n    //Check path\n    for (var i in this.path) {\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\n        return false;\n      }\n    }\n\n    //Same path!\n    return true;\n  };\n\n  /**\n   * Clone\n   */\n  GamePath.prototype.clone = function() {\n\n    //Create new instance\n    var newPath = new GamePath();\n\n    //Set vars\n    newPath.move = this.move;\n    newPath.branches = this.branches;\n    newPath.path = angular.copy(this.path);\n\n    //Return\n    return newPath;\n  };\n\n  /**\n   * Helper to find node name recursively\n   */\n  var findNodeName = function(node, nodeName, path) {\n\n    //Found in this node?\n    if (node.name && node.name === nodeName) {\n      return true;\n    }\n\n    //Loop children\n    for (var i = 0; i < node.children.length; i++) {\n\n      //Advance path\n      path.advance(i);\n\n      //Found in child node?\n      if (findNodeName(node.children[i], nodeName, path)) {\n        return true;\n      }\n\n      //Not found in this child node, retreat path\n      path.retreat();\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Static helper to create a path object to reach a certain node\n   */\n  GamePath.findNode = function(nodeName, rootNode) {\n\n    //Create new instance\n    var path = new GamePath();\n\n    //Find the node name\n    if (findNodeName(rootNode, nodeName, path)) {\n      return path;\n    }\n\n    //Not found\n    return null;\n  };\n\n  //Return\n  return GamePath;\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\n * markup on the board in this position, as well as any captures that were made and which player's\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\n * compare changes to other positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Position.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePosition', ['StoneColor', 'BoardGrid', function(StoneColor, BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var GamePosition = function(width, height) {\n\n    //Initialize\n    this.error = 0;\n    this.width = 0;\n    this.height = 0;\n    this.stones = new BoardGrid();\n    this.markup = new BoardGrid();\n    this.turn = StoneColor.B;\n\n    //Initialize captures\n    this.captures = {};\n    this.captures[StoneColor.B] = [];\n    this.captures[StoneColor.W] = [];\n\n    //Set empty value for stones grid\n    this.stones.whenEmpty(StoneColor.EMPTY);\n\n    //Set size\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set the grid size\n   */\n  GamePosition.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Set in grids\n    this.stones.setSize(width, height);\n    this.markup.setSize(width, height);\n\n    //Empty the position\n    this.empty();\n  };\n\n  /**\n   * Clear the whole position\n   */\n  GamePosition.prototype.empty = function() {\n    this.stones.empty();\n    this.markup.empty();\n  };\n\n  /**\n   * Sets stone color at given coordinates.\n   */\n  GamePosition.prototype.setStone = function(x, y, color) {\n    this.stones.set(x, y, color);\n  };\n\n  /**\n   * Sets markup type at given coordinates.\n   */\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\n    this.markup.set(x, y, markup);\n  };\n\n  /*****************************************************************************\n   * Liberties and capturing\n   ***/\n\n  /**\n   * Check if a group of given color has liberties, starting at the given coordinates\n   */\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\n\n    //Out of bounds? No liberties outside of the board\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Initialize tested grid if needed\n    tested = tested || new BoardGrid(this.width, this.height);\n\n    //See what color is present on the coordinates\n    var color = this.stones.get(x, y);\n\n    //If no group color was given, use what's on the position\n    groupColor = groupColor || color;\n\n    //Already tested, or enemy stone? Not giving any liberties\n    if (tested.get(x, y) === true || color === -groupColor) {\n      return false;\n    }\n\n    //Empty? That's a liberty\n    if (color === StoneColor.EMPTY) {\n      return true;\n    }\n\n    //Mark this position as tested now\n    tested.set(x, y, true);\n\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\n    //If we get at least one true, we have a liberty\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\n        this.hasLiberties(x + 1, y, groupColor, tested);\n  };\n\n  /**\n   * Helper to capture adjacent groups\n   */\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    friendlyColor = friendlyColor || this.stones.get(x, y);\n\n    //Can't capture empty spots\n    if (friendlyColor === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Flag to see if we captured stuff\n    var captured = false;\n\n    //Check adjacent positions now, capturing stones in the process if possible\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n\n    //Return\n    return captured;\n  };\n\n  /**\n   * Helper if we can capture a certain group\n   */\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\n\n    //Out of bounds? Nothing to capture\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Empty spot? Can't capture\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //We need to have a stone of matching group color in order to be able to capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //There is a capturable stone, let's see if it has any liberties left\n    if (this.hasLiberties(x, y, enemyColor)) {\n      return false;\n    }\n\n    //No liberties left, the group is capturable. Capture if we want to\n    if (doCapture) {\n      this.captureGroup(x, y, enemyColor);\n    }\n\n    //Capturable\n    return true;\n  };\n\n  /**\n   * Capture a group of certain color, starting at the given coordinates\n   */\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //If no group color was given, use what's on the position\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //Stone at position does not match the given group color? Can't capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //Capture the stone\n    this.captureStone(x, y);\n\n    //Capture the rest of the group\n    this.captureGroup(x, y - 1, enemyColor);\n    this.captureGroup(x, y + 1, enemyColor);\n    this.captureGroup(x - 1, y, enemyColor);\n    this.captureGroup(x + 1, y, enemyColor);\n\n    //At least one stone was captured\n    return true;\n  };\n\n  /**\n   * Capture a stone at given coordinates\n   */\n  GamePosition.prototype.captureStone = function(x, y) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Get color\n    var color = this.stones.get(x, y);\n\n    //Empty?\n    if (color === StoneColor.EMPTY) {\n      return;\n    }\n\n    //Ok, stone present, capture it\n    this.stones.set(x, y, StoneColor.EMPTY);\n    this.captures[color].push({x: x, y: y});\n  };\n\n  /**\n   * Set captures for a color (expects array with capture object coordinates)\n   */\n  GamePosition.prototype.setCaptures = function(color, captures) {\n    this.captures[color] = captures;\n  };\n\n  /**\n   * Get captures for a color\n   */\n  GamePosition.prototype.getCaptures = function(color) {\n    return this.captures[color] || [];\n  };\n\n  /**\n   * Get the capture count for a color (= the number of captures of the opposing color)\n   */\n  GamePosition.prototype.getCaptureCount = function(color) {\n    return this.captures[-color].length;\n  };\n\n  /*****************************************************************************\n   * Turn control\n   ***/\n\n  /**\n   * Set color for whose move it is at this position\n   */\n  GamePosition.prototype.setTurn = function(color) {\n    this.turn = color;\n  };\n\n  /**\n   * Get color for whose move it is at this position\n   */\n  GamePosition.prototype.getTurn = function() {\n    return this.turn;\n  };\n\n  /**\n   * Switch the player turn on this position\n   */\n  GamePosition.prototype.switchTurn = function() {\n    this.turn = -this.turn;\n  };\n\n  /*****************************************************************************\n   * Cloning and comparison\n   ***/\n\n  /**\n   * Clones the whole position except turn and captures\n   */\n  GamePosition.prototype.clone = function() {\n\n    //Create a new position\n    var newPosition = new GamePosition();\n\n    //Set vars manually for maximum efficiency\n    newPosition.turn = this.turn;\n    newPosition.width = this.width;\n    newPosition.height = this.height;\n    newPosition.stones = this.stones.clone();\n    newPosition.markup = new BoardGrid(this.width, this.height);\n\n    //Return\n    return newPosition;\n  };\n\n  /**\n   * Checks if a given position is the same as the current position\n   */\n  GamePosition.prototype.isSameAs = function(newPosition) {\n\n    //Must have the same size\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\n      return false;\n    }\n\n    //Compare the grids\n    return this.stones.isSameAs(newPosition.stones);\n  };\n\n  //Return\n  return GamePosition;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScore :: A simple class that contains a game score\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Score.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScore', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Helper to calculate the total points\n   */\n  var calcTotal = function() {\n    return parseInt(this.stones) + parseInt(this.territory) +\n      parseInt(this.captures) + parseInt(this.komi);\n  };\n\n  /**\n   * Constructor\n   */\n  var GameScore = function() {\n\n    //Get self\n    var self = this;\n\n    //Setup score containers\n    this.black = {};\n    this.white = {};\n\n    //Initialize\n    this.reset();\n\n    //Add total handlers\n    this.black.total = function() {\n      return calcTotal.call(self.black);\n    };\n    this.white.total = function() {\n      return calcTotal.call(self.white);\n    };\n  };\n\n  /**\n   * Reset the game score\n   */\n  GameScore.prototype.reset = function() {\n\n    //Get properties to loop\n    var props = ['stones', 'territory', 'captures', 'komi'];\n\n    //Score for black player\n    for (var i = 0; i < props.length; i++) {\n      this.black[props[i]] = 0;\n      this.white[props[i]] = 0;\n    }\n  };\n\n  /**\n   * Get the winner\n   */\n  GameScore.prototype.winner = function() {\n\n    //Get totals\n    var b = this.black.total();\n    var w = this.white.total();\n\n    //Determine winner\n    if (w > b) {\n      return StoneColor.W;\n    }\n    else if (b > w) {\n      return StoneColor.B;\n    }\n    return StoneColor.E;\n  };\n\n  //Return\n  return GameScore;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScorer :: This class is used to determine the score of a certain game position. It also\n * provides handling of manual adjustment of dead / living groups.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Scorer.Service', [\n  'ngGo',\n  'ngGo.Game.Score.Service',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScorer', ['GameScore', 'StoneColor', 'BoardGrid', function(GameScore, StoneColor, BoardGrid) {\n\n  /**\n   * Possible score states\n   */\n  var scoreState = {\n    UNKNOWN: StoneColor.EMPTY,\n    BLACK_STONE: StoneColor.B,\n    WHITE_STONE: StoneColor.W,\n    BLACK_CANDIDATE: StoneColor.B * 2,\n    WHITE_CANDIDATE: StoneColor.W * 2,\n    NEUTRAL: StoneColor.B * 3\n  };\n\n  /**\n   * Helper to set territory\n   */\n  var territorySet = function(x, y, candidateColor, boundaryColor) {\n\n    //Get color at given position\n    var posColor = this.stones.get(x, y);\n    var origColor = this.game.position.stones.get(x, y);\n\n    //If border reached, or a position which is already this color, or boundary color, can't set\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\n      return;\n    }\n\n    //Don't turn stones which are already this color into candidates, instead\n    //reset their color to what they were\n    if (origColor * 2 === candidateColor) {\n      this.stones.set(x, y, origColor);\n    }\n\n    //Otherwise, mark as candidate\n    else {\n      this.stones.set(x, y, candidateColor);\n    }\n\n    //Set adjacent squares\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\n  };\n\n  /**\n   * Helper to reset territory\n   */\n  var territoryReset = function(x, y) {\n\n    //Get original color from this position\n    var origColor = this.game.position.stones.get(x, y);\n\n    //Not on grid, or already this color?\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\n      return;\n    }\n\n    //Reset the color\n    this.stones.set(x, y, origColor);\n\n    //Set adjacent squares\n    territoryReset.call(this, x - 1, y);\n    territoryReset.call(this, x, y - 1);\n    territoryReset.call(this, x + 1, y);\n    territoryReset.call(this, x, y + 1);\n  };\n\n  /**\n   * Helper to determine score state\n   */\n  var determineScoreState = function() {\n\n    //Initialize vars\n    var change = true;\n    var curState, newState, adjacent, b, w, a, x, y;\n\n    //Loop while there is change\n    while (change) {\n\n      //Set to false\n      change = false;\n\n      //Go through the whole position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get current state at position\n          curState = this.stones.get(x, y);\n\n          //Unknown or candiates?\n          if (\n            curState === scoreState.UNKNOWN ||\n            curState === scoreState.BLACK_CANDIDATE ||\n            curState === scoreState.WHITE_CANDIDATE\n          ) {\n\n            //Get state in adjacent positions\n            adjacent = [\n              this.stones.get(x - 1, y),\n              this.stones.get(x, y - 1),\n              this.stones.get(x + 1, y),\n              this.stones.get(x, y + 1)\n            ];\n\n            //Reset\n            b = w = false;\n\n            //Loop adjacent squares\n            for (a = 0; a < 4; a++) {\n              if (\n                adjacent[a] === scoreState.BLACK_STONE ||\n                adjacent[a] === scoreState.BLACK_CANDIDATE\n              ) {\n                b = true;\n              }\n              else if (\n                adjacent[a] === scoreState.WHITE_STONE ||\n                adjacent[a] === scoreState.WHITE_CANDIDATE\n              ) {\n                w = true;\n              }\n              else if (adjacent[a] === scoreState.NEUTRAL) {\n                b = w = true;\n              }\n            }\n\n            //Determine new state\n            if (b && w) {\n              newState = scoreState.NEUTRAL;\n            }\n            else if (b) {\n              newState = scoreState.BLACK_CANDIDATE;\n            }\n            else if (w) {\n              newState = scoreState.WHITE_CANDIDATE;\n            }\n            else {\n              newState = false;\n            }\n\n            //Change?\n            if (newState !== false && newState !== curState) {\n              change = true;\n              this.stones.set(x, y, newState);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * this.game scorer class\n   */\n  var GameScorer = {\n\n    //Game to score\n    game: null,\n\n    //Score\n    score: null,\n\n    //Stones, captures and points grids\n    stones: null,\n    captures: null,\n    points: null,\n\n    /**\n     * Load a game to score\n     */\n    load: function(game) {\n\n      //Reset score\n      this.score = new GameScore();\n\n      //Remember\n      this.game = game;\n\n      //Clone position to work with\n      this.stones = this.game.position.stones.clone();\n\n      //Create grids\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n    },\n\n    /**\n     * Get the calculated score\n     */\n    getScore: function() {\n      return this.score;\n    },\n\n    /**\n     * Get the points grid\n     */\n    getPoints: function() {\n      return this.points;\n    },\n\n    /**\n     * Get the captures grid\n     */\n    getCaptures: function() {\n      return this.captures;\n    },\n\n    /**\n     * Run score calculation routine\n     */\n    calculate: function() {\n\n      //No game?\n      if (!this.game) {\n        console.warn('No game loaded in game scorer, can\\'t calutlate score.');\n        return;\n      }\n\n      //Empty grids\n      this.points.empty();\n      this.captures.empty();\n\n      //Determine score state\n      determineScoreState.call(this);\n\n      //Get komi and captures\n      var komi = this.game.get('game.komi');\n      var captures = this.game.getCaptureCount();\n\n      //Reset score\n      this.score.reset();\n\n      //Set captures and komi\n      this.score.black.captures = captures[StoneColor.B];\n      this.score.white.captures = captures[StoneColor.W];\n      this.score.black.komi = komi < 0 ? komi : 0;\n      this.score.white.komi = komi > 0 ? komi : 0;\n\n      //Init helper vars\n      var x, y, state, color;\n\n      //Loop position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get state and color on original position\n          state = this.stones.get(x, y);\n          color = this.game.position.stones.get(x, y);\n\n          //Black stone\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\n            this.score.black.stones++;\n            continue;\n          }\n\n          //White stone\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\n            this.score.white.stones++;\n            continue;\n          }\n\n          //Black candidate\n          if (state === scoreState.BLACK_CANDIDATE) {\n            this.score.black.territory++;\n            this.points.set(x, y, StoneColor.B);\n\n            //White stone underneath?\n            if (color === StoneColor.W) {\n              this.score.black.captures++;\n              this.captures.set(x, y, StoneColor.W);\n            }\n            continue;\n          }\n\n          //White candidate\n          if (state === scoreState.WHITE_CANDIDATE) {\n            this.score.white.territory++;\n            this.points.set(x, y, StoneColor.W);\n\n            //Black stone underneath?\n            if (color === StoneColor.B) {\n              this.score.white.captures++;\n              this.captures.set(x, y, StoneColor.B);\n            }\n            continue;\n          }\n        }\n      }\n    },\n\n    /**\n     * Mark stones dead or alive\n     */\n    mark: function(x, y) {\n\n      //Get color of original position and state of the count position\n      var color = this.game.position.stones.get(x, y);\n      var state = this.stones.get(x, y);\n\n      //White stone\n      if (color === StoneColor.W) {\n\n        //Was white, mark it and any territory it's in as black's\n        if (state === scoreState.WHITE_STONE) {\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\n        }\n\n        //Was marked as not white, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n\n      //Black stone\n      else if (color === StoneColor.B) {\n\n        //Was black, mark it and any territory it's in as white's\n        if (state === scoreState.BLACK_STONE) {\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\n        }\n\n        //Was marked as not black, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n    }\n  };\n\n  //Return\n  return GameScorer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Blank.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('KifuBlank', ['ngGo', function(ngGo) {\n\n  /**\n   * Blank JGF\n   */\n  var blankJgf = {\n    record: {\n      application: ngGo.name + ' v' + ngGo.version,\n      version: 1,\n      charset: 'UTF-8'\n    },\n    game: {\n      type: 'go',\n      players: [\n        {\n          color: 'black',\n          name: 'Black'\n        },\n        {\n          color: 'white',\n          name: 'White'\n        }\n      ]\n    },\n    board: {\n      width: 19,\n      height: 19\n    },\n    tree: []\n  };\n\n  /**\n   * Blank SGF\n   */\n  var blankSgf = {\n    AP: ngGo.name + ':' + ngGo.version,\n    CA: 'UTF-8',\n    FF: '4',\n    GM: '1',\n    SZ: '19',\n    PB: 'Black',\n    PW: 'White'\n  };\n\n  /**\n   * Blank JGF/SGF container\n   */\n  var KifuBlank = {\n\n    /**\n     * Get blank JGF\n     */\n    jgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankJgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    },\n\n    /**\n     * Get blank SGF\n     */\n    sgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankSgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = base[p];\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    }\n  };\n\n  //Return object\n  return KifuBlank;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\n * constants used by the parsers to aid conversion.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parser.Service', [\n  'ngGo',\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service'\n])\n\n/**\n * SGF/JGF aliases constant for conversion between the two formats\n * Note: not all properties can be translated directly, so some are\n * not present here in this constant\n */\n.constant('sgfAliases', {\n\n  //Record properties\n  'AP': 'record.application',\n  'CA': 'record.charset',\n  'CP': 'record.copyright',\n  'SO': 'record.source',\n  'US': 'record.transcriber',\n  'AN': 'record.annotator',\n\n  //Game properties\n  'GM': 'game.type',\n  'GN': 'game.name',\n  'KM': 'game.komi',\n  'HA': 'game.handicap',\n  'RE': 'game.result',\n  'RU': 'game.rules',\n  'TM': 'game.time.main',\n  'OT': 'game.time.overtime',\n  'DT': 'game.dates',\n  'PC': 'game.location',\n  'EV': 'game.event',\n  'RO': 'game.round',\n  'ON': 'game.opening',\n  'GC': 'game.comment',\n\n  //Player info properties\n  'PB': 'name',\n  'PW': 'name',\n  'BT': 'team',\n  'WT': 'team',\n  'BR': 'rank',\n  'WR': 'rank',\n\n  //Node annotation\n  'N': 'name',\n  'C': 'comments',\n  'CR': 'circle',\n  'TR': 'triangle',\n  'SQ': 'square',\n  'MA': 'mark',\n  'SL': 'select',\n  'LB': 'label'\n})\n\n/**\n * SGF game definitions\n */\n.constant('sgfGames', {\n  1: 'go',\n  2: 'othello',\n  3: 'chess',\n  4: 'renju',\n  6: 'backgammon',\n  7: 'chinese chess',\n  8: 'shogi'\n})\n\n/**\n * Factory definition\n */\n.factory('KifuParser', ['Gib2Jgf', 'Sgf2Jgf', 'Jgf2Sgf', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\n\n  /**\n   * Parser wrapper class\n   */\n  var KifuParser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    gib2jgf: function(gib, stringified) {\n      return Gib2Jgf.parse(gib, stringified);\n    },\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    sgf2jgf: function(sgf, stringified) {\n      return Sgf2Jgf.parse(sgf, stringified);\n    },\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    jgf2sgf: function(jgf) {\n      return Jgf2Sgf.parse(jgf);\n    }\n  };\n\n  //Return object\n  return KifuParser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Directive', [\n  'ngGo.Board.Directive'\n])\n\n/**\n * Directive definition\n */\n.directive('player', ['Player', function(Player) {\n  return {\n    restrict: 'E',\n\n    /**\n     * Controller\n     */\n    controller: ['$scope', function($scope) {\n\n      //Set player in scope\n      if (!$scope.Player) {\n        $scope.Player = Player;\n      }\n    }],\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Link the element\n      Player.linkElement(element);\n\n      //Observe mode and tool attributes\n      attrs.$observe('mode', function(mode) {\n        Player.switchMode(mode);\n      });\n      attrs.$observe('tool', function(tool) {\n        Player.switchTool(tool);\n      });\n\n      //Observe other settings attributes\n      attrs.$observe('variationMarkup', function(attr) {\n        Player.setVariationMarkup(attr === 'true');\n      });\n      attrs.$observe('solutionPaths', function(attr) {\n        Player.toggleSolutionPaths(attr === 'true');\n      });\n      attrs.$observe('lastMoveMarker', function(attr) {\n        Player.setLastMoveMarker(attr);\n      });\n    }\n  };\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Player :: This class brings the board to life and allows a user to interact with it. It\n * handles user input, controls objects going to the board, can load game records, and allows the\n * user to manipulate the board according to the current player mode.\n * Unless you want to display static positions, this is the class you'd use by default.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Service', [\n  'ngGo',\n  'ngGo.Player.Directive',\n  'ngGo.Player.Mode.Common.Service',\n  'ngGo.Board.Service',\n  'ngGo.Game.Service',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Player', ['PlayerModes', 'PlayerTools', 'MarkupTypes', function(PlayerModes, PlayerTools, MarkupTypes) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default mode/tool\n    mode: PlayerModes.REPLAY,\n    tool: PlayerTools.MOVE,\n\n    //Keys/scrollwheel navigation\n    arrow_keys_navigation: true,\n    scroll_wheel_navigation: true,\n\n    //Last move marker, leave empty for none\n    last_move_marker: MarkupTypes.LAST,\n\n    //Indicate variations with markup on the board, and show\n    //successor node variations or current node variations\n    variation_markup: true,\n    variation_children: true,\n    variation_siblings: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$document', 'Game', 'GameScorer', 'Board', 'PlayerTools', function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\n\n    /**\n     * Helper to append board grid coordinatess to the broadcast event object\n     */\n    var processMouseEvent = function(broadcastEvent, mouseEvent) {\n\n      //Can only do this with a board and mouse event\n      if (!this.board || !mouseEvent) {\n        broadcastEvent.x = -1;\n        broadcastEvent.y = -1;\n        return;\n      }\n\n      //Init\n      var x = 0;\n      var y = 0;\n\n      //Set x\n      if (typeof mouseEvent.offsetX !== 'undefined') {\n        x = mouseEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.layerX;\n      }\n\n      //Set y\n      if (typeof mouseEvent.offsetY !== 'undefined') {\n        y = mouseEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.layerY;\n      }\n\n      //Apply pixel ratio factor\n      x *= (window.devicePixelRatio || 1);\n      y *= (window.devicePixelRatio || 1);\n\n      //Append coords\n      broadcastEvent.x = this.board.getGridX(x);\n      broadcastEvent.y = this.board.getGridY(y);\n\n      //Did we drag?\n      if (mouseEvent.drag) {\n        broadcastEvent.drag = mouseEvent.drag;\n      }\n    };\n\n    /**\n     * Player class\n     */\n    var Player = {\n\n      //Player configuration\n      config: {},\n\n      //Board and game instances\n      board: null,\n      game: null,\n\n      //Available modes and tools\n      modes: {},\n      tools: [],\n\n      //Player mode and active tool\n      mode: '',\n      tool: '',\n\n      //Current path\n      path: null,\n\n      /**\n       * Initialization\n       */\n      init: function() {\n\n        //Unlink board instance, create new game\n        this.board = null;\n        this.game = new Game();\n\n        //Reset path\n        this.path = null;\n\n        //Player mode and active tool\n        this.mode = '';\n        this.tool = '';\n\n        //Arrow keys / scroll wheel navigation\n        this.arrowKeysNavigation = false;\n        this.scrollWheelNavigation = false;\n\n        //Last move marker\n        this.lastMoveMarker = '';\n\n        //Variation markup\n        this.variationMarkup = false;\n        this.variationChildren = false;\n        this.variationSiblings = false;\n\n        //Restricted nodes\n        this.restrictNodeStart = null;\n        this.restrictNodeEnd = null;\n\n        //Parse config\n        this.parseConfig();\n      },\n\n      /**\n       * Link the player to a HTML element\n       */\n      linkElement: function(element) {\n\n        //Set element\n        this.element = element;\n\n        //Register document event\n        this.registerElementEvent('keydown', $document);\n\n        //Register element events\n        this.registerElementEvent('click');\n        this.registerElementEvent('mousedown');\n        this.registerElementEvent('mouseup');\n        this.registerElementEvent('mousemove');\n        this.registerElementEvent('mouseout');\n        this.registerElementEvent('mousewheel');\n        this.registerElementEvent('wheel');\n      },\n\n      /*****************************************************************************\n       * Configuration\n       ***/\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, defaultConfig, config || {});\n\n        //Process settings\n        this.switchMode(this.config.mode);\n        this.switchTool(this.config.tool);\n        this.setArrowKeysNavigation(this.config.arrow_keys_navigation);\n        this.setScrollWheelNavigation(this.config.scroll_wheel_navigation);\n        this.setLastMoveMarker(this.config.last_move_marker);\n        this.setVariationMarkup(\n          this.config.variation_markup,\n          this.config.variation_children,\n          this.config.variation_siblings\n        );\n\n        //Let the modes parse their config\n        for (var mode in this.modes) {\n          if (this.modes[mode].parseConfig) {\n            this.modes[mode].parseConfig.call(this, this.config);\n          }\n        }\n      },\n\n      /**\n       * Set arrow keys navigation\n       */\n      setArrowKeysNavigation: function(arrowKeys) {\n        if (arrowKeys !== this.arrowKeysNavigation) {\n          this.arrowKeysNavigation = arrowKeys;\n          this.broadcast('settingChange', 'arrowKeysNavigation');\n        }\n      },\n\n      /**\n       * Set scroll wheel navigation\n       */\n      setScrollWheelNavigation: function(scrollWheel) {\n        if (scrollWheel !== this.scrollWheelNavigation) {\n          this.scrollWheelNavigation = scrollWheel;\n          this.broadcast('settingChange', 'scrollWheelNavigation');\n        }\n      },\n\n      /**\n       * Set the last move marker\n       */\n      setLastMoveMarker: function(lastMoveMarker) {\n        if (lastMoveMarker !== this.lastMoveMarker) {\n          this.lastMoveMarker = lastMoveMarker;\n          this.broadcast('settingChange', 'lastMoveMarker');\n        }\n      },\n\n      /**\n       * Set variation markup on the board\n       */\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\n\n        //One change event for these three settings\n        var change = false;\n\n        //Markup setting change?\n        if (variationMarkup !== this.variationMarkup) {\n          this.variationMarkup = variationMarkup;\n          change = true;\n        }\n\n        //Children setting change?\n        if (\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\n        ) {\n          this.variationChildren = variationChildren;\n          change = true;\n        }\n\n        //Siblings setting change?\n        if (\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\n        ) {\n          this.variationSiblings = variationSiblings;\n          change = true;\n        }\n\n        //Did anything change?\n        if (change) {\n          this.broadcast('settingChange', 'variationMarkup');\n        }\n      },\n\n      /*****************************************************************************\n       * Mode and tool handling\n       ***/\n\n      /**\n       * Register a player mode\n       */\n      registerMode: function(mode, PlayerMode) {\n\n        //Register the mode and let it parse the configuration\n        this.modes[mode] = PlayerMode;\n\n        //Parse config if we have a handler\n        if (this.modes[mode].parseConfig) {\n          this.modes[mode].parseConfig.call(this, this.config);\n        }\n\n        //Force switch the mode now, if it matches the initial mode\n        if (this.mode === mode) {\n          this.switchMode(this.mode, true);\n          this.switchTool(this.tool, true);\n        }\n      },\n\n      /**\n       * Set available tools\n       */\n      setTools: function(tools) {\n        this.tools = tools || [PlayerTools.NONE];\n      },\n\n      /**\n       * Check if we have a player mode\n       */\n      hasMode: function(mode) {\n        return this.modes[mode] ? true : false;\n      },\n\n      /**\n       * Check if we have a player tool\n       */\n      hasTool: function(tool) {\n        return (this.tools.indexOf(tool) !== -1);\n      },\n\n      /**\n       * Switch player mode\n       */\n      switchMode: function(mode, force) {\n\n        //No change?\n        if (!force && (!mode || this.mode === mode)) {\n          return false;\n        }\n\n        //Broadcast mode exit\n        if (this.mode) {\n          this.broadcast('modeExit', this.mode);\n        }\n\n        //Set mode, reset tools and active tool\n        this.mode = mode;\n        this.tools = [];\n        this.tool = PlayerTools.NONE;\n\n        //Broadcast mode entry\n        this.broadcast('modeEnter', this.mode);\n        return true;\n      },\n\n      /**\n       * Switch player tool\n       */\n      switchTool: function(tool, force) {\n\n        //No change?\n        if (!force && (!tool || this.tool === tool)) {\n          return false;\n        }\n\n        //Validate tool switch (only when there is a mode)\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\n          return false;\n        }\n\n        //Change tool\n        this.tool = tool;\n        this.broadcast('toolSwitch', this.tool);\n        return true;\n      },\n\n      /**\n       * Save the full player state\n       */\n      saveState: function() {\n\n        //Save player state\n        this.playerState = {\n          mode: this.mode,\n          tool: this.tool,\n          restrictNodeStart: this.restrictNodeStart,\n          restrictNodeEnd: this.restrictNodeEnd\n        };\n\n        //Save game state\n        this.saveGameState();\n      },\n\n      /**\n       * Restore to the saved player state\n       */\n      restoreState: function() {\n\n        //Must have player state\n        if (!this.playerState) {\n          return;\n        }\n\n        //Restore\n        this.switchMode(this.playerState.mode);\n        this.switchTool(this.playerState.tool);\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\n\n        //Restore game state\n        this.restoreGameState();\n      },\n\n      /*****************************************************************************\n       * Game record handling\n       ***/\n\n      /**\n       * Load game record\n       */\n      load: function(data, allowPlayerConfig) {\n\n        //Try to load the game record data\n        try {\n          this.game.load(data);\n        }\n        catch (error) {\n          throw error;\n        }\n\n        //Reset path\n        this.path = null;\n\n        //Parse configuration from JGF if allowed\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\n          this.parseConfig(this.game.get('settings'));\n        }\n\n        //Dispatch game loaded event\n        this.broadcast('gameLoaded', this.game);\n\n        //Board present?\n        if (this.board) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n\n        //Loaded ok\n        return true;\n      },\n\n      /**\n       * Reload the existing game record\n       */\n      reload: function() {\n\n        //Must have game\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reload game\n        this.game.reload();\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Save the current state\n       */\n      saveGameState: function() {\n        if (this.game && this.game.isLoaded()) {\n          this.gameState = this.game.getState();\n        }\n      },\n\n      /**\n       * Restore to the saved state\n       */\n      restoreGameState: function() {\n\n        //Must have game and saved state\n        if (!this.game || !this.gameState) {\n          return;\n        }\n\n        //Restore state\n        this.game.restoreState(this.gameState);\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /*****************************************************************************\n       * Navigation\n       ***/\n\n      /**\n       * Go to the next position\n       */\n      next: function(i) {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.next(i);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position\n       */\n      previous: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previous();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the last position\n       */\n      last: function() {\n        if (this.game) {\n          this.game.last();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the first position\n       */\n      first: function() {\n        if (this.game) {\n          this.game.first();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to a specific move number, tree path or named node\n       */\n      goto: function(target) {\n        if (this.game && target) {\n          this.game.goto(target);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the previous fork\n       */\n      previousFork: function() {\n        if (this.game) {\n          this.game.previousFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next fork\n       */\n      nextFork: function() {\n        if (this.game) {\n          this.game.nextFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Restrict navigation to the current node\n       */\n      restrictNode: function(end) {\n\n        //Must have game and node\n        if (!this.game || !this.game.node) {\n          return;\n        }\n\n        //Restrict to current node\n        if (end) {\n          this.restrictNodeEnd = this.game.node;\n        }\n        else {\n          this.restrictNodeStart = this.game.node;\n        }\n      },\n\n      /**\n       * Process a new game position\n       */\n      processPosition: function() {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Get current node and game position\n        var node = this.game.getNode();\n        var path = this.game.getPath();\n        var position = this.game.getPosition();\n        var pathChanged = !path.compare(this.path);\n\n        //Update board\n        this.updateBoard(node, position, pathChanged);\n\n        //Path change?\n        if (pathChanged) {\n\n          //Copy new path and broadcast path change\n          this.path = path.clone();\n          this.broadcast('pathChange', node);\n\n          //Named node reached? Broadcast event\n          if (node.name) {\n            this.broadcast('reachedNode.' + node.name, node);\n          }\n        }\n\n        //Passed?\n        if (node.move && node.move.pass) {\n          this.broadcast('movePassed', node);\n        }\n      },\n\n      /*****************************************************************************\n       * Game handling\n       ***/\n\n      /**\n       * Start a new game\n       */\n      newGame: function() {\n        this.game = new Game();\n        this.processPosition();\n      },\n\n      /**\n       * Score the current game position\n       */\n      scoreGame: function() {\n\n        //Calculate score\n        GameScorer.calculate();\n\n        //Get score, points and captures\n        var score = GameScorer.getScore();\n        var points = GameScorer.getPoints();\n        var captures = GameScorer.getCaptures();\n\n        //Remove all markup, and set captures and points\n        this.board.layers.markup.removeAll();\n        this.board.layers.score.setAll(points, captures);\n\n        //Broadcast score\n        this.broadcast('scoreCalculated', score);\n      },\n\n      /*****************************************************************************\n       * Board handling\n       ***/\n\n      /**\n       * Get the board\n       */\n      getBoard: function() {\n        return this.board;\n      },\n\n      /**\n       * Set the board\n       */\n      setBoard: function(Board) {\n\n        //Set the board\n        this.board = Board;\n\n        //Board ready\n        if (this.board) {\n          this.broadcast('boardReady', this.board);\n        }\n\n        //If a game has been loaded already, parse config and update the board\n        if (this.game && this.game.isLoaded()) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Update the board\n       */\n      updateBoard: function(node, position, pathChanged) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Update board with new position\n        this.board.updatePosition(position, pathChanged);\n\n        //Mark last move\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\n        }\n\n        //Broadcast board update event\n        this.broadcast('boardUpdate', node);\n      },\n\n      /*****************************************************************************\n       * Event handling\n       ***/\n\n      /**\n       * Register an element event\n       */\n      registerElementEvent: function(event, element) {\n\n        //Which element to use\n        if (typeof element === 'undefined' || !element.on) {\n          element = this.element;\n        }\n\n        //Remove any existing event listener and apply new one\n        //TODO: Namespacing events doesn't work with Angular's jqLite\n        element.off(event/* + '.ngGo.player'*/);\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\n      },\n\n      /**\n       * Event listener\n       */\n      on: function(type, listener, mode, $scope) {\n\n        //Must have valid listener\n        if (typeof listener !== 'function') {\n          console.warn('Listener is not a function:', listener);\n          return;\n        }\n\n        //Scope given as 3rd parameter?\n        if (mode && mode.$parent) {\n          $scope = mode;\n          mode = '';\n        }\n\n        //Multiple events?\n        if (type.indexOf(' ') !== -1) {\n          var types = type.split(' ');\n          for (var t = 0; t < types.length; t++) {\n            this.on(types[t], listener, mode, $scope);\n          }\n          return;\n        }\n\n        //Get self and determine scope to use\n        var self = this;\n        var scope = $scope || $rootScope;\n\n        //Create listener and return de-registration function\n        return scope.$on('ngGo.player.' + type, function() {\n\n          //Filter on mode\n          if (mode) {\n            if (\n              (typeof mode === 'string' && mode !== self.mode) ||\n              mode.indexOf(self.mode) === -1\n            ) {\n              return;\n            }\n          }\n\n          //Inside a text field?\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\n            return;\n          }\n\n          //Append grid coordinates for mouse events\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\n            processMouseEvent.call(self, arguments[0], arguments[1]);\n          }\n\n          //Dragging? Prevent click events from firing\n          if (self.preventClickEvent && type === 'click') {\n            delete self.preventClickEvent;\n            return;\n          }\n          else if (type === 'mousedrag') {\n            self.preventClickEvent = true;\n          }\n\n          //Call listener\n          listener.apply(self, arguments);\n        });\n      },\n\n      /**\n       * Event broadcaster\n       */\n      broadcast: function(type, args) {\n\n        //Must have type\n        if (!type) {\n          return;\n        }\n\n        //Make sure we are in a digest cycle\n        if (!$rootScope.$$phase) {\n          $rootScope.$apply(function() {\n            $rootScope.$broadcast('ngGo.player.' + type, args);\n          });\n        }\n        else {\n          $rootScope.$broadcast('ngGo.player.' + type, args);\n        }\n      }\n    };\n\n    //Initialize\n    Player.init();\n\n    //Return object\n    return Player;\n  }];\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\n * gridlines, starpoints and coordinates via the Coordinates class.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Coordinates.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GridLayer', ['BoardLayer', 'Coordinates', function(BoardLayer, Coordinates) {\n\n  /**\n   * Helper for drawing starpoints\n   */\n  var drawStarPoint = function(gridX, gridY, starRadius, starColor) {\n\n    //Don't draw if it falls outsize of the board grid\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\n      return;\n    }\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\n      return;\n    }\n\n    //Get absolute coordinates and star point radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n\n    //Draw star point\n    this.context.beginPath();\n    this.context.fillStyle = starColor;\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\n    this.context.fill();\n  };\n\n  /**\n   * Constructor\n   */\n  var GridLayer = function(board, context) {\n\n    //Set coordinates setting\n    this.coordinates = false;\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Show or hide the coordinates.\n   */\n  GridLayer.prototype.setCoordinates = function(show) {\n    this.coordinates = show;\n  };\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Get all has nothing to return\n   */\n  GridLayer.prototype.getAll = function() {\n    return null;\n  };\n\n  /**\n   * Set all has nothing to set\n   */\n  GridLayer.prototype.setAll = function(/*grid*/) {\n    return;\n  };\n\n  /**\n   * Remove all has nothing to remove\n   */\n  GridLayer.prototype.removeAll = function() {\n    return;\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw method\n   */\n  GridLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Determine top x and y margin\n    var tx = this.board.drawMarginHor;\n    var ty = this.board.drawMarginVer;\n\n    //Get theme properties\n    var cellSize = this.board.getCellSize();\n    var lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\n    var lineCap = this.board.theme.get('grid.lineCap');\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', cellSize);\n    var starColor = this.board.theme.get('grid.star.color');\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n    this.context.strokeStyle = strokeStyle;\n\n    //Helper vars\n    var i, x, y;\n\n    //Draw vertical lines\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\n      x = this.board.getAbsX(i);\n      this.context.moveTo(x, ty);\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\n    }\n\n    //Draw horizontal lines\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\n      y = this.board.getAbsY(i);\n      this.context.moveTo(tx, y);\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\n    }\n\n    //Draw grid lines\n    this.context.stroke();\n\n    //Star points defined?\n    for (i = 0; i < starPoints.length; i++) {\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n\n    //Draw coordinates\n    if (this.coordinates) {\n      Coordinates.draw.call(this);\n    }\n  };\n\n  /**\n   * Clear a square cell area on the grid\n   */\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Clear rectangle\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Redraw a square cell area on the grid\n   */\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', s);\n    var starColor = this.board.theme.get('grid.star.color');\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n\n    //Determine draw coordinates\n    var x1 = (gridX === 0) ? x : x - r;\n    var x2 = (gridX === this.board.width - 1) ? x : x + r;\n    var y1 = (gridY === 0) ? y : y - r;\n    var y2 = (gridY === this.board.height - 1) ? y : y + r;\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Patch up grid lines\n    this.context.moveTo(x1, y);\n    this.context.lineTo(x2, y);\n    this.context.moveTo(x, y1);\n    this.context.lineTo(x, y2);\n    this.context.stroke();\n\n    //Check if we need to draw a star point here\n    for (var i in starPoints) {\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\n      }\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  //Return\n  return GridLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('HoverLayer', ['BoardLayer', 'Markup', 'StoneFaded', function(BoardLayer, Markup, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var HoverLayer = function(board, context) {\n\n    //Container for items to restore\n    this.restore = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add hover item\n   */\n  HoverLayer.prototype.add = function(x, y, hover) {\n\n    //Validate coordinates\n    if (!this.grid.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Remove any previous item at this position\n    this.remove(x, y);\n\n    //Create hover object\n    hover.object = {\n      x: x,\n      y: y\n    };\n\n    //Stones\n    if (hover.type === 'stones') {\n      hover.objectClass = StoneFaded;\n      hover.object.color = hover.value;\n    }\n\n    //Markup\n    else if (hover.type === 'markup') {\n      hover.objectClass = Markup;\n      if (typeof hover.value === 'object') {\n        hover.object = angular.extend(hover.object, hover.value);\n      }\n      else {\n        hover.object.type = hover.value;\n      }\n    }\n\n    //Unknown\n    else {\n      console.warn('Unknown hover type', hover.type);\n      return;\n    }\n\n    //Check if we need to hide something on layers underneath\n    if (this.board.has(hover.type, x, y)) {\n      this.restore.push({\n        x: x,\n        y: y,\n        layer: hover.type,\n        value: this.board.get(hover.type, x, y)\n      });\n      this.board.remove(hover.type, x, y);\n    }\n\n    //Add to stack\n    this.grid.set(x, y, hover);\n\n    //Draw item\n    if (hover.objectClass && hover.objectClass.draw) {\n      hover.objectClass.draw.call(this, hover.object);\n    }\n  };\n\n  /**\n   * Remove the hover object\n   */\n  HoverLayer.prototype.remove = function(x, y) {\n\n    //Validate coordinates\n    if (!this.grid.has(x, y)) {\n      return;\n    }\n\n    //Get object and clear it\n    var hover = this.grid.get(x, y);\n    if (hover.objectClass && hover.objectClass.clear) {\n      hover.objectClass.clear.call(this, hover.object);\n    }\n\n    //Other objects to restore?\n    for (var i = 0; i < this.restore.length; i++) {\n      if (this.restore[i].x === x && this.restore[i].y === y) {\n        this.board.add(\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n        );\n        this.restore.splice(i, 1);\n      }\n    }\n  };\n\n  /**\n   * Remove all hover objects\n   */\n  HoverLayer.prototype.removeAll = function() {\n\n    //Anything to do?\n    if (this.grid.isEmpty()) {\n      return;\n    }\n\n    //Get all item as objects\n    var i;\n    var hover = this.grid.all('layer');\n\n    //Clear them\n    for (i = 0; i < hover.length; i++) {\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\n        hover[i].objectClass.clear.call(this, hover[i].object);\n      }\n    }\n\n    //Clear layer and empty grid\n    this.clear();\n    this.grid.empty();\n\n    //Restore objects on other layers\n    for (i = 0; i < this.restore.length; i++) {\n      this.board.add(\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n      );\n    }\n\n    //Clear restore array\n    this.restore = [];\n  };\n\n  /**\n   * Draw layer\n   */\n  HoverLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Loop objects and clear them\n    var hover = this.grid.all('hover');\n    for (var i = 0; i < hover.length; i++) {\n      if (hover.objectClass && hover.objectClass.draw) {\n        hover.objectClass.draw.call(this, hover.object);\n      }\n    }\n  };\n\n  //Return\n  return HoverLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('MarkupLayer', ['BoardLayer', 'Markup', function(BoardLayer, Markup) {\n\n  /**\n   * Constructor\n   */\n  var MarkupLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all markup at once\n   */\n  MarkupLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'type');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Markup.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Markup.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  MarkupLayer.prototype.removeAll = function() {\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Clear them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.clear.call(this, markup[i]);\n    }\n\n    //Empty the grid now\n    this.grid.empty();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  MarkupLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Draw them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.draw.call(this, markup[i]);\n    }\n  };\n\n  /**\n   * Draw cell\n   */\n  MarkupLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  MarkupLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  //Return\n  return MarkupLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ScoreLayer', ['BoardLayer', 'StoneMini', 'StoneFaded', function(BoardLayer, StoneMini, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var ScoreLayer = function(board, context) {\n\n    //Points and captures\n    this.points = [];\n    this.captures = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set points and captures\n   */\n  ScoreLayer.prototype.setAll = function(points, captures) {\n\n    //Remove all existing stuff first\n    this.removeAll();\n\n    //Set new stuff\n    this.points = points.all('color');\n    this.captures = captures.all('color');\n\n    //Draw\n    this.draw();\n  };\n\n  /**\n   * Remove all scoring\n   */\n  ScoreLayer.prototype.removeAll = function() {\n\n    //If there are captures, draw them back onto the stones layer\n    for (var i = 0; i < this.captures.length; i++) {\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\n    }\n\n    //Clear the layer\n    this.clear();\n\n    //Remove all stuff\n    this.points = [];\n    this.captures = [];\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  ScoreLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Init\n    var i;\n\n    //Draw captures first (removing stones from the stones layer)\n    for (i = 0; i < this.captures.length; i++) {\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\n      StoneFaded.draw.call(this, this.captures[i]);\n    }\n\n    //Draw points on top of it\n    for (i = 0; i < this.points.length; i++) {\n      StoneMini.draw.call(this, this.points[i]);\n    }\n  };\n\n  //Return\n  return ScoreLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneShadow.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ShadowLayer', ['BoardLayer', 'StoneShadow', function(BoardLayer, StoneShadow) {\n\n  /**\n   * Constructor\n   */\n  var ShadowLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add a stone\n   */\n  ShadowLayer.prototype.add = function(stone) {\n\n    //Don't add if no shadow\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\n      return;\n    }\n\n    //Already have a stone here?\n    if (this.grid.has(stone.x, stone.y)) {\n      return;\n    }\n\n    //Add to grid\n    this.grid.set(stone.x, stone.y, stone.color);\n\n    //Draw it if there is a context\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\n      StoneShadow.draw.call(this, stone);\n    }\n  };\n\n  /**\n   * Remove a stone\n   */\n  ShadowLayer.prototype.remove = function(stone) {\n\n    //Remove from grid\n    this.grid.unset(stone.x, stone.y);\n\n    //Redraw whole layer\n    this.redraw();\n  };\n\n  /**\n   * Draw layer\n   */\n  ShadowLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get shadowsize from theme\n    var shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\n\n    //Apply shadow transformation\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      StoneShadow.draw.call(this, stones[i]);\n    }\n  };\n\n  //Return\n  return ShadowLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StonesLayer', ['BoardLayer', 'Stone', 'StoneColor', function(BoardLayer, Stone, StoneColor) {\n\n  /**\n   * Constructor\n   */\n  var StonesLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n\n    //Set empty value for grid\n    this.grid.whenEmpty(StoneColor.EMPTY);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all stones at once\n   */\n  StonesLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'color');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Stone.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Stone.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  StonesLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      Stone.draw.call(this, stones[i]);\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  StonesLayer.prototype.redraw = function() {\n\n    //Clear shadows layer\n    this.board.removeAll('shadow');\n\n    //Redraw ourselves\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  StonesLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  StonesLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  //Return\n  return StonesLayer;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Coordinates :: This class is used for drawing board coordinates\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Coordinates.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('Coordinates', function() {\n\n  //Kanji\n  var kanji = [\n    '一', '二', '三', '四', '五', '六', '七', '八', '九', '十',\n    '十一', '十二', '十三', '十四', '十五', '十六', '十七', '十八', '十九', '二十',\n    '二十一', '二十二', '二十三', '二十四', '二十五', '二十六', '二十七', '二十八', '二十九', '三十',\n    '三十一', '三十二', '三十三', '三十四', '三十五', '三十六', '三十七', '三十八', '三十九', '四十'\n  ];\n\n  //Character codes\n  var aChar = 'A'.charCodeAt(0);\n  var aCharLc = 'a'.charCodeAt(0);\n\n  /**\n   * Coordinate generators\n   */\n  var coordinates = {\n\n    //Kanji coordinates\n    kanji: function(i) {\n      return kanji[i] || '';\n    },\n\n    //Numbers from 1\n    numbers: function(i) {\n      return i + 1;\n    },\n\n    //Capital letters from A\n    letters: function(i) {\n\n      //Initialize\n      var ch = '';\n\n      //Beyond Z? Prepend with A\n      if (i >= 25) {\n        ch = 'A';\n        i -= 25;\n      }\n\n      //The letter I is ommitted\n      if (i >= 8) {\n        i++;\n      }\n\n      //Return\n      return ch + String.fromCharCode(aChar + i);\n    },\n\n    //JGF coordinates (e.g. 0, 1, ...)\n    jgf: function(i) {\n      return i;\n    },\n\n    //SGF coordinates (e.g. a, b, ...)\n    sgf: function(i) {\n      var ch;\n      if (i < 26) {\n        ch = aCharLc + i;\n      }\n      else {\n        ch = aChar + i;\n      }\n      return String.fromCharCode(ch);\n    }\n  };\n\n  /**\n   * Coordinates object\n   */\n  var Coordinates = {\n\n    /**\n     * Draw\n     */\n    draw: function() {\n\n      //Can only draw when we have context and dimensions\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Get cell size\n      var cellSize = this.board.getCellSize();\n\n      //Get boundary coordinates\n      var xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\n      var xr = this.board.drawWidth - xl;\n      var yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\n      var yb = this.board.drawHeight - yt;\n\n      //Get theme properties\n      var fillStyle = this.board.theme.get('coordinates.color');\n      var vertical = {\n        font: this.board.theme.get('coordinates.vertical.font'),\n        size: this.board.theme.get('coordinates.vertical.size'),\n        style: this.board.theme.get('coordinates.vertical.style'),\n        inverse: this.board.theme.get('coordinates.vertical.inverse')\n      };\n      var horizontal = {\n        font: this.board.theme.get('coordinates.horizontal.font'),\n        size: this.board.theme.get('coordinates.horizontal.size'),\n        style: this.board.theme.get('coordinates.horizontal.style'),\n        inverse: this.board.theme.get('coordinates.horizontal.inverse')\n      };\n\n      //Configure context\n      this.context.fillStyle = fillStyle;\n      this.context.textBaseline = 'middle';\n      this.context.textAlign = 'center';\n\n      //Helper vars\n      var i, j, x, y, ch;\n\n      //Draw vertical coordinates\n      for (i = 0; i < this.board.height; i++) {\n\n        //Inverse?\n        j = i;\n        if (vertical.inverse) {\n          j = this.board.height - i - 1;\n        }\n\n        //Get character\n        if (typeof vertical.style === 'function') {\n          ch = vertical.style.call(this, j);\n        }\n        else if (coordinates[vertical.style]) {\n          ch = coordinates[vertical.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        y = this.board.getAbsY(i);\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\n        this.context.fillText(ch, xl, y);\n        this.context.fillText(ch, xr, y);\n      }\n\n      //Draw horizontal coordinates\n      for (i = 0; i < this.board.width; i++) {\n\n        //Inverse?\n        j = i;\n        if (horizontal.inverse) {\n          j = this.board.width - i - 1;\n        }\n\n        //Get character\n        if (typeof horizontal.style === 'function') {\n          ch = horizontal.style.call(this, j);\n        }\n        else if (coordinates[horizontal.style]) {\n          ch = coordinates[horizontal.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        x = this.board.getAbsX(i);\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\n        this.context.fillText(ch, x, yt);\n        this.context.fillText(ch, x, yb);\n      }\n    }\n  };\n\n  //Return\n  return Coordinates;\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Markup :: This class is used for drawing markup\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Markup.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Markup', ['MarkupTypes', 'BoardObject', function(MarkupTypes, BoardObject) {\n\n  /**\n   * Math constants\n   */\n  var cosPi4 = Math.cos(Math.PI / 4);\n  var cosPi6 = Math.cos(Math.PI / 6);\n\n  /**\n   * Triangle draw handler\n   */\n  var drawTriangle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y - r);\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.closePath();\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Square draw handler\n   */\n  var drawSquare = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw circle handler\n   */\n  var drawCircle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw mark handler\n   */\n  var drawMark = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x - rcos, y - rcos);\n    this.context.lineTo(x + rcos, y + rcos);\n    this.context.moveTo(x + rcos, y - rcos);\n    this.context.lineTo(x - rcos, y + rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw select handler\n   */\n  var drawSelect = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Last move draw handler\n   */\n  var drawLast = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(s);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y);\n    this.context.lineTo(x + r, y);\n    this.context.lineTo(x, y + r);\n    this.context.closePath();\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw happy smiley handler\n   */\n  var drawHappySmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 8);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw sad smiley handler\n   */\n  var drawSadSmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw label\n   */\n  var drawLabel = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var font = markup.font || this.board.theme.get('markup.label.font') || '';\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //First, clear grid square below for clarity\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.clearCell(markup.x, markup.y);\n    }\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.textBaseline = 'middle';\n    this.context.textAlign = 'center';\n\n    //Convert to text\n    if (typeof markup.text === 'number') {\n      markup.text = markup.text.toString();\n    }\n\n    //Determine font size\n    if (markup.text.length === 1) {\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\n    }\n    else if (markup.text.length === 2) {\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\n    }\n    else {\n      this.context.font = r + 'px ' + font;\n    }\n\n    //Draw element\n    this.context.beginPath();\n    this.context.fillText(markup.text, x, y, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Clear label\n   */\n  var clearLabel = function(markup) {\n\n    //No stone on location? Redraw the grid square, if we cleared it\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\n    }\n  };\n\n  /**\n   * Markup class\n   */\n  var Markup = {\n\n    /**\n     * Draw\n     */\n    draw: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Drawing depends on type\n      switch (markup.type) {\n\n        //Triangle\n        case MarkupTypes.TRIANGLE:\n          drawTriangle.call(this, markup);\n          break;\n\n        //Square\n        case MarkupTypes.SQUARE:\n          drawSquare.call(this, markup);\n          break;\n\n        //Circle\n        case MarkupTypes.CIRCLE:\n          drawCircle.call(this, markup);\n          break;\n\n        //Mark\n        case MarkupTypes.MARK:\n          drawMark.call(this, markup);\n          break;\n\n        //Select\n        case MarkupTypes.SELECT:\n          drawSelect.call(this, markup);\n          break;\n\n        //happy\n        case MarkupTypes.HAPPY:\n          drawHappySmiley.call(this, markup);\n          break;\n\n        //Sad\n        case MarkupTypes.SAD:\n          drawSadSmiley.call(this, markup);\n          break;\n\n        //Last move marker\n        case MarkupTypes.LAST:\n          drawLast.call(this, markup);\n          break;\n\n        //Label\n        case MarkupTypes.LABEL:\n          markup.text = markup.text || '';\n          drawLabel.call(this, markup);\n          break;\n      }\n    },\n\n    /**\n     * Clear\n     */\n    clear: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, markup);\n\n      //Special handling for label\n      if (markup.type === MarkupTypes.LABEL) {\n        clearLabel.call(this, markup);\n      }\n    }\n  };\n\n  //Return\n  return Markup;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Stone :: This class is used for drawing stones on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Stone.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n  'ngGo.Board.ShellPattern.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Stone', ['$injector', 'BoardObject', 'StoneColor', 'ShellPattern', function($injector, BoardObject, StoneColor, ShellPattern) {\n\n  /**\n   * Shell random seed\n   */\n  var shellSeed;\n\n  /**\n   * Mono colored stones\n   */\n  var drawMono = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Don't draw shadow\n    stone.shadow = false;\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\n    var fillStyle = this.board.theme.get('stone.mono.color', color);\n    var strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Configure context\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Draw outline\n    this.context.stroke();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Glass stones\n   */\n  var drawGlass = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Begin path\n    this.context.beginPath();\n\n    //Determine stone texture\n    if (color === StoneColor.W) {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#fff');\n      this.context.fillStyle.addColorStop(1, '#aaa');\n    }\n    else {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#666');\n      this.context.fillStyle.addColorStop(1, '#111');\n    }\n\n    //Complete drawing\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Slate and shell stones\n   */\n  var drawSlateShell = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Get random seed\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var shellTypes = this.board.theme.get('stone.shell.types');\n    var fillStyle = this.board.theme.get('stone.shell.color', color);\n    var strokeStyle = this.board.theme.get('stone.shell.stroke');\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fillStyle = fillStyle;\n    this.context.fill();\n\n    //Shell stones\n    if (color === StoneColor.W) {\n\n      //Get random shell type\n      var type =\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\n\n      //Determine random angle\n      var z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\n      var angle = (2 / z) * (shellSeed % z);\n\n      //Draw shell pattern\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Slate stones\n    else {\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Constructor\n   */\n  var Stone = {\n\n    /**\n     * Draw a stone\n     */\n    draw: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Determine style of stone\n      var style = this.board.theme.get('stone.style');\n\n      //Draw using the appropriate handler\n      switch (style) {\n\n        //Slate and shell\n        case 'shell':\n          drawSlateShell.call(this, stone);\n          break;\n\n        //Glass stones\n        case 'glass':\n          drawGlass.call(this, stone);\n          break;\n\n        //Mono stones\n        case 'mono':\n          drawMono.call(this, stone);\n          break;\n\n        //Custom type\n        default:\n          var handler = $injector.get(style);\n          if (handler) {\n            handler.call(this, stone);\n          }\n      }\n\n      //Add shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.add(stone);\n      }\n    },\n\n    /**\n     * Clear a stone\n     */\n    clear: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, stone);\n\n      //Remove shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.remove(stone);\n      }\n    }\n  };\n\n  //Return\n  return Stone;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneFaded', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneFaded = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.faded.scale');\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneFaded;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\n * (for scoring).\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneMini.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneMini', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneMini = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.mini.scale');\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneMini;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneShadow :: This class is used for drawing stone shadows on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneShadow', function() {\n\n  /**\n   * Constructor\n   */\n  var StoneShadow = {\n\n    /**\n     * Draw a stone shadow\n     */\n    draw: function(stone) {\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\n\n      //Apply scaling factor?\n      if (stone.scale) {\n        r = Math.round(r * stone.scale);\n      }\n\n      //Get theme properties\n      var blur = this.board.theme.get('shadow.blur', s);\n      var offsetX = this.board.theme.get('shadow.offsetX', s);\n      var offsetY = this.board.theme.get('shadow.offsetY', s);\n      var shadowColor = this.board.theme.get('shadow.color');\n\n      //Configure context\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\n      );\n      this.context.fillStyle.addColorStop(0, shadowColor);\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n\n      //Draw shadow\n      this.context.beginPath();\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\n      this.context.fill();\n    },\n\n    /**\n     * Clear a stone shadow\n     */\n    clear: function(stone) {\n\n      //Note: this method is currently not in use due to the overlapping shadows\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\n      //appropriate either, so for now we will leave it at this.\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = this.board.theme.get('stone.radius', s);\n\n      //Clear a generous rectangle\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\n    }\n  };\n\n  //Return\n  return StoneShadow;\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Gib2Jgf', ['ngGo', 'KifuBlank', function(ngGo, KifuBlank) {\n\n  /**\n   * Regular expressions\n   */\n  var regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\n  var regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\n  var regKomi = /GAMEGONGJE=([0-9]+)/gi;\n  var regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\n  var regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\n  var regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\n\n  /**\n   * Player parser function\n   */\n  var parsePlayer = function(jgf, match) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\n\n    //Create player object\n    var player = {\n      color: color,\n      name: match[2],\n      rank: match[3].toLowerCase()\n    };\n\n    //Check if player of this color already exists, if so, overwrite\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p] = player;\n        return;\n      }\n    }\n\n    //Player of this color not found, push\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, match) {\n    jgf.game.komi = parseFloat(match[1] / 10);\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, match) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Push date\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\n  };\n\n  /**\n   * Result parser function\n   */\n  var parseResult = function(jgf, match) {\n\n    //Winner color\n    var result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\n    result += '+';\n\n    //Win condition\n    if (match[2].match(/res/i)) {\n      result += 'R';\n    }\n    else if (match[2].match(/time/i)) {\n      result += 'T';\n    }\n    else {\n      result += match[2];\n    }\n\n    //Set in JGF\n    jgf.game.result = result;\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, match) {\n\n    //Determine player color\n    var color = match[2];\n    if (color === 1) {\n      color = 'B';\n    }\n    else if (color === 2) {\n      color = 'W';\n    }\n    else {\n      return;\n    }\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (false) {\n\n    }\n\n    //Regular move\n    else {\n      node.move[color] = [match[3] * 1, match[4] * 1];\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    parse: function(gib, stringified) {\n\n      //Get new JGF object\n      var jgf = KifuBlank.jgf();\n\n      //Initialize\n      var match;\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find player information\n      while ((match = regPlayer.exec(gib))) {\n        parsePlayer(jgf, match);\n      }\n\n      //Find komi\n      if ((match = regKomi.exec(gib))) {\n        parseKomi(jgf, match);\n      }\n\n      //Find game date\n      if ((match = regDate.exec(gib))) {\n        parseDate(jgf, match);\n      }\n\n      //Find game result\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\n        parseResult(jgf, match);\n      }\n\n      //Find moves\n      while ((match = regMove.exec(gib))) {\n\n        //Create new node\n        node = {};\n\n        //Parse move\n        parseMove(jgf, node, match);\n\n        //Push node to container\n        container.push(node);\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Jgf2Sgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Flip SGF alias map and create JGF alias map\n   */\n  var jgfAliases = {};\n  for (var sgfProp in sgfAliases) {\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\n    }\n  }\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert to SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Helper to escape SGF info\n   */\n  var escapeSgf = function(text) {\n    if (typeof text === 'string') {\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\n    }\n    return text;\n  };\n\n  /**\n   * Helper to write an SGF group\n   */\n  var writeGroup = function(prop, values, output, escape) {\n    if (values.length) {\n      output.sgf += prop;\n      for (var i = 0; i < values.length; i++) {\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\n      }\n    }\n  };\n\n  /**\n   * Move parser\n   */\n  var parseMove = function(move, output) {\n\n    //Determine and validate color\n    var color = move.B ? 'B' : (move.W ? 'W' : '');\n    if (color === '') {\n      return;\n    }\n\n    //Determine move\n    var coords = (move[color] === 'pass') ? '' : move[color];\n\n    //Append to SGF\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\n  };\n\n  /**\n   * Setup parser\n   */\n  var parseSetup = function(setup, output) {\n\n    //Loop colors\n    for (var color in setup) {\n      if (setup.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < setup[color].length; i++) {\n          setup[color][i] = convertCoordinates(setup[color][i]);\n        }\n\n        //Write as group\n        writeGroup('A' + color, setup[color], output);\n      }\n    }\n  };\n\n  /**\n   * Score parser\n   */\n  var parseScore = function(score, output) {\n\n    //Loop colors\n    for (var color in score) {\n      if (score.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < score[color].length; i++) {\n          score[color][i] = convertCoordinates(score[color][i]);\n        }\n\n        //Write as group\n        writeGroup('T' + color, score[color], output);\n      }\n    }\n  };\n\n  /**\n   * Markup parser\n   */\n  var parseMarkup = function(markup, output) {\n\n    //Loop markup types\n    for (var type in markup) {\n      if (markup.hasOwnProperty(type)) {\n        var i;\n\n        //Label type has the label text appended to the coords\n        if (type === 'label') {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\n          }\n        }\n        else {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]);\n          }\n        }\n\n        //Convert type\n        if (typeof jgfAliases[type] !== 'undefined') {\n          type = jgfAliases[type];\n        }\n\n        //Write as group\n        writeGroup(type, markup[type], output);\n      }\n    }\n  };\n\n  /**\n   * Turn parser\n   */\n  var parseTurn = function(turn, output) {\n    output.sgf += 'PL[' + turn + ']';\n  };\n\n  /**\n   * Comments parser\n   */\n  var parseComments = function(comments, output) {\n\n    //Determine key\n    var key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\n\n    //Flatten comment objects\n    var flatComments = [];\n    for (var c = 0; c < comments.length; c++) {\n      if (typeof comments[c] === 'string') {\n        flatComments.push(comments[c]);\n      }\n      else if (comments[c].comment) {\n        flatComments.push(comments[c].comment);\n      }\n    }\n\n    //Write as group\n    writeGroup(key, flatComments, output, true);\n  };\n\n  /**\n   * Node name parser\n   */\n  var parseNodeName = function(nodeName, output) {\n    var key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\n  };\n\n  /**\n   * Game parser\n   */\n  var parseGame = function(game) {\n\n    //Loop SGF game definitions\n    for (var i in sgfGames) {\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\n        return i;\n      }\n    }\n\n    //Not found\n    return 0;\n  };\n\n  /**\n   * Application parser\n   */\n  var parseApplication = function(application) {\n    var parts = application.split(' v');\n    if (parts.length > 1) {\n      return parts[0] + ':' + parts[1];\n    }\n    return application;\n  };\n\n  /**\n   * Player instructions parser\n   */\n  var parsePlayer = function(player, rootProperties) {\n\n    //Variation handling\n    var st = 0;\n    if (!player.variation_markup) {\n      st += 2;\n    }\n    if (player.variation_siblings) {\n      st += 1;\n    }\n\n    //Set in root properties\n    rootProperties.ST = st;\n  };\n\n  /**\n   * Board parser\n   */\n  var parseBoard = function(board, rootProperties) {\n\n    //Both width and height should be given\n    if (board.width && board.height) {\n\n      //Same dimensions?\n      if (board.width === board.height) {\n        rootProperties.SZ = board.width;\n      }\n\n      //Different dimensions are not supported by SGF, but OGS uses the\n      //format w:h, so we will stick with that for anyone who supports it.\n      else {\n        rootProperties.SZ = board.width + ':' + board.height;\n      }\n    }\n\n    //Otherwise, check if only width or height were given at least\n    else if (board.width) {\n      rootProperties.SZ = board.width;\n    }\n    else if (board.height) {\n      rootProperties.SZ = board.height;\n    }\n\n    //Can't determine size\n    else {\n      rootProperties.SZ = '';\n    }\n  };\n\n  /**\n   * Players parser\n   */\n  var parsePlayers = function(players, rootProperties) {\n\n    //Loop players\n    for (var p = 0; p < players.length; p++) {\n\n      //Validate color\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\n        continue;\n      }\n\n      //Get SGF color\n      var color = (players[p].color === 'black') ? 'B' : 'W';\n\n      //Name given?\n      if (players[p].name) {\n        rootProperties['P' + color] = players[p].name;\n      }\n\n      //Rank given?\n      if (players[p].rank) {\n        rootProperties[color + 'R'] = players[p].rank;\n      }\n\n      //Team given?\n      if (players[p].team) {\n        rootProperties[color + 'T'] = players[p].team;\n      }\n    }\n  };\n\n  /**\n   * Parse function to property mapper\n   */\n  var parsingMap = {\n\n    //Node properties\n    'move': parseMove,\n    'setup': parseSetup,\n    'score': parseScore,\n    'markup': parseMarkup,\n    'turn': parseTurn,\n    'comments': parseComments,\n    'name': parseNodeName,\n\n    //Info properties\n    'record.application': parseApplication,\n    'player': parsePlayer,\n    'board': parseBoard,\n    'game.type': parseGame,\n    'game.players': parsePlayers\n  };\n\n  /*****************************************************************************\n   * Parser functions\n   ***/\n\n  /**\n   * Helper to write a JGF tree to SGF\n   */\n  var writeTree = function(tree, output) {\n\n    //Loop nodes in the tree\n    for (var i = 0; i < tree.length; i++) {\n      var node = tree[i];\n\n      //Array? That means a variation\n      if (angular.isArray(node)) {\n        for (var j = 0; j < node.length; j++) {\n          output.sgf += '(\\n;';\n          writeTree(node[j], output);\n          output.sgf += '\\n)';\n        }\n\n        //Continue\n        continue;\n      }\n\n      //Loop node properties\n      for (var key in node) {\n        if (node.hasOwnProperty(key)) {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[key] !== 'undefined') {\n            parsingMap[key](node[key], output);\n            continue;\n          }\n\n          //Other object, can't handle it\n          if (typeof node[key] === 'object') {\n            continue;\n          }\n\n          //Anything else, append it\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\n        }\n      }\n\n      //More to come?\n      if ((i + 1) < tree.length) {\n        output.sgf += '\\n;';\n      }\n    }\n  };\n\n  /**\n   * Helper to extract all SGF root properties from a JGF object\n   */\n  var extractRootProperties = function(jgf, rootProperties, key) {\n\n    //Initialize key\n    if (typeof key === 'undefined') {\n      key = '';\n    }\n\n    //Loop properties of jgf node\n    for (var subKey in jgf) {\n      if (jgf.hasOwnProperty(subKey)) {\n\n        //Skip SGF signature (as we keep our own)\n        if (subKey === 'sgf') {\n          continue;\n        }\n\n        //Build jgf key\n        var jgfKey = (key === '') ? subKey : key + '.' + subKey;\n\n        //If the item is an object, handle separately\n        if (typeof jgf[subKey] === 'object') {\n\n          //Handler for this object present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\n          }\n\n          //Otherwise, just flatten and call this function recursively\n          else {\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\n          }\n          continue;\n        }\n\n        //Check if it's a known key, if so, append the value to the root\n        var value;\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            value = parsingMap[jgfKey](jgf[subKey]);\n          }\n          else {\n            value = escapeSgf(jgf[subKey]);\n          }\n\n          //Set in root properties\n          rootProperties[jgfAliases[jgfKey]] = value;\n        }\n      }\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    parse: function(jgf) {\n\n      //String given?\n      if (typeof jgf === 'string') {\n        jgf = angular.fromJson(jgf);\n      }\n\n      //Must have moves tree\n      if (!jgf.tree) {\n        console.error('No moves tree in JGF object');\n        return;\n      }\n\n      //Initialize output (as object, so it remains a reference) and root properties container\n      var output = {sgf: '(\\n;'};\n      var root = angular.copy(jgf);\n      var rootProperties = KifuBlank.sgf();\n\n      //The first node of the JGF tree is the root node, and it can contain comments,\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\n      //and attach it to the root\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\n        root = angular.extend(root, jgf.tree[0]);\n        delete root.root;\n        delete jgf.tree[0];\n      }\n\n      //Set root properties\n      delete root.tree;\n      extractRootProperties(root, rootProperties);\n\n      //Write root properties\n      for (var key in rootProperties) {\n        if (rootProperties[key]) {\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\n        }\n      }\n\n      //Write game tree\n      writeTree(jgf.tree, output);\n\n      //Close SGF and return\n      output.sgf += ')';\n      return output.sgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Sgf2Jgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Regular expressions for SGF data\n   */\n  var regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\n  var regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\n  var regProperty = /[A-Z]+/;\n  var regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Application parser function (doesn't overwrite existing signature)\n   */\n  var parseApp = function(jgf, node, key, value) {\n    if (!jgf.record.application) {\n      var app = value[0].split(':');\n      if (app.length > 1) {\n        jgf.record.application = app[0] + ' v' + app[1];\n      }\n      else {\n        jgf.record.application = app[0];\n      }\n    }\n  };\n\n  /**\n   * SGF format parser\n   */\n  var parseSgfFormat = function() {\n    return;\n  };\n\n  /**\n   * Game type parser function\n   */\n  var parseGame = function(jgf, node, key, value) {\n    var game = value[0];\n    if (typeof sgfGames[game] !== 'undefined') {\n      jgf.game.type = sgfGames[game];\n    }\n    else {\n      jgf.game.type = value[0];\n    }\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, key, value) {\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\n      node.move[key] = 'pass';\n    }\n\n    //Regular move\n    else {\n      node.move[key] = convertCoordinates(value[0]);\n    }\n  };\n\n  /**\n   * Comment parser function\n   */\n  var parseComment = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Node name parser function\n   */\n  var parseNodeName = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value[0];\n  };\n\n  /**\n   * Board setup parser function\n   */\n  var parseSetup = function(jgf, node, key, value) {\n\n    //Initialize setup container on node\n    if (typeof node.setup === 'undefined') {\n      node.setup = {};\n    }\n\n    //Remove \"A\" from setup key\n    key = key.charAt(1);\n\n    //Initialize setup container of this type\n    if (typeof node.setup[key] === 'undefined') {\n      node.setup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.setup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Scoring parser function\n   */\n  var parseScore = function(jgf, node, key, value) {\n\n    //Initialize score container on node\n    if (typeof node.score === 'undefined') {\n      node.score = {\n        B: [],\n        W: []\n      };\n    }\n\n    //Remove \"T\" from setup key\n    key = key.charAt(1);\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.score[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Turn parser function\n   */\n  var parseTurn = function(jgf, node, key, value) {\n    node.turn = value[0];\n  };\n\n  /**\n   * Label parser function\n   */\n  var parseLabel = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n\n      //Split off coordinates and add label contents\n      var coords = convertCoordinates(value[i].substr(0, 2));\n      coords.push(value[i].substr(3));\n\n      //Add to node\n      node.markup[key].push(coords);\n    }\n  };\n\n  /**\n   * Markup parser function\n   */\n  var parseMarkup = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.markup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Size parser function\n   */\n  var parseSize = function(jgf, node, key, value) {\n\n    //Initialize board container\n    if (typeof jgf.board === 'undefined') {\n      jgf.board = {};\n    }\n\n    //Add size property (can be width:height or just a single size)\n    var size = value[0].split(':');\n    if (size.length > 1) {\n      jgf.board.width = parseInt(size[0]);\n      jgf.board.height = parseInt(size[1]);\n    }\n    else {\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\n    }\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, node, key, value) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Explode dates\n    var dates = value[0].split(',');\n    for (var d = 0; d < dates.length; d++) {\n      jgf.game.dates.push(dates[d]);\n    }\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, node, key, value) {\n    jgf.game.komi = parseFloat(value[0]);\n  };\n\n  /**\n   * Variations handling parser function\n   */\n  var parseVariations = function(jgf, node, key, value) {\n\n    //Initialize display property\n    if (typeof jgf.player === 'undefined') {\n      jgf.player = {};\n    }\n\n    //Initialize variation display settings\n    jgf.player.variation_markup = false;\n    jgf.player.variation_children = false;\n    jgf.player.variation_siblings = false;\n\n    //Parse as integer\n    var st = parseInt(value[0]);\n\n    //Determine what we want (see SGF specs for details)\n    switch (st) {\n      case 0:\n        jgf.player.variation_markup = true;\n        jgf.player.variation_children = true;\n        break;\n      case 1:\n        jgf.player.variation_markup = true;\n        jgf.player.variation_siblings = true;\n        break;\n      case 2:\n        jgf.player.variation_children = true;\n        break;\n      case 3:\n        jgf.player.variation_siblings = true;\n        break;\n    }\n  };\n\n  /**\n   * Player info parser function\n   */\n  var parsePlayer = function(jgf, node, key, value) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Check if player of this color already exists\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p][key] = value[0];\n        return;\n      }\n    }\n\n    //Player of this color not found, initialize\n    var player = {color: color};\n    player[key] = value[0];\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Parsing function to property mapper\n   */\n  var parsingMap = {\n\n    //Application, game type, board size, komi, date\n    'AP': parseApp,\n    'FF': parseSgfFormat,\n    'GM': parseGame,\n    'SZ': parseSize,\n    'KM': parseKomi,\n    'DT': parseDate,\n\n    //Variations handling\n    'ST': parseVariations,\n\n    //Player info handling\n    'PB': parsePlayer,\n    'PW': parsePlayer,\n    'BT': parsePlayer,\n    'WT': parsePlayer,\n    'BR': parsePlayer,\n    'WR': parsePlayer,\n\n    //Moves\n    'B': parseMove,\n    'W': parseMove,\n\n    //Node annotation\n    'C': parseComment,\n    'N': parseNodeName,\n\n    //Board setup\n    'AB': parseSetup,\n    'AW': parseSetup,\n    'AE': parseSetup,\n    'PL': parseTurn,\n    'TW': parseScore,\n    'TB': parseScore,\n\n    //Markup\n    'CR': parseMarkup,\n    'SQ': parseMarkup,\n    'TR': parseMarkup,\n    'MA': parseMarkup,\n    'SL': parseMarkup,\n    'LB': parseLabel\n  };\n\n  /**\n   * These properties need a node object\n   */\n  var needsNode = [\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB'\n  ];\n\n  /*****************************************************************************\n   * Parser helpers\n   ***/\n\n  /**\n   * Set info in the JGF tree at a certain position\n   */\n  var setInfo = function(jgf, position, value) {\n\n    //Position given must be an array\n    if (typeof position !== 'object') {\n      return;\n    }\n\n    //Initialize node to attach value to\n    var node = jgf;\n    var key;\n\n    //Loop the position\n    for (var p = 0; p < position.length; p++) {\n\n      //Get key\n      key = position[p];\n\n      //Last key reached? Done\n      if ((p + 1) === position.length) {\n        break;\n      }\n\n      //Create container if not set\n      if (typeof node[key] !== 'object') {\n        node[key] = {};\n      }\n\n      //Move up in tree\n      node = node[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    parse: function(sgf, stringified) {\n\n      //Get new JGF object (with SGF node as a base)\n      var jgf = KifuBlank.jgf({record: {sgf: {}}});\n\n      //Initialize\n      var stack = [];\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find sequence of elements\n      var sequence = sgf.match(regSequence);\n\n      //Loop sequence items\n      for (var i = 0; i < sequence.length; i++) {\n\n        //Push stack if new variation found\n        if (sequence[i] === '(') {\n\n          //First encounter, this defines the main tree branch, so skip\n          if (i === 0 || i === '0') {\n            continue;\n          }\n\n          //Push the current container to the stack\n          stack.push(container);\n\n          //Create variation container if it doesn't exist yet\n          if (!angular.isArray(container[container.length - 1])) {\n            container.push([]);\n          }\n\n          //Use variation container\n          container = container[container.length - 1];\n\n          //Now create moves container\n          container.push([]);\n          container = container[container.length - 1];\n          continue;\n        }\n\n        //Grab last container from stack if end of variation reached\n        else if (sequence[i] === ')') {\n          if (stack.length) {\n            container = stack.pop();\n          }\n          continue;\n        }\n\n        //Make array of properties within this sequence\n        var properties = sequence[i].match(regNode) || [];\n\n        //Loop them\n        for (var j = 0; j < properties.length; j++) {\n\n          //Get property's key and separate values\n          var key = regProperty.exec(properties[j])[0].toUpperCase();\n          var values = properties[j].match(regValues);\n\n          //Remove additional braces [ and ]\n          for (var k = 0; k < values.length; k++) {\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\n          }\n\n          //SGF parser present for this key? Call it, and we're done\n          if (typeof parsingMap[key] !== 'undefined') {\n\n            //Does this type of property need a node?\n            if (needsNode.indexOf(key) !== -1) {\n\n              //If no node object present, create a new node\n              //For moves, always a new node is created\n              if (!node || key === 'B' || key === 'W') {\n                node = {};\n                container.push(node);\n              }\n            }\n\n            //Apply parsing function on node\n            parsingMap[key](jgf, node, key, values);\n            continue;\n          }\n\n          //No SGF parser present, we continue with regular property handling\n\n          //If there is only one value, simplify array\n          if (values.length === 1) {\n            values = values[0];\n          }\n\n          //SGF alias known? Then this is an info element and we handle it accordingly\n          if (typeof sgfAliases[key] !== 'undefined') {\n\n            //The position in the JGF object is represented by dot separated strings\n            //in the sgfAliases array. Split the position and use the setInfo helper\n            //to set the info on the JGF object\n            setInfo(jgf, sgfAliases[key].split('.'), values);\n            continue;\n          }\n\n          //No SGF alias present either, just append the data\n\n          //Save in node\n          if (node) {\n            node[key] = values;\n          }\n\n          //Save in root\n          else {\n            jgf[key] = values;\n          }\n        }\n\n        //Reset node, unless this was the root node\n        if (node && !node.root) {\n          node = null;\n        }\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeCommon :: This class governs common event handling of the player shared by\n * various player modes. It's basically an abstract player mode and it can't be actively set.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Common.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Run block\n */\n.run(['Player', 'PlayerModes', 'PlayerModeCommon', function(Player, PlayerModes, PlayerModeCommon) {\n\n  /**\n   * Register common event handlers\n   */\n  Player.on('keydown', PlayerModeCommon.keyDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n}])\n\n/**\n * Factory definition\n */\n.factory('PlayerModeCommon', ['Player', 'PlayerTools', 'GameScorer', 'KeyCodes', function(Player, PlayerTools, GameScorer, KeyCodes) {\n\n  /**\n   * Helper to build drag object\n   */\n  var dragObject = function(event) {\n\n    //Initialize drag object\n    var drag = {\n      start: {\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y\n      },\n      stop: {\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y\n      }\n    };\n\n    //Fix boundaries\n    if (drag.start.x < 0) {\n      drag.start.x = 0;\n    }\n    if (drag.start.y < 0) {\n      drag.start.y = 0;\n    }\n    if (drag.stop.x > this.board.width - 1) {\n      drag.stop.x = this.board.width - 1;\n    }\n    if (drag.stop.y > this.board.height - 1) {\n      drag.stop.y = this.board.height - 1;\n    }\n\n    //Return\n    return drag;\n  };\n\n  /**\n   * Normalize the mousewheel event helper\n   */\n  function normalizeMousewheelEvent(event) {\n\n    //Initialize vars\n    var deltaX = 0;\n    var deltaY = 0;\n\n    //Old school scrollwheel delta\n    if ('detail' in event) {\n      deltaY = event.detail * -1;\n    }\n    if ('wheelDelta' in event) {\n      deltaY = event.wheelDelta;\n    }\n    if ('wheelDeltaY' in event) {\n      deltaY = event.wheelDeltaY;\n    }\n    if ('wheelDeltaX' in event) {\n      deltaX = event.wheelDeltaX * -1;\n    }\n\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\n      deltaX = deltaY * -1;\n      deltaY = 0;\n    }\n\n    //New type wheel delta (WheelEvent)\n    if ('deltaY' in event) {\n      deltaY = event.deltaY * -1;\n    }\n    if ('deltaX' in event) {\n      deltaX = event.deltaX;\n    }\n\n    //Set in event (have to use different property name because of strict mode)\n    event.mouseWheelX = deltaX;\n    event.mouseWheelY = deltaY;\n\n    //Return\n    return event;\n  }\n\n  /**\n   * Player extension\n   */\n  angular.extend(Player, {\n\n    /**\n     * Mouse coordinate helper vars\n     */\n    mouse: {\n\n      //Drag start\n      dragStart: null,\n\n      //Last grid coordinates\n      lastX: -1,\n      lastY: -1\n    }\n  });\n\n  /**\n   * Player mode definition\n   */\n  var PlayerMode = {\n\n    /**\n     * Handler for keydown events\n     */\n    keyDown: function(event, keyboardEvent) {\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Switch key code\n      switch (keyboardEvent.keyCode) {\n\n        //ESC\n        case KeyCodes.ESC:\n\n          //Cancel drag event, and prevent click event as well\n          this.mouse.dragStart = null;\n          this.preventClickEvent = true;\n          break;\n\n        //Right arrow\n        case KeyCodes.RIGHT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Advance to the next move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\n              this.next();\n            }\n          }\n          break;\n\n        //Left arrow\n        case KeyCodes.LEFT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Go to the previous move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\n              this.previous();\n            }\n          }\n          break;\n\n        //Up arrow\n        case KeyCodes.UP:\n          break;\n\n        //Down arrow\n        case KeyCodes.DOWN:\n          break;\n      }\n    },\n\n    /**\n     * Handler for mousewheel events\n     */\n    mouseWheel: function(event, mouseEvent) {\n\n      //Disabled or not using move tool?\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\n        return true;\n      }\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return true;\n      }\n\n      //Normalize mousewheel event\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\n\n      //Find delta\n      var delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\n\n      //Next move\n      if (delta < 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.next();\n      }\n\n      //Previous move\n      else if (delta > 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.previous();\n      }\n\n      //Don't scroll the window\n      if (delta !== 0) {\n        mouseEvent.preventDefault();\n      }\n    },\n\n    /**\n     * Mouse out handler\n     */\n    mouseOut: function() {\n      if (this.board) {\n        this.board.removeAll('hover');\n      }\n    },\n\n    /**\n     * Mouse move handler\n     */\n    mouseMove: function(event, mouseEvent) {\n\n      //Attach drag object to events\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n      }\n\n      //Nothing else to do?\n      if (!this.board || !this.board.layers.hover) {\n        return;\n      }\n\n      //Last coordinates are the same?\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\n        return;\n      }\n\n      //Remember last coordinates\n      this.mouse.lastX = event.x;\n      this.mouse.lastY = event.y;\n\n      //Broadcast hover event\n      this.broadcast('hover', mouseEvent);\n    },\n\n    /**\n     * Mouse down handler\n     */\n    mouseDown: function(event) {\n      this.mouse.dragStart = {\n        x: event.x,\n        y: event.y\n      };\n    },\n\n    /**\n     * Mouse up handler\n     */\n    mouseUp: function(event, mouseEvent) {\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n        this.broadcast('mousedrag', mouseEvent);\n      }\n      this.mouse.dragStart = null;\n    }\n  };\n\n  //Return\n  return PlayerMode;\n}]);\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\n * a game record and its board positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Edit.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Setup tools\n */\n.constant('SetupTools', {\n  BLACK: 'black',\n  WHITE: 'white',\n  CLEAR: 'clear'\n})\n\n/**\n * Markup tools\n */\n.constant('MarkupTools', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  SAD: 'sad',\n  HAPPY: 'happy',\n  TEXT: 'text',\n  NUMBER: 'number',\n  CLEAR: 'clear'\n})\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeEdit', function(Player, PlayerModes, PlayerModeEdit) {\n\n  //Register event handlers\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\n\n  //Register mode\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeEdit', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['Player', 'PlayerTools', 'SetupTools', 'MarkupTools', 'MarkupTypes', 'GameScorer', 'StoneColor', function(\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\n  ) {\n\n    //Character codes\n    var aChar = 'A'.charCodeAt(0);\n    var aCharLc = 'a'.charCodeAt(0);\n\n    /**\n     * Update hover mark at specific coordinates\n     */\n    var updateHoverMark = function(x, y, isDrag) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Setup tool\n        case PlayerTools.SETUP:\n\n          //Clear tool\n          if (this.setupTool === SetupTools.CLEAR) {\n\n            //Stone present? Can remove it\n            if (this.game.hasStone(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Stone color tool\n          else {\n\n            //Add or overwrite stone if no stone present of the given color\n            if (!this.game.hasStone(x, y, this.setupToolColor())) {\n              this.board.add('hover', x, y, {\n                type: 'stones',\n                value: this.setupToolColor()\n              });\n            }\n\n            //Stone present of same color? Can remove it if we're not dragging\n            else if (!isDrag) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n          break;\n\n        //Markup tool\n        case PlayerTools.MARKUP:\n\n          //Clear tool, or already markup in place?\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\n            if (this.game.hasMarkup(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Text or number\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: {\n                type: MarkupTypes.LABEL,\n                text: this.markupLabel\n              }\n            });\n          }\n\n          //Other markup\n          else {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: this.markupTool\n            });\n          }\n          break;\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to set markup\n     */\n    var setMarkup = function(x, y) {\n\n      //Already markup in place? Remove it first\n      if (this.game.hasMarkup(x, y)) {\n\n        //Check what markup there is\n        var markup = this.game.getMarkup(x, y);\n\n        //Label? Also remove from our labels list\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\n          var i = this.markupLabels.indexOf(markup.text);\n          if (i !== -1) {\n            this.markupLabels.splice(i, 1);\n          }\n        }\n\n        //Remove from game\n        this.game.removeMarkup(x, y);\n        return;\n      }\n\n      //Clear tool used? Done\n      if (this.markupTool === MarkupTools.CLEAR) {\n        return;\n      }\n\n      //Text\n      else if (this.markupTool === MarkupTools.TEXT) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next text label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Number\n      else if (this.markupTool === MarkupTools.NUMBER) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next number label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Other markup\n      else {\n        this.game.addMarkup(x, y, this.markupTool);\n      }\n    };\n\n    /**\n     * Helper to set a stone\n     */\n    var setStone = function(x, y, isDrag) {\n\n      //Get the stone color\n      var color = this.setupToolColor();\n\n      //Trying to remove a stone\n      if (color === StoneColor.EMPTY) {\n        this.game.removeStone(x, y);\n      }\n\n      //Adding a stone\n      else {\n\n        //A stone there already of the same color? Just remove if not dragging\n        if (!isDrag && this.game.hasStone(x, y, color)) {\n          this.game.removeStone(x, y);\n          return;\n        }\n\n        //Any stone present?\n        else if (this.game.hasStone(x, y)) {\n          this.game.removeStone(x, y);\n        }\n\n        //Add stone now\n        this.game.addStone(x, y, color);\n      }\n\n      //Redraw markup\n      this.board.layers.markup.redrawCell(x, y);\n    };\n\n    /**\n     * Find all markup labels in current position\n     */\n    var findAllMarkupLabels = function() {\n\n      //Clear\n      this.markupLabels = [];\n\n      //Must have game\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get all markup from position\n      var markup = this.game.position.markup.all('type');\n      for (var i = 0; i < markup.length; i++) {\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\n          this.markupLabels.push(markup[i].text);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Active setup tool and markup tool\n      setupTool: SetupTools.BLACK,\n      markupTool: MarkupTools.TRIANGLE,\n\n      //Current markup labels on the board and current markup label\n      markupLabels: [],\n      markupLabel: '',\n\n      /**\n       * Set the setup tool\n       */\n      switchSetupTool: function(tool) {\n        this.setupTool = tool;\n      },\n\n      /**\n       * Set the markup tool\n       */\n      switchMarkupTool: function(tool) {\n        this.markupTool = tool;\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          this.determineMarkupLabel();\n        }\n      },\n\n      /**\n       * Conversion of setup tool to stone color\n       */\n      setupToolColor: function() {\n        switch (this.setupTool) {\n          case SetupTools.BLACK:\n            return StoneColor.B;\n          case SetupTools.WHITE:\n            return StoneColor.W;\n          default:\n            return StoneColor.EMPTY;\n        }\n      },\n\n      /**\n       * Set the new text markup label\n       */\n      setMarkupLabel: function(label) {\n        if (label) {\n          this.markupLabel = label;\n        }\n      },\n\n      /**\n       * Determine the new text markup label\n       */\n      determineMarkupLabel: function() {\n\n        //Clear\n        this.markupLabel = '';\n\n        //Check what tool we're using\n        switch (this.markupTool) {\n\n          //Text tool?\n          case MarkupTools.TEXT:\n            var i = 0;\n\n            //Loop while the label is present\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n\n              //A-Z\n              if (i < 26) {\n                this.markupLabel = String.fromCharCode(aChar + i);\n              }\n\n              //a-z\n              else if (i < 52) {\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\n              }\n\n              //AA, AB, AC, etc.\n              else {\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\n                  String.fromCharCode(aChar + (i % 26));\n              }\n\n              //Keep going\n              i++;\n            }\n            break;\n\n          //Number tool?\n          case MarkupTools.NUMBER:\n            this.markupLabel = 0;\n\n            //Loop while the label is present\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n              this.markupLabel++;\n            }\n            break;\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeEdit = {\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Remove all hover items\n        this.board.removeAll('hover');\n\n        //Single coordinate?\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //No dragging for labels\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //Loop area\n        for (var x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n          for (var y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n            updateHoverMark.call(this, x, y, true);\n          }\n        }\n      },\n\n      /**\n       * Keydown handler\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //TODO: tool switching via keyboard input\n        }\n      },\n\n      /**\n       * Click handler\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        this.board.removeAll('hover');\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Try to play the move\n            if (!this.game.play(event.x, event.y)) {\n              return;\n            }\n            this.processPosition();\n            break;\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Set stone and update board\n            setStone.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Set markup and update board\n            setMarkup.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Mouse drag handler\n       */\n      mouseDrag: function(event) {\n\n        //Initialize vars\n        var x, y;\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setStone.call(this, x, y, true);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Don't do this for labels\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n              break;\n            }\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setMarkup.call(this, x, y);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Path change\n       */\n      pathChange: function() {\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SETUP,\n          PlayerTools.MARKUP,\n          PlayerTools.SCORE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Find all markup labels in the current game position\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeEdit;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\n * through an existing game record without the ability to deviate from the tree or its variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Replay.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeReplay', function(Player, PlayerModes, PlayerModeReplay) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\n\n  //Register the mode\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeReplay', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Auto play delay\n    auto_play_delay: 1000\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$interval', 'Player', 'PlayerModes', 'PlayerTools', 'MarkupTypes', 'GameScorer', function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show move variations on the board\n     */\n    var showMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n\n        //Auto variation markup should never overwrite existing markup\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\n          continue;\n        }\n\n        //Add to board\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n          type: this.board.theme.get('markup.variation.type'),\n          text: this.board.theme.get('markup.variation.text', i),\n          color: this.board.theme.get('markup.variation.color')\n        });\n      }\n    };\n\n    /**\n     * Helper to hide move variations from the board\n     */\n    var hideMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) move variations on the board\n     */\n    var drawMoveVariations = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get the current node\n      var node = this.game.getNode();\n      var variations;\n      if (!node) {\n        return;\n      }\n\n      //Child variations?\n      if (this.variationChildren && node.hasMoveVariations()) {\n        variations = node.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n\n      //Sibling variations?\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\n        variations = node.parent.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Auto play vars\n      autoPlaying: false,\n      autoPlayDelay: 1000,\n      autoPlayPromise: null,\n\n      /**\n       * Set auto play delay\n       */\n      setAutoPlayDelay: function(delay) {\n        if (this.autoPlayDelay !== delay) {\n          this.autoPlayDelay = delay;\n          this.broadcast('settingChange', 'autoPlayDelay');\n        }\n      },\n\n      /**\n       * Start auto play with a given delay\n       */\n      start: function(delay) {\n\n        //Not in replay mode or already auto playing?\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\n          return;\n        }\n\n        //Already auto playing, no game or no move children?\n        if (!this.game || !this.game.node.hasChildren()) {\n          return;\n        }\n\n        //Get self\n        var self = this;\n\n        //Determine delay\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\n\n        //Switch tool\n        this.switchTool(PlayerTools.NONE);\n\n        //Create interval\n        this.autoPlaying = true;\n        this.autoPlayPromise = $interval(function() {\n\n          //Advance to the next node\n          self.next(0, true);\n\n          //Ran out of children?\n          if (!self.game.node.hasChildren()) {\n            self.stop();\n          }\n        }, delay);\n\n        //Broadcast event\n        this.broadcast('autoPlayStarted', this.game.node);\n      },\n\n      /**\n       * Stop auto play\n       */\n      stop: function() {\n\n        //Not in replay mode or not auto playing?\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\n          return;\n        }\n\n        //Cancel interval\n        if (this.autoPlayPromise) {\n          $interval.cancel(this.autoPlayPromise);\n        }\n\n        //Clear flags\n        this.autoPlayPromise = null;\n        this.autoPlaying = false;\n\n        //Broadcast event\n        this.broadcast('autoPlayStopped', this.game.node);\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeReplay = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.setAutoPlayDelay(this.config.auto_play_delay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'variationMarkup') {\n          drawMoveVariations.call(this, this.variationMarkup);\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Check if we clicked a move variation, advance to the next position if so\n            if (this.game.isMoveVariation(event.x, event.y)) {\n              this.next(this.game.getMoveVariation(event.x, event.y));\n            }\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeReplay.hover.call(this, event);\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SCORE,\n          PlayerTools.NONE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Stop auto playing\n        if (this.autoPlaying) {\n          this.stop();\n        }\n\n        //Hide move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, false);\n        }\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeReplay;\n  }];\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\n * go problems and finding the right move or variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Solve.Service', [\n  'ngGo'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeSolve', function(Player, PlayerModes, PlayerModeSolve) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\n\n  //Register mode\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeSolve', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Player color\n    player_color: StoneColor.B,\n\n    //Show solution paths\n    solution_paths: false,\n\n    //Auto play settings\n    solve_auto_play: true,\n    solve_auto_play_delay: 500\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$timeout', 'Player', 'PlayerModes', 'PlayerTools', 'KeyCodes', function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\n\n    /**\n     * Check if we can make a move\n     */\n    var canMakeMove = function() {\n\n      //We can make a move when...\n\n      //...there is no auto play going on\n      if (!this.solveAutoPlay) {\n        return true;\n      }\n\n      //...we solved the puzzle already\n      if (this.problemSolved) {\n        return true;\n      }\n\n      //...we are off path\n      if (this.problemOffPath) {\n        return true;\n      }\n\n      //...it's our turn\n      if (this.game.getTurn() === this.playerColor) {\n        return true;\n      }\n\n      //Otherwise, we can't make a move\n      return false;\n    };\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show solution paths\n     */\n    var showSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        if (variations[i].solution === true) {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.valid.type'),\n            text: this.board.theme.get('markup.solution.valid.text', i),\n            scale: this.board.theme.get('markup.solution.valid.scale'),\n            color: this.board.theme.get('markup.solution.valid.color')\n          });\n        }\n        else {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.invalid.type'),\n            text: this.board.theme.get('markup.solution.invalid.text', i),\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\n            color: this.board.theme.get('markup.solution.invalid.color')\n          });\n        }\n      }\n    };\n\n    /**\n     * Helper to hide solution paths\n     */\n    var hideSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) solution paths\n     */\n    var drawSolutionPaths = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get node and variations\n      var node = this.game.getNode();\n      var variations = node.getMoveVariations();\n\n      //When showing, make sure it's not during the auto solver's move\n      if (show && !this.problemSolved && this.solveAutoPlay) {\n        if (this.game.getTurn() !== this.playerColor) {\n          hideSolutionPaths.call(this, variations);\n          return;\n        }\n      }\n\n      //Call helper\n      if (show) {\n        showSolutionPaths.call(this, variations);\n      }\n      else {\n        hideSolutionPaths.call(this, variations);\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Solved and off-path flags\n      problemSolved: false,\n      problemOffPath: false,\n\n      //Problem start path\n      problemStartPath: null,\n\n      //The player color\n      playerColor: 0,\n\n      //Solution paths\n      solutionPaths: false,\n\n      //Auto play vars\n      solveAutoPlay: true,\n      solveAutoPlayDelay: 500,\n\n      //Navigation blocked flag\n      solveNavigationBlocked: false,\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlay: function(autoPlay) {\n        if (this.solveAutoPlay !== autoPlay) {\n          this.solveAutoPlay = autoPlay;\n          this.broadcast('settingChange', 'solveAutoPlay');\n        }\n      },\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlayDelay: function(delay) {\n        if (this.solveAutoPlayDelay !== delay) {\n          this.solveAutoPlayDelay = delay;\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\n        }\n      },\n\n      /**\n       * Set player color\n       */\n      setPlayerColor: function(color) {\n        if (this.playerColor !== color) {\n          this.playerColor = color;\n          this.broadcast('settingChange', 'playerColor');\n        }\n      },\n\n      /**\n       * Get player color\n       */\n      getPlayerColor: function(asOnBoard) {\n        if (asOnBoard && this.board) {\n          return this.board.colorMultiplier * this.playerColor;\n        }\n        return this.playerColor;\n      },\n\n      /**\n       * Toggle solution paths\n       */\n      toggleSolutionPaths: function(solutionPaths) {\n\n        //Toggle if not given\n        if (typeof solutionPaths === 'undefined') {\n          solutionPaths = !this.solutionPaths;\n        }\n\n        //Change?\n        if (solutionPaths !== this.solutionPaths) {\n          this.solutionPaths = solutionPaths;\n          this.broadcast('settingChange', 'solutionPaths');\n        }\n      },\n\n      /**\n       * Auto play next move\n       */\n      autoPlayNext: function(immediately) {\n\n        //Must have game and children\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\n          return;\n        }\n\n        //Init vars\n        var children = [];\n        var self = this;\n        var i;\n\n        //When picking a child node, we always prefer to pick a valid solution\n        for (i = 0; i < this.game.node.children.length; i++) {\n          if (this.game.node.children[i].solution) {\n            children.push(this.game.node.children[i]);\n          }\n        }\n\n        //No solution nodes? Just use all nodes then.\n        if (children.length === 0) {\n          children = this.game.node.children;\n        }\n\n        //Pick a random child node\n        i = Math.floor(Math.random() * children.length);\n\n        //No delay?\n        if (immediately || !this.solveAutoPlayDelay) {\n          this.next(children[i]);\n          return;\n        }\n\n        //Block navigation and run the timeout\n        this.solveNavigationBlocked = true;\n        $timeout(function() {\n\n          //Move to next move and unblock navigation\n          self.next(children[i]);\n          self.solveNavigationBlocked = false;\n\n        }, this.solveAutoPlayDelay);\n      },\n\n      /**\n       * Start solving from the current game node\n       */\n      solve: function() {\n\n        //Must have a game\n        if (!this.game || !this.game.isLoaded()) {\n          return false;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Remember problem start path\n        this.problemStartPath = this.game.getPath(true);\n\n        //Restrict start of navigation to the current node\n        this.restrictNode();\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      },\n\n      /**\n       * Restart the problem\n       */\n      restartProblem: function() {\n\n        //Must be in solve mode, must have game\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Go back to the start path\n        if (this.problemStartPath) {\n          this.goto(this.problemStartPath);\n        }\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeSolve = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.toggleSolutionPaths(this.config.solution_paths);\n        this.setPlayerColor(this.config.player_color);\n        this.setSolveAutoPlay(this.config.solve_auto_play);\n        this.setSolveAutoPlayDelay(this.config.solve_auto_play_delay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'solutionPaths') {\n          drawSolutionPaths.call(this, this.solutionPaths);\n        }\n\n        //Player color changed?\n        if (setting === 'playerColor') {\n\n          //Draw (or hide) solution paths\n          drawSolutionPaths.call(this, this.solutionPaths);\n\n          //Make an auto play move if it's not our turn\n          if (\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\n          ) {\n            this.autoPlayNext(true);\n          }\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this, event.x, event.y);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for keydown events\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //Right arrow\n          case KeyCodes.RIGHT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\n\n                //Go forward one move if solved\n                if (this.problemSolved) {\n                  this.next();\n                }\n              }\n            }\n            break;\n\n          //Left arrow\n          case KeyCodes.LEFT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked and not reached the start?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\n\n                //Go back one move\n                this.previous();\n\n                //Go back one more if this is not the player's turn and if\n                //the problem hasn't been solved yet\n                if (\n                  !this.problemSolved && this.solveAutoPlay &&\n                  this.game.getTurn() === -this.playerColor\n                ) {\n                  this.previous();\n                }\n              }\n            }\n            break;\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //A valid variation\n        if (this.game.isMoveVariation(event.x, event.y)) {\n\n          //Get the node\n          var i = this.game.getMoveVariation(event.x, event.y);\n\n          //Advance to the next position and get the next node\n          this.next(i);\n          var node = this.game.getNode();\n\n          //No children left? Check if we solved it or not\n          if (node.children.length === 0) {\n            if (node.solution === true) {\n              this.problemSolved = true;\n              this.broadcast('solutionFound', node);\n            }\n            else {\n              this.broadcast('solutionWrong', node);\n            }\n          }\n\n          //Auto-play next move?\n          else if (!this.problemSolved && this.solveAutoPlay) {\n            this.autoPlayNext();\n          }\n        }\n\n        //Unknown variation, try to play\n        else if (this.game.play(event.x, event.y)) {\n          this.problemOffPath = true;\n          this.processPosition();\n          this.broadcast('solutionOffPath', this.game.getNode());\n        }\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Draw solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Hide any solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, false);\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeSolve;\n  }];\n}]);\n\n})(window, window.angular);\n","/**\n * ngGo - v1.2.5 - 2-11-2015\n * https://github.com/adambuczynski/ngGo\n *\n * Copyright (c) 2015 Adam Buczynski <me@adambuczynski.com>\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n/**\n * ngGo\n *\n * This is the AngularJS implementation of WGo, based on WGo version 2.3.1. All code has been\n * refactored to fit the Angular framework, as well as having been linted, properly commented\n * and generally cleaned up.\n *\n * Copyright (c) 2013 Jan Prokop (WGo)\n * Copyright (c) 2014-2015 Adam Buczynski (ngGo)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo', [])\n\n/**\n * ngGo constants\n */\n.constant('ngGo', {\n  name: 'ngGo',\n  version: '1.2.5',\n  error: {\n\n    //Position errors\n    POSITION_OUT_OF_BOUNDS: 1,\n    POSITION_ALREADY_HAS_STONE: 2,\n    POSITION_IS_SUICIDE: 3,\n    POSITION_IS_REPEATING: 4,\n\n    //Data loading errors\n    NO_DATA: 5,\n    UNKNOWN_DATA: 6,\n    INVALID_SGF: 7,\n    INVALID_GIB: 8,\n    INVALID_JGF_JSON: 9,\n    INVALID_JGF_TREE_JSON: 10\n  }\n})\n\n/**\n * Stone colors\n */\n.constant('StoneColor', {\n  E: 0,\n  EMPTY: 0,\n  B: 1,\n  BLACK: 1,\n  W: -1,\n  WHITE: -1\n})\n\n/**\n * Markup types\n */\n.constant('MarkupTypes', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  LABEL: 'label',\n  LAST: 'last',\n  SAD: 'sad',\n  HAPPY: 'happy'\n})\n\n/**\n * Player modes\n */\n.constant('PlayerModes', {\n  PLAY: 'play',\n  REPLAY: 'replay',\n  EDIT: 'edit',\n  SOLVE: 'solve'\n})\n\n/**\n * Player tools\n */\n.constant('PlayerTools', {\n  NONE: 'none',\n  MOVE: 'move',\n  SCORE: 'score',\n  SETUP: 'setup',\n  MARKUP: 'markup'\n})\n\n/**\n * Key codes\n */\n.constant('KeyCodes', {\n  LEFT: 37,\n  RIGHT: 39,\n  UP: 38,\n  DOWN: 40,\n  ESC: 27,\n  ENTER: 13,\n  SPACE: 32,\n  TAB: 9,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  HOME: 36,\n  END: 35,\n  PAGEUP: 33,\n  PAGEDOWN: 34\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Directive', [\n  'ngGo.Board.Service'\n])\n\n/**\n * Directive definition\n */\n.directive('board', ['$window', 'Board', function($window, Board) {\n\n  //Get pixel ratio\n  var pixelRatio = window.pixelRatio || 1;\n\n  /**\n   * Helper to create a layer canvas\n   */\n  var createLayerCanvas = function(name) {\n\n    //Create canvas element and get context\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    //Scale context depending on pixel ratio\n    if (pixelRatio > 1) {\n      context.scale(pixelRatio, pixelRatio);\n    }\n\n    //Set class\n    canvas.className = name;\n\n    //Set initial canvas width/height based on our own size\n    canvas.width = this.clientWidth * pixelRatio;\n    canvas.height = this.clientHeight * pixelRatio;\n\n    //Append to element now and return context\n    this.appendChild(canvas);\n    return context;\n  };\n\n  /**\n   * Helper to determine draw size\n   */\n  var determineDrawSize = function(scope, availableWidth, availableHeight) {\n\n    //Init vars\n    var drawWidth, drawHeight, cellSize;\n\n    //Stretch available height to width if zero\n    if (availableHeight === 0 && availableWidth > 0) {\n      availableHeight = availableWidth;\n    }\n\n    //Grid size known?\n    if (scope.Board.width && scope.Board.height) {\n\n      //Determine smallest cell size\n      cellSize = Math.min(availableWidth / scope.Board.width, availableHeight / scope.Board.height);\n\n      //Set draw size\n      drawWidth = Math.floor(cellSize * scope.Board.width);\n      drawHeight = Math.floor(cellSize * scope.Board.height);\n    }\n\n    //Otherwise, use the lesser of the available width/height\n    else {\n      drawWidth = drawHeight = Math.min(availableWidth, availableHeight);\n    }\n\n    //Broadcast new size if changed\n    if (scope.lastDrawWidth !== drawWidth || scope.lastDrawHeight !== drawHeight) {\n      scope.lastDrawWidth = drawWidth;\n      scope.lastDrawHeight = drawHeight;\n      scope.$broadcast('ngGo.board.drawSizeChanged', drawWidth, drawHeight);\n      return true;\n    }\n\n    //No change\n    return false;\n  };\n\n  /**\n   * Directive\n   */\n  return {\n    restrict: 'E',\n    scope: {\n      instance: '&'\n    },\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Init vars\n      var i, context, layer, playerElement;\n      var parent = element.parent();\n      var sizingElement = element[0];\n      var existingInstance = true;\n\n      //Remember last draw width/height\n      scope.lastDrawWidth = 0;\n      scope.lastDrawHeight = 0;\n\n      //Get board instance\n      scope.Board = scope.instance();\n\n      //Function given?\n      if (typeof scope.Board === 'function') {\n        scope.Board = scope.Board();\n      }\n\n      //Instantiate board if not present in scope\n      if (!scope.Board) {\n        existingInstance = false;\n        scope.Board = new Board();\n      }\n\n      //Link element\n      scope.Board.linkElement(element);\n\n      //Find player element\n      if (parent[0].tagName === 'PLAYER') {\n        playerElement = parent;\n        sizingElement = parent.parent()[0];\n      }\n\n      //Listen for board drawsize events\n      scope.$on('ngGo.board.drawSizeChanged', function(event, width, height) {\n\n        //First set the new dimensions on the canvas elements\n        var canvas = element.find('canvas');\n        for (i = 0; i < canvas.length; i++) {\n          canvas[i].width = width * pixelRatio;\n          canvas[i].height = height * pixelRatio;\n        }\n\n        //Set on the element if we're using a player element and if there is a size\n        if (playerElement || attrs.forceSize === 'true') {\n          element.css({width: width + 'px', height: height + 'px'});\n        }\n\n        //Next set it on the board itself\n        scope.Board.setDrawSize(width * pixelRatio, height * pixelRatio);\n      });\n\n      //Determine initial draw size\n      determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n\n      //On window resize, determine the draw size again\n      angular.element($window).on('resize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On manual resize, determine draw size again\n      scope.$on('ngGo.board.determineDrawSize', function() {\n        determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight);\n      });\n\n      //On board grid resize, determine the draw size again\n      scope.$on('ngGo.board.resize', function(event, board) {\n\n        //Only relevent if this was our own board\n        if (board !== scope.Board) {\n          return;\n        }\n\n        //If the draw size didn't change, the draw size event won't be triggered.\n        //However, that means we should call the resized() method now manually because\n        //it won't be called with the setDrawSize() call.\n        //This may seem a bit \"off\", but it's the best way to prevent redundant redraws.\n        if (!determineDrawSize(scope, sizingElement.clientWidth, sizingElement.clientHeight)) {\n          scope.Board.resized();\n        }\n      });\n\n      //Static board\n      if (attrs.static && attrs.static === 'true') {\n\n        //Add static class and make the board static\n        element.addClass('static');\n        scope.Board.makeStatic();\n\n        //Create single canvas and link to all relevant layer service classes\n        context = createLayerCanvas.call(element[0], 'static');\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Dynamic board\n      else {\n\n        //Create individual layer canvasses and link the canvas context to the layer service class\n        for (i = 0; i < scope.Board.layerOrder.length; i++) {\n          layer = scope.Board.layerOrder[i];\n          context = createLayerCanvas.call(element[0], layer);\n          scope.Board.layers[layer].setContext(context);\n        }\n      }\n\n      //Observe the board size attribute\n      attrs.$observe('size', function(size) {\n        if (typeof size === 'string' && size.toLowerCase().indexOf('x') !== -1) {\n          size = size.split('x');\n          scope.Board.setSize(size[0], size[1]);\n        }\n        else {\n          scope.Board.setSize(size, size);\n        }\n      });\n\n      //Observe the coordinates attribute\n      attrs.$observe('coordinates', function(attr) {\n        scope.Board.toggleCoordinates(attr === 'true');\n      });\n\n      //Observe the cutoff attribute\n      attrs.$observe('cutoff', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.setCutoff(attr.split(','));\n        }\n      });\n\n      //Observe color multiplier\n      attrs.$observe('colorMultiplier', function(attr) {\n        if (angular.isDefined(attr)) {\n          scope.Board.swapColors(attr);\n        }\n      });\n\n      //Link board to player if present in parent scope\n      if (scope.$parent.Player) {\n        scope.$parent.Player.setBoard(scope.Board);\n      }\n\n      //Redraw board if we had an existing instance (it might contain data)\n      if (existingInstance) {\n        scope.Board.redraw();\n      }\n    }\n  };\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Board :: This class represents the Go board. It is a placeholder for all the various board layers\n * and is used for placing and removing objects on the board. The class has helpers to figure out\n * the correct size of the grid cells and to toggle coordinates on or off. This class is\n * responsible for drawing all layers on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Service', [\n  'ngGo',\n  'ngGo.Board.Directive',\n  'ngGo.Board.Theme.Service',\n  'ngGo.Board.Layer.GridLayer.Service',\n  'ngGo.Board.Layer.ShadowLayer.Service',\n  'ngGo.Board.Layer.StonesLayer.Service',\n  'ngGo.Board.Layer.MarkupLayer.Service',\n  'ngGo.Board.Layer.ScoreLayer.Service',\n  'ngGo.Board.Layer.HoverLayer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.Stone.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Board', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Width and height\n    width: 0,\n    height: 0,\n\n    //Grid cut-off sides (i.e. [\"top\", \"left\"])\n    cutoff: [],\n\n    //Section of board to display\n    section: {top: 0, right: 0, bottom: 0, left: 0},\n\n    //Show coordinates?\n    coordinates: false,\n\n    //Color multiplier (use -1 to swap colors)\n    color_multiplier: 1\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$injector', 'BoardTheme', function($rootScope, $injector, BoardTheme) {\n\n    /**\n     * Board constructor\n     */\n    var Board = function(config) {\n\n      //Initialize board\n      this.init();\n\n      //Parse config\n      this.parseConfig(config || {});\n    };\n\n    /**\n     * Initialize board\n     */\n    Board.prototype.init = function() {\n\n      //Remove everything\n      this.removeAll();\n\n      //Set board theme\n      this.theme = new BoardTheme();\n\n      //Initialize board draw dimensions in pixels\n      this.cellSize = 0;\n      this.drawWidth = 0;\n      this.drawHeight = 0;\n      this.drawMarginHor = 0;\n      this.drawMarginVer = 0;\n      this.gridDrawWidth = 0;\n      this.gridDrawHeight = 0;\n\n      //Set layer order\n      this.layerOrder = ['grid', 'shadow', 'stones', 'score', 'markup', 'hover'];\n\n      //Initialize layers\n      this.layers = {};\n      for (var l = 0; l < this.layerOrder.length; l++) {\n        var layer = this.layerOrder[l];\n        var layerClass = layer[0].toUpperCase() + layer.substr(1) + 'Layer';\n        var LayerClass = $injector.get(layerClass);\n        this.layers[layer] = new LayerClass(this);\n      }\n\n      //Static board flag\n      this.static = false;\n\n      //Get margin from theme\n      this.margin = this.theme.get('board.margin');\n\n      //Color multiplier (to allow color swapping)\n      this.colorMultiplier = 1;\n\n      //Turn off coordinates\n      this.coordinates = false;\n      this.layers.grid.setCoordinates(false);\n\n      //Initialize grid size\n      this.width = 0;\n      this.height = 0;\n\n      //Initialize cutoff\n      this.cutoff = {\n        top: false,\n        left: false,\n        right: false,\n        bottom: false\n      };\n\n      //Initialize section\n      this.section = {\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    };\n\n    /**\n     * Link the board to a HTML element\n     */\n    Board.prototype.linkElement = function(element) {\n      this.element = element;\n    };\n\n    /**\n     * Make this board static (one canvas layer, only grid, stones and markup)\n     */\n    Board.prototype.makeStatic = function() {\n      this.static = true;\n      this.layerOrder = ['grid', 'stones', 'markup'];\n    };\n\n    /*****************************************************************************\n     * Configuration\n     ***/\n\n    /**\n     * Parse config instructions\n     */\n    Board.prototype.parseConfig = function(config) {\n\n      //Validate\n      if (typeof config !== 'object') {\n        return;\n      }\n\n      //Extend from default config\n      config = angular.extend({}, defaultConfig, config);\n\n      //Process settigns\n      this.toggleCoordinates(config.coordinates);\n      this.swapColors(config.color_multiplier);\n      this.setCutoff(config.cutoff);\n      this.setSection(config.section);\n      this.setSize(config.width, config.height);\n    };\n\n    /**\n     * Set margin\n     */\n    Board.prototype.setMargin = function(margin) {\n\n      //Reset when not defined\n      if (typeof margin === 'undefined') {\n        margin = this.theme.get('board.margin');\n      }\n\n      //Set margin if changed\n      if (this.margin !== margin) {\n        this.margin = margin;\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set grid cut-off\n     */\n    Board.prototype.setCutoff = function(cutoff) {\n\n      //Nothing given? Reset cutoff\n      if (!cutoff || !angular.isArray(cutoff)) {\n        cutoff = [];\n      }\n\n      //Init\n      var changes = false;\n\n      //Check if there's a change\n      for (var side in this.cutoff) {\n        if (this.cutoff.hasOwnProperty(side)) {\n          if (cutoff.indexOf(side) !== -1) {\n            if (!this.cutoff[side]) {\n              this.cutoff[side] = true;\n              changes = true;\n            }\n          }\n          else {\n            if (this.cutoff[side]) {\n              this.cutoff[side] = false;\n              changes = true;\n            }\n          }\n        }\n      }\n\n      //Trigger resized if there were changes\n      if (changes) {\n        this.resized();\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set section of the board to be displayed\n     */\n    Board.prototype.setSection = function(section) {\n\n      //Nothing given?\n      if (!section || typeof section !== 'object') {\n        return this;\n      }\n\n      //Expand on default\n      section = angular.extend({\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      }, section);\n\n      //No changes?\n      if (\n        this.section.top === section.top && this.section.bottom === section.bottom &&\n        this.section.left === section.left && this.section.right === section.right\n      ) {\n        return this;\n      }\n\n      //Set section and call resized handler\n      this.section = section;\n      this.resized();\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set board size. This will clear the board objects.\n     */\n    Board.prototype.setSize = function(width, height) {\n\n      //Check what's given\n      width = parseInt(width || height || 0);\n      height = parseInt(height || width || 0);\n\n      //Invalid?\n      if (isNaN(width) || isNaN(height)) {\n        return;\n      }\n\n      //Changing?\n      if (width !== this.width || height !== this.height) {\n\n        //Remember size\n        this.width = width;\n        this.height = height;\n\n        //Set size in layers\n        for (var layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].setSize(width, height);\n          }\n        }\n\n        //Broadcast event (no call to resized, as that is handled in the directive)\n        $rootScope.$broadcast('ngGo.board.resize', this, width, height);\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * Set new draw size\n     */\n    Board.prototype.setDrawSize = function(width, height) {\n      if (width !== this.drawWidth || height !== this.drawHeight) {\n        this.drawWidth = width;\n        this.drawHeight = height;\n        this.resized();\n      }\n    };\n\n    /**\n     * Toggle the coordinates\n     */\n    Board.prototype.toggleCoordinates = function(show) {\n\n      //Set or toggle\n      if (typeof show !== 'undefined') {\n        this.coordinates = show;\n      }\n      else {\n        this.coordinates = !this.coordinates;\n      }\n\n      //Set in grid layer\n      this.layers.grid.setCoordinates(this.coordinates);\n\n      //Set the proper board margin\n      if (this.coordinates) {\n        this.setMargin(this.theme.get('coordinates.margin'));\n      }\n      else {\n        this.setMargin(this.theme.get('board.margin'));\n      }\n    };\n\n    /**\n     * Swap colors on the board\n     */\n    Board.prototype.swapColors = function(multiplier) {\n\n      //Multiplier not given? Set to inverse of current value\n      if (typeof multiplier === 'undefined') {\n        multiplier = -this.colorMultiplier;\n      }\n      else {\n        multiplier = parseInt(multiplier);\n        if (isNaN(multiplier)) {\n          return;\n        }\n      }\n\n      //No change?\n      if (multiplier === this.colorMultiplier) {\n        return;\n      }\n\n      //Set new value\n      this.colorMultiplier = multiplier;\n\n      //For static board, redraw the whole thing\n      if (this.static) {\n        this.redraw();\n      }\n\n      //For a dynamic board, only these layers\n      else {\n        this.redraw('stones');\n        this.redraw('markup');\n      }\n    };\n\n    /*****************************************************************************\n     * Theme handling\n     ***/\n\n    /**\n     * Get the current theme object\n     */\n    Board.prototype.getTheme = function() {\n      return this.theme;\n    };\n\n    /**\n     * Set the theme object\n     */\n    Board.prototype.setTheme = function(theme) {\n      this.theme = theme;\n      return this;\n    };\n\n    /*****************************************************************************\n     * Object handling\n     ***/\n\n    /**\n     * Add an object to a board layer\n     */\n    Board.prototype.add = function(layer, x, y, value) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].add(x, y, value);\n      }\n    };\n\n    /**\n     * Remove an object from a board layer\n     */\n    Board.prototype.remove = function(layer, x, y) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].remove(x, y);\n      }\n    };\n\n    /**\n     * Get something from a board layer\n     */\n    Board.prototype.get = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].get(x, y));\n    };\n\n    /**\n     * Check if we have something at given coordinates for a given layer\n     */\n    Board.prototype.has = function(layer, x, y) {\n      return (this.layers[layer] && this.layers[layer].has(x, y));\n    };\n\n    /**\n     * Set all objects (grid) for a given layer\n     */\n    Board.prototype.setAll = function(layer, grid) {\n      if (typeof this.layers[layer] !== 'undefined') {\n        this.layers[layer].setAll(grid);\n      }\n    };\n\n    /**\n     * Remove all objects from the board, optionally for a given layer\n     */\n    Board.prototype.removeAll = function(layer) {\n      if (layer) {\n        if (typeof this.layers[layer] !== 'undefined') {\n          this.layers[layer].removeAll();\n        }\n      }\n      else {\n        for (layer in this.layers) {\n          if (this.layers.hasOwnProperty(layer)) {\n            this.layers[layer].removeAll();\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Position handling\n     ***/\n\n    /**\n     * Update the board with a new position\n     */\n    Board.prototype.updatePosition = function(position, pathChanged) {\n\n      //If we have no grid size yet, use what's in the position\n      if (!this.width || !this.height) {\n        this.setSize(position.width, position.height);\n      }\n\n      //Remove markup if path changed\n      if (pathChanged) {\n        this.removeAll('markup');\n      }\n\n      //Set new stones and markup grids\n      this.setAll('stones', position.stones);\n      this.setAll('markup', position.markup);\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state (list of objects per layer)\n     */\n    Board.prototype.getState = function(layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          return this.layers[layer].getAll();\n        }\n        return null;\n      }\n\n      //All layers\n      var state = {};\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          var grid = this.layers[layer].getAll();\n          if (grid && !grid.isEmpty()) {\n            state[layer] = grid;\n          }\n        }\n      }\n      return state;\n    };\n\n    /**\n     * Restore the board state from given state object\n     */\n    Board.prototype.restoreState = function(state, layer) {\n\n      //Only specific layer?\n      if (layer) {\n        if (this.layers[layer]) {\n          this.layers[layer].setAll(state);\n        }\n        return;\n      }\n\n      //All layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].removeAll();\n          if (state[layer]) {\n            this.layers[layer].setAll(state[layer]);\n          }\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing control\n     ***/\n\n    /**\n     * Clear the whole board\n     */\n    Board.prototype.clear = function(layer) {\n\n      //Just clearing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Clear the layer\n        this.layers[layer].clear();\n        return;\n      }\n\n      //Static? One clear is enough\n      if (this.static) {\n        this.layers.stones.clear();\n        return;\n      }\n\n      //Clear all layers\n      for (layer in this.layers) {\n        if (this.layers.hasOwnProperty(layer)) {\n          this.layers[layer].clear();\n        }\n      }\n    };\n\n    /**\n     * Redraw everything or just a single layer\n     */\n    Board.prototype.redraw = function(layer) {\n\n      //The board can only be redrawn when there is a grid size and a draw size\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Just redrawing one layer?\n      if (layer) {\n\n        //If the board is static or the layer is unknown, we can't do this\n        if (this.static || !this.layers[layer]) {\n          return;\n        }\n\n        //Redraw the layer\n        this.layers[layer].redraw();\n        return;\n      }\n\n      //Clear the board first\n      this.clear();\n\n      //Now draw all layers again in the correct order\n      for (var i = 0; i < this.layerOrder.length; i++) {\n        layer = this.layerOrder[i];\n        this.layers[layer].draw();\n      }\n    };\n\n    /*****************************************************************************\n     * Drawing helpers\n     ***/\n\n    /**\n     * Called after a board size change, draw size change, section change or margin change\n     */\n    Board.prototype.resized = function() {\n\n      //Determine the new grid\n      this.grid = {\n        xLeft: 0 + this.section.left,\n        xRight: this.width - 1 - this.section.right,\n        yTop: 0 + this.section.top,\n        yBot: this.height - 1 - this.section.bottom\n      };\n\n      //Only redraw when there is sensible data\n      if (!this.width || !this.height || !this.drawWidth || !this.drawHeight) {\n        return;\n      }\n\n      //Determine number of cells horizontall and vertically\n      //The margin is a factor of the cell size, so let's add it to the number of cells\n      var noCellsHor = this.width + this.margin;\n      var noCellsVer = this.height + this.margin;\n\n      //Are we cutting off parts of the grid? Add half a cell of draw size\n      for (var side in this.cutoff) {\n        if (this.cutoff[side]) {\n          if (side === 'top' || side === 'bottom') {\n            noCellsVer += 0.5;\n          }\n          else {\n            noCellsHor += 0.5;\n          }\n        }\n      }\n\n      //Determine cell size now\n      this.cellSize = Math.floor(Math.min(\n        this.drawWidth / noCellsHor,\n        this.drawHeight / noCellsVer\n      ));\n\n      //Determine actual grid draw size (taking off the margin again)\n      this.gridDrawWidth = this.cellSize * (noCellsHor - this.margin - 1);\n      this.gridDrawHeight = this.cellSize * (noCellsVer - this.margin - 1);\n\n      //Determine draw margins\n      this.drawMarginHor = Math.floor((this.drawWidth - this.gridDrawWidth) / 2);\n      this.drawMarginVer = Math.floor((this.drawHeight - this.gridDrawHeight) / 2);\n\n      //Redraw\n      this.redraw();\n    };\n\n    /**\n     * Get the current cell size\n     */\n    Board.prototype.getCellSize = function() {\n      return this.cellSize;\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsX = function(gridX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return this.drawMarginHor + Math.round((gridX + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert grid coordinate to pixel coordinate\n     */\n    Board.prototype.getAbsY = function(gridY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return this.drawMarginVer + Math.round((gridY + offset) * this.cellSize);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridX = function(absX) {\n      var offset = this.cutoff.left ? 0.5 : 0;\n      return Math.round((absX - this.drawMarginHor) / this.cellSize - offset);\n    };\n\n    /**\n     * Convert pixel coordinate to grid coordinate\n     */\n    Board.prototype.getGridY = function(absY) {\n      var offset = this.cutoff.top ? 0.5 : 0;\n      return Math.round((absY - this.drawMarginVer) / this.cellSize - offset);\n    };\n\n    /**\n     * Check if given grid coordinates are on board\n     */\n    Board.prototype.isOnBoard = function(gridX, gridY) {\n      return (\n        gridX >= this.grid.xLeft && gridY >= this.grid.yTop &&\n        gridX <= this.grid.xRight && gridY <= this.grid.yBot\n      );\n    };\n\n    //Return object\n    return Board;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * DefaultClearHandler :: This is the default clear handler for clearing a cell of the board grid.\n * It is used by all objects that lack their own specific clear handler. Basically, it just clears\n * a small rectangular area on the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.DefaultClearHandler.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('DefaultClearHandler', function() {\n\n  /**\n   * Clear handler definition\n   *\n   * All external handlers are called from the context of the layer that contains the object.\n   * First parameter is the canvas2d context, second parameter is the object itself.\n   */\n  return function(context, obj) {\n\n    //No context?\n    if (!context) {\n      return;\n    }\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(obj.x);\n    var y = this.board.getAbsY(obj.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Clear rectangle the size of the stone radius\n    context.clearRect(x - r, y - r, 2 * r, 2 * r);\n  };\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGrid :: This class represents a board grid of a given size. It acts as a container for\n * values (e.g. stone colors, markup types) for the layer classes, as well as a container for\n * stone color values for the game position class. It has built in validation of coordinates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Grid.Service', [\n  'ngGo',\n  'ngGo.Board.GridChanges.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGrid', ['BoardGridChanges', function(BoardGridChanges) {\n\n  /**\n   * Helper to convert a value at given coordinates to an object\n   */\n  var toObject = function(x, y, valueKey) {\n\n    //Create coordinates object\n    var obj = {\n      x: x,\n      y: y\n    };\n\n    //Already an object?\n    if (typeof this.grid[x][y] === 'object') {\n      return angular.extend(obj, this.grid[x][y]);\n    }\n\n    //Not an object, set value with given value key and return\n    obj[valueKey] = this.grid[x][y];\n    return obj;\n  };\n\n  /**\n   * Constructor\n   */\n  var BoardGrid = function(width, height, emptyValue) {\n\n    //Initialize size and grid array\n    this.width = 0;\n    this.height = 0;\n    this.grid = [];\n    this.emptyValue = null;\n\n    //Set empty value if given\n    if (typeof emptyValue !== 'undefined') {\n      this.emptyValue = emptyValue;\n    }\n\n    //Size given? Set it\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set a value\n   */\n  BoardGrid.prototype.set = function(x, y, value) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = value;\n    }\n  };\n\n  /**\n   * Unset a value\n   */\n  BoardGrid.prototype.unset = function(x, y) {\n    if (this.isOnGrid(x, y)) {\n      this.grid[x][y] = this.emptyValue;\n    }\n  };\n\n  /**\n   * Check if we have a non null value on the coordinates\n   */\n  BoardGrid.prototype.has = function(x, y) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] !== this.emptyValue);\n  };\n\n  /**\n   * Check if we have a specific value on the coordinates\n   */\n  BoardGrid.prototype.is = function(x, y, value) {\n    return (this.isOnGrid(x, y) && this.grid[x][y] === value);\n  };\n\n  /**\n   * Get a value, or an object with coordinates and the value in the given value key\n   */\n  BoardGrid.prototype.get = function(x, y, valueKey) {\n\n    //Validate\n    if (!this.isOnGrid(x, y) || this.grid[x][y] === this.emptyValue) {\n      return this.emptyValue;\n    }\n\n    //Return as is?\n    if (!valueKey) {\n      return this.grid[x][y];\n    }\n\n    //Return as object\n    return toObject.call(this, x, y, valueKey);\n  };\n\n  /*****************************************************************************\n   * Mass operations\n   ***/\n\n  /**\n   * Get all items in the grid. If you specify a value key, a list of objects with coordinates\n   * and the value in the given value key will be returned.\n   */\n  BoardGrid.prototype.all = function(valueKey) {\n\n    //Just get the grid?\n    if (!valueKey) {\n      return this.grid;\n    }\n\n    //Initialize objects list\n    var objects = [];\n\n    //Loop coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          objects.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return objects list\n    return objects;\n  };\n\n  /**\n   * Check if there is anything\n   */\n  BoardGrid.prototype.isEmpty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== this.emptyValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Populate the whole grid with a given value\n   */\n  BoardGrid.prototype.populate = function(value) {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = value;\n      }\n    }\n  };\n\n  /**\n   * Empty the grid\n   */\n  BoardGrid.prototype.empty = function() {\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Clone ourselves\n   */\n  BoardGrid.prototype.clone = function() {\n\n    //Create new instance\n    var newGrid = new BoardGrid();\n\n    //Manually set vars for maximum efficiency\n    newGrid.grid = angular.copy(this.grid);\n    newGrid.emptyValue = this.emptyValue;\n    newGrid.width = this.width;\n    newGrid.height = this.height;\n\n    //Return\n    return newGrid;\n  };\n\n  /*****************************************************************************\n   * Comparison\n   ***/\n\n  /**\n   * Checks if a given grid is the same as the current grid\n   */\n  BoardGrid.prototype.isSameAs = function(grid) {\n\n    //Must have the same size\n    if (this.width !== grid.width || this.height !== grid.height) {\n      return false;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n        if (this.grid[x][y] !== grid[x][y]) {\n          return false;\n        }\n      }\n    }\n\n    //No differences found\n    return true;\n  };\n\n  /**\n   * Compares this position with another position and return change object\n   */\n  BoardGrid.prototype.compare = function(newGrid, valueKey) {\n\n    //Initialize board grid changes object\n    var changes = new BoardGridChanges();\n\n    //Must have the same size\n    if (this.width !== newGrid.width || this.height !== newGrid.height) {\n      console.warn('Trying to compare grids of a different size');\n      return changes;\n    }\n\n    //Loop all coordinates\n    for (var x = 0; x < this.width; x++) {\n      for (var y = 0; y < this.height; y++) {\n\n        //Something to add?\n        if (newGrid.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.add.push(toObject.call(newGrid, x, y, valueKey));\n        }\n\n        //Something to remove?\n        if (this.grid[x][y] !== this.emptyValue && newGrid.grid[x][y] !== this.grid[x][y]) {\n          changes.remove.push(toObject.call(this, x, y, valueKey));\n        }\n      }\n    }\n\n    //Return changes grid\n    return changes;\n  };\n\n  /*****************************************************************************\n   * Helpers\n   ***/\n\n  /**\n   * Helper to validate coordinates (first param can be an object)\n   */\n  BoardGrid.prototype.isOnGrid = function(x, y) {\n    return (x >= 0 && y >= 0 && x < this.width && y < this.height);\n  };\n\n  /**\n   * Helper to set the empty value\n   */\n  BoardGrid.prototype.whenEmpty = function(emptyValue) {\n    this.emptyValue = emptyValue;\n  };\n\n  /**\n   * Set the grid size\n   */\n  BoardGrid.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Create grid array\n    this.grid = [];\n    for (var x = 0; x < this.width; x++) {\n      this.grid[x] = [];\n      for (var y = 0; y < this.height; y++) {\n        this.grid[x][y] = this.emptyValue;\n      }\n    }\n  };\n\n  /**\n   * Get the grid size object\n   */\n  BoardGrid.prototype.getSize = function() {\n    return {width: this.width, height: this.height};\n  };\n\n  //Return\n  return BoardGrid;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardGridChanges :: This is a simple class which acts as a wrapper for changes between two board\n * grids. It simply keeps track of what was added and what was removed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.GridChanges.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardGridChanges', function() {\n\n  /**\n   * Helper to subtract sets\n   */\n  var setSubtract = function(a, b) {\n    var n = [];\n    var q;\n    for (var i = 0; i < a.length; i++) {\n      q = true;\n      for (var j in b) {\n        if (a[i].x === b[j].x && a[i].y === b[j].y) {\n          q = false;\n          break;\n        }\n      }\n      if (q) {\n        n.push(a[i]);\n      }\n    }\n    return n;\n  };\n\n  /**\n   * Game position constructor\n   */\n  return function() {\n\n    /**\n     * Containers\n     */\n    this.add = [];\n    this.remove = [];\n\n    /**\n     * Concatenation helper\n     */\n    this.concat = function(newChanges) {\n      this.add = setSubtract(this.add, newChanges.remove).concat(newChanges.add);\n      this.remove = setSubtract(this.remove, newChanges.add).concat(newChanges.remove);\n    };\n\n    /**\n     * Check if there are changes\n     */\n    this.has = function() {\n      return !!(this.add.length || this.remove.length);\n    };\n  };\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardLayer :: This class represents a layer on the board and is the base class for all board\n * layers. Each layer can contain it's own objects on a grid with coordinates and is responsible\n * for drawing itself as well as its objects onto the canvas.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardLayer', ['BoardGrid', function(BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var BoardLayer = function(board, context) {\n\n    //Remember board reference and 2d canvas context\n    this.board = board;\n    this.context = context;\n\n    //Initialize grid for board objects\n    this.grid = new BoardGrid();\n  };\n\n  /*****************************************************************************\n   * Generic grid and object handling\n   ***/\n\n  /**\n   * Set grid size\n   */\n  BoardLayer.prototype.setSize = function(width, height) {\n\n    //Note: since this method is usually only called upon a global board resize,\n    //which also triggers the redraw method for layers, the layer is not cleared\n    //here, as it will happen anyway during the redraw cycle.\n\n    //Set it in the grid (removing all objects in the process)\n    this.grid.setSize(width, height);\n  };\n\n  /**\n   * Get all items\n   */\n  BoardLayer.prototype.getAll = function() {\n    return this.grid.clone();\n  };\n\n  /**\n   * Set all items at once\n   */\n  BoardLayer.prototype.setAll = function(grid) {\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  BoardLayer.prototype.removeAll = function() {\n    this.clear();\n    this.grid.empty();\n  };\n\n  /**\n   * Add a single item\n   */\n  BoardLayer.prototype.add = function(x, y, value) {\n    this.clearCell(x, y);\n    this.grid.set(x, y, value);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Remove a single item\n   */\n  BoardLayer.prototype.remove = function(x, y) {\n    this.clearCell(x, y);\n    this.grid.unset(x, y);\n  };\n\n  /**\n   * Get an item\n   */\n  BoardLayer.prototype.get = function(x, y) {\n    return this.grid.get(x, y);\n  };\n\n  /**\n   * Check if there is an item\n   */\n  BoardLayer.prototype.has = function(x, y) {\n    return this.grid.has(x, y);\n  };\n\n  /*****************************************************************************\n   * Generic drawing methods\n   ***/\n\n  /**\n   * Draw layer\n   */\n  BoardLayer.prototype.draw = function() {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear layer (this method doesn't clear objects, as the canvas wipe clears the entire canvas)\n   */\n  BoardLayer.prototype.clear = function() {\n    if (this.context) {\n      this.context.clearRect(\n        0, 0, this.context.canvas.clientWidth, this.context.canvas.clientHeight\n      );\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  BoardLayer.prototype.redraw = function() {\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  BoardLayer.prototype.drawCell = function(/*x, y*/) {\n    //Drawing method to be implemented in specific layer class\n  };\n\n  /**\n   * Clear cell\n   */\n  BoardLayer.prototype.clearCell = function(/*x, y*/) {\n    //Clearing method to be implemented in specific layer class\n  };\n\n  /**\n   * Redraw cell\n   */\n  BoardLayer.prototype.redrawCell = function(x, y) {\n    this.clearCell(x, y);\n    this.drawCell(x, y);\n  };\n\n  /**\n   * Set the canvas2d context\n   */\n  BoardLayer.prototype.setContext = function(context) {\n    this.context = context;\n  };\n\n  /**\n   * Get the canvas2d context\n   */\n  BoardLayer.prototype.getContext = function() {\n    return this.context;\n  };\n\n  //Return\n  return BoardLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardObject :: Base class for drawing board objects\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Service', [\n  'ngGo',\n  'ngGo.Board.DefaultClearHandler.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('BoardObject', ['DefaultClearHandler', function(DefaultClearHandler) {\n\n  /**\n   * Constructor\n   */\n  var BoardObject = {\n\n    /**\n     * Draw method\n     */\n    draw: function(/*obj*/) {\n      if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n    },\n\n    /**\n     * Clear method\n     */\n    clear: function(obj) {\n      DefaultClearHandler.call(this, this.context, obj);\n    }\n  };\n\n  //Return\n  return BoardObject;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * ShellPattern :: This is a helper class to draw shell patterned white stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.ShellPattern.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('ShellPattern', function() {\n\n  /**\n   * Helper to draw a shell line\n   */\n  var shellLine = function(ctx, x, y, radius, startAngle, endAngle, strokeStyle) {\n\n    //Initialize\n    ctx.shadowBlur = 2;\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = (radius / 30) * this.thickness;\n    ctx.beginPath();\n\n    //Lower radius\n    radius -= Math.max(1, ctx.lineWidth);\n\n    //Determine coordinates\n    var x1 = x + radius * Math.cos(startAngle * Math.PI);\n    var y1 = y + radius * Math.sin(startAngle * Math.PI);\n    var x2 = x + radius * Math.cos(endAngle * Math.PI);\n    var y2 = y + radius * Math.sin(endAngle * Math.PI);\n\n    //Math magic\n    var m, angle;\n    if (x2 > x1) {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m);\n    }\n    else if (x2 === x1) {\n      angle = Math.PI / 2;\n    }\n    else {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m) - Math.PI;\n    }\n\n    //Curvature factor\n    var c = this.factor * radius;\n    var dx = Math.sin(angle) * c;\n    var dy = Math.cos(angle) * c;\n\n    //Curvature coordinates\n    var bx1 = x1 + dx;\n    var by1 = y1 - dy;\n    var bx2 = x2 + dx;\n    var by2 = y2 - dy;\n\n    //Draw shell stroke\n    ctx.moveTo(x1, y1);\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\n    ctx.stroke();\n  };\n\n  /**\n   * Shell pattern drawer\n   */\n  return function(ctx, x, y, radius, angle, strokeStyle) {\n\n    //Initialize start and end angle\n    var startAngle = angle;\n    var endAngle = angle;\n\n    //Loop lines\n    for (var i = 0; i < this.lines.length; i++) {\n      startAngle += this.lines[i];\n      endAngle -= this.lines[i];\n      shellLine.call(this, ctx, x, y, radius, startAngle, endAngle, strokeStyle);\n    }\n  };\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * BoardTheme :: This class representes the theme of a Go board. It contains all tweakable visual\n * aspects like colors, dimensions, used stone style, etc. It is very flexible and allows you to\n * use static values or dynamic values depending on other properties, like the grid cell size.\n * Using the provider, the theme can be configured globally at application launch.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Theme.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.provider('BoardTheme', ['StoneColor', 'MarkupTypes', function(StoneColor, MarkupTypes) {\n\n  /**\n   * Default theme\n   */\n  var defaultTheme = {\n\n    //Board\n    board: {\n\n      //Board margin factor\n      margin: 0.25\n    },\n\n    //Stones\n    stone: {\n\n      //Stone style can be shell, glass, mono, or specify a custom handler service\n      style: 'shell',\n      shadow: true,\n      radius: function(cellSize) {\n        return Math.floor(cellSize / 2);\n      },\n\n      //Shell stones\n      shell: {\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#111';\n          }\n          return '#BFBFBA';\n        },\n        stroke: 'rgba(128,128,128,0.15)',\n        types: [\n          {\n            lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\n            factor: 0.15,\n            thickness: 1.75\n          },\n          {\n            lines: [0.10, 0.09, 0.08, 0.07, 0.09, 0.06, 0.06, 0.07, 0.07, 0.06, 0.06],\n            factor: 0.1,\n            thickness: 1.5\n          },\n          {\n            lines: [0.22, 0.11, 0.13, 0.06, 0.11, 0.09],\n            factor: 0.05,\n            thickness: 1.75\n          },\n          {\n            lines: [0.18, 0.23, 0.09, 0.17, 0.14],\n            factor: 0.1,\n            thickness: 2\n          }\n        ]\n      },\n\n      //Mono stones\n      mono: {\n        lineWidth: 1,\n        lineColor: function() {\n          return '#000';\n        },\n        color: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return '#000';\n          }\n          return '#fff';\n        }\n      },\n\n      //Mini stones\n      mini: {\n        scale: 0.5,\n        alpha: 1\n      },\n\n      //Faded stones\n      faded: {\n        scale: 1,\n        alpha: function(stoneColor) {\n          if (stoneColor === StoneColor.B) {\n            return 0.3;\n          }\n          return 0.4;\n        }\n      }\n    },\n\n    //Shadows\n    shadow: {\n\n      //Shadow gradient colors\n      color: 'rgba(40,30,20,0.5)',\n\n      //Shadow size\n      size: function(cellSize) {\n        return Math.floor(cellSize / 20);\n      },\n\n      //Shadow blur size\n      blur: function(cellSize) {\n        return cellSize / 20;\n      },\n\n      //Shadow offset\n      offsetX: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      },\n      offsetY: function(cellSize) {\n        return Math.ceil(cellSize / 20);\n      }\n    },\n\n    //Markup\n    markup: {\n\n      //Standard color\n      color: function(stoneColor) {\n        if (stoneColor === StoneColor.B) {\n          return 'rgba(255,255,255,0.9)';\n        }\n        return 'rgba(0,0,0,0.9)';\n      },\n\n      //Line width\n      lineWidth: function(cellSize) {\n        return Math.max(1, Math.floor(cellSize / 16));\n      },\n\n      //Triangle\n      triangle: {\n        scale: 0.85\n      },\n\n      //Square\n      square: {\n        scale: 0.85\n      },\n\n      //Cricle\n      circle: {\n        scale: 0.55\n      },\n\n      //Mark\n      mark: {\n        lineCap: 'square',\n        scale: 0.75\n      },\n\n      //Last\n      last: {\n        scale: 0.7\n      },\n\n      //Smiley\n      smiley: {\n        lineCap: 'round',\n        scale: 0.85\n      },\n\n      //Label\n      label: {\n        font: 'Arial'\n      },\n\n      //Variation markup\n      variation: {\n        type: MarkupTypes.LABEL,\n        text: function(i) {\n          return String.fromCharCode(65 + i);\n        },\n        color: 'rgba(86,114,30,0.9)'\n      },\n\n      //Solution paths markup\n      solution: {\n        valid: {\n          type: MarkupTypes.SELECT,\n          text: null,\n          color: 'rgba(86,114,30,1)',\n          scale: 0.5\n        },\n        invalid: {\n          type: MarkupTypes.MARK,\n          text: null,\n          color: 'rgba(237,9,15,1)',\n          scale: 0.3\n        }\n      }\n    },\n\n    //Grid\n    grid: {\n\n      //Line properties\n      lineColor: 'rgba(60,40,15,1)',\n      lineWidth: function(cellSize) {\n        if (cellSize > 60) {\n          return 2;\n        }\n        else if (cellSize > 50) {\n          return 1.5;\n        }\n        return 1;\n      },\n      lineCap: 'square',\n\n      //Star points\n      star: {\n\n        //Color and radius\n        color: 'rgba(60,40,15,1)',\n        radius: function(cellSize) {\n          if (cellSize > 50) {\n            return Math.floor((cellSize / 16) + 1);\n          }\n          else if (cellSize > 30) {\n            return 3;\n          }\n          else if (cellSize > 15) {\n            return 2;\n          }\n          else if (cellSize > 5) {\n            return 1.5;\n          }\n          return 1;\n        },\n\n        //Locations\n        points: function(width, height) {\n\n          //19x19\n          if (width === height && width === 19) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 }, { x: 15,y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }, { x: 15,y: 9 },\n              { x: 3, y: 15 }, { x: 9, y: 15 }, { x: 15,y: 15 }\n            ];\n          }\n\n          //13x13\n          if (width === height && width === 13) {\n            return [\n              { x: 3, y: 3 }, { x: 9, y: 3 },\n              { x: 3, y: 9 }, { x: 9, y: 9 }\n            ];\n          }\n\n          //9x9\n          if (width === height && width === 9) {\n            return [\n              { x: 4, y: 4}, { x: 2, y: 2},\n              { x: 2, y: 6}, { x: 6, y: 2},\n              { x: 6, y: 6}\n            ];\n          }\n\n          //No star points\n          return [];\n        }\n      }\n    },\n\n    //Coordinates\n    coordinates: {\n\n      //Color\n      color: 'rgba(101,69,37,0.5)',\n\n      //Board margin factor when showing coordinates\n      margin: 1.25,\n\n      //Vertical coordinates style\n      vertical: {\n        font: 'Arial',\n        style: 'numbers',\n        inverse: true,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      },\n\n      //Horizontal coordinates style\n      horizontal: {\n        font: 'Arial',\n        style: 'letters',\n        inverse: false,\n        size: function() {\n          return function(ch, cellSize) {\n            return Math.floor((cellSize * 0.3) + 1) + 'px';\n          };\n        }\n      }\n    }\n  };\n\n  /**\n   * Set global default theme\n   */\n  this.setTheme = function(theme) {\n    if (theme) {\n      defaultTheme = angular.merge(defaultTheme, theme);\n    }\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function() {\n\n    /**\n     * Board theme constructor\n     */\n    var BoardTheme = function(theme) {\n\n      //Remember the given instance theme settings and (re)set the theme\n      this.instanceTheme = theme;\n      this.reset();\n    };\n\n    /**\n     * Reset the theme to defaults\n     */\n    BoardTheme.prototype.reset = function() {\n\n      //Use default theme as a base\n      this.theme = angular.copy(defaultTheme);\n\n      //Add any instance theme properties\n      if (this.instanceTheme) {\n        angular.merge(this.theme, this.instanceTheme);\n      }\n    };\n\n    /**\n     * Get a theme property\n     */\n    BoardTheme.prototype.get = function(property) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Can't find the property?\n        if (typeof prop[path[i]] === 'undefined') {\n          console.warn('Could not find theme property', property);\n          return null;\n        }\n\n        //Advance further in the object\n        prop = prop[path[i]];\n      }\n\n      //Found what we're looking for\n      if (typeof prop !== 'function') {\n        return prop;\n      }\n\n      //Prepare arguments\n      var args = [];\n      if (arguments.length > 1) {\n        for (var a = 1; a < arguments.length; a++) {\n          args.push(arguments[a]);\n        }\n      }\n\n      //Call function\n      return prop.apply(this, args);\n    };\n\n    /**\n     * Change a theme property dynamically (accepts handler function as value)\n     */\n    BoardTheme.prototype.set = function(property, value) {\n\n      //Determine path to the property\n      var path = property.split('.');\n      var prop = this.theme;\n\n      //Loop path\n      for (var i = 0; i < path.length; i++) {\n\n        //Time to set?\n        if ((i + 1) === path.length) {\n          prop[path[i]] = value;\n          break;\n        }\n\n        //Not set?\n        if (typeof prop[path[i]] === 'undefined') {\n          prop[path[i]] = {};\n        }\n\n        //Move on\n        prop = prop[path[i]];\n      }\n\n      //Return self for chaining\n      return this;\n    };\n\n    /**\n     * To combat 2d canvas blurry lines, we translate the canvas prior to drawing elements.\n     * See: http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/\n     */\n    BoardTheme.prototype.canvasTranslate = function(lineWidth) {\n\n      //If no linewidth specified, use the grid line width as a reference\n      //to make sure stuff is aligned to the grid\n      if (typeof lineWidth === 'undefined') {\n        lineWidth = this.get('grid.lineWidth');\n      }\n\n      //Return a translation for uneven widths\n      return (lineWidth % 2) * 0.5;\n    };\n\n    //Return\n    return BoardTheme;\n  };\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidDataError :: Error class to handle invalid data.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidDataError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidDataError', ['ngGo', function(ngGo) {\n\n  /**\n   * Define error\n   */\n  var InvalidDataError = function(code) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidDataError';\n    this.message = 'Invalid data: ';\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.NO_DATA:\n        this.message += 'no data to process.';\n        break;\n      case ngGo.error.UNKNOWN_DATA:\n        this.message += 'unknown data format.';\n        break;\n      case ngGo.error.INVALID_GIB:\n        this.message += 'unable to parse GIB data.';\n        break;\n      case ngGo.error.INVALID_SGF:\n        this.message += 'unable to parse SGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_JSON:\n        this.message += 'unable to parse JGF data.';\n        break;\n      case ngGo.error.INVALID_JGF_TREE_JSON:\n        this.message += 'unable to parse the JGF tree data.';\n        break;\n      default:\n        this.message += 'unable to parse the data.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidDataError.prototype = new Error();\n  InvalidDataError.prototype.constructor = InvalidDataError;\n\n  //Return object\n  return InvalidDataError;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * InvalidPositionError :: Error class to handle invalid moves.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Errors.InvalidPositionError.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('InvalidPositionError', ['ngGo', 'StoneColor', function(ngGo, StoneColor) {\n\n  /**\n   * Define error\n   */\n  var InvalidPositionError = function(code, x, y, color) {\n\n    //Set name and message\n    this.code = code;\n    this.name = 'InvalidPositionError';\n    this.message = 'Invalid position detected.';\n\n    //Add position data\n    if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof color !== 'undefined') {\n      this.message += ' Trying to place a ' + (color === StoneColor.W ? 'white' : 'black') +\n        ' stone on (' + x + ', ' + y + ')';\n    }\n\n    //Append code message\n    switch (code) {\n      case ngGo.error.POSTITION_OUT_OF_BOUNDS:\n        this.message += ', but these coordinates are not on the board.';\n        break;\n      case ngGo.error.POSTITION_ALREADY_HAS_STONE:\n        this.message += ', but there is already a stone on those coordinates.';\n        break;\n      case ngGo.error.POSTITION_IS_SUICIDE:\n        this.message += ', but that would be suicide.';\n        break;\n      case ngGo.error.POSTITION_IS_REPEATING:\n        this.message += ', but this position already occured.';\n        break;\n      default:\n        this.message += '.';\n    }\n  };\n\n  /**\n   * Extend from error class\n   */\n  InvalidPositionError.prototype = new Error();\n  InvalidPositionError.prototype.constructor = InvalidPositionError;\n\n  //Return object\n  return InvalidPositionError;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Game :: This class represents a game record or a game that is being played/edited. The class\n * traverses the move tree nodes and keeps track of the changes between the previous and new game\n * positions. These changes can then be fed to the board, to add or remove stones and markup.\n * The class also keeps a stack of all board positions in memory and can validate moves to make\n * sure they are not repeating or suicide.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Service', [\n  'ngGo',\n  'ngGo.Game.Path.Service',\n  'ngGo.Game.Node.Service',\n  'ngGo.Game.Position.Service',\n  'ngGo.Kifu.Blank.Service',\n  'ngGo.Kifu.Parser.Service',\n  'ngGo.Errors.InvalidDataError.Service',\n  'ngGo.Errors.InvalidPositionError.Service'\n])\n\n/**\n * Factory definition\n */\n.provider('Game', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default size of board\n    defaultSize: 0,\n\n    //Default komi and handicap\n    defaultKomi: 0,\n    defaultHandicap: 0,\n\n    //Remember last selected variation when traversing nodes\n    rememberPath: true,\n\n    //Check for repeating positions? (KO / ALL / empty)\n    checkRepeat: 'KO',\n\n    //Allow suicide?\n    allowSuicide: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['ngGo', 'StoneColor', 'GamePath', 'GameNode', 'GamePosition', 'KifuParser', 'KifuBlank', 'InvalidDataError', 'InvalidPositionError', function(\n    ngGo, StoneColor, GamePath, GameNode, GamePosition, KifuParser,\n    KifuBlank, InvalidDataError, InvalidPositionError\n  ) {\n\n    /*****************************************************************************\n     * General helpers\n     ***/\n\n    /**\n     * Validate the info we have to make sure the properties exist\n     */\n    var validateInfo = function() {\n\n      //Set board info if not set\n      if (!this.info.board) {\n        this.info.board = {};\n      }\n\n      //Set game info if not set\n      if (!this.info.game) {\n        this.info.game = {};\n      }\n\n      //Set defaults\n      if (typeof this.info.board.width === 'undefined') {\n        this.info.board.width = this.config.defaultSize;\n      }\n      if (typeof this.info.board.height === 'undefined') {\n        this.info.board.height = this.config.defaultSize;\n      }\n      if (typeof this.info.game.komi === 'undefined') {\n        this.info.game.komi = this.config.defaultKomi;\n      }\n      if (typeof this.info.game.handicap === 'undefined') {\n        this.info.game.handicap = this.config.defaultHandicap;\n      }\n    };\n\n    /*****************************************************************************\n     * Node navigation helpers\n     ***/\n\n    /**\n     * Navigate to the next node\n     */\n    var nextNode = function(i) {\n\n      //Check if we have children\n      if (this.node.children.length === 0) {\n        return false;\n      }\n\n      //Remembered the path we took earlier?\n      if (i === undefined) {\n        i = this.node._remembered_path;\n      }\n\n      //Determine which child node to process\n      i = i || 0;\n      if (i === -1) {\n        i = 0;\n      }\n\n      //Validate\n      if (i >= this.node.children.length || !this.node.children[i]) {\n        return false;\n      }\n\n      //Advance path\n      this.path.advance(i);\n\n      //Set pointer of current node\n      this.node = this.node.children[i];\n      return true;\n    };\n\n    /**\n     * Navigate to the previous node\n     */\n    var previousNode = function() {\n\n      //No parent node?\n      if (!this.node.parent) {\n        return false;\n      }\n\n      //Retreat path\n      this.path.retreat();\n\n      //Set pointer of current node\n      this.node = this.node.parent;\n      return true;\n    };\n\n    /**\n     * Navigate to the first node\n     */\n    var firstNode = function() {\n\n      //Reset path\n      this.path.reset();\n\n      //Set node pointer back to root\n      this.node = this.root;\n\n      //Set the initial turn depending on handicap (can be overwritten by game record instructions)\n      this.setTurn((this.info.game.handicap > 1) ? StoneColor.W : StoneColor.B);\n    };\n\n    /*****************************************************************************\n     * Position history helpers\n     ***/\n\n    /**\n     * Clear the position history and initialize with a blank position\n     */\n    var initializeHistory = function() {\n\n      //Already at beginning?\n      if (this.history.length === 1) {\n        return;\n      }\n\n      //Clear positions stack and create new blank position\n      this.history = [];\n      this.history.push(new GamePosition());\n\n      //Set board size if we have the info\n      if (this.info.board) {\n        this.history[0].setSize(this.info.board.width, this.info.board.height);\n      }\n    };\n\n    /**\n     * Add position to stack. If position isn't specified current position is\n     * cloned and stacked. Pointer of actual position is moved to the new position.\n     */\n    var pushPosition = function(newPosition) {\n\n      //Position not given?\n      if (!newPosition) {\n        newPosition = this.position.clone();\n      }\n\n      //Push\n      this.history.push(newPosition);\n      return newPosition;\n    };\n\n    /**\n     * Remove current position from stack\n     */\n    var popPosition = function() {\n\n      //Nothing left?\n      if (this.history.length === 0) {\n        return null;\n      }\n\n      //Get old position\n      return this.history.pop();\n    };\n\n    /**\n     * Replace the current position in the stack\n     */\n    var replacePosition = function(newPosition) {\n      if (newPosition) {\n        this.history.pop();\n        this.history.push(newPosition);\n      }\n    };\n\n    /*****************************************************************************\n     * Execution helpers\n     ***/\n\n    /**\n     * Execute the current node\n     */\n    var executeNode = function() {\n\n      //Remember last selected node if we have a parent\n      if (this.node.parent) {\n        this.node.parent._remembered_path = this.node.parent.children.indexOf(this.node);\n      }\n\n      //Initialize new position\n      var i;\n      var newPosition = this.position.clone();\n\n      //Handle moves\n      if (this.node.move) {\n        if (this.node.move.pass) {\n          newPosition.setTurn(-this.node.move.color);\n        }\n        else {\n          this.validateMove(this.node.move.x, this.node.move.y, this.node.move.color, newPosition);\n        }\n      }\n\n      //Handle turn instructions\n      if (this.node.turn) {\n        newPosition.setTurn(this.node.turn);\n      }\n\n      //Handle setup instructions\n      if (this.node.setup) {\n        for (i in this.node.setup) {\n          if (this.node.setup.hasOwnProperty(i)) {\n            newPosition.stones.set(\n              this.node.setup[i].x, this.node.setup[i].y, this.node.setup[i].color\n            );\n          }\n        }\n      }\n\n      //Handle markup\n      if (this.node.markup) {\n        for (i in this.node.markup) {\n          if (this.node.markup.hasOwnProperty(i)) {\n            newPosition.markup.set(\n              this.node.markup[i].x, this.node.markup[i].y, this.node.markup[i]\n            );\n          }\n        }\n      }\n\n      //Push the new position into the history now\n      pushPosition.call(this, newPosition);\n    };\n\n    /*****************************************************************************\n     * Game class\n     ***/\n\n    /**\n     * Constructor\n     */\n    var Game = function(data, config) {\n\n      //Extend config\n      this.config = angular.extend({}, defaultConfig, config || {});\n\n      //Define property getter/setter for position\n      Object.defineProperty(this, 'position', {\n\n        //Getter returns the last position from the stack\n        get: function() {\n          return this.history[this.history.length - 1];\n        },\n\n        //Setter adds a new position to the stack\n        set: function(newPosition) {\n          this.history[this.history.length] = newPosition;\n        }\n      });\n\n      //Load data\n      if (data) {\n        this.load(data);\n      }\n      else {\n        this.init();\n      }\n    };\n\n    /**\n     * Initialize\n     */\n    Game.prototype.init = function() {\n\n      //Info properties\n      this.info = {};\n\n      //The rood node and pointer to the current node\n      this.root = null;\n      this.node = null;\n\n      //Game path\n      this.path = new GamePath();\n\n      //JGF record we loaded from\n      this.jgf = null;\n\n      //Positions history stack\n      this.history = [];\n    };\n\n    /**\n     * Load game record data\n     */\n    Game.prototype.load = function(data) {\n\n      //Initialize\n      this.init();\n\n      //Try to load game record data\n      try {\n        this.fromData(data);\n      }\n      catch (errorCode) {\n\n        //Just initialize our history with a blank position\n        initializeHistory.call(this);\n\n        //Wrap error code in error object\n        throw new InvalidDataError(errorCode);\n      }\n\n      //Go to the first move\n      this.first();\n    };\n\n    /**\n     * Reload game record\n     */\n    Game.prototype.reload = function() {\n      if (this.jgf) {\n        this.load(this.jgf);\n      }\n    };\n\n    /**\n     * Check if we managed to load a valid game record\n     */\n    Game.prototype.isLoaded = function() {\n      return this.root !== null;\n    };\n\n    /*****************************************************************************\n     * Game cloning and conversion\n     ***/\n\n    /**\n     * Clone this game\n     */\n    Game.prototype.clone = function() {\n\n      //Create new kifu object and get properties\n      var clone = new Game();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy all properties\n      for (var p = 0; p < props.length; p++) {\n        clone[p] = angular.copy(this[p]);\n      }\n\n      //Return clone\n      return clone;\n    };\n\n    /**\n     * Load from an unknown data source\n     */\n    Game.prototype.fromData = function(data) {\n\n      //No data, can't do much\n      if (!data) {\n        throw ngGo.error.NO_DATA;\n      }\n\n      //String given, could be stringified JGF, an SGF or GIB file\n      if (typeof data === 'string') {\n        var c = data.charAt(0);\n        if (c === '(') {\n          return this.fromSgf(data);\n        }\n        else if (c === '{' || c === '[') {\n          return this.fromJgf(data);\n        }\n        else if (c === '\\\\') {\n          return this.fromGib(data);\n        }\n        else {\n          throw ngGo.error.UNKNOWN_DATA;\n        }\n      }\n\n      //Object given? Probably a JGF object\n      else if (typeof data === 'object') {\n        this.fromJgf(data);\n      }\n\n      //Something else?\n      else {\n        throw ngGo.error.UNKNOWN_DATA;\n      }\n    };\n\n    /**\n     * Load from GIB data\n     */\n    Game.prototype.fromGib = function(gib) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.gib2jgf(gib);\n      if (!jgf) {\n        throw ngGo.error.INVALID_GIB;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from SGF data\n     */\n    Game.prototype.fromSgf = function(sgf) {\n\n      //Use the kifu parser\n      var jgf = KifuParser.sgf2jgf(sgf);\n      if (!jgf) {\n        throw ngGo.error.INVALID_SGF;\n      }\n\n      //Now load from JGF\n      this.fromJgf(jgf);\n    };\n\n    /**\n     * Load from JGF data\n     */\n    Game.prototype.fromJgf = function(jgf) {\n\n      //Parse jgf string\n      if (typeof jgf === 'string') {\n        try {\n          jgf = angular.fromJson(jgf);\n        }\n        catch (error) {\n          throw ngGo.error.INVALID_JGF_JSON;\n        }\n      }\n\n      //If array given, convert to object with only tree\n      if (angular.isArray(jgf)) {\n        jgf = {\n          tree: jgf\n        };\n      }\n\n      //Parse tree string\n      if (typeof jgf.tree === 'string') {\n        if (jgf.tree.charAt(0) === '[') {\n          try {\n            jgf.tree = angular.fromJson(jgf.tree);\n          }\n          catch (error) {\n            throw ngGo.error.INVALID_JGF_TREE_JSON;\n          }\n        }\n        else {\n          jgf.tree = [];\n        }\n      }\n\n      //Copy all properties except moves tree\n      for (var i in jgf) {\n        if (jgf.hasOwnProperty(i) && i !== 'tree') {\n          this.info[i] = angular.copy(jgf[i]);\n        }\n      }\n\n      //Validate info\n      validateInfo.call(this);\n\n      //Create root node\n      this.root = new GameNode();\n\n      //Tree given? Load all the moves\n      if (jgf.tree) {\n        this.root.fromJgf(jgf.tree);\n      }\n\n      //Remember JGF\n      this.jgf = jgf;\n    };\n\n    /**\n     * Convert to SGF\n     */\n    Game.prototype.toSgf = function() {\n      return KifuParser.jgf2sgf(this.toJgf());\n    };\n\n    /**\n     * Convert to JGF (optionally stringified)\n     */\n    Game.prototype.toJgf = function(stringify) {\n\n      //Initialize JGF and get properties\n      var jgf = KifuBlank.jgf();\n      var props = Object.getOwnPropertyNames(this);\n\n      //Copy properties\n      for (var p = 0; p < props.length; p++) {\n\n        //Skip root\n        if (p === 'root') {\n          continue;\n        }\n\n        //Already present on JGF object? Extend\n        if (jgf[p]) {\n          jgf[p] = angular.extend(jgf[p], this[p]);\n        }\n\n        //Otherwise copy\n        else {\n          jgf[p] = angular.copy(this[p]);\n        }\n      }\n\n      //Build tree\n      jgf.tree = this.root.toJgf();\n\n      //Return\n      return stringify ? angular.toJson(jgf) : jgf;\n    };\n\n    /*****************************************************************************\n     * Getters\n     ***/\n\n    /**\n     * Get current node\n     */\n    Game.prototype.getNode = function() {\n      return this.node;\n    };\n\n    /**\n     * Get the current game position\n     */\n    Game.prototype.getPosition = function() {\n      return this.position;\n    };\n\n    /**\n     * Get the game path\n     */\n    Game.prototype.getPath = function(clone) {\n      if (clone) {\n        return this.path.clone();\n      }\n      return this.path;\n    };\n\n    /**\n     * Clone the current game path\n     */\n    Game.prototype.clonePath = function() {\n      return this.path.clone();\n    };\n\n    /**\n     * Get the game path to a certain named node\n     */\n    Game.prototype.getPathToNode = function(nodeName) {\n      return GamePath.findNode(nodeName, this.root);\n    };\n\n    /**\n     * Get the game komi\n     */\n    Game.prototype.getKomi = function() {\n      if (!this.info.game.komi) {\n        return 0;\n      }\n      return parseFloat(this.info.game.komi);\n    };\n\n    /**\n     * Set the game komi\n     */\n    Game.prototype.setKomi = function(komi) {\n      this.info.game.komi = komi ? parseFloat(komi) : this.config.defaultKomi;\n    };\n\n    /**\n     * Get the player turn for this position\n     */\n    Game.prototype.getTurn = function() {\n\n      //Must have a position\n      if (!this.history.length) {\n        return StoneColor.B;\n      }\n\n      //Get from position\n      return this.position.getTurn();\n    };\n\n    /**\n     * Set the player turn for the current position\n     */\n    Game.prototype.setTurn = function(color) {\n\n      //Must have a position\n      if (!this.history.length) {\n        return;\n      }\n\n      //Set in position\n      this.position.setTurn(color);\n    };\n\n    /**\n     * Get the total capture count up to the current position\n     */\n    Game.prototype.getCaptureCount = function() {\n\n      //Initialize\n      var captures = {};\n      captures[StoneColor.B] = 0;\n      captures[StoneColor.W] = 0;\n\n      //Loop all positions and increment capture count\n      for (var i = 0; i < this.history.length; i++) {\n        captures[StoneColor.B] += this.history[i].getCaptureCount(StoneColor.B);\n        captures[StoneColor.W] += this.history[i].getCaptureCount(StoneColor.W);\n      }\n\n      //Return\n      return captures;\n    };\n\n    /**\n     * Get the move variation for given coordinates\n     */\n    Game.prototype.getMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.getMoveVariation(x, y);\n      }\n      return -1;\n    };\n\n    /**\n     * Get current move number\n     */\n    Game.prototype.getMove = function() {\n      return this.path.getMove();\n    };\n\n    /**\n     * Get the number of moves in the main branch\n     */\n    Game.prototype.getMoveCount = function() {\n\n      //Initialize node to process\n      var node = this.root;\n      var noMoves = 0;\n\n      //Process children\n      while (node.children.length > 0) {\n        node = node.children[0];\n        if (typeof node.move !== 'undefined') {\n          noMoves++;\n        }\n      }\n\n      //Return move count\n      return noMoves;\n    };\n\n    /**\n     * Get an info property\n     */\n    Game.prototype.get = function(position) {\n\n      //Must have a position\n      if (!position) {\n        return;\n      }\n\n      //The item's position in the object is given by dot separated strings\n      if (typeof position === 'string') {\n        position = position.split('.');\n      }\n\n      //Initialize object we're getting info from\n      var obj = this.info;\n      var key;\n\n      //Loop the position\n      for (var p = 0; p < position.length; p++) {\n\n        //Get actual key\n        key = position[p];\n\n        //Last key reached? Done, get value\n        if ((p + 1) === position.length) {\n          return obj[key];\n        }\n\n        //Must be object container\n        if (typeof obj[key] !== 'object') {\n          console.warn('Game property', key, 'is not an object');\n          return;\n        }\n\n        //Move up in tree\n        obj = obj[key];\n      }\n    };\n\n    /*****************************************************************************\n     * Checkers\n     ***/\n\n    /**\n     * Check if coordinates are on the board\n     */\n    Game.prototype.isOnBoard = function(x, y) {\n      return x >= 0 && y >= 0 && x < this.info.board.width && y < this.info.board.height;\n    };\n\n    /**\n     * Check if given coordinates are one of the next child node coordinates\n     */\n    Game.prototype.isMoveVariation = function(x, y) {\n      if (this.node) {\n        return this.node.isMoveVariation(x, y);\n      }\n      return false;\n    };\n\n    /**\n     * Check if a given position is repeating within this game\n     */\n    Game.prototype.isRepeatingPosition = function(checkPosition) {\n\n      //Init\n      var stop;\n\n      //Check for ko only? (Last two positions)\n      if (this.checkRepeat === 'KO' && (this.history.length - 2) >= 0) {\n        stop = this.history.length - 2;\n      }\n\n      //Check all history?\n      else if (this.checkRepeat === 'ALL') {\n        stop = 0;\n      }\n\n      //Not repeating\n      else {\n        return false;\n      }\n\n      //Loop history of positions to check\n      for (var i = this.history.length - 2; i >= stop; i--) {\n        if (checkPosition.isSameAs(this.history[i])) {\n          return true;\n        }\n      }\n\n      //Not repeating\n      return false;\n    };\n\n    /**\n     * Wrapper for validateMove() returning a boolean and catching any errors\n     */\n    Game.prototype.isValidMove = function(x, y, color) {\n      try {\n        this.validateMove(x, y, color);\n        return true;\n      }\n      catch (error) {\n        return false;\n      }\n    };\n\n    /**\n     * Check if a move is valid. If valid, the new game position object is returned.\n     * You can supply a pre-created position to use, or the current position is cloned.\n     */\n    Game.prototype.validateMove = function(x, y, color, newPosition) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Something already here?\n      if (this.position.stones.get(x, y) !== StoneColor.EMPTY) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_ALREADY_HAS_STONE, x, y, color);\n      }\n\n      //Set color of move to make\n      color = color || this.position.getTurn();\n\n      //Determine position to use\n      newPosition = newPosition || this.position.clone();\n\n      //Place the stone\n      newPosition.stones.set(x, y, color);\n\n      //Capture adjacent stones if possible\n      var captures = newPosition.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created?\n        if (!newPosition.hasLiberties(x, y)) {\n\n          //Capture the group if it's allowed\n          if (this.allowSuicide) {\n            newPosition.captureGroup(x, y);\n          }\n\n          //Invalid move\n          else {\n            throw new InvalidPositionError(ngGo.error.POSTITION_IS_SUICIDE, x, y, color);\n          }\n        }\n      }\n\n      //Check history for repeating moves\n      if (this.checkRepeat && this.isRepeatingPosition(newPosition)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_IS_REPEATING, x, y, color);\n      }\n\n      //Set proper turn\n      newPosition.setTurn(-color);\n\n      //Move is valid\n      return newPosition;\n    };\n\n    /**\n     * Check if a stone (setup) placement is valid.\n     */\n    Game.prototype.validatePlacement = function(x, y, color, position) {\n\n      //Check coordinates validity\n      if (!this.isOnBoard(x, y)) {\n        throw new InvalidPositionError(ngGo.error.POSTITION_OUT_OF_BOUNDS, x, y, color);\n      }\n\n      //Place the stone\n      position.stones.set(x, y, color);\n\n      //Empty spot? Don't need to check for captures\n      if (color === StoneColor.EMPTY) {\n        return;\n      }\n\n      //Capture adjacent stones if possible\n      var captures = position.captureAdjacent(x, y);\n\n      //No captures occurred? Check if the move we're making is a suicide move\n      if (!captures) {\n\n        //No liberties for the group we've just created? Capture it\n        if (!position.hasLiberties(x, y)) {\n          position.captureGroup(x, y);\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * Stone and markup handling\n     ***/\n\n    /**\n     * Add a stone\n     */\n    Game.prototype.addStone = function(x, y, color) {\n\n      //Check if there's anything to do at all\n      if (this.position.stones.is(x, y, color)) {\n        return;\n      }\n\n      //Create temporary position\n      var tempPosition = this.position.clone();\n\n      //Validate placement on temp position\n      this.validatePlacement(x, y, color, tempPosition);\n\n      //No setup instructions container in this node?\n      if (typeof this.node.setup === 'undefined') {\n\n        //Is this a move node?\n        if (this.node.move) {\n\n          //Clone our position\n          pushPosition.call(this);\n\n          //Create new node\n          var node = new GameNode();\n\n          //Append it to the current node and change the pointer\n          var i = node.appendTo(this.node);\n          this.node = node;\n\n          //Advance path to the added node index\n          this.path.advance(i);\n        }\n\n        //Create setup container in this node\n        this.node.setup = [];\n      }\n\n      //Replace current position\n      replacePosition.call(this, tempPosition);\n\n      //Add setup instructions to node\n      this.node.setup.push(this.position.stones.get(x, y, 'color'));\n    };\n\n    /**\n     * Add markup\n     */\n    Game.prototype.addMarkup = function(x, y, markup) {\n\n      //No markup instructions container in this node?\n      if (typeof this.node.markup === 'undefined') {\n        this.node.markup = [];\n      }\n\n      //Add markup to game position\n      this.position.markup.set(x, y, markup);\n\n      //Add markup instructions to node\n      this.node.markup.push(this.position.markup.get(x, y, 'type'));\n    };\n\n    /**\n     * Remove a stone\n     */\n    Game.prototype.removeStone = function(x, y) {\n\n      //Check if the stone is found in setup instructions\n      var foundInSetup = false;\n\n      //Remove from node setup instruction\n      if (typeof this.node.setup !== 'undefined') {\n        for (var i = 0; i < this.node.setup.length; i++) {\n          if (x === this.node.setup[i].x && y === this.node.setup[i].y) {\n\n            //Remove from node and unset in position\n            this.node.setup.splice(i, 1);\n            this.position.stones.unset(x, y);\n\n            //Mark as found\n            foundInSetup = true;\n            break;\n          }\n        }\n      }\n\n      //Not found in setup? Add as no stone color\n      if (!foundInSetup) {\n        this.addStone(x, y, StoneColor.EMPTY);\n      }\n    };\n\n    /**\n     * Remove markup\n     */\n    Game.prototype.removeMarkup = function(x, y) {\n\n      //Remove from node\n      if (typeof this.node.markup !== 'undefined') {\n        for (var i = 0; i < this.node.markup.length; i++) {\n          if (x === this.node.markup[i].x && y === this.node.markup[i].y) {\n            this.node.markup.splice(i, 1);\n            this.position.markup.unset(x, y);\n            break;\n          }\n        }\n      }\n    };\n\n    /**\n     * Check if there is a stone at the given coordinates for the current position\n     */\n    Game.prototype.hasStone = function(x, y, color) {\n      if (typeof color !== 'undefined') {\n        return this.position.stones.is(x, y, color);\n      }\n      return this.position.stones.has(x, y);\n    };\n\n    /**\n     * Check if there is markup at the given coordinate for the current position\n     */\n    Game.prototype.hasMarkup = function(x, y, type) {\n      if (typeof type !== 'undefined') {\n        return this.position.markup.is(x, y, type);\n      }\n      return this.position.markup.has(x, y);\n    };\n\n    /**\n     * Get stone on coordinates\n     */\n    Game.prototype.getStone = function(x, y) {\n      return this.position.stones.get(x, y);\n    };\n\n    /**\n     * Get markup on coordinates\n     */\n    Game.prototype.getMarkup = function(x, y) {\n      return this.position.markup.get(x, y);\n    };\n\n    /*****************************************************************************\n     * Move handling\n     ***/\n\n    /**\n     * Play move\n     */\n    Game.prototype.play = function(x, y, color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Validate move and get new position\n      var newPosition = this.validateMove(x, y, color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          x: x,\n          y: y,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node._remembered_path = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n\n      //Valid move\n      return true;\n    };\n\n    /**\n     * Play pass\n     */\n    Game.prototype.pass = function(color) {\n\n      //Color defaults to current turn\n      color = color || this.position.getTurn();\n\n      //Initialize new position and switch the turn\n      var newPosition = this.position.clone();\n      newPosition.setTurn(-color);\n\n      //Push new position\n      pushPosition.call(this, newPosition);\n\n      //Create new move node\n      var node = new GameNode({\n        move: {\n          pass: true,\n          color: color\n        }\n      });\n\n      //Append it to the current node, remember the path, and change the pointer\n      var i = node.appendTo(this.node);\n      this.node._remembered_path = i;\n      this.node = node;\n\n      //Advance path to the added node index\n      this.path.advance(i);\n    };\n\n    /*****************************************************************************\n     * Game tree navigation\n     ***/\n\n    /**\n     * Go to the next position\n     */\n    Game.prototype.next = function(i) {\n\n      //Object (node) given as parameter? Find index\n      if (typeof i === 'object') {\n        i = this.node.children.indexOf(i);\n      }\n\n      //Go to the next node\n      if (nextNode.call(this, i)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n          return true;\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n\n      //Didn't go to next position\n      return false;\n    };\n\n    /**\n     * Go to the previous position\n     */\n    Game.prototype.previous = function() {\n\n      //Go to the previous node\n      if (previousNode.call(this)) {\n        popPosition.call(this);\n        return true;\n      }\n\n      //Didn't go to previous position\n      return false;\n    };\n\n    /**\n     * Go to the last position\n     */\n    Game.prototype.last = function() {\n\n      //Keep going to the next node until we reach the end\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the first position\n     */\n    Game.prototype.first = function() {\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      executeNode.call(this);\n    };\n\n    /**\n     * Go to position specified by a path object, a numeric move numer, or a node name string\n     */\n    Game.prototype.goto = function(target) {\n\n      //Must have a tree\n      if (this.root === null) {\n        return;\n      }\n\n      //Nothing given?\n      if (typeof target === 'undefined') {\n        return;\n      }\n\n      //Function given? Call now\n      if (typeof target === 'function') {\n        target = target.call(this);\n      }\n\n      //Initialize path\n      var path;\n\n      //Simple move number? Convert to path object\n      if (typeof target === 'number') {\n        path = this.path.clone();\n        path.setMove(target);\n      }\n\n      //String? Named node\n      else if (typeof target === 'string') {\n\n        //Already here?\n        if (this.node.name === target) {\n          return;\n        }\n\n        //Find path to node\n        path = this.getPathToNode(target);\n        if (path === null) {\n          return;\n        }\n      }\n\n      //Otherwise assume path object\n      else {\n        path = target;\n      }\n\n      //Already here?\n      if (this.path.compare(path)) {\n        return;\n      }\n\n      //Go to the first node\n      firstNode.call(this);\n\n      //Create the initial position, clone it and parse the current node\n      initializeHistory.call(this);\n      pushPosition.call(this);\n      executeNode.call(this);\n\n      //Loop path\n      var n = path.getMove();\n      for (var i = 0; i < n; i++) {\n\n        //Try going to the next node\n        if (!nextNode.call(this, path.nodeAt(i))) {\n          break;\n        }\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n      }\n    };\n\n    /**\n     * Go to the previous fork\n     */\n    Game.prototype.previousFork = function() {\n\n      //Loop until we find a node with more than one child\n      while (previousNode.call(this)) {\n        popPosition.call(this);\n\n        //Break when found a node with more than one child\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /**\n     * Go to the next fork\n     */\n    Game.prototype.nextFork = function() {\n\n      //Keep going to the next node until we reach one with multiple children\n      while (nextNode.call(this)) {\n\n        //If an invalid move is detected, we can't go on\n        try {\n          executeNode.call(this);\n        }\n        catch (error) {\n          previousNode.call(this);\n          throw error;\n        }\n\n        //Have multiple children?\n        if (this.node.children.length > 1) {\n          break;\n        }\n      }\n    };\n\n    /*****************************************************************************\n     * State handling\n     ***/\n\n    /**\n     * Get the board state\n     */\n    Game.prototype.getState = function() {\n\n      //Can only create when we have a JGF and path\n      if (!this.jgf || !this.path) {\n        return null;\n      }\n\n      //Create state\n      var state = {\n        jgf: this.jgf,\n        path: this.path.clone()\n      };\n\n      //Return\n      return state;\n    };\n\n    /**\n     * Restore the game state\n     */\n    Game.prototype.restoreState = function(state) {\n\n      //Must have jgf and path\n      if (!state || !state.jgf || !state.path) {\n        return;\n      }\n\n      //Restore state\n      this.load(state.jgf);\n      this.goto(state.path);\n    };\n\n    //Return object\n    return Game;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GameNode :: This class represents a single node in the game moves tree. It contains\n * properties like the x and y grid coordinates, the move played, board setup instructions,\n * markup, player turn and comments. The moves tree in the game record is represented by a\n * string of GameNodes, each with pointers to their parent and children. Each node can have\n * multiple children (move variations), but only one parent.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Node.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameNode', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /**\n   * Helper to construct a coordinates base object\n   */\n  var coordinatesObject = function(coords, baseObject) {\n    baseObject = baseObject || {};\n    if (coords === '' || coords === 'pass') {\n      baseObject.pass = true;\n    }\n    else {\n\n      //Backwards compatibility with SGF string coordinates in JGF\n      if (typeof coords === 'string') {\n        coords = convertCoordinates(coords);\n      }\n\n      //Append coordinates\n      baseObject.x = coords[0] * 1;\n      baseObject.y = coords[1] * 1;\n    }\n    return baseObject;\n  };\n\n  /**\n   * Convert a numeric color value (color constant) to a string\n   */\n  var toStringColor = function(color) {\n    return (color === StoneColor.B) ? 'B' : (((color === StoneColor.W) ? 'W' : ''));\n  };\n\n  /**\n   * Convert a string color value to a numeric color constant\n   */\n  var toColorConstant = function(color) {\n    if (color === 'B') {\n      return StoneColor.B;\n    }\n    else if (color === 'W') {\n      return StoneColor.W;\n    }\n    return StoneColor.E;\n  };\n\n  /*****************************************************************************\n   * Helpers for conversion between JGF / KIFU format\n   ***/\n\n  /**\n   * Convert move object to JGF format\n   */\n  var convertMoveToJgf = function(move) {\n\n    //Initialize JGF move object and determine color\n    var jgfMove = angular.copy(move);\n    var color = toStringColor(move.color);\n\n    //No color?\n    if (color === '') {\n      return null;\n    }\n\n    //Pass move?\n    if (move.pass === true) {\n      jgfMove[color] = 'pass';\n    }\n\n    //Regular move\n    else {\n      jgfMove[color] = [move.x, move.y];\n    }\n\n    //Delete coordinates and color\n    delete jgfMove.x;\n    delete jgfMove.y;\n    delete jgfMove.color;\n\n    //Return move\n    return jgfMove;\n  };\n\n  /**\n   * Convert move from JGF format\n   */\n  var convertMoveFromJgf = function(move) {\n\n    //Prepare color, coordinates\n    var color, coords;\n\n    //Check whose move it was\n    if (move.W) {\n      color = 'W';\n      coords = move.W;\n    }\n    else if (move.B) {\n      color = 'B';\n      coords = move.B;\n    }\n\n    //No coordinates?\n    if (!coords) {\n      return null;\n    }\n\n    //Return coordinates object\n    return coordinatesObject(coords, {\n      color: toColorConstant(color)\n    });\n  };\n\n  /**\n   * Convert setup object to JGF format\n   */\n  var convertSetupToJgf = function(setup) {\n\n    //Initialize variables\n    var i, color;\n    var jgfSetup = {};\n\n    //Loop setup objects\n    for (i in setup) {\n      if (setup.hasOwnProperty(i)) {\n\n        //Get color\n        color = toStringColor(setup[i].color) || 'E';\n\n        //Initialize array\n        if (typeof jgfSetup[color] === 'undefined') {\n          jgfSetup[color] = [];\n        }\n\n        //Add coordinates\n        jgfSetup[color].push([setup[i].x, setup[i].y]);\n      }\n    }\n\n    //Return\n    return jgfSetup;\n  };\n\n  /**\n   * Convert setup from JGF format\n   */\n  var convertSetupFromJgf = function(setup) {\n\n    //Initialize variables\n    var c, key, color;\n    var gameSetup = [];\n\n    //Loop setup\n    for (key in setup) {\n      if (setup.hasOwnProperty(key)) {\n\n        //Get color constant\n        color = toColorConstant(key);\n\n        //Loop coordinates\n        for (c in setup[key]) {\n          if (setup[key].hasOwnProperty(c)) {\n            gameSetup.push(coordinatesObject(setup[key][c], {\n              color: color\n            }));\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameSetup;\n  };\n\n  /**\n   * Convert markup object to JGF format\n   */\n  var convertMarkupToJgf = function(markup) {\n\n    //Initialize variables\n    var i, type;\n    var jgfMarkup = {};\n\n    //Loop setup objects\n    for (i in markup) {\n      if (markup.hasOwnProperty(i)) {\n\n        //Get type\n        type = markup[i].type;\n\n        //Initialize array\n        if (typeof jgfMarkup[type] === 'undefined') {\n          jgfMarkup[type] = [];\n        }\n\n        //Label?\n        if (type === 'label') {\n          jgfMarkup[type].push([markup[i].x, markup[i].y, markup[i].text]);\n        }\n        else {\n          jgfMarkup[type].push([markup[i].x, markup[i].y]);\n        }\n      }\n    }\n\n    //Return\n    return jgfMarkup;\n  };\n\n  /**\n   * Convert markup from JGF format\n   */\n  var convertMarkupFromJgf = function(markup) {\n\n    //Initialize variables\n    var l, type;\n    var gameMarkup = [];\n\n    //Loop markup types\n    for (type in markup) {\n      if (markup.hasOwnProperty(type)) {\n\n        //Label?\n        if (type === 'label') {\n          for (l = 0; l < markup[type].length; l++) {\n\n            //Validate\n            if (!angular.isArray(markup[type][l])) {\n              continue;\n            }\n\n            //SGF type coordinates?\n            if (markup[type][l].length === 2 && typeof markup[type][l][0] === 'string') {\n              var text = markup[type][l][1];\n              markup[type][l] = convertCoordinates(markup[type][l][0]);\n              markup[type][l].push(text);\n            }\n\n            //Validate length\n            if (markup[type][l].length < 3) {\n              continue;\n            }\n\n            //Add to stack\n            gameMarkup.push(coordinatesObject(markup[type][l], {\n              type: type,\n              text: markup[type][l][2]\n            }));\n          }\n        }\n        else {\n\n          //Loop coordinates\n          for (l in markup[type]) {\n            if (markup[type].hasOwnProperty(l)) {\n              gameMarkup.push(coordinatesObject(markup[type][l], {\n                type: type\n              }));\n            }\n          }\n        }\n      }\n    }\n\n    //Return\n    return gameMarkup;\n  };\n\n  /**\n   * Convert turn object to JGF format\n   */\n  var convertTurnToJgf = function(turn) {\n    switch (turn) {\n      case StoneColor.W:\n        return 'W';\n      case StoneColor.B:\n        return 'B';\n      default:\n        return '';\n    }\n  };\n\n  /**\n   * Convert turn from JGF format\n   */\n  var convertTurnFromJgf = function(turn) {\n    switch (turn) {\n      case 'W':\n        return StoneColor.W;\n      case 'B':\n        return StoneColor.B;\n      default:\n        return StoneColor.EMPTY;\n    }\n  };\n\n  /**\n   * Conversions map\n   */\n  var conversionMap = {\n    toJgf: {\n      move: convertMoveToJgf,\n      setup: convertSetupToJgf,\n      markup: convertMarkupToJgf,\n      turn: convertTurnToJgf\n    },\n    fromJgf: {\n      move: convertMoveFromJgf,\n      setup: convertSetupFromJgf,\n      markup: convertMarkupFromJgf,\n      turn: convertTurnFromJgf\n    }\n  };\n\n  /**\n   * Constructor\n   */\n  var GameNode = function(properties, parent) {\n\n    //Set parent and children\n    this.parent = parent || null;\n    this.children = [];\n\n    //Save properties\n    if (properties) {\n      for (var key in properties) {\n        if (properties.hasOwnProperty(key)) {\n          this[key] = properties[key];\n        }\n      }\n    }\n  };\n\n  /**\n   * Get node's child specified by index or null if doesn't exist\n   */\n  GameNode.prototype.getChild = function(i) {\n    i = i || 0;\n    if (this.children[i]) {\n      return this.children[i];\n    }\n    return null;\n  };\n\n  /**\n   * Get all the children\n   */\n  GameNode.prototype.getChildren = function() {\n    return this.children;\n  };\n\n  /**\n   * Check if the node has any chilren\n   */\n  GameNode.prototype.hasChildren = function() {\n    return (this.children.length > 0);\n  };\n\n  /**\n   * Check if the node has more than one move variation\n   */\n  GameNode.prototype.hasMoveVariations = function() {\n\n    //Less than two child nodes?\n    if (this.children.length <= 1) {\n      return false;\n    }\n\n    //Loop children\n    var moveVariations = 0;\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].move) {\n        moveVariations++;\n      }\n\n      //More than one move node present?\n      if (moveVariations > 1) {\n        return true;\n      }\n    }\n\n    //No move variations\n    return false;\n  };\n\n  /**\n   * Get all the move variation nodes\n   */\n  GameNode.prototype.getMoveVariations = function() {\n\n    //No child nodes?\n    if (this.children.length === 0) {\n      return false;\n    }\n\n    //Initialize\n    var moveVariations = [];\n\n    //Loop child nodes\n    for (var i = 0; i < this.children.length; i++) {\n\n      //Is this a move node?\n      if (this.children[i].move) {\n        moveVariations.push(this.children[i]);\n      }\n    }\n\n    //Return\n    return moveVariations;\n  };\n\n  /**\n   * Get the move variation for given coordinates\n   */\n  GameNode.prototype.getMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return i;\n      }\n    }\n\n    //Not found\n    return -1;\n  };\n\n  /**\n   * Check if given coordinates are one of the next child node coordinates\n   */\n  GameNode.prototype.isMoveVariation = function(x, y) {\n\n    //Loop the child nodes\n    for (var i = 0; i < this.children.length; i++) {\n      if (this.children[i].move && this.children[i].move.x === x && this.children[i].move.y === y) {\n        return true;\n      }\n    }\n\n    //Not found\n    return false;\n  };\n\n  /*****************************************************************************\n   * Node manipulation\n   ***/\n\n  /**\n   * Remove this node from its parent\n   */\n  GameNode.prototype.remove = function() {\n\n    //Can't remove if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found remove it\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1) {\n      this.parent.children.splice(i, 1);\n    }\n\n    //Clear parent reference\n    this.parent = null;\n  };\n\n  /**\n   * Move the node up in the parent's child tree\n   */\n  GameNode.prototype.moveUp = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i > 0) {\n      var temp = this.parent.children[i - 1];\n      this.parent.children[i - 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Move the node down in the parent's child tree\n   */\n  GameNode.prototype.moveDown = function() {\n\n    //Can't move if no parent\n    if (!this.parent) {\n      return;\n    }\n\n    //Find the index of this node, and if found swap the nodes from position\n    var i = this.parent.children.indexOf(this);\n    if (i !== -1 && i < (this.parent.children.length - 1)) {\n      var temp = this.parent.children[i + 1];\n      this.parent.children[i + 1] = this;\n      this.parent.children[i] = temp;\n    }\n  };\n\n  /**\n   * Append this node to another node\n   */\n  GameNode.prototype.appendTo = function(node) {\n\n    //Remove from existing parent\n    this.remove();\n\n    //Set new parent\n    this.parent = node;\n    node.children.push(this);\n    return node.children.length - 1;\n  };\n\n  /**\n   * Append child node to this node.\n   */\n  GameNode.prototype.appendChild = function(node) {\n    node.parent = this;\n    this.children.push(node);\n    return this.children.length - 1;\n  };\n\n  /**\n   * Insert another node after this one\n   */\n  GameNode.prototype.insertNode = function(node) {\n\n    //Loop our children and change parent node\n    for (var i = 0; i < this.children.length; i++) {\n      this.children[i].parent = node;\n    }\n\n    //Merge children, set this node as the parent of given node\n    node.children = node.children.concat(this.children);\n    node.parent = this;\n\n    //Set given node as the child of this node\n    this.children = [node];\n  };\n\n  /*****************************************************************************\n   * JGF conversion\n   ***/\n\n  /**\n   * Build a Game Node from a given JGF tree\n   */\n  GameNode.prototype.fromJgf = function(jgf, gameNode) {\n\n    //Root JGF file given?\n    if (typeof jgf.tree !== 'undefined') {\n      return GameNode.fromJgf(jgf.tree, gameNode);\n    }\n\n    //Initialize helper vars\n    var variationNode, nextNode, i, j;\n\n    //Node to work with given? Otherwise, work with ourselves\n    gameNode = gameNode || this;\n\n    //Loop moves in the JGF tree\n    for (i = 0; i < jgf.length; i++) {\n\n      //Array? That means a variation branch\n      if (angular.isArray(jgf[i])) {\n\n        //Loop variation stacks\n        for (j = 0; j < jgf[i].length; j++) {\n\n          //Build the variation node\n          variationNode = new GameNode();\n          variationNode.fromJgf(jgf[i][j]);\n\n          //Append to working node\n          gameNode.appendChild(variationNode);\n        }\n      }\n\n      //Regular node\n      else {\n\n        //Get properties to copy\n        var properties = Object.getOwnPropertyNames(jgf[i]);\n\n        //Copy node properties\n        for (var key in properties) {\n          if (properties.hasOwnProperty(key)) {\n            var prop = properties[key];\n\n            //Conversion function present?\n            if (typeof conversionMap.fromJgf[prop] !== 'undefined') {\n              gameNode[prop] = conversionMap.fromJgf[prop](jgf[i][prop]);\n            }\n            else if (typeof jgf[i][prop] === 'object') {\n              gameNode[prop] = angular.copy(jgf[i][prop]);\n            }\n            else {\n              gameNode[prop] = jgf[i][prop];\n            }\n          }\n        }\n      }\n\n      //Next element is a regular node? Prepare new working node\n      //Otherwise, if there are no more nodes or if the next element is\n      //an array (e.g. variations), we keep our working node as the current one\n      if ((i + 1) < jgf.length && !angular.isArray(jgf[i + 1])) {\n        nextNode = new GameNode();\n        gameNode.appendChild(nextNode);\n        gameNode = nextNode;\n      }\n    }\n  };\n\n  /**\n   * Convert this node to a JGF node container\n   */\n  GameNode.prototype.toJgf = function(container) {\n\n    //Initialize container to add nodes to\n    container = container || [];\n\n    //Initialize node and get properties\n    var node = {};\n    var properties = Object.getOwnPropertyNames(this);\n\n    //Copy node properties\n    for (var key in properties) {\n      if (properties.hasOwnProperty(key)) {\n        var prop = properties[key];\n\n        //Skip some properties\n        if (prop === 'parent' || prop === 'children') {\n          continue;\n        }\n\n        //Conversion function present?\n        if (typeof conversionMap.toJgf[prop] !== 'undefined') {\n          node[prop] = conversionMap.toJgf[prop](this[prop]);\n        }\n        else if (typeof this[prop] === 'object') {\n          node[prop] = angular.copy(this[prop]);\n        }\n        else {\n          node[prop] = this[prop];\n        }\n      }\n    }\n\n    //Add node to container\n    container.push(node);\n\n    //Variations present?\n    if (this.children.length > 1) {\n\n      //Create variations container\n      var variationsContainer = [];\n      container.push(variationsContainer);\n\n      //Loop child (variation) nodes\n      for (var i = 0; i < this.children.length; i++) {\n\n        //Create container for this variation\n        var variationContainer = [];\n        variationsContainer.push(variationContainer);\n\n        //Call child node converter\n        this.children[i].toJgf(variationContainer);\n      }\n    }\n\n    //Just one child?\n    else if (this.children.length === 1) {\n      this.children[0].toJgf(container);\n    }\n\n    //Return container\n    return container;\n  };\n\n  //Return object\n  return GameNode;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePath :: A simple class that keeps track of a path taken in a game.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Path.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePath', function() {\n\n  /**\n   * Constructor\n   */\n  var GamePath = function() {\n    this.reset();\n  };\n\n  /**\n   * Reset\n   */\n  GamePath.prototype.reset = function() {\n    this.move = 0;\n    this.path = {};\n    this.branches = 0;\n    return this;\n  };\n\n  /**\n   * Advance a move\n   */\n  GamePath.prototype.advance = function(i) {\n\n    //Different child variation chosen? Remember\n    if (i > 0) {\n      this.path[this.move] = 1;\n      this.branches++;\n    }\n\n    //Increment move\n    this.move++;\n    return this;\n  };\n\n  /**\n   * Retreat a move\n   */\n  GamePath.prototype.retreat = function() {\n\n    //At start?\n    if (this.move === 0) {\n      return;\n    }\n\n    //Delete path choice\n    if (this.path[this.move]) {\n      delete this.path[this.move];\n      this.branches--;\n    }\n\n    //Decrement move\n    this.move--;\n    return this;\n  };\n\n  /**\n   * Go to a specific move number\n   */\n  GamePath.prototype.setMove = function(no) {\n\n    //Less than our current move? We need to erase any paths above the move number\n    if (no < this.move) {\n      for (var i in this.path) {\n        if (i > no) {\n          delete this.path[i];\n          this.branches--;\n        }\n      }\n    }\n\n    //Set move number\n    this.move = no;\n    return this;\n  };\n\n  /**\n   * Get the move number\n   */\n  GamePath.prototype.getMove = function() {\n    return this.move;\n  };\n\n  /**\n   * Get the node choice at a specific move number\n   */\n  GamePath.prototype.nodeAt = function(no) {\n    return (typeof this.path[no] === 'undefined') ? 0 : this.path[no];\n  };\n\n  /**\n   * Compare to another path\n   */\n  GamePath.prototype.compare = function(otherPath) {\n\n    //Invalid object?\n    if (!otherPath || typeof otherPath !== 'object' || typeof otherPath.move === 'undefined') {\n      return;\n    }\n\n    //Different move number or path length?\n    if (this.move !== otherPath.move || this.branches !== otherPath.branches) {\n      return false;\n    }\n\n    //Check path\n    for (var i in this.path) {\n      if (typeof otherPath.path[i] === 'undefined' || this.path[i] !== otherPath.path[i]) {\n        return false;\n      }\n    }\n\n    //Same path!\n    return true;\n  };\n\n  /**\n   * Clone\n   */\n  GamePath.prototype.clone = function() {\n\n    //Create new instance\n    var newPath = new GamePath();\n\n    //Set vars\n    newPath.move = this.move;\n    newPath.branches = this.branches;\n    newPath.path = angular.copy(this.path);\n\n    //Return\n    return newPath;\n  };\n\n  /**\n   * Helper to find node name recursively\n   */\n  var findNodeName = function(node, nodeName, path) {\n\n    //Found in this node?\n    if (node.name && node.name === nodeName) {\n      return true;\n    }\n\n    //Loop children\n    for (var i = 0; i < node.children.length; i++) {\n\n      //Advance path\n      path.advance(i);\n\n      //Found in child node?\n      if (findNodeName(node.children[i], nodeName, path)) {\n        return true;\n      }\n\n      //Not found in this child node, retreat path\n      path.retreat();\n    }\n\n    //Not found\n    return false;\n  };\n\n  /**\n   * Static helper to create a path object to reach a certain node\n   */\n  GamePath.findNode = function(nodeName, rootNode) {\n\n    //Create new instance\n    var path = new GamePath();\n\n    //Find the node name\n    if (findNodeName(rootNode, nodeName, path)) {\n      return path;\n    }\n\n    //Not found\n    return null;\n  };\n\n  //Return\n  return GamePath;\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GamePosition :: This class represents a single game position. It keeps track of the stones and\n * markup on the board in this position, as well as any captures that were made and which player's\n * turn it is. The class is also equipped with helpers to check for liberties, capture stones, and\n * compare changes to other positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Position.Service', [\n  'ngGo',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GamePosition', ['StoneColor', 'BoardGrid', function(StoneColor, BoardGrid) {\n\n  /**\n   * Constructor\n   */\n  var GamePosition = function(width, height) {\n\n    //Initialize\n    this.error = 0;\n    this.width = 0;\n    this.height = 0;\n    this.stones = new BoardGrid();\n    this.markup = new BoardGrid();\n    this.turn = StoneColor.B;\n\n    //Initialize captures\n    this.captures = {};\n    this.captures[StoneColor.B] = [];\n    this.captures[StoneColor.W] = [];\n\n    //Set empty value for stones grid\n    this.stones.whenEmpty(StoneColor.EMPTY);\n\n    //Set size\n    if (width || height) {\n      this.setSize(width, height);\n    }\n  };\n\n  /**\n   * Set the grid size\n   */\n  GamePosition.prototype.setSize = function(width, height) {\n\n    //Check what's given\n    width = width || height || 0;\n    height = height || width || 0;\n\n    //Set\n    this.width = parseInt(width);\n    this.height = parseInt(height);\n\n    //Set in grids\n    this.stones.setSize(width, height);\n    this.markup.setSize(width, height);\n\n    //Empty the position\n    this.empty();\n  };\n\n  /**\n   * Clear the whole position\n   */\n  GamePosition.prototype.empty = function() {\n    this.stones.empty();\n    this.markup.empty();\n  };\n\n  /**\n   * Sets stone color at given coordinates.\n   */\n  GamePosition.prototype.setStone = function(x, y, color) {\n    this.stones.set(x, y, color);\n  };\n\n  /**\n   * Sets markup type at given coordinates.\n   */\n  GamePosition.prototype.setMarkup = function(x, y, markup) {\n    this.markup.set(x, y, markup);\n  };\n\n  /*****************************************************************************\n   * Liberties and capturing\n   ***/\n\n  /**\n   * Check if a group of given color has liberties, starting at the given coordinates\n   */\n  GamePosition.prototype.hasLiberties = function(x, y, groupColor, tested) {\n\n    //Out of bounds? No liberties outside of the board\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Initialize tested grid if needed\n    tested = tested || new BoardGrid(this.width, this.height);\n\n    //See what color is present on the coordinates\n    var color = this.stones.get(x, y);\n\n    //If no group color was given, use what's on the position\n    groupColor = groupColor || color;\n\n    //Already tested, or enemy stone? Not giving any liberties\n    if (tested.get(x, y) === true || color === -groupColor) {\n      return false;\n    }\n\n    //Empty? That's a liberty\n    if (color === StoneColor.EMPTY) {\n      return true;\n    }\n\n    //Mark this position as tested now\n    tested.set(x, y, true);\n\n    //Ok, so we're looking at a stone of our own color. Test adjacent positions.\n    //If we get at least one true, we have a liberty\n    return this.hasLiberties(x, y - 1, groupColor, tested) ||\n        this.hasLiberties(x, y + 1, groupColor, tested) ||\n        this.hasLiberties(x - 1, y, groupColor, tested) ||\n        this.hasLiberties(x + 1, y, groupColor, tested);\n  };\n\n  /**\n   * Helper to capture adjacent groups\n   */\n  GamePosition.prototype.captureAdjacent = function(x, y, friendlyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    friendlyColor = friendlyColor || this.stones.get(x, y);\n\n    //Can't capture empty spots\n    if (friendlyColor === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Flag to see if we captured stuff\n    var captured = false;\n\n    //Check adjacent positions now, capturing stones in the process if possible\n    if (this.canCapture(x, y - 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x, y + 1, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x - 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n    if (this.canCapture(x + 1, y, -friendlyColor, true)) {\n      captured = true;\n    }\n\n    //Return\n    return captured;\n  };\n\n  /**\n   * Helper if we can capture a certain group\n   */\n  GamePosition.prototype.canCapture = function(x, y, enemyColor, doCapture) {\n\n    //Out of bounds? Nothing to capture\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //Empty spot? Can't capture\n    if (this.stones.get(x, y) === StoneColor.EMPTY) {\n      return false;\n    }\n\n    //Use color of stone present if none given\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //We need to have a stone of matching group color in order to be able to capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //There is a capturable stone, let's see if it has any liberties left\n    if (this.hasLiberties(x, y, enemyColor)) {\n      return false;\n    }\n\n    //No liberties left, the group is capturable. Capture if we want to\n    if (doCapture) {\n      this.captureGroup(x, y, enemyColor);\n    }\n\n    //Capturable\n    return true;\n  };\n\n  /**\n   * Capture a group of certain color, starting at the given coordinates\n   */\n  GamePosition.prototype.captureGroup = function(x, y, enemyColor) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return false;\n    }\n\n    //If no group color was given, use what's on the position\n    enemyColor = enemyColor || this.stones.get(x, y);\n\n    //Stone at position does not match the given group color? Can't capture it\n    if (this.stones.get(x, y) !== enemyColor) {\n      return false;\n    }\n\n    //Capture the stone\n    this.captureStone(x, y);\n\n    //Capture the rest of the group\n    this.captureGroup(x, y - 1, enemyColor);\n    this.captureGroup(x, y + 1, enemyColor);\n    this.captureGroup(x - 1, y, enemyColor);\n    this.captureGroup(x + 1, y, enemyColor);\n\n    //At least one stone was captured\n    return true;\n  };\n\n  /**\n   * Capture a stone at given coordinates\n   */\n  GamePosition.prototype.captureStone = function(x, y) {\n\n    //Validate boundaries\n    if (!this.stones.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Get color\n    var color = this.stones.get(x, y);\n\n    //Empty?\n    if (color === StoneColor.EMPTY) {\n      return;\n    }\n\n    //Ok, stone present, capture it\n    this.stones.set(x, y, StoneColor.EMPTY);\n    this.captures[color].push({x: x, y: y});\n  };\n\n  /**\n   * Set captures for a color (expects array with capture object coordinates)\n   */\n  GamePosition.prototype.setCaptures = function(color, captures) {\n    this.captures[color] = captures;\n  };\n\n  /**\n   * Get captures for a color\n   */\n  GamePosition.prototype.getCaptures = function(color) {\n    return this.captures[color] || [];\n  };\n\n  /**\n   * Get the capture count for a color (= the number of captures of the opposing color)\n   */\n  GamePosition.prototype.getCaptureCount = function(color) {\n    return this.captures[-color].length;\n  };\n\n  /*****************************************************************************\n   * Turn control\n   ***/\n\n  /**\n   * Set color for whose move it is at this position\n   */\n  GamePosition.prototype.setTurn = function(color) {\n    this.turn = color;\n  };\n\n  /**\n   * Get color for whose move it is at this position\n   */\n  GamePosition.prototype.getTurn = function() {\n    return this.turn;\n  };\n\n  /**\n   * Switch the player turn on this position\n   */\n  GamePosition.prototype.switchTurn = function() {\n    this.turn = -this.turn;\n  };\n\n  /*****************************************************************************\n   * Cloning and comparison\n   ***/\n\n  /**\n   * Clones the whole position except turn and captures\n   */\n  GamePosition.prototype.clone = function() {\n\n    //Create a new position\n    var newPosition = new GamePosition();\n\n    //Set vars manually for maximum efficiency\n    newPosition.turn = this.turn;\n    newPosition.width = this.width;\n    newPosition.height = this.height;\n    newPosition.stones = this.stones.clone();\n    newPosition.markup = new BoardGrid(this.width, this.height);\n\n    //Return\n    return newPosition;\n  };\n\n  /**\n   * Checks if a given position is the same as the current position\n   */\n  GamePosition.prototype.isSameAs = function(newPosition) {\n\n    //Must have the same size\n    if (this.width !== newPosition.width || this.height !== newPosition.height) {\n      return false;\n    }\n\n    //Compare the grids\n    return this.stones.isSameAs(newPosition.stones);\n  };\n\n  //Return\n  return GamePosition;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScore :: A simple class that contains a game score\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Score.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScore', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Helper to calculate the total points\n   */\n  var calcTotal = function() {\n    return parseInt(this.stones) + parseInt(this.territory) +\n      parseInt(this.captures) + parseInt(this.komi);\n  };\n\n  /**\n   * Constructor\n   */\n  var GameScore = function() {\n\n    //Get self\n    var self = this;\n\n    //Setup score containers\n    this.black = {};\n    this.white = {};\n\n    //Initialize\n    this.reset();\n\n    //Add total handlers\n    this.black.total = function() {\n      return calcTotal.call(self.black);\n    };\n    this.white.total = function() {\n      return calcTotal.call(self.white);\n    };\n  };\n\n  /**\n   * Reset the game score\n   */\n  GameScore.prototype.reset = function() {\n\n    //Get properties to loop\n    var props = ['stones', 'territory', 'captures', 'komi'];\n\n    //Score for black player\n    for (var i = 0; i < props.length; i++) {\n      this.black[props[i]] = 0;\n      this.white[props[i]] = 0;\n    }\n  };\n\n  /**\n   * Get the winner\n   */\n  GameScore.prototype.winner = function() {\n\n    //Get totals\n    var b = this.black.total();\n    var w = this.white.total();\n\n    //Determine winner\n    if (w > b) {\n      return StoneColor.W;\n    }\n    else if (b > w) {\n      return StoneColor.B;\n    }\n    return StoneColor.E;\n  };\n\n  //Return\n  return GameScore;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GameScorer :: This class is used to determine the score of a certain game position. It also\n * provides handling of manual adjustment of dead / living groups.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Game.Scorer.Service', [\n  'ngGo',\n  'ngGo.Game.Score.Service',\n  'ngGo.Board.Grid.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GameScorer', ['GameScore', 'StoneColor', 'BoardGrid', function(GameScore, StoneColor, BoardGrid) {\n\n  /**\n   * Possible score states\n   */\n  var scoreState = {\n    UNKNOWN: StoneColor.EMPTY,\n    BLACK_STONE: StoneColor.B,\n    WHITE_STONE: StoneColor.W,\n    BLACK_CANDIDATE: StoneColor.B * 2,\n    WHITE_CANDIDATE: StoneColor.W * 2,\n    NEUTRAL: StoneColor.B * 3\n  };\n\n  /**\n   * Helper to set territory\n   */\n  var territorySet = function(x, y, candidateColor, boundaryColor) {\n\n    //Get color at given position\n    var posColor = this.stones.get(x, y);\n    var origColor = this.game.position.stones.get(x, y);\n\n    //If border reached, or a position which is already this color, or boundary color, can't set\n    if (!this.stones.isOnGrid(x, y) || posColor === candidateColor || posColor === boundaryColor) {\n      return;\n    }\n\n    //Don't turn stones which are already this color into candidates, instead\n    //reset their color to what they were\n    if (origColor * 2 === candidateColor) {\n      this.stones.set(x, y, origColor);\n    }\n\n    //Otherwise, mark as candidate\n    else {\n      this.stones.set(x, y, candidateColor);\n    }\n\n    //Set adjacent squares\n    territorySet.call(this, x - 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y - 1, candidateColor, boundaryColor);\n    territorySet.call(this, x + 1, y, candidateColor, boundaryColor);\n    territorySet.call(this, x, y + 1, candidateColor, boundaryColor);\n  };\n\n  /**\n   * Helper to reset territory\n   */\n  var territoryReset = function(x, y) {\n\n    //Get original color from this position\n    var origColor = this.game.position.stones.get(x, y);\n\n    //Not on grid, or already this color?\n    if (!this.stones.isOnGrid(x, y) || this.stones.get(x, y) === origColor) {\n      return;\n    }\n\n    //Reset the color\n    this.stones.set(x, y, origColor);\n\n    //Set adjacent squares\n    territoryReset.call(this, x - 1, y);\n    territoryReset.call(this, x, y - 1);\n    territoryReset.call(this, x + 1, y);\n    territoryReset.call(this, x, y + 1);\n  };\n\n  /**\n   * Helper to determine score state\n   */\n  var determineScoreState = function() {\n\n    //Initialize vars\n    var change = true;\n    var curState, newState, adjacent, b, w, a, x, y;\n\n    //Loop while there is change\n    while (change) {\n\n      //Set to false\n      change = false;\n\n      //Go through the whole position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get current state at position\n          curState = this.stones.get(x, y);\n\n          //Unknown or candiates?\n          if (\n            curState === scoreState.UNKNOWN ||\n            curState === scoreState.BLACK_CANDIDATE ||\n            curState === scoreState.WHITE_CANDIDATE\n          ) {\n\n            //Get state in adjacent positions\n            adjacent = [\n              this.stones.get(x - 1, y),\n              this.stones.get(x, y - 1),\n              this.stones.get(x + 1, y),\n              this.stones.get(x, y + 1)\n            ];\n\n            //Reset\n            b = w = false;\n\n            //Loop adjacent squares\n            for (a = 0; a < 4; a++) {\n              if (\n                adjacent[a] === scoreState.BLACK_STONE ||\n                adjacent[a] === scoreState.BLACK_CANDIDATE\n              ) {\n                b = true;\n              }\n              else if (\n                adjacent[a] === scoreState.WHITE_STONE ||\n                adjacent[a] === scoreState.WHITE_CANDIDATE\n              ) {\n                w = true;\n              }\n              else if (adjacent[a] === scoreState.NEUTRAL) {\n                b = w = true;\n              }\n            }\n\n            //Determine new state\n            if (b && w) {\n              newState = scoreState.NEUTRAL;\n            }\n            else if (b) {\n              newState = scoreState.BLACK_CANDIDATE;\n            }\n            else if (w) {\n              newState = scoreState.WHITE_CANDIDATE;\n            }\n            else {\n              newState = false;\n            }\n\n            //Change?\n            if (newState !== false && newState !== curState) {\n              change = true;\n              this.stones.set(x, y, newState);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * this.game scorer class\n   */\n  var GameScorer = {\n\n    //Game to score\n    game: null,\n\n    //Score\n    score: null,\n\n    //Stones, captures and points grids\n    stones: null,\n    captures: null,\n    points: null,\n\n    /**\n     * Load a game to score\n     */\n    load: function(game) {\n\n      //Reset score\n      this.score = new GameScore();\n\n      //Remember\n      this.game = game;\n\n      //Clone position to work with\n      this.stones = this.game.position.stones.clone();\n\n      //Create grids\n      this.captures = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n      this.points = new BoardGrid(this.stones.width, this.stones.height, this.stones.emptyValue);\n    },\n\n    /**\n     * Get the calculated score\n     */\n    getScore: function() {\n      return this.score;\n    },\n\n    /**\n     * Get the points grid\n     */\n    getPoints: function() {\n      return this.points;\n    },\n\n    /**\n     * Get the captures grid\n     */\n    getCaptures: function() {\n      return this.captures;\n    },\n\n    /**\n     * Run score calculation routine\n     */\n    calculate: function() {\n\n      //No game?\n      if (!this.game) {\n        console.warn('No game loaded in game scorer, can\\'t calutlate score.');\n        return;\n      }\n\n      //Empty grids\n      this.points.empty();\n      this.captures.empty();\n\n      //Determine score state\n      determineScoreState.call(this);\n\n      //Get komi and captures\n      var komi = this.game.get('game.komi');\n      var captures = this.game.getCaptureCount();\n\n      //Reset score\n      this.score.reset();\n\n      //Set captures and komi\n      this.score.black.captures = captures[StoneColor.B];\n      this.score.white.captures = captures[StoneColor.W];\n      this.score.black.komi = komi < 0 ? komi : 0;\n      this.score.white.komi = komi > 0 ? komi : 0;\n\n      //Init helper vars\n      var x, y, state, color;\n\n      //Loop position\n      for (x = 0; x < this.stones.width; x++) {\n        for (y = 0; y < this.stones.height; y++) {\n\n          //Get state and color on original position\n          state = this.stones.get(x, y);\n          color = this.game.position.stones.get(x, y);\n\n          //Black stone\n          if (state === scoreState.BLACK_STONE && color === StoneColor.B) {\n            this.score.black.stones++;\n            continue;\n          }\n\n          //White stone\n          if (state === scoreState.WHITE_STONE && color === StoneColor.W) {\n            this.score.white.stones++;\n            continue;\n          }\n\n          //Black candidate\n          if (state === scoreState.BLACK_CANDIDATE) {\n            this.score.black.territory++;\n            this.points.set(x, y, StoneColor.B);\n\n            //White stone underneath?\n            if (color === StoneColor.W) {\n              this.score.black.captures++;\n              this.captures.set(x, y, StoneColor.W);\n            }\n            continue;\n          }\n\n          //White candidate\n          if (state === scoreState.WHITE_CANDIDATE) {\n            this.score.white.territory++;\n            this.points.set(x, y, StoneColor.W);\n\n            //Black stone underneath?\n            if (color === StoneColor.B) {\n              this.score.white.captures++;\n              this.captures.set(x, y, StoneColor.B);\n            }\n            continue;\n          }\n        }\n      }\n    },\n\n    /**\n     * Mark stones dead or alive\n     */\n    mark: function(x, y) {\n\n      //Get color of original position and state of the count position\n      var color = this.game.position.stones.get(x, y);\n      var state = this.stones.get(x, y);\n\n      //White stone\n      if (color === StoneColor.W) {\n\n        //Was white, mark it and any territory it's in as black's\n        if (state === scoreState.WHITE_STONE) {\n          territorySet.call(this, x, y, scoreState.BLACK_CANDIDATE, scoreState.BLACK_STONE);\n        }\n\n        //Was marked as not white, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n\n      //Black stone\n      else if (color === StoneColor.B) {\n\n        //Was black, mark it and any territory it's in as white's\n        if (state === scoreState.BLACK_STONE) {\n          territorySet.call(this, x, y, scoreState.WHITE_CANDIDATE, scoreState.WHITE_STONE);\n        }\n\n        //Was marked as not black, reset the territory\n        else {\n          territoryReset.call(this, x, y);\n        }\n      }\n    }\n  };\n\n  //Return\n  return GameScorer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuBlank :: This is a class which can generate blank JGF or SGF templates.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Blank.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('KifuBlank', ['ngGo', function(ngGo) {\n\n  /**\n   * Blank JGF\n   */\n  var blankJgf = {\n    record: {\n      application: ngGo.name + ' v' + ngGo.version,\n      version: 1,\n      charset: 'UTF-8'\n    },\n    game: {\n      type: 'go',\n      players: [\n        {\n          color: 'black',\n          name: 'Black'\n        },\n        {\n          color: 'white',\n          name: 'White'\n        }\n      ]\n    },\n    board: {\n      width: 19,\n      height: 19\n    },\n    tree: []\n  };\n\n  /**\n   * Blank SGF\n   */\n  var blankSgf = {\n    AP: ngGo.name + ':' + ngGo.version,\n    CA: 'UTF-8',\n    FF: '4',\n    GM: '1',\n    SZ: '19',\n    PB: 'Black',\n    PW: 'White'\n  };\n\n  /**\n   * Blank JGF/SGF container\n   */\n  var KifuBlank = {\n\n    /**\n     * Get blank JGF\n     */\n    jgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankJgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = angular.extend(blank[p] || {}, base[p]);\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    },\n\n    /**\n     * Get blank SGF\n     */\n    sgf: function(base) {\n\n      //Initialize blank\n      var blank = angular.copy(blankSgf);\n\n      //Base given?\n      if (base) {\n        for (var p in base) {\n          if (base.hasOwnProperty(p)) {\n            blank[p] = base[p];\n          }\n        }\n      }\n\n      //Return\n      return blank;\n    }\n  };\n\n  //Return object\n  return KifuBlank;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * KifuParser :: This is a wrapper class for all available kifu parsers. It also provides\n * constants used by the parsers to aid conversion.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parser.Service', [\n  'ngGo',\n  'ngGo.Kifu.Parsers.Gib2Jgf.Service',\n  'ngGo.Kifu.Parsers.Sgf2Jgf.Service',\n  'ngGo.Kifu.Parsers.Jgf2Sgf.Service'\n])\n\n/**\n * SGF/JGF aliases constant for conversion between the two formats\n * Note: not all properties can be translated directly, so some are\n * not present here in this constant\n */\n.constant('sgfAliases', {\n\n  //Record properties\n  'AP': 'record.application',\n  'CA': 'record.charset',\n  'CP': 'record.copyright',\n  'SO': 'record.source',\n  'US': 'record.transcriber',\n  'AN': 'record.annotator',\n\n  //Game properties\n  'GM': 'game.type',\n  'GN': 'game.name',\n  'KM': 'game.komi',\n  'HA': 'game.handicap',\n  'RE': 'game.result',\n  'RU': 'game.rules',\n  'TM': 'game.time.main',\n  'OT': 'game.time.overtime',\n  'DT': 'game.dates',\n  'PC': 'game.location',\n  'EV': 'game.event',\n  'RO': 'game.round',\n  'ON': 'game.opening',\n  'GC': 'game.comment',\n\n  //Player info properties\n  'PB': 'name',\n  'PW': 'name',\n  'BT': 'team',\n  'WT': 'team',\n  'BR': 'rank',\n  'WR': 'rank',\n\n  //Node annotation\n  'N': 'name',\n  'C': 'comments',\n  'CR': 'circle',\n  'TR': 'triangle',\n  'SQ': 'square',\n  'MA': 'mark',\n  'SL': 'select',\n  'LB': 'label'\n})\n\n/**\n * SGF game definitions\n */\n.constant('sgfGames', {\n  1: 'go',\n  2: 'othello',\n  3: 'chess',\n  4: 'renju',\n  6: 'backgammon',\n  7: 'chinese chess',\n  8: 'shogi'\n})\n\n/**\n * Factory definition\n */\n.factory('KifuParser', ['Gib2Jgf', 'Sgf2Jgf', 'Jgf2Sgf', function(Gib2Jgf, Sgf2Jgf, Jgf2Sgf) {\n\n  /**\n   * Parser wrapper class\n   */\n  var KifuParser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    gib2jgf: function(gib, stringified) {\n      return Gib2Jgf.parse(gib, stringified);\n    },\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    sgf2jgf: function(sgf, stringified) {\n      return Sgf2Jgf.parse(sgf, stringified);\n    },\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    jgf2sgf: function(jgf) {\n      return Jgf2Sgf.parse(jgf);\n    }\n  };\n\n  //Return object\n  return KifuParser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Directive', [\n  'ngGo.Board.Directive'\n])\n\n/**\n * Directive definition\n */\n.directive('player', ['Player', function(Player) {\n  return {\n    restrict: 'E',\n\n    /**\n     * Controller\n     */\n    controller: ['$scope', function($scope) {\n\n      //Set player in scope\n      if (!$scope.Player) {\n        $scope.Player = Player;\n      }\n    }],\n\n    /**\n     * Linking function\n     */\n    link: function(scope, element, attrs) {\n\n      //Link the element\n      Player.linkElement(element);\n\n      //Observe mode and tool attributes\n      attrs.$observe('mode', function(mode) {\n        Player.switchMode(mode);\n      });\n      attrs.$observe('tool', function(tool) {\n        Player.switchTool(tool);\n      });\n\n      //Observe other settings attributes\n      attrs.$observe('variationMarkup', function(attr) {\n        Player.setVariationMarkup(attr === 'true');\n      });\n      attrs.$observe('solutionPaths', function(attr) {\n        Player.toggleSolutionPaths(attr === 'true');\n      });\n      attrs.$observe('lastMoveMarker', function(attr) {\n        Player.setLastMoveMarker(attr);\n      });\n    }\n  };\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Player :: This class brings the board to life and allows a user to interact with it. It\n * handles user input, controls objects going to the board, can load game records, and allows the\n * user to manipulate the board according to the current player mode.\n * Unless you want to display static positions, this is the class you'd use by default.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Service', [\n  'ngGo',\n  'ngGo.Player.Directive',\n  'ngGo.Player.Mode.Common.Service',\n  'ngGo.Board.Service',\n  'ngGo.Game.Service',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Provider definition\n */\n.provider('Player', ['PlayerModes', 'PlayerTools', 'MarkupTypes', function(PlayerModes, PlayerTools, MarkupTypes) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Default mode/tool\n    mode: PlayerModes.REPLAY,\n    tool: PlayerTools.MOVE,\n\n    //Keys/scrollwheel navigation\n    arrow_keys_navigation: true,\n    scroll_wheel_navigation: true,\n\n    //Last move marker, leave empty for none\n    last_move_marker: MarkupTypes.LAST,\n\n    //Indicate variations with markup on the board, and show\n    //successor node variations or current node variations\n    variation_markup: true,\n    variation_children: true,\n    variation_siblings: false\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$rootScope', '$document', 'Game', 'GameScorer', 'Board', 'PlayerTools', function($rootScope, $document, Game, GameScorer, Board, PlayerTools) {\n\n    /**\n     * Helper to append board grid coordinatess to the broadcast event object\n     */\n    var processMouseEvent = function(broadcastEvent, mouseEvent) {\n\n      //Can only do this with a board and mouse event\n      if (!this.board || !mouseEvent) {\n        broadcastEvent.x = -1;\n        broadcastEvent.y = -1;\n        return;\n      }\n\n      //Init\n      var x = 0;\n      var y = 0;\n\n      //Set x\n      if (typeof mouseEvent.offsetX !== 'undefined') {\n        x = mouseEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.offsetX;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerX !== 'undefined'\n      ) {\n        x = mouseEvent.originalEvent.layerX;\n      }\n\n      //Set y\n      if (typeof mouseEvent.offsetY !== 'undefined') {\n        y = mouseEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.offsetY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.offsetY;\n      }\n      else if (\n        mouseEvent.originalEvent && typeof mouseEvent.originalEvent.layerY !== 'undefined'\n      ) {\n        y = mouseEvent.originalEvent.layerY;\n      }\n\n      //Apply pixel ratio factor\n      x *= (window.devicePixelRatio || 1);\n      y *= (window.devicePixelRatio || 1);\n\n      //Append coords\n      broadcastEvent.x = this.board.getGridX(x);\n      broadcastEvent.y = this.board.getGridY(y);\n\n      //Did we drag?\n      if (mouseEvent.drag) {\n        broadcastEvent.drag = mouseEvent.drag;\n      }\n    };\n\n    /**\n     * Player class\n     */\n    var Player = {\n\n      //Player configuration\n      config: {},\n\n      //Board and game instances\n      board: null,\n      game: null,\n\n      //Available modes and tools\n      modes: {},\n      tools: [],\n\n      //Player mode and active tool\n      mode: '',\n      tool: '',\n\n      //Current path\n      path: null,\n\n      /**\n       * Initialization\n       */\n      init: function() {\n\n        //Unlink board instance, create new game\n        this.board = null;\n        this.game = new Game();\n\n        //Reset path\n        this.path = null;\n\n        //Player mode and active tool\n        this.mode = '';\n        this.tool = '';\n\n        //Arrow keys / scroll wheel navigation\n        this.arrowKeysNavigation = false;\n        this.scrollWheelNavigation = false;\n\n        //Last move marker\n        this.lastMoveMarker = '';\n\n        //Variation markup\n        this.variationMarkup = false;\n        this.variationChildren = false;\n        this.variationSiblings = false;\n\n        //Restricted nodes\n        this.restrictNodeStart = null;\n        this.restrictNodeEnd = null;\n\n        //Parse config\n        this.parseConfig();\n      },\n\n      /**\n       * Link the player to a HTML element\n       */\n      linkElement: function(element) {\n\n        //Set element\n        this.element = element;\n\n        //Register document event\n        this.registerElementEvent('keydown', $document);\n\n        //Register element events\n        this.registerElementEvent('click');\n        this.registerElementEvent('mousedown');\n        this.registerElementEvent('mouseup');\n        this.registerElementEvent('mousemove');\n        this.registerElementEvent('mouseout');\n        this.registerElementEvent('mousewheel');\n        this.registerElementEvent('wheel');\n      },\n\n      /*****************************************************************************\n       * Configuration\n       ***/\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, defaultConfig, config || {});\n\n        //Process settings\n        this.switchMode(this.config.mode);\n        this.switchTool(this.config.tool);\n        this.setArrowKeysNavigation(this.config.arrow_keys_navigation);\n        this.setScrollWheelNavigation(this.config.scroll_wheel_navigation);\n        this.setLastMoveMarker(this.config.last_move_marker);\n        this.setVariationMarkup(\n          this.config.variation_markup,\n          this.config.variation_children,\n          this.config.variation_siblings\n        );\n\n        //Let the modes parse their config\n        for (var mode in this.modes) {\n          if (this.modes[mode].parseConfig) {\n            this.modes[mode].parseConfig.call(this, this.config);\n          }\n        }\n      },\n\n      /**\n       * Set arrow keys navigation\n       */\n      setArrowKeysNavigation: function(arrowKeys) {\n        if (arrowKeys !== this.arrowKeysNavigation) {\n          this.arrowKeysNavigation = arrowKeys;\n          this.broadcast('settingChange', 'arrowKeysNavigation');\n        }\n      },\n\n      /**\n       * Set scroll wheel navigation\n       */\n      setScrollWheelNavigation: function(scrollWheel) {\n        if (scrollWheel !== this.scrollWheelNavigation) {\n          this.scrollWheelNavigation = scrollWheel;\n          this.broadcast('settingChange', 'scrollWheelNavigation');\n        }\n      },\n\n      /**\n       * Set the last move marker\n       */\n      setLastMoveMarker: function(lastMoveMarker) {\n        if (lastMoveMarker !== this.lastMoveMarker) {\n          this.lastMoveMarker = lastMoveMarker;\n          this.broadcast('settingChange', 'lastMoveMarker');\n        }\n      },\n\n      /**\n       * Set variation markup on the board\n       */\n      setVariationMarkup: function(variationMarkup, variationChildren, variationSiblings) {\n\n        //One change event for these three settings\n        var change = false;\n\n        //Markup setting change?\n        if (variationMarkup !== this.variationMarkup) {\n          this.variationMarkup = variationMarkup;\n          change = true;\n        }\n\n        //Children setting change?\n        if (\n          typeof variationChildren !== 'undefined' && variationChildren !== this.variationChildren\n        ) {\n          this.variationChildren = variationChildren;\n          change = true;\n        }\n\n        //Siblings setting change?\n        if (\n          typeof variationSiblings !== 'undefined' && variationSiblings !== this.variationSiblings\n        ) {\n          this.variationSiblings = variationSiblings;\n          change = true;\n        }\n\n        //Did anything change?\n        if (change) {\n          this.broadcast('settingChange', 'variationMarkup');\n        }\n      },\n\n      /*****************************************************************************\n       * Mode and tool handling\n       ***/\n\n      /**\n       * Register a player mode\n       */\n      registerMode: function(mode, PlayerMode) {\n\n        //Register the mode and let it parse the configuration\n        this.modes[mode] = PlayerMode;\n\n        //Parse config if we have a handler\n        if (this.modes[mode].parseConfig) {\n          this.modes[mode].parseConfig.call(this, this.config);\n        }\n\n        //Force switch the mode now, if it matches the initial mode\n        if (this.mode === mode) {\n          this.switchMode(this.mode, true);\n          this.switchTool(this.tool, true);\n        }\n      },\n\n      /**\n       * Set available tools\n       */\n      setTools: function(tools) {\n        this.tools = tools || [PlayerTools.NONE];\n      },\n\n      /**\n       * Check if we have a player mode\n       */\n      hasMode: function(mode) {\n        return this.modes[mode] ? true : false;\n      },\n\n      /**\n       * Check if we have a player tool\n       */\n      hasTool: function(tool) {\n        return (this.tools.indexOf(tool) !== -1);\n      },\n\n      /**\n       * Switch player mode\n       */\n      switchMode: function(mode, force) {\n\n        //No change?\n        if (!force && (!mode || this.mode === mode)) {\n          return false;\n        }\n\n        //Broadcast mode exit\n        if (this.mode) {\n          this.broadcast('modeExit', this.mode);\n        }\n\n        //Set mode, reset tools and active tool\n        this.mode = mode;\n        this.tools = [];\n        this.tool = PlayerTools.NONE;\n\n        //Broadcast mode entry\n        this.broadcast('modeEnter', this.mode);\n        return true;\n      },\n\n      /**\n       * Switch player tool\n       */\n      switchTool: function(tool, force) {\n\n        //No change?\n        if (!force && (!tool || this.tool === tool)) {\n          return false;\n        }\n\n        //Validate tool switch (only when there is a mode)\n        if (this.mode && this.modes[this.mode] && this.tools.indexOf(tool) === -1) {\n          return false;\n        }\n\n        //Change tool\n        this.tool = tool;\n        this.broadcast('toolSwitch', this.tool);\n        return true;\n      },\n\n      /**\n       * Save the full player state\n       */\n      saveState: function() {\n\n        //Save player state\n        this.playerState = {\n          mode: this.mode,\n          tool: this.tool,\n          restrictNodeStart: this.restrictNodeStart,\n          restrictNodeEnd: this.restrictNodeEnd\n        };\n\n        //Save game state\n        this.saveGameState();\n      },\n\n      /**\n       * Restore to the saved player state\n       */\n      restoreState: function() {\n\n        //Must have player state\n        if (!this.playerState) {\n          return;\n        }\n\n        //Restore\n        this.switchMode(this.playerState.mode);\n        this.switchTool(this.playerState.tool);\n        this.restrictNodeStart = this.playerState.restrictNodeStart;\n        this.restrictNodeEnd = this.playerState.restrictNodeEnd;\n\n        //Restore game state\n        this.restoreGameState();\n      },\n\n      /*****************************************************************************\n       * Game record handling\n       ***/\n\n      /**\n       * Load game record\n       */\n      load: function(data, allowPlayerConfig) {\n\n        //Try to load the game record data\n        try {\n          this.game.load(data);\n        }\n        catch (error) {\n          throw error;\n        }\n\n        //Reset path\n        this.path = null;\n\n        //Parse configuration from JGF if allowed\n        if (allowPlayerConfig || typeof allowPlayerConfig === 'undefined') {\n          this.parseConfig(this.game.get('settings'));\n        }\n\n        //Dispatch game loaded event\n        this.broadcast('gameLoaded', this.game);\n\n        //Board present?\n        if (this.board) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n\n        //Loaded ok\n        return true;\n      },\n\n      /**\n       * Reload the existing game record\n       */\n      reload: function() {\n\n        //Must have game\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reload game\n        this.game.reload();\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Save the current state\n       */\n      saveGameState: function() {\n        if (this.game && this.game.isLoaded()) {\n          this.gameState = this.game.getState();\n        }\n      },\n\n      /**\n       * Restore to the saved state\n       */\n      restoreGameState: function() {\n\n        //Must have game and saved state\n        if (!this.game || !this.gameState) {\n          return;\n        }\n\n        //Restore state\n        this.game.restoreState(this.gameState);\n\n        //Update board\n        if (this.board) {\n          this.board.removeAll();\n          this.processPosition();\n        }\n      },\n\n      /*****************************************************************************\n       * Navigation\n       ***/\n\n      /**\n       * Go to the next position\n       */\n      next: function(i) {\n        if (this.game && this.game.node !== this.restrictNodeEnd) {\n          this.game.next(i);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go back to the previous position\n       */\n      previous: function() {\n        if (this.game && this.game.node !== this.restrictNodeStart) {\n          this.game.previous();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the last position\n       */\n      last: function() {\n        if (this.game) {\n          this.game.last();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the first position\n       */\n      first: function() {\n        if (this.game) {\n          this.game.first();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to a specific move number, tree path or named node\n       */\n      goto: function(target) {\n        if (this.game && target) {\n          this.game.goto(target);\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the previous fork\n       */\n      previousFork: function() {\n        if (this.game) {\n          this.game.previousFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Go to the next fork\n       */\n      nextFork: function() {\n        if (this.game) {\n          this.game.nextFork();\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Restrict navigation to the current node\n       */\n      restrictNode: function(end) {\n\n        //Must have game and node\n        if (!this.game || !this.game.node) {\n          return;\n        }\n\n        //Restrict to current node\n        if (end) {\n          this.restrictNodeEnd = this.game.node;\n        }\n        else {\n          this.restrictNodeStart = this.game.node;\n        }\n      },\n\n      /**\n       * Process a new game position\n       */\n      processPosition: function() {\n\n        //No game?\n        if (!this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Get current node and game position\n        var node = this.game.getNode();\n        var path = this.game.getPath();\n        var position = this.game.getPosition();\n        var pathChanged = !path.compare(this.path);\n\n        //Update board\n        this.updateBoard(node, position, pathChanged);\n\n        //Path change?\n        if (pathChanged) {\n\n          //Copy new path and broadcast path change\n          this.path = path.clone();\n          this.broadcast('pathChange', node);\n\n          //Named node reached? Broadcast event\n          if (node.name) {\n            this.broadcast('reachedNode.' + node.name, node);\n          }\n        }\n\n        //Passed?\n        if (node.move && node.move.pass) {\n          this.broadcast('movePassed', node);\n        }\n      },\n\n      /*****************************************************************************\n       * Game handling\n       ***/\n\n      /**\n       * Start a new game\n       */\n      newGame: function() {\n        this.game = new Game();\n        this.processPosition();\n      },\n\n      /**\n       * Score the current game position\n       */\n      scoreGame: function() {\n\n        //Calculate score\n        GameScorer.calculate();\n\n        //Get score, points and captures\n        var score = GameScorer.getScore();\n        var points = GameScorer.getPoints();\n        var captures = GameScorer.getCaptures();\n\n        //Remove all markup, and set captures and points\n        this.board.layers.markup.removeAll();\n        this.board.layers.score.setAll(points, captures);\n\n        //Broadcast score\n        this.broadcast('scoreCalculated', score);\n      },\n\n      /*****************************************************************************\n       * Board handling\n       ***/\n\n      /**\n       * Get the board\n       */\n      getBoard: function() {\n        return this.board;\n      },\n\n      /**\n       * Set the board\n       */\n      setBoard: function(Board) {\n\n        //Set the board\n        this.board = Board;\n\n        //Board ready\n        if (this.board) {\n          this.broadcast('boardReady', this.board);\n        }\n\n        //If a game has been loaded already, parse config and update the board\n        if (this.game && this.game.isLoaded()) {\n          this.board.removeAll();\n          this.board.parseConfig(this.game.get('board'));\n          this.processPosition();\n        }\n      },\n\n      /**\n       * Update the board\n       */\n      updateBoard: function(node, position, pathChanged) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Update board with new position\n        this.board.updatePosition(position, pathChanged);\n\n        //Mark last move\n        if (this.lastMoveMarker && node.move && !node.move.pass) {\n          this.board.add('markup', node.move.x, node.move.y, this.lastMoveMarker);\n        }\n\n        //Broadcast board update event\n        this.broadcast('boardUpdate', node);\n      },\n\n      /*****************************************************************************\n       * Event handling\n       ***/\n\n      /**\n       * Register an element event\n       */\n      registerElementEvent: function(event, element) {\n\n        //Which element to use\n        if (typeof element === 'undefined' || !element.on) {\n          element = this.element;\n        }\n\n        //Remove any existing event listener and apply new one\n        //TODO: Namespacing events doesn't work with Angular's jqLite\n        element.off(event/* + '.ngGo.player'*/);\n        element.on(event/* + '.ngGo.player'*/, this.broadcast.bind(this, event));\n      },\n\n      /**\n       * Event listener\n       */\n      on: function(type, listener, mode, $scope) {\n\n        //Must have valid listener\n        if (typeof listener !== 'function') {\n          console.warn('Listener is not a function:', listener);\n          return;\n        }\n\n        //Scope given as 3rd parameter?\n        if (mode && mode.$parent) {\n          $scope = mode;\n          mode = '';\n        }\n\n        //Multiple events?\n        if (type.indexOf(' ') !== -1) {\n          var types = type.split(' ');\n          for (var t = 0; t < types.length; t++) {\n            this.on(types[t], listener, mode, $scope);\n          }\n          return;\n        }\n\n        //Get self and determine scope to use\n        var self = this;\n        var scope = $scope || $rootScope;\n\n        //Create listener and return de-registration function\n        return scope.$on('ngGo.player.' + type, function() {\n\n          //Filter on mode\n          if (mode) {\n            if (\n              (typeof mode === 'string' && mode !== self.mode) ||\n              mode.indexOf(self.mode) === -1\n            ) {\n              return;\n            }\n          }\n\n          //Inside a text field?\n          if (type === 'keydown' && $document[0].querySelector(':focus')) {\n            return;\n          }\n\n          //Append grid coordinates for mouse events\n          if (type === 'click' || type === 'hover' || type.substr(0, 5) === 'mouse') {\n            processMouseEvent.call(self, arguments[0], arguments[1]);\n          }\n\n          //Dragging? Prevent click events from firing\n          if (self.preventClickEvent && type === 'click') {\n            delete self.preventClickEvent;\n            return;\n          }\n          else if (type === 'mousedrag') {\n            self.preventClickEvent = true;\n          }\n\n          //Call listener\n          listener.apply(self, arguments);\n        });\n      },\n\n      /**\n       * Event broadcaster\n       */\n      broadcast: function(type, args) {\n\n        //Must have type\n        if (!type) {\n          return;\n        }\n\n        //Make sure we are in a digest cycle\n        if (!$rootScope.$$phase) {\n          $rootScope.$apply(function() {\n            $rootScope.$broadcast('ngGo.player.' + type, args);\n          });\n        }\n        else {\n          $rootScope.$broadcast('ngGo.player.' + type, args);\n        }\n      }\n    };\n\n    //Initialize\n    Player.init();\n\n    //Return object\n    return Player;\n  }];\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * GridLayer :: This class represents the grid layer of the board, and it is responsible for drawing\n * gridlines, starpoints and coordinates via the Coordinates class.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.GridLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Coordinates.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('GridLayer', ['BoardLayer', 'Coordinates', function(BoardLayer, Coordinates) {\n\n  /**\n   * Helper for drawing starpoints\n   */\n  var drawStarPoint = function(gridX, gridY, starRadius, starColor) {\n\n    //Don't draw if it falls outsize of the board grid\n    if (gridX < this.board.grid.xLeft || gridX > this.board.grid.xRight) {\n      return;\n    }\n    if (gridY < this.board.grid.yTop || gridY > this.board.grid.yBot) {\n      return;\n    }\n\n    //Get absolute coordinates and star point radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n\n    //Draw star point\n    this.context.beginPath();\n    this.context.fillStyle = starColor;\n    this.context.arc(x, y, starRadius, 0, 2 * Math.PI, true);\n    this.context.fill();\n  };\n\n  /**\n   * Constructor\n   */\n  var GridLayer = function(board, context) {\n\n    //Set coordinates setting\n    this.coordinates = false;\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(GridLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Show or hide the coordinates.\n   */\n  GridLayer.prototype.setCoordinates = function(show) {\n    this.coordinates = show;\n  };\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Get all has nothing to return\n   */\n  GridLayer.prototype.getAll = function() {\n    return null;\n  };\n\n  /**\n   * Set all has nothing to set\n   */\n  GridLayer.prototype.setAll = function(/*grid*/) {\n    return;\n  };\n\n  /**\n   * Remove all has nothing to remove\n   */\n  GridLayer.prototype.removeAll = function() {\n    return;\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw method\n   */\n  GridLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Determine top x and y margin\n    var tx = this.board.drawMarginHor;\n    var ty = this.board.drawMarginVer;\n\n    //Get theme properties\n    var cellSize = this.board.getCellSize();\n    var lineWidth = this.board.theme.get('grid.lineWidth', cellSize);\n    var lineCap = this.board.theme.get('grid.lineCap');\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', cellSize);\n    var starColor = this.board.theme.get('grid.star.color');\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n    this.context.strokeStyle = strokeStyle;\n\n    //Helper vars\n    var i, x, y;\n\n    //Draw vertical lines\n    for (i = this.board.grid.xLeft; i <= this.board.grid.xRight; i++) {\n      x = this.board.getAbsX(i);\n      this.context.moveTo(x, ty);\n      this.context.lineTo(x, ty + this.board.gridDrawHeight);\n    }\n\n    //Draw horizontal lines\n    for (i = this.board.grid.yTop; i <= this.board.grid.yBot; i++) {\n      y = this.board.getAbsY(i);\n      this.context.moveTo(tx, y);\n      this.context.lineTo(tx + this.board.gridDrawWidth, y);\n    }\n\n    //Draw grid lines\n    this.context.stroke();\n\n    //Star points defined?\n    for (i = 0; i < starPoints.length; i++) {\n      drawStarPoint.call(this, starPoints[i].x, starPoints[i].y, starRadius, starColor);\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n\n    //Draw coordinates\n    if (this.coordinates) {\n      Coordinates.draw.call(this);\n    }\n  };\n\n  /**\n   * Clear a square cell area on the grid\n   */\n  GridLayer.prototype.clearCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Clear rectangle\n    this.context.clearRect(x - r, y - r, 2 * r, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Redraw a square cell area on the grid\n   */\n  GridLayer.prototype.redrawCell = function(gridX, gridY) {\n\n    //Get absolute coordinates and stone radius\n    var x = this.board.getAbsX(gridX);\n    var y = this.board.getAbsY(gridY);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('grid.lineWidth', s);\n    var strokeStyle = this.board.theme.get('grid.lineColor');\n    var starRadius = this.board.theme.get('grid.star.radius', s);\n    var starColor = this.board.theme.get('grid.star.color');\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n    var starPoints = this.board.theme.get('grid.star.points', this.board.width, this.board.height);\n\n    //Determine draw coordinates\n    var x1 = (gridX === 0) ? x : x - r;\n    var x2 = (gridX === this.board.width - 1) ? x : x + r;\n    var y1 = (gridY === 0) ? y : y - r;\n    var y2 = (gridY === this.board.height - 1) ? y : y + r;\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.beginPath();\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Patch up grid lines\n    this.context.moveTo(x1, y);\n    this.context.lineTo(x2, y);\n    this.context.moveTo(x, y1);\n    this.context.lineTo(x, y2);\n    this.context.stroke();\n\n    //Check if we need to draw a star point here\n    for (var i in starPoints) {\n      if (starPoints[i].x === gridX && starPoints[i].y === gridY) {\n        drawStarPoint.call(this, gridX, gridY, starRadius, starColor);\n      }\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  //Return\n  return GridLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.HoverLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('HoverLayer', ['BoardLayer', 'Markup', 'StoneFaded', function(BoardLayer, Markup, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var HoverLayer = function(board, context) {\n\n    //Container for items to restore\n    this.restore = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(HoverLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add hover item\n   */\n  HoverLayer.prototype.add = function(x, y, hover) {\n\n    //Validate coordinates\n    if (!this.grid.isOnGrid(x, y)) {\n      return;\n    }\n\n    //Remove any previous item at this position\n    this.remove(x, y);\n\n    //Create hover object\n    hover.object = {\n      x: x,\n      y: y\n    };\n\n    //Stones\n    if (hover.type === 'stones') {\n      hover.objectClass = StoneFaded;\n      hover.object.color = hover.value;\n    }\n\n    //Markup\n    else if (hover.type === 'markup') {\n      hover.objectClass = Markup;\n      if (typeof hover.value === 'object') {\n        hover.object = angular.extend(hover.object, hover.value);\n      }\n      else {\n        hover.object.type = hover.value;\n      }\n    }\n\n    //Unknown\n    else {\n      console.warn('Unknown hover type', hover.type);\n      return;\n    }\n\n    //Check if we need to hide something on layers underneath\n    if (this.board.has(hover.type, x, y)) {\n      this.restore.push({\n        x: x,\n        y: y,\n        layer: hover.type,\n        value: this.board.get(hover.type, x, y)\n      });\n      this.board.remove(hover.type, x, y);\n    }\n\n    //Add to stack\n    this.grid.set(x, y, hover);\n\n    //Draw item\n    if (hover.objectClass && hover.objectClass.draw) {\n      hover.objectClass.draw.call(this, hover.object);\n    }\n  };\n\n  /**\n   * Remove the hover object\n   */\n  HoverLayer.prototype.remove = function(x, y) {\n\n    //Validate coordinates\n    if (!this.grid.has(x, y)) {\n      return;\n    }\n\n    //Get object and clear it\n    var hover = this.grid.get(x, y);\n    if (hover.objectClass && hover.objectClass.clear) {\n      hover.objectClass.clear.call(this, hover.object);\n    }\n\n    //Other objects to restore?\n    for (var i = 0; i < this.restore.length; i++) {\n      if (this.restore[i].x === x && this.restore[i].y === y) {\n        this.board.add(\n          this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n        );\n        this.restore.splice(i, 1);\n      }\n    }\n  };\n\n  /**\n   * Remove all hover objects\n   */\n  HoverLayer.prototype.removeAll = function() {\n\n    //Anything to do?\n    if (this.grid.isEmpty()) {\n      return;\n    }\n\n    //Get all item as objects\n    var i;\n    var hover = this.grid.all('layer');\n\n    //Clear them\n    for (i = 0; i < hover.length; i++) {\n      if (hover[i].objectClass && hover[i].objectClass.clear) {\n        hover[i].objectClass.clear.call(this, hover[i].object);\n      }\n    }\n\n    //Clear layer and empty grid\n    this.clear();\n    this.grid.empty();\n\n    //Restore objects on other layers\n    for (i = 0; i < this.restore.length; i++) {\n      this.board.add(\n        this.restore[i].layer, this.restore[i].x, this.restore[i].y, this.restore[i].value\n      );\n    }\n\n    //Clear restore array\n    this.restore = [];\n  };\n\n  /**\n   * Draw layer\n   */\n  HoverLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Loop objects and clear them\n    var hover = this.grid.all('hover');\n    for (var i = 0; i < hover.length; i++) {\n      if (hover.objectClass && hover.objectClass.draw) {\n        hover.objectClass.draw.call(this, hover.object);\n      }\n    }\n  };\n\n  //Return\n  return HoverLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.MarkupLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Markup.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('MarkupLayer', ['BoardLayer', 'Markup', function(BoardLayer, Markup) {\n\n  /**\n   * Constructor\n   */\n  var MarkupLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(MarkupLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all markup at once\n   */\n  MarkupLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'type');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Markup.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Markup.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /**\n   * Remove all (clear layer and empty grid)\n   */\n  MarkupLayer.prototype.removeAll = function() {\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Clear them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.clear.call(this, markup[i]);\n    }\n\n    //Empty the grid now\n    this.grid.empty();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  MarkupLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all markup as objects\n    var markup = this.grid.all('type');\n\n    //Draw them\n    for (var i = 0; i < markup.length; i++) {\n      Markup.draw.call(this, markup[i]);\n    }\n  };\n\n  /**\n   * Draw cell\n   */\n  MarkupLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Markup.draw.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  MarkupLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Markup.clear.call(this, this.grid.get(x, y, 'type'));\n    }\n  };\n\n  //Return\n  return MarkupLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ScoreLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneMini.Service',\n  'ngGo.Board.Object.StoneFaded.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ScoreLayer', ['BoardLayer', 'StoneMini', 'StoneFaded', function(BoardLayer, StoneMini, StoneFaded) {\n\n  /**\n   * Constructor\n   */\n  var ScoreLayer = function(board, context) {\n\n    //Points and captures\n    this.points = [];\n    this.captures = [];\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ScoreLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set points and captures\n   */\n  ScoreLayer.prototype.setAll = function(points, captures) {\n\n    //Remove all existing stuff first\n    this.removeAll();\n\n    //Set new stuff\n    this.points = points.all('color');\n    this.captures = captures.all('color');\n\n    //Draw\n    this.draw();\n  };\n\n  /**\n   * Remove all scoring\n   */\n  ScoreLayer.prototype.removeAll = function() {\n\n    //If there are captures, draw them back onto the stones layer\n    for (var i = 0; i < this.captures.length; i++) {\n      this.board.add('stones', this.captures[i].x, this.captures[i].y, this.captures[i].color);\n    }\n\n    //Clear the layer\n    this.clear();\n\n    //Remove all stuff\n    this.points = [];\n    this.captures = [];\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  ScoreLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Init\n    var i;\n\n    //Draw captures first (removing stones from the stones layer)\n    for (i = 0; i < this.captures.length; i++) {\n      this.board.remove('stones', this.captures[i].x, this.captures[i].y);\n      StoneFaded.draw.call(this, this.captures[i]);\n    }\n\n    //Draw points on top of it\n    for (i = 0; i < this.points.length; i++) {\n      StoneMini.draw.call(this, this.points[i]);\n    }\n  };\n\n  //Return\n  return ScoreLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.ShadowLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.StoneShadow.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('ShadowLayer', ['BoardLayer', 'StoneShadow', function(BoardLayer, StoneShadow) {\n\n  /**\n   * Constructor\n   */\n  var ShadowLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(ShadowLayer.prototype, BoardLayer.prototype);\n\n  /**\n   * Add a stone\n   */\n  ShadowLayer.prototype.add = function(stone) {\n\n    //Don't add if no shadow\n    if (stone.shadow === false || (typeof stone.alpha !== 'undefined' && stone.alpha < 1)) {\n      return;\n    }\n\n    //Already have a stone here?\n    if (this.grid.has(stone.x, stone.y)) {\n      return;\n    }\n\n    //Add to grid\n    this.grid.set(stone.x, stone.y, stone.color);\n\n    //Draw it if there is a context\n    if (this.context && this.board.drawWidth !== 0 && this.board.drawheight !== 0) {\n      StoneShadow.draw.call(this, stone);\n    }\n  };\n\n  /**\n   * Remove a stone\n   */\n  ShadowLayer.prototype.remove = function(stone) {\n\n    //Remove from grid\n    this.grid.unset(stone.x, stone.y);\n\n    //Redraw whole layer\n    this.redraw();\n  };\n\n  /**\n   * Draw layer\n   */\n  ShadowLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get shadowsize from theme\n    var shadowSize = this.board.theme.get('shadow.size', this.board.getCellSize());\n\n    //Apply shadow transformation\n    this.context.setTransform(1, 0, 0, 1, shadowSize, shadowSize);\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      StoneShadow.draw.call(this, stones[i]);\n    }\n  };\n\n  //Return\n  return ShadowLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Layer.StonesLayer.Service', [\n  'ngGo',\n  'ngGo.Board.Layer.Service',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StonesLayer', ['BoardLayer', 'Stone', 'StoneColor', function(BoardLayer, Stone, StoneColor) {\n\n  /**\n   * Constructor\n   */\n  var StonesLayer = function(board, context) {\n\n    //Call parent constructor\n    BoardLayer.call(this, board, context);\n\n    //Set empty value for grid\n    this.grid.whenEmpty(StoneColor.EMPTY);\n  };\n\n  /**\n   * Prototype extension\n   */\n  angular.extend(StonesLayer.prototype, BoardLayer.prototype);\n\n  /*****************************************************************************\n   * Object handling\n   ***/\n\n  /**\n   * Set all stones at once\n   */\n  StonesLayer.prototype.setAll = function(grid) {\n\n    //Get changes compared to current grid\n    var i;\n    var changes = this.grid.compare(grid, 'color');\n\n    //Clear removed stuff\n    for (i = 0; i < changes.remove.length; i++) {\n      Stone.clear.call(this, changes.remove[i]);\n    }\n\n    //Draw added stuff\n    for (i = 0; i < changes.add.length; i++) {\n      Stone.draw.call(this, changes.add[i]);\n    }\n\n    //Remember new grid\n    this.grid = grid.clone();\n  };\n\n  /*****************************************************************************\n   * Drawing\n   ***/\n\n  /**\n   * Draw layer\n   */\n  StonesLayer.prototype.draw = function() {\n\n    //Can only draw when we have dimensions and context\n    if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //Get all stones as objects\n    var stones = this.grid.all('color');\n\n    //Draw them\n    for (var i = 0; i < stones.length; i++) {\n      Stone.draw.call(this, stones[i]);\n    }\n  };\n\n  /**\n   * Redraw layer\n   */\n  StonesLayer.prototype.redraw = function() {\n\n    //Clear shadows layer\n    this.board.removeAll('shadow');\n\n    //Redraw ourselves\n    this.clear();\n    this.draw();\n  };\n\n  /**\n   * Draw cell\n   */\n  StonesLayer.prototype.drawCell = function(x, y) {\n\n    //Can only draw when we have dimensions\n    if (this.board.drawWidth === 0 || this.board.drawheight === 0) {\n      return;\n    }\n\n    //On grid?\n    if (this.grid.has(x, y)) {\n      Stone.draw.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  /**\n   * Clear cell\n   */\n  StonesLayer.prototype.clearCell = function(x, y) {\n    if (this.grid.has(x, y)) {\n      Stone.clear.call(this, this.grid.get(x, y, 'color'));\n    }\n  };\n\n  //Return\n  return StonesLayer;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Coordinates :: This class is used for drawing board coordinates\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Coordinates.Service', [\n  'ngGo'\n])\n\n/**\n * Factory definition\n */\n.factory('Coordinates', function() {\n\n  //Kanji\n  var kanji = [\n    '一', '二', '三', '四', '五', '六', '七', '八', '九', '十',\n    '十一', '十二', '十三', '十四', '十五', '十六', '十七', '十八', '十九', '二十',\n    '二十一', '二十二', '二十三', '二十四', '二十五', '二十六', '二十七', '二十八', '二十九', '三十',\n    '三十一', '三十二', '三十三', '三十四', '三十五', '三十六', '三十七', '三十八', '三十九', '四十'\n  ];\n\n  //Character codes\n  var aChar = 'A'.charCodeAt(0);\n  var aCharLc = 'a'.charCodeAt(0);\n\n  /**\n   * Coordinate generators\n   */\n  var coordinates = {\n\n    //Kanji coordinates\n    kanji: function(i) {\n      return kanji[i] || '';\n    },\n\n    //Numbers from 1\n    numbers: function(i) {\n      return i + 1;\n    },\n\n    //Capital letters from A\n    letters: function(i) {\n\n      //Initialize\n      var ch = '';\n\n      //Beyond Z? Prepend with A\n      if (i >= 25) {\n        ch = 'A';\n        i -= 25;\n      }\n\n      //The letter I is ommitted\n      if (i >= 8) {\n        i++;\n      }\n\n      //Return\n      return ch + String.fromCharCode(aChar + i);\n    },\n\n    //JGF coordinates (e.g. 0, 1, ...)\n    jgf: function(i) {\n      return i;\n    },\n\n    //SGF coordinates (e.g. a, b, ...)\n    sgf: function(i) {\n      var ch;\n      if (i < 26) {\n        ch = aCharLc + i;\n      }\n      else {\n        ch = aChar + i;\n      }\n      return String.fromCharCode(ch);\n    }\n  };\n\n  /**\n   * Coordinates object\n   */\n  var Coordinates = {\n\n    /**\n     * Draw\n     */\n    draw: function() {\n\n      //Can only draw when we have context and dimensions\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Get cell size\n      var cellSize = this.board.getCellSize();\n\n      //Get boundary coordinates\n      var xl = Math.ceil((this.board.drawMarginHor - cellSize / 2) / 2);\n      var xr = this.board.drawWidth - xl;\n      var yt = Math.ceil((this.board.drawMarginVer - cellSize / 2) / 2);\n      var yb = this.board.drawHeight - yt;\n\n      //Get theme properties\n      var fillStyle = this.board.theme.get('coordinates.color');\n      var vertical = {\n        font: this.board.theme.get('coordinates.vertical.font'),\n        size: this.board.theme.get('coordinates.vertical.size'),\n        style: this.board.theme.get('coordinates.vertical.style'),\n        inverse: this.board.theme.get('coordinates.vertical.inverse')\n      };\n      var horizontal = {\n        font: this.board.theme.get('coordinates.horizontal.font'),\n        size: this.board.theme.get('coordinates.horizontal.size'),\n        style: this.board.theme.get('coordinates.horizontal.style'),\n        inverse: this.board.theme.get('coordinates.horizontal.inverse')\n      };\n\n      //Configure context\n      this.context.fillStyle = fillStyle;\n      this.context.textBaseline = 'middle';\n      this.context.textAlign = 'center';\n\n      //Helper vars\n      var i, j, x, y, ch;\n\n      //Draw vertical coordinates\n      for (i = 0; i < this.board.height; i++) {\n\n        //Inverse?\n        j = i;\n        if (vertical.inverse) {\n          j = this.board.height - i - 1;\n        }\n\n        //Get character\n        if (typeof vertical.style === 'function') {\n          ch = vertical.style.call(this, j);\n        }\n        else if (coordinates[vertical.style]) {\n          ch = coordinates[vertical.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        y = this.board.getAbsY(i);\n        this.context.font = vertical.size(ch, cellSize) + ' ' + vertical.font;\n        this.context.fillText(ch, xl, y);\n        this.context.fillText(ch, xr, y);\n      }\n\n      //Draw horizontal coordinates\n      for (i = 0; i < this.board.width; i++) {\n\n        //Inverse?\n        j = i;\n        if (horizontal.inverse) {\n          j = this.board.width - i - 1;\n        }\n\n        //Get character\n        if (typeof horizontal.style === 'function') {\n          ch = horizontal.style.call(this, j);\n        }\n        else if (coordinates[horizontal.style]) {\n          ch = coordinates[horizontal.style].call(this, j);\n        }\n        else {\n          ch = j;\n        }\n\n        //Draw\n        x = this.board.getAbsX(i);\n        this.context.font = horizontal.size(ch, cellSize) + ' ' + horizontal.font;\n        this.context.fillText(ch, x, yt);\n        this.context.fillText(ch, x, yb);\n      }\n    }\n  };\n\n  //Return\n  return Coordinates;\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Markup :: This class is used for drawing markup\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Markup.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Markup', ['MarkupTypes', 'BoardObject', function(MarkupTypes, BoardObject) {\n\n  /**\n   * Math constants\n   */\n  var cosPi4 = Math.cos(Math.PI / 4);\n  var cosPi6 = Math.cos(Math.PI / 6);\n\n  /**\n   * Triangle draw handler\n   */\n  var drawTriangle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.triangle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y - r);\n    this.context.lineTo(x - Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.lineTo(x + Math.round(r * cosPi6), y + Math.round(r / 2));\n    this.context.closePath();\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Square draw handler\n   */\n  var drawSquare = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.square.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.rect(x - rcos, y - rcos, 2 * rcos, 2 * rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw circle handler\n   */\n  var drawCircle = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw mark handler\n   */\n  var drawMark = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.mark.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Determine cos\n    var rcos = Math.round(r * cosPi4);\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.mark.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(lineWidth);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x - rcos, y - rcos);\n    this.context.lineTo(x + rcos, y + rcos);\n    this.context.moveTo(x + rcos, y - rcos);\n    this.context.lineTo(x - rcos, y + rcos);\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw select handler\n   */\n  var drawSelect = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.circle.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.lineWidth = lineWidth;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x, y, r, 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Last move draw handler\n   */\n  var drawLast = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.last.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate(s);\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.moveTo(x, y);\n    this.context.lineTo(x + r, y);\n    this.context.lineTo(x, y + r);\n    this.context.closePath();\n    this.context.fill();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw happy smiley handler\n   */\n  var drawHappySmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 8);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 1.5, x + r / 1.8, y + r / 1.5, x + r / 1.6, y + r / 8\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw sad smiley handler\n   */\n  var drawSadSmiley = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = Math.round(\n      this.board.theme.get('stone.radius', s) * this.board.theme.get('markup.smiley.scale')\n    );\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = markup.lineWidth || this.board.theme.get('markup.lineWidth', s) || 1;\n    var lineCap = markup.lineCap || this.board.theme.get('markup.smiley.lineCap');\n    var strokeStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.strokeStyle = strokeStyle;\n    this.context.lineWidth = lineWidth;\n    this.context.lineCap = lineCap;\n\n    //Draw element\n    this.context.beginPath();\n    this.context.arc(x - r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.arc(x + r / 3, y - r / 3, r / 6, 0, 2 * Math.PI, true);\n    this.context.stroke();\n    this.context.beginPath();\n    this.context.moveTo(x - r / 1.6, y + r / 1.5 - 1);\n    this.context.bezierCurveTo(\n      x - r / 1.8, y + r / 8 - 1, x + r / 1.8, y + r / 8 - 1, x + r / 1.6, y + r / 1.5 - 1\n    );\n    this.context.stroke();\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Draw label\n   */\n  var drawLabel = function(markup) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(markup.x);\n    var y = this.board.getAbsY(markup.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (markup.scale) {\n      r = Math.round(r * markup.scale);\n    }\n\n    //Get stone color\n    var stoneColor = this.board.get('stones', markup.x, markup.y) * this.board.colorMultiplier;\n\n    //Get theme properties\n    var font = markup.font || this.board.theme.get('markup.label.font') || '';\n    var fillStyle = markup.color || this.board.theme.get('markup.color', stoneColor);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //First, clear grid square below for clarity\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.clearCell(markup.x, markup.y);\n    }\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n    this.context.textBaseline = 'middle';\n    this.context.textAlign = 'center';\n\n    //Convert to text\n    if (typeof markup.text === 'number') {\n      markup.text = markup.text.toString();\n    }\n\n    //Determine font size\n    if (markup.text.length === 1) {\n      this.context.font = Math.round(r * 1.5) + 'px ' + font;\n    }\n    else if (markup.text.length === 2) {\n      this.context.font = Math.round(r * 1.2) + 'px ' + font;\n    }\n    else {\n      this.context.font = r + 'px ' + font;\n    }\n\n    //Draw element\n    this.context.beginPath();\n    this.context.fillText(markup.text, x, y, 2 * r);\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Clear label\n   */\n  var clearLabel = function(markup) {\n\n    //No stone on location? Redraw the grid square, if we cleared it\n    if (!this.board.has('stones', markup.x, markup.y)) {\n      this.board.layers.grid.redrawCell(markup.x, markup.y);\n    }\n  };\n\n  /**\n   * Markup class\n   */\n  var Markup = {\n\n    /**\n     * Draw\n     */\n    draw: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Drawing depends on type\n      switch (markup.type) {\n\n        //Triangle\n        case MarkupTypes.TRIANGLE:\n          drawTriangle.call(this, markup);\n          break;\n\n        //Square\n        case MarkupTypes.SQUARE:\n          drawSquare.call(this, markup);\n          break;\n\n        //Circle\n        case MarkupTypes.CIRCLE:\n          drawCircle.call(this, markup);\n          break;\n\n        //Mark\n        case MarkupTypes.MARK:\n          drawMark.call(this, markup);\n          break;\n\n        //Select\n        case MarkupTypes.SELECT:\n          drawSelect.call(this, markup);\n          break;\n\n        //happy\n        case MarkupTypes.HAPPY:\n          drawHappySmiley.call(this, markup);\n          break;\n\n        //Sad\n        case MarkupTypes.SAD:\n          drawSadSmiley.call(this, markup);\n          break;\n\n        //Last move marker\n        case MarkupTypes.LAST:\n          drawLast.call(this, markup);\n          break;\n\n        //Label\n        case MarkupTypes.LABEL:\n          markup.text = markup.text || '';\n          drawLabel.call(this, markup);\n          break;\n      }\n    },\n\n    /**\n     * Clear\n     */\n    clear: function(markup) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, markup);\n\n      //Special handling for label\n      if (markup.type === MarkupTypes.LABEL) {\n        clearLabel.call(this, markup);\n      }\n    }\n  };\n\n  //Return\n  return Markup;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Stone :: This class is used for drawing stones on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.Stone.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service',\n  'ngGo.Board.ShellPattern.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Stone', ['$injector', 'BoardObject', 'StoneColor', 'ShellPattern', function($injector, BoardObject, StoneColor, ShellPattern) {\n\n  /**\n   * Shell random seed\n   */\n  var shellSeed;\n\n  /**\n   * Mono colored stones\n   */\n  var drawMono = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Don't draw shadow\n    stone.shadow = false;\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme properties\n    var lineWidth = this.board.theme.get('stone.mono.lineWidth', s) || 1;\n    var fillStyle = this.board.theme.get('stone.mono.color', color);\n    var strokeStyle = this.board.theme.get('stone.mono.lineColor', color);\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Configure context\n    this.context.fillStyle = fillStyle;\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - lineWidth), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Configure context\n    this.context.lineWidth = lineWidth;\n    this.context.strokeStyle = strokeStyle;\n\n    //Draw outline\n    this.context.stroke();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Glass stones\n   */\n  var drawGlass = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Begin path\n    this.context.beginPath();\n\n    //Determine stone texture\n    if (color === StoneColor.W) {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 3, x - r / 5, y - r / 5, 5 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#fff');\n      this.context.fillStyle.addColorStop(1, '#aaa');\n    }\n    else {\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 5, y - r / 5, 4 * r / 5\n      );\n      this.context.fillStyle.addColorStop(0, '#666');\n      this.context.fillStyle.addColorStop(1, '#111');\n    }\n\n    //Complete drawing\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fill();\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Slate and shell stones\n   */\n  var drawSlateShell = function(stone) {\n\n    //Get coordinates and stone radius\n    var x = this.board.getAbsX(stone.x);\n    var y = this.board.getAbsY(stone.y);\n    var s = this.board.getCellSize();\n    var r = this.board.theme.get('stone.radius', s);\n\n    //Apply scaling factor?\n    if (stone.scale) {\n      r = Math.round(r * stone.scale);\n    }\n\n    //Get random seed\n    shellSeed = shellSeed || Math.ceil(Math.random() * 9999999);\n\n    //Apply color multiplier\n    var color = stone.color * this.board.colorMultiplier;\n\n    //Get theme variables\n    var shellTypes = this.board.theme.get('stone.shell.types');\n    var fillStyle = this.board.theme.get('stone.shell.color', color);\n    var strokeStyle = this.board.theme.get('stone.shell.stroke');\n    var canvasTranslate = this.board.theme.canvasTranslate();\n\n    //Translate canvas\n    this.context.translate(canvasTranslate, canvasTranslate);\n\n    //Apply transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = stone.alpha;\n    }\n\n    //Draw stone\n    this.context.beginPath();\n    this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n    this.context.fillStyle = fillStyle;\n    this.context.fill();\n\n    //Shell stones\n    if (color === StoneColor.W) {\n\n      //Get random shell type\n      var type =\n        shellSeed % (shellTypes.length + stone.x * this.board.width + stone.y) % shellTypes.length;\n\n      //Determine random angle\n      var z = this.board.width * this.board.height + stone.x * this.board.width + stone.y;\n      var angle = (2 / z) * (shellSeed % z);\n\n      //Draw shell pattern\n      ShellPattern.call(shellTypes[type], this.context, x, y, r, angle, strokeStyle);\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, r / 6, x - r / 5, y - r / 5, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(255,255,255,0.9)');\n      this.context.fillStyle.addColorStop(1, 'rgba(255,255,255,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Slate stones\n    else {\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + 2 * r / 5, y + 2 * r / 5, 0, x + r / 2, y + r / 2, r\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(32,32,32,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n\n      //Add radial gradient\n      this.context.beginPath();\n      this.context.fillStyle = this.context.createRadialGradient(\n        x - 2 * r / 5, y - 2 * r / 5, 1, x - r / 2, y - r / 2, 3 * r / 2\n      );\n      this.context.fillStyle.addColorStop(0, 'rgba(64,64,64,1)');\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n      this.context.arc(x, y, Math.max(0, r - 0.5), 0, 2 * Math.PI, true);\n      this.context.fill();\n    }\n\n    //Undo transparency?\n    if (stone.alpha && stone.alpha < 1) {\n      this.context.globalAlpha = 1;\n    }\n\n    //Undo translation\n    this.context.translate(-canvasTranslate, -canvasTranslate);\n  };\n\n  /**\n   * Constructor\n   */\n  var Stone = {\n\n    /**\n     * Draw a stone\n     */\n    draw: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Determine style of stone\n      var style = this.board.theme.get('stone.style');\n\n      //Draw using the appropriate handler\n      switch (style) {\n\n        //Slate and shell\n        case 'shell':\n          drawSlateShell.call(this, stone);\n          break;\n\n        //Glass stones\n        case 'glass':\n          drawGlass.call(this, stone);\n          break;\n\n        //Mono stones\n        case 'mono':\n          drawMono.call(this, stone);\n          break;\n\n        //Custom type\n        default:\n          var handler = $injector.get(style);\n          if (handler) {\n            handler.call(this, stone);\n          }\n      }\n\n      //Add shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.add(stone);\n      }\n    },\n\n    /**\n     * Clear a stone\n     */\n    clear: function(stone) {\n\n      //Can only draw when we have dimensions and context\n      if (!this.context || this.board.drawWidth === 0 || this.board.drawheight === 0) {\n        return;\n      }\n\n      //Call parent method\n      BoardObject.clear.call(this, stone);\n\n      //Remove shadow\n      if (!this.board.static && stone.shadow !== false && this.board.theme.get('stone.shadow')) {\n        this.board.layers.shadow.remove(stone);\n      }\n    }\n  };\n\n  //Return\n  return Stone;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneFaded :: This class extends the Stone class and is used for drawing faded stones.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneFaded.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneFaded', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneFaded = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.faded.scale');\n      stone.alpha = this.board.theme.get('stone.faded.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneFaded;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneMini :: This class extends the Stone class and is used for drawing mini stones\n * (for scoring).\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneMini.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Stone.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneMini', ['Stone', function(Stone) {\n\n  /**\n   * Class\n   */\n  var StoneMini = {\n\n    /**\n     * Draw stone\n     */\n    draw: function(stone) {\n\n      //Set scale and alpha\n      stone.scale = this.board.theme.get('stone.mini.scale');\n      stone.alpha = this.board.theme.get('stone.mini.alpha', stone.color);\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Now call the regular stone draw handler\n      Stone.draw.call(this, stone);\n    },\n\n    /**\n     * Clear stone\n     */\n    clear: function(stone) {\n\n      //Don't show shadow\n      stone.shadow = false;\n\n      //Call parent method\n      Stone.clear.call(this, stone);\n    }\n  };\n\n  //Return\n  return StoneMini;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * StoneShadow :: This class is used for drawing stone shadows on the board.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Board.Object.StoneShadow.Service', [\n  'ngGo',\n  'ngGo.Board.Object.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('StoneShadow', function() {\n\n  /**\n   * Constructor\n   */\n  var StoneShadow = {\n\n    /**\n     * Draw a stone shadow\n     */\n    draw: function(stone) {\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = Math.max(0, this.board.theme.get('stone.radius', s) - 0.5);\n\n      //Apply scaling factor?\n      if (stone.scale) {\n        r = Math.round(r * stone.scale);\n      }\n\n      //Get theme properties\n      var blur = this.board.theme.get('shadow.blur', s);\n      var offsetX = this.board.theme.get('shadow.offsetX', s);\n      var offsetY = this.board.theme.get('shadow.offsetY', s);\n      var shadowColor = this.board.theme.get('shadow.color');\n\n      //Configure context\n      this.context.fillStyle = this.context.createRadialGradient(\n        x + offsetX, y + offsetY, r - 1 - blur, x + offsetX, y + offsetY, r + blur\n      );\n      this.context.fillStyle.addColorStop(0, shadowColor);\n      this.context.fillStyle.addColorStop(1, 'rgba(0,0,0,0)');\n\n      //Draw shadow\n      this.context.beginPath();\n      this.context.arc(x + offsetX, y + offsetY, r + blur, 0, 2 * Math.PI, true);\n      this.context.fill();\n    },\n\n    /**\n     * Clear a stone shadow\n     */\n    clear: function(stone) {\n\n      //Note: this method is currently not in use due to the overlapping shadows\n      //problem. Instead, the entire shadow layer is simply cleared and redrawn\n      //when removing stones. The multiple canvasses solution from WGo didn't seem\n      //appropriate either, so for now we will leave it at this.\n\n      //No context?\n      if (!this.context) {\n        return;\n      }\n\n      //Don't draw shadows if there is stone alpha or if explicitly stated\n      if ((stone.alpha && stone.alpha < 1) || stone.shadow === false) {\n        return;\n      }\n\n      //Get coordinates and stone radius\n      var x = this.board.getAbsX(stone.x);\n      var y = this.board.getAbsY(stone.y);\n      var s = this.board.getCellSize();\n      var r = this.board.theme.get('stone.radius', s);\n\n      //Clear a generous rectangle\n      this.context.clearRect(x - 1.2 * r, y - 1.2 * r, 2.4 * r, 2.4 * r);\n    }\n  };\n\n  //Return\n  return StoneShadow;\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Gib2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom GIB to JGF.\n * Since the Gib format is not public, the accuracy of this parser is not guaranteed.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Gib2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Gib2Jgf', ['ngGo', 'KifuBlank', function(ngGo, KifuBlank) {\n\n  /**\n   * Regular expressions\n   */\n  var regMove = /STO\\s0\\s([0-9]+)\\s(1|2)\\s([0-9]+)\\s([0-9]+)/gi;\n  var regPlayer = /GAME(BLACK|WHITE)NAME=([A-Za-z0-9]+)\\s\\(([0-9]+D|K)\\)/gi;\n  var regKomi = /GAMEGONGJE=([0-9]+)/gi;\n  var regDate = /GAMEDATE=([0-9]+)-\\s?([0-9]+)-\\s?([0-9]+)/g;\n  var regResultMargin = /GAMERESULT=(white|black)\\s([0-9]+\\.?[0-9]?)/gi;\n  var regResultOther = /GAMERESULT=(white|black)\\s[a-z\\s]+(resignation|time)/gi;\n\n  /**\n   * Player parser function\n   */\n  var parsePlayer = function(jgf, match) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (match[1].toUpperCase() === 'BLACK') ? 'black' : 'white';\n\n    //Create player object\n    var player = {\n      color: color,\n      name: match[2],\n      rank: match[3].toLowerCase()\n    };\n\n    //Check if player of this color already exists, if so, overwrite\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p] = player;\n        return;\n      }\n    }\n\n    //Player of this color not found, push\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, match) {\n    jgf.game.komi = parseFloat(match[1] / 10);\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, match) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Push date\n    jgf.game.dates.push(match[1] + '-' + match[2] + '-' + match[3]);\n  };\n\n  /**\n   * Result parser function\n   */\n  var parseResult = function(jgf, match) {\n\n    //Winner color\n    var result = (match[1].toLowerCase() === 'black') ? 'B' : 'W';\n    result += '+';\n\n    //Win condition\n    if (match[2].match(/res/i)) {\n      result += 'R';\n    }\n    else if (match[2].match(/time/i)) {\n      result += 'T';\n    }\n    else {\n      result += match[2];\n    }\n\n    //Set in JGF\n    jgf.game.result = result;\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, match) {\n\n    //Determine player color\n    var color = match[2];\n    if (color === 1) {\n      color = 'B';\n    }\n    else if (color === 2) {\n      color = 'W';\n    }\n    else {\n      return;\n    }\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (false) {\n\n    }\n\n    //Regular move\n    else {\n      node.move[color] = [match[3] * 1, match[4] * 1];\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse GIB string into a JGF object or string\n     */\n    parse: function(gib, stringified) {\n\n      //Get new JGF object\n      var jgf = KifuBlank.jgf();\n\n      //Initialize\n      var match;\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find player information\n      while ((match = regPlayer.exec(gib))) {\n        parsePlayer(jgf, match);\n      }\n\n      //Find komi\n      if ((match = regKomi.exec(gib))) {\n        parseKomi(jgf, match);\n      }\n\n      //Find game date\n      if ((match = regDate.exec(gib))) {\n        parseDate(jgf, match);\n      }\n\n      //Find game result\n      if ((match = regResultMargin.exec(gib)) || (match = regResultOther.exec(gib))) {\n        parseResult(jgf, match);\n      }\n\n      //Find moves\n      while ((match = regMove.exec(gib))) {\n\n        //Create new node\n        node = {};\n\n        //Parse move\n        parseMove(jgf, node, match);\n\n        //Push node to container\n        container.push(node);\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Jgf2Sgf :: This is a parser wrapped by the KifuParser which is used to convert fom JGF to SGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Jgf2Sgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Jgf2Sgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Flip SGF alias map and create JGF alias map\n   */\n  var jgfAliases = {};\n  for (var sgfProp in sgfAliases) {\n    if (sgfAliases.hasOwnProperty(sgfProp)) {\n      jgfAliases[sgfAliases[sgfProp]] = sgfProp;\n    }\n  }\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert to SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return String.fromCharCode(aChar + coords[0]) + String.fromCharCode(aChar + coords[1]);\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Helper to escape SGF info\n   */\n  var escapeSgf = function(text) {\n    if (typeof text === 'string') {\n      return text.replace(/\\\\/g, '\\\\\\\\').replace(/]/g, '\\\\]');\n    }\n    return text;\n  };\n\n  /**\n   * Helper to write an SGF group\n   */\n  var writeGroup = function(prop, values, output, escape) {\n    if (values.length) {\n      output.sgf += prop;\n      for (var i = 0; i < values.length; i++) {\n        output.sgf += '[' + (escape ? escapeSgf(values[i]) : values[i]) + ']';\n      }\n    }\n  };\n\n  /**\n   * Move parser\n   */\n  var parseMove = function(move, output) {\n\n    //Determine and validate color\n    var color = move.B ? 'B' : (move.W ? 'W' : '');\n    if (color === '') {\n      return;\n    }\n\n    //Determine move\n    var coords = (move[color] === 'pass') ? '' : move[color];\n\n    //Append to SGF\n    output.sgf += color + '[' + convertCoordinates(coords) + ']';\n  };\n\n  /**\n   * Setup parser\n   */\n  var parseSetup = function(setup, output) {\n\n    //Loop colors\n    for (var color in setup) {\n      if (setup.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < setup[color].length; i++) {\n          setup[color][i] = convertCoordinates(setup[color][i]);\n        }\n\n        //Write as group\n        writeGroup('A' + color, setup[color], output);\n      }\n    }\n  };\n\n  /**\n   * Score parser\n   */\n  var parseScore = function(score, output) {\n\n    //Loop colors\n    for (var color in score) {\n      if (score.hasOwnProperty(color)) {\n\n        //Convert coordinates\n        for (var i = 0; i < score[color].length; i++) {\n          score[color][i] = convertCoordinates(score[color][i]);\n        }\n\n        //Write as group\n        writeGroup('T' + color, score[color], output);\n      }\n    }\n  };\n\n  /**\n   * Markup parser\n   */\n  var parseMarkup = function(markup, output) {\n\n    //Loop markup types\n    for (var type in markup) {\n      if (markup.hasOwnProperty(type)) {\n        var i;\n\n        //Label type has the label text appended to the coords\n        if (type === 'label') {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]) + ':' + markup[type][i][2];\n          }\n        }\n        else {\n          for (i = 0; i < markup[type].length; i++) {\n            markup[type][i] = convertCoordinates(markup[type][i]);\n          }\n        }\n\n        //Convert type\n        if (typeof jgfAliases[type] !== 'undefined') {\n          type = jgfAliases[type];\n        }\n\n        //Write as group\n        writeGroup(type, markup[type], output);\n      }\n    }\n  };\n\n  /**\n   * Turn parser\n   */\n  var parseTurn = function(turn, output) {\n    output.sgf += 'PL[' + turn + ']';\n  };\n\n  /**\n   * Comments parser\n   */\n  var parseComments = function(comments, output) {\n\n    //Determine key\n    var key = (typeof jgfAliases.comments !== 'undefined') ? jgfAliases.comments : 'C';\n\n    //Flatten comment objects\n    var flatComments = [];\n    for (var c = 0; c < comments.length; c++) {\n      if (typeof comments[c] === 'string') {\n        flatComments.push(comments[c]);\n      }\n      else if (comments[c].comment) {\n        flatComments.push(comments[c].comment);\n      }\n    }\n\n    //Write as group\n    writeGroup(key, flatComments, output, true);\n  };\n\n  /**\n   * Node name parser\n   */\n  var parseNodeName = function(nodeName, output) {\n    var key = (typeof jgfAliases.name !== 'undefined') ? jgfAliases.name : 'N';\n    output.sgf += key + '[' + escapeSgf(nodeName) + ']';\n  };\n\n  /**\n   * Game parser\n   */\n  var parseGame = function(game) {\n\n    //Loop SGF game definitions\n    for (var i in sgfGames) {\n      if (sgfGames.hasOwnProperty(i) && sgfGames[i] === game) {\n        return i;\n      }\n    }\n\n    //Not found\n    return 0;\n  };\n\n  /**\n   * Application parser\n   */\n  var parseApplication = function(application) {\n    var parts = application.split(' v');\n    if (parts.length > 1) {\n      return parts[0] + ':' + parts[1];\n    }\n    return application;\n  };\n\n  /**\n   * Player instructions parser\n   */\n  var parsePlayer = function(player, rootProperties) {\n\n    //Variation handling\n    var st = 0;\n    if (!player.variation_markup) {\n      st += 2;\n    }\n    if (player.variation_siblings) {\n      st += 1;\n    }\n\n    //Set in root properties\n    rootProperties.ST = st;\n  };\n\n  /**\n   * Board parser\n   */\n  var parseBoard = function(board, rootProperties) {\n\n    //Both width and height should be given\n    if (board.width && board.height) {\n\n      //Same dimensions?\n      if (board.width === board.height) {\n        rootProperties.SZ = board.width;\n      }\n\n      //Different dimensions are not supported by SGF, but OGS uses the\n      //format w:h, so we will stick with that for anyone who supports it.\n      else {\n        rootProperties.SZ = board.width + ':' + board.height;\n      }\n    }\n\n    //Otherwise, check if only width or height were given at least\n    else if (board.width) {\n      rootProperties.SZ = board.width;\n    }\n    else if (board.height) {\n      rootProperties.SZ = board.height;\n    }\n\n    //Can't determine size\n    else {\n      rootProperties.SZ = '';\n    }\n  };\n\n  /**\n   * Players parser\n   */\n  var parsePlayers = function(players, rootProperties) {\n\n    //Loop players\n    for (var p = 0; p < players.length; p++) {\n\n      //Validate color\n      if (!players[p].color || (players[p].color !== 'black' && players[p].color !== 'white')) {\n        continue;\n      }\n\n      //Get SGF color\n      var color = (players[p].color === 'black') ? 'B' : 'W';\n\n      //Name given?\n      if (players[p].name) {\n        rootProperties['P' + color] = players[p].name;\n      }\n\n      //Rank given?\n      if (players[p].rank) {\n        rootProperties[color + 'R'] = players[p].rank;\n      }\n\n      //Team given?\n      if (players[p].team) {\n        rootProperties[color + 'T'] = players[p].team;\n      }\n    }\n  };\n\n  /**\n   * Parse function to property mapper\n   */\n  var parsingMap = {\n\n    //Node properties\n    'move': parseMove,\n    'setup': parseSetup,\n    'score': parseScore,\n    'markup': parseMarkup,\n    'turn': parseTurn,\n    'comments': parseComments,\n    'name': parseNodeName,\n\n    //Info properties\n    'record.application': parseApplication,\n    'player': parsePlayer,\n    'board': parseBoard,\n    'game.type': parseGame,\n    'game.players': parsePlayers\n  };\n\n  /*****************************************************************************\n   * Parser functions\n   ***/\n\n  /**\n   * Helper to write a JGF tree to SGF\n   */\n  var writeTree = function(tree, output) {\n\n    //Loop nodes in the tree\n    for (var i = 0; i < tree.length; i++) {\n      var node = tree[i];\n\n      //Array? That means a variation\n      if (angular.isArray(node)) {\n        for (var j = 0; j < node.length; j++) {\n          output.sgf += '(\\n;';\n          writeTree(node[j], output);\n          output.sgf += '\\n)';\n        }\n\n        //Continue\n        continue;\n      }\n\n      //Loop node properties\n      for (var key in node) {\n        if (node.hasOwnProperty(key)) {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[key] !== 'undefined') {\n            parsingMap[key](node[key], output);\n            continue;\n          }\n\n          //Other object, can't handle it\n          if (typeof node[key] === 'object') {\n            continue;\n          }\n\n          //Anything else, append it\n          output.sgf += key + '[' + escapeSgf(node[key]) + ']';\n        }\n      }\n\n      //More to come?\n      if ((i + 1) < tree.length) {\n        output.sgf += '\\n;';\n      }\n    }\n  };\n\n  /**\n   * Helper to extract all SGF root properties from a JGF object\n   */\n  var extractRootProperties = function(jgf, rootProperties, key) {\n\n    //Initialize key\n    if (typeof key === 'undefined') {\n      key = '';\n    }\n\n    //Loop properties of jgf node\n    for (var subKey in jgf) {\n      if (jgf.hasOwnProperty(subKey)) {\n\n        //Skip SGF signature (as we keep our own)\n        if (subKey === 'sgf') {\n          continue;\n        }\n\n        //Build jgf key\n        var jgfKey = (key === '') ? subKey : key + '.' + subKey;\n\n        //If the item is an object, handle separately\n        if (typeof jgf[subKey] === 'object') {\n\n          //Handler for this object present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            parsingMap[jgfKey](jgf[subKey], rootProperties);\n          }\n\n          //Otherwise, just flatten and call this function recursively\n          else {\n            extractRootProperties(jgf[subKey], rootProperties, jgfKey);\n          }\n          continue;\n        }\n\n        //Check if it's a known key, if so, append the value to the root\n        var value;\n        if (typeof jgfAliases[jgfKey] !== 'undefined') {\n\n          //Handler present in parsing map?\n          if (typeof parsingMap[jgfKey] !== 'undefined') {\n            value = parsingMap[jgfKey](jgf[subKey]);\n          }\n          else {\n            value = escapeSgf(jgf[subKey]);\n          }\n\n          //Set in root properties\n          rootProperties[jgfAliases[jgfKey]] = value;\n        }\n      }\n    }\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse JGF object or string into an SGF string\n     */\n    parse: function(jgf) {\n\n      //String given?\n      if (typeof jgf === 'string') {\n        jgf = angular.fromJson(jgf);\n      }\n\n      //Must have moves tree\n      if (!jgf.tree) {\n        console.error('No moves tree in JGF object');\n        return;\n      }\n\n      //Initialize output (as object, so it remains a reference) and root properties container\n      var output = {sgf: '(\\n;'};\n      var root = angular.copy(jgf);\n      var rootProperties = KifuBlank.sgf();\n\n      //The first node of the JGF tree is the root node, and it can contain comments,\n      //board setup parameters, etc. It doesn't contain moves. We handle it separately here\n      //and attach it to the root\n      if (jgf.tree && jgf.tree.length > 0 && jgf.tree[0].root) {\n        root = angular.extend(root, jgf.tree[0]);\n        delete root.root;\n        delete jgf.tree[0];\n      }\n\n      //Set root properties\n      delete root.tree;\n      extractRootProperties(root, rootProperties);\n\n      //Write root properties\n      for (var key in rootProperties) {\n        if (rootProperties[key]) {\n          output.sgf += key + '[' + escapeSgf(rootProperties[key]) + ']';\n        }\n      }\n\n      //Write game tree\n      writeTree(jgf.tree, output);\n\n      //Close SGF and return\n      output.sgf += ')';\n      return output.sgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * Sgf2Jgf :: This is a parser wrapped by the KifuParser which is used to convert fom SGF to JGF\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Kifu.Parsers.Sgf2Jgf.Service', [\n  'ngGo',\n  'ngGo.Kifu.Blank.Service'\n])\n\n/**\n * Factory definition\n */\n.factory('Sgf2Jgf', ['ngGo', 'sgfAliases', 'sgfGames', 'KifuBlank', function(ngGo, sgfAliases, sgfGames, KifuBlank) {\n\n  /**\n   * Regular expressions for SGF data\n   */\n  var regSequence = /\\(|\\)|(;(\\s*[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+)*)/g;\n  var regNode = /[A-Z]+\\s*((\\[\\])|(\\[(.|\\s)*?([^\\\\]\\])))+/g;\n  var regProperty = /[A-Z]+/;\n  var regValues = /(\\[\\])|(\\[(.|\\s)*?([^\\\\]\\]))/g;\n\n  /**\n   * Character index of \"a\"\n   */\n  var aChar = 'a'.charCodeAt(0);\n\n  /**\n   * Helper to convert SGF coordinates\n   */\n  var convertCoordinates = function(coords) {\n    return [coords.charCodeAt(0) - aChar, coords.charCodeAt(1) - aChar];\n  };\n\n  /*****************************************************************************\n   * Conversion helpers\n   ***/\n\n  /**\n   * Application parser function (doesn't overwrite existing signature)\n   */\n  var parseApp = function(jgf, node, key, value) {\n    if (!jgf.record.application) {\n      var app = value[0].split(':');\n      if (app.length > 1) {\n        jgf.record.application = app[0] + ' v' + app[1];\n      }\n      else {\n        jgf.record.application = app[0];\n      }\n    }\n  };\n\n  /**\n   * SGF format parser\n   */\n  var parseSgfFormat = function() {\n    return;\n  };\n\n  /**\n   * Game type parser function\n   */\n  var parseGame = function(jgf, node, key, value) {\n    var game = value[0];\n    if (typeof sgfGames[game] !== 'undefined') {\n      jgf.game.type = sgfGames[game];\n    }\n    else {\n      jgf.game.type = value[0];\n    }\n  };\n\n  /**\n   * Move parser function\n   */\n  var parseMove = function(jgf, node, key, value) {\n\n    //Create move container\n    node.move = {};\n\n    //Pass\n    if (value[0] === '' || (jgf.width <= 19 && value[0] === 'tt')) {\n      node.move[key] = 'pass';\n    }\n\n    //Regular move\n    else {\n      node.move[key] = convertCoordinates(value[0]);\n    }\n  };\n\n  /**\n   * Comment parser function\n   */\n  var parseComment = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Node name parser function\n   */\n  var parseNodeName = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Set value\n    node[key] = value[0];\n  };\n\n  /**\n   * Board setup parser function\n   */\n  var parseSetup = function(jgf, node, key, value) {\n\n    //Initialize setup container on node\n    if (typeof node.setup === 'undefined') {\n      node.setup = {};\n    }\n\n    //Remove \"A\" from setup key\n    key = key.charAt(1);\n\n    //Initialize setup container of this type\n    if (typeof node.setup[key] === 'undefined') {\n      node.setup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.setup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Scoring parser function\n   */\n  var parseScore = function(jgf, node, key, value) {\n\n    //Initialize score container on node\n    if (typeof node.score === 'undefined') {\n      node.score = {\n        B: [],\n        W: []\n      };\n    }\n\n    //Remove \"T\" from setup key\n    key = key.charAt(1);\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.score[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Turn parser function\n   */\n  var parseTurn = function(jgf, node, key, value) {\n    node.turn = value[0];\n  };\n\n  /**\n   * Label parser function\n   */\n  var parseLabel = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n\n      //Split off coordinates and add label contents\n      var coords = convertCoordinates(value[i].substr(0, 2));\n      coords.push(value[i].substr(3));\n\n      //Add to node\n      node.markup[key].push(coords);\n    }\n  };\n\n  /**\n   * Markup parser function\n   */\n  var parseMarkup = function(jgf, node, key, value) {\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Initialize markup container on node\n    if (typeof node.markup === 'undefined') {\n      node.markup = {};\n    }\n\n    //Initialize markup container of this type\n    if (typeof node.markup[key] === 'undefined') {\n      node.markup[key] = [];\n    }\n\n    //Add values\n    for (var i = 0; i < value.length; i++) {\n      node.markup[key].push(convertCoordinates(value[i]));\n    }\n  };\n\n  /**\n   * Size parser function\n   */\n  var parseSize = function(jgf, node, key, value) {\n\n    //Initialize board container\n    if (typeof jgf.board === 'undefined') {\n      jgf.board = {};\n    }\n\n    //Add size property (can be width:height or just a single size)\n    var size = value[0].split(':');\n    if (size.length > 1) {\n      jgf.board.width = parseInt(size[0]);\n      jgf.board.height = parseInt(size[1]);\n    }\n    else {\n      jgf.board.width = jgf.board.height = parseInt(size[0]);\n    }\n  };\n\n  /**\n   * Date parser function\n   */\n  var parseDate = function(jgf, node, key, value) {\n\n    //Initialize dates container\n    if (typeof jgf.game.dates === 'undefined') {\n      jgf.game.dates = [];\n    }\n\n    //Explode dates\n    var dates = value[0].split(',');\n    for (var d = 0; d < dates.length; d++) {\n      jgf.game.dates.push(dates[d]);\n    }\n  };\n\n  /**\n   * Komi parser function\n   */\n  var parseKomi = function(jgf, node, key, value) {\n    jgf.game.komi = parseFloat(value[0]);\n  };\n\n  /**\n   * Variations handling parser function\n   */\n  var parseVariations = function(jgf, node, key, value) {\n\n    //Initialize display property\n    if (typeof jgf.player === 'undefined') {\n      jgf.player = {};\n    }\n\n    //Initialize variation display settings\n    jgf.player.variation_markup = false;\n    jgf.player.variation_children = false;\n    jgf.player.variation_siblings = false;\n\n    //Parse as integer\n    var st = parseInt(value[0]);\n\n    //Determine what we want (see SGF specs for details)\n    switch (st) {\n      case 0:\n        jgf.player.variation_markup = true;\n        jgf.player.variation_children = true;\n        break;\n      case 1:\n        jgf.player.variation_markup = true;\n        jgf.player.variation_siblings = true;\n        break;\n      case 2:\n        jgf.player.variation_children = true;\n        break;\n      case 3:\n        jgf.player.variation_siblings = true;\n        break;\n    }\n  };\n\n  /**\n   * Player info parser function\n   */\n  var parsePlayer = function(jgf, node, key, value) {\n\n    //Initialize players container\n    if (typeof jgf.game.players === 'undefined') {\n      jgf.game.players = [];\n    }\n\n    //Determine player color\n    var color = (key === 'PB' || key === 'BT' || key === 'BR') ? 'black' : 'white';\n\n    //Get key alias\n    if (typeof sgfAliases[key] !== 'undefined') {\n      key = sgfAliases[key];\n    }\n\n    //Check if player of this color already exists\n    for (var p = 0; p < jgf.game.players.length; p++) {\n      if (jgf.game.players[p].color === color) {\n        jgf.game.players[p][key] = value[0];\n        return;\n      }\n    }\n\n    //Player of this color not found, initialize\n    var player = {color: color};\n    player[key] = value[0];\n    jgf.game.players.push(player);\n  };\n\n  /**\n   * Parsing function to property mapper\n   */\n  var parsingMap = {\n\n    //Application, game type, board size, komi, date\n    'AP': parseApp,\n    'FF': parseSgfFormat,\n    'GM': parseGame,\n    'SZ': parseSize,\n    'KM': parseKomi,\n    'DT': parseDate,\n\n    //Variations handling\n    'ST': parseVariations,\n\n    //Player info handling\n    'PB': parsePlayer,\n    'PW': parsePlayer,\n    'BT': parsePlayer,\n    'WT': parsePlayer,\n    'BR': parsePlayer,\n    'WR': parsePlayer,\n\n    //Moves\n    'B': parseMove,\n    'W': parseMove,\n\n    //Node annotation\n    'C': parseComment,\n    'N': parseNodeName,\n\n    //Board setup\n    'AB': parseSetup,\n    'AW': parseSetup,\n    'AE': parseSetup,\n    'PL': parseTurn,\n    'TW': parseScore,\n    'TB': parseScore,\n\n    //Markup\n    'CR': parseMarkup,\n    'SQ': parseMarkup,\n    'TR': parseMarkup,\n    'MA': parseMarkup,\n    'SL': parseMarkup,\n    'LB': parseLabel\n  };\n\n  /**\n   * These properties need a node object\n   */\n  var needsNode = [\n    'B', 'W', 'C', 'N', 'AB', 'AW', 'AE', 'PL', 'LB', 'CR', 'SQ', 'TR', 'MA', 'SL', 'TW', 'TB'\n  ];\n\n  /*****************************************************************************\n   * Parser helpers\n   ***/\n\n  /**\n   * Set info in the JGF tree at a certain position\n   */\n  var setInfo = function(jgf, position, value) {\n\n    //Position given must be an array\n    if (typeof position !== 'object') {\n      return;\n    }\n\n    //Initialize node to attach value to\n    var node = jgf;\n    var key;\n\n    //Loop the position\n    for (var p = 0; p < position.length; p++) {\n\n      //Get key\n      key = position[p];\n\n      //Last key reached? Done\n      if ((p + 1) === position.length) {\n        break;\n      }\n\n      //Create container if not set\n      if (typeof node[key] !== 'object') {\n        node[key] = {};\n      }\n\n      //Move up in tree\n      node = node[key];\n    }\n\n    //Set value\n    node[key] = value;\n  };\n\n  /**\n   * Parser class\n   */\n  var Parser = {\n\n    /**\n     * Parse SGF string into a JGF object or string\n     */\n    parse: function(sgf, stringified) {\n\n      //Get new JGF object (with SGF node as a base)\n      var jgf = KifuBlank.jgf({record: {sgf: {}}});\n\n      //Initialize\n      var stack = [];\n      var container = jgf.tree;\n\n      //Create first node for game, which is usually an empty board position, but can\n      //contain comments or board setup instructions, which will be added to the node\n      //later if needed.\n      var node = {root: true};\n      container.push(node);\n\n      //Find sequence of elements\n      var sequence = sgf.match(regSequence);\n\n      //Loop sequence items\n      for (var i = 0; i < sequence.length; i++) {\n\n        //Push stack if new variation found\n        if (sequence[i] === '(') {\n\n          //First encounter, this defines the main tree branch, so skip\n          if (i === 0 || i === '0') {\n            continue;\n          }\n\n          //Push the current container to the stack\n          stack.push(container);\n\n          //Create variation container if it doesn't exist yet\n          if (!angular.isArray(container[container.length - 1])) {\n            container.push([]);\n          }\n\n          //Use variation container\n          container = container[container.length - 1];\n\n          //Now create moves container\n          container.push([]);\n          container = container[container.length - 1];\n          continue;\n        }\n\n        //Grab last container from stack if end of variation reached\n        else if (sequence[i] === ')') {\n          if (stack.length) {\n            container = stack.pop();\n          }\n          continue;\n        }\n\n        //Make array of properties within this sequence\n        var properties = sequence[i].match(regNode) || [];\n\n        //Loop them\n        for (var j = 0; j < properties.length; j++) {\n\n          //Get property's key and separate values\n          var key = regProperty.exec(properties[j])[0].toUpperCase();\n          var values = properties[j].match(regValues);\n\n          //Remove additional braces [ and ]\n          for (var k = 0; k < values.length; k++) {\n            values[k] = values[k].substring(1, values[k].length - 1).replace(/\\\\(?!\\\\)/g, '');\n          }\n\n          //SGF parser present for this key? Call it, and we're done\n          if (typeof parsingMap[key] !== 'undefined') {\n\n            //Does this type of property need a node?\n            if (needsNode.indexOf(key) !== -1) {\n\n              //If no node object present, create a new node\n              //For moves, always a new node is created\n              if (!node || key === 'B' || key === 'W') {\n                node = {};\n                container.push(node);\n              }\n            }\n\n            //Apply parsing function on node\n            parsingMap[key](jgf, node, key, values);\n            continue;\n          }\n\n          //No SGF parser present, we continue with regular property handling\n\n          //If there is only one value, simplify array\n          if (values.length === 1) {\n            values = values[0];\n          }\n\n          //SGF alias known? Then this is an info element and we handle it accordingly\n          if (typeof sgfAliases[key] !== 'undefined') {\n\n            //The position in the JGF object is represented by dot separated strings\n            //in the sgfAliases array. Split the position and use the setInfo helper\n            //to set the info on the JGF object\n            setInfo(jgf, sgfAliases[key].split('.'), values);\n            continue;\n          }\n\n          //No SGF alias present either, just append the data\n\n          //Save in node\n          if (node) {\n            node[key] = values;\n          }\n\n          //Save in root\n          else {\n            jgf[key] = values;\n          }\n        }\n\n        //Reset node, unless this was the root node\n        if (node && !node.root) {\n          node = null;\n        }\n      }\n\n      //Return stringified\n      if (stringified) {\n        return angular.toJson(jgf);\n      }\n\n      //Return jgf\n      return jgf;\n    }\n  };\n\n  //Return object\n  return Parser;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeCommon :: This class governs common event handling of the player shared by\n * various player modes. It's basically an abstract player mode and it can't be actively set.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Common.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Run block\n */\n.run(['Player', 'PlayerModes', 'PlayerModeCommon', function(Player, PlayerModes, PlayerModeCommon) {\n\n  /**\n   * Register common event handlers\n   */\n  Player.on('keydown', PlayerModeCommon.keyDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousewheel wheel', PlayerModeCommon.mouseWheel, [\n    PlayerModes.REPLAY, PlayerModes.EDIT\n  ]);\n  Player.on('mousemove', PlayerModeCommon.mouseMove, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseout', PlayerModeCommon.mouseOut, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mousedown', PlayerModeCommon.mouseDown, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n  Player.on('mouseup', PlayerModeCommon.mouseUp, [\n    PlayerModes.REPLAY, PlayerModes.EDIT, PlayerModes.SOLVE\n  ]);\n}])\n\n/**\n * Factory definition\n */\n.factory('PlayerModeCommon', ['Player', 'PlayerTools', 'GameScorer', 'KeyCodes', function(Player, PlayerTools, GameScorer, KeyCodes) {\n\n  /**\n   * Helper to build drag object\n   */\n  var dragObject = function(event) {\n\n    //Initialize drag object\n    var drag = {\n      start: {\n        x: (this.mouse.dragStart.x > event.x) ? event.x : this.mouse.dragStart.x,\n        y: (this.mouse.dragStart.y > event.y) ? event.y : this.mouse.dragStart.y\n      },\n      stop: {\n        x: (this.mouse.dragStart.x > event.x) ? this.mouse.dragStart.x : event.x,\n        y: (this.mouse.dragStart.y > event.y) ? this.mouse.dragStart.y : event.y\n      }\n    };\n\n    //Fix boundaries\n    if (drag.start.x < 0) {\n      drag.start.x = 0;\n    }\n    if (drag.start.y < 0) {\n      drag.start.y = 0;\n    }\n    if (drag.stop.x > this.board.width - 1) {\n      drag.stop.x = this.board.width - 1;\n    }\n    if (drag.stop.y > this.board.height - 1) {\n      drag.stop.y = this.board.height - 1;\n    }\n\n    //Return\n    return drag;\n  };\n\n  /**\n   * Normalize the mousewheel event helper\n   */\n  function normalizeMousewheelEvent(event) {\n\n    //Initialize vars\n    var deltaX = 0;\n    var deltaY = 0;\n\n    //Old school scrollwheel delta\n    if ('detail' in event) {\n      deltaY = event.detail * -1;\n    }\n    if ('wheelDelta' in event) {\n      deltaY = event.wheelDelta;\n    }\n    if ('wheelDeltaY' in event) {\n      deltaY = event.wheelDeltaY;\n    }\n    if ('wheelDeltaX' in event) {\n      deltaX = event.wheelDeltaX * -1;\n    }\n\n    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\n      deltaX = deltaY * -1;\n      deltaY = 0;\n    }\n\n    //New type wheel delta (WheelEvent)\n    if ('deltaY' in event) {\n      deltaY = event.deltaY * -1;\n    }\n    if ('deltaX' in event) {\n      deltaX = event.deltaX;\n    }\n\n    //Set in event (have to use different property name because of strict mode)\n    event.mouseWheelX = deltaX;\n    event.mouseWheelY = deltaY;\n\n    //Return\n    return event;\n  }\n\n  /**\n   * Player extension\n   */\n  angular.extend(Player, {\n\n    /**\n     * Mouse coordinate helper vars\n     */\n    mouse: {\n\n      //Drag start\n      dragStart: null,\n\n      //Last grid coordinates\n      lastX: -1,\n      lastY: -1\n    }\n  });\n\n  /**\n   * Player mode definition\n   */\n  var PlayerMode = {\n\n    /**\n     * Handler for keydown events\n     */\n    keyDown: function(event, keyboardEvent) {\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Switch key code\n      switch (keyboardEvent.keyCode) {\n\n        //ESC\n        case KeyCodes.ESC:\n\n          //Cancel drag event, and prevent click event as well\n          this.mouse.dragStart = null;\n          this.preventClickEvent = true;\n          break;\n\n        //Right arrow\n        case KeyCodes.RIGHT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Advance to the next move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeEnd) {\n              this.next();\n            }\n          }\n          break;\n\n        //Left arrow\n        case KeyCodes.LEFT:\n\n          //Arrow navigation enabled?\n          if (this.arrowKeysNavigation) {\n            keyboardEvent.preventDefault();\n\n            //Go to the previous move\n            if (this.tool === PlayerTools.MOVE && this.game.node !== this.restrictNodeStart) {\n              this.previous();\n            }\n          }\n          break;\n\n        //Up arrow\n        case KeyCodes.UP:\n          break;\n\n        //Down arrow\n        case KeyCodes.DOWN:\n          break;\n      }\n    },\n\n    /**\n     * Handler for mousewheel events\n     */\n    mouseWheel: function(event, mouseEvent) {\n\n      //Disabled or not using move tool?\n      if (!this.scrollWheelNavigation || this.tool !== PlayerTools.MOVE) {\n        return true;\n      }\n\n      //No game?\n      if (!this.game || !this.game.isLoaded()) {\n        return true;\n      }\n\n      //Normalize mousewheel event\n      mouseEvent = normalizeMousewheelEvent(mouseEvent);\n\n      //Find delta\n      var delta = mouseEvent.mouseWheelY || mouseEvent.deltaY;\n\n      //Next move\n      if (delta < 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.next();\n      }\n\n      //Previous move\n      else if (delta > 0) {\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n        this.previous();\n      }\n\n      //Don't scroll the window\n      if (delta !== 0) {\n        mouseEvent.preventDefault();\n      }\n    },\n\n    /**\n     * Mouse out handler\n     */\n    mouseOut: function() {\n      if (this.board) {\n        this.board.removeAll('hover');\n      }\n    },\n\n    /**\n     * Mouse move handler\n     */\n    mouseMove: function(event, mouseEvent) {\n\n      //Attach drag object to events\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n      }\n\n      //Nothing else to do?\n      if (!this.board || !this.board.layers.hover) {\n        return;\n      }\n\n      //Last coordinates are the same?\n      if (this.mouse.lastX === event.x && this.mouse.lastY === event.y) {\n        return;\n      }\n\n      //Remember last coordinates\n      this.mouse.lastX = event.x;\n      this.mouse.lastY = event.y;\n\n      //Broadcast hover event\n      this.broadcast('hover', mouseEvent);\n    },\n\n    /**\n     * Mouse down handler\n     */\n    mouseDown: function(event) {\n      this.mouse.dragStart = {\n        x: event.x,\n        y: event.y\n      };\n    },\n\n    /**\n     * Mouse up handler\n     */\n    mouseUp: function(event, mouseEvent) {\n      if (\n        this.mouse.dragStart &&\n        (this.mouse.dragStart.x !== event.x || this.mouse.dragStart.y !== event.y)\n      ) {\n        mouseEvent.drag = dragObject.call(this, event);\n        this.broadcast('mousedrag', mouseEvent);\n      }\n      this.mouse.dragStart = null;\n    }\n  };\n\n  //Return\n  return PlayerMode;\n}]);\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeEdit :: This module governs the \"edit\" mode of the player, e.g. editing\n * a game record and its board positions.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Edit.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Setup tools\n */\n.constant('SetupTools', {\n  BLACK: 'black',\n  WHITE: 'white',\n  CLEAR: 'clear'\n})\n\n/**\n * Markup tools\n */\n.constant('MarkupTools', {\n  TRIANGLE: 'triangle',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  MARK: 'mark',\n  SELECT: 'select',\n  SAD: 'sad',\n  HAPPY: 'happy',\n  TEXT: 'text',\n  NUMBER: 'number',\n  CLEAR: 'clear'\n})\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeEdit', function(Player, PlayerModes, PlayerModeEdit) {\n\n  //Register event handlers\n  Player.on('pathChange', PlayerModeEdit.pathChange, PlayerModes.EDIT);\n  Player.on('toolSwitch', PlayerModeEdit.toolSwitch, PlayerModes.EDIT);\n  Player.on('modeEnter', PlayerModeEdit.modeEnter, PlayerModes.EDIT);\n  Player.on('mousedrag', PlayerModeEdit.mouseDrag, PlayerModes.EDIT);\n  Player.on('keydown', PlayerModeEdit.keyDown, PlayerModes.EDIT);\n  Player.on('click', PlayerModeEdit.click, PlayerModes.EDIT);\n  Player.on('hover', PlayerModeEdit.hover, PlayerModes.EDIT);\n\n  //Register mode\n  Player.registerMode(PlayerModes.EDIT, PlayerModeEdit);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeEdit', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['Player', 'PlayerTools', 'SetupTools', 'MarkupTools', 'MarkupTypes', 'GameScorer', 'StoneColor', function(\n    Player, PlayerTools, SetupTools, MarkupTools, MarkupTypes, GameScorer, StoneColor\n  ) {\n\n    //Character codes\n    var aChar = 'A'.charCodeAt(0);\n    var aCharLc = 'a'.charCodeAt(0);\n\n    /**\n     * Update hover mark at specific coordinates\n     */\n    var updateHoverMark = function(x, y, isDrag) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Setup tool\n        case PlayerTools.SETUP:\n\n          //Clear tool\n          if (this.setupTool === SetupTools.CLEAR) {\n\n            //Stone present? Can remove it\n            if (this.game.hasStone(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Stone color tool\n          else {\n\n            //Add or overwrite stone if no stone present of the given color\n            if (!this.game.hasStone(x, y, this.setupToolColor())) {\n              this.board.add('hover', x, y, {\n                type: 'stones',\n                value: this.setupToolColor()\n              });\n            }\n\n            //Stone present of same color? Can remove it if we're not dragging\n            else if (!isDrag) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n          break;\n\n        //Markup tool\n        case PlayerTools.MARKUP:\n\n          //Clear tool, or already markup in place?\n          if (this.markupTool === MarkupTools.CLEAR || this.game.hasMarkup(x, y)) {\n            if (this.game.hasMarkup(x, y)) {\n              this.board.add('hover', x, y, {\n                type: 'markup',\n                value: MarkupTypes.MARK\n              });\n            }\n          }\n\n          //Text or number\n          else if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: {\n                type: MarkupTypes.LABEL,\n                text: this.markupLabel\n              }\n            });\n          }\n\n          //Other markup\n          else {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: this.markupTool\n            });\n          }\n          break;\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to set markup\n     */\n    var setMarkup = function(x, y) {\n\n      //Already markup in place? Remove it first\n      if (this.game.hasMarkup(x, y)) {\n\n        //Check what markup there is\n        var markup = this.game.getMarkup(x, y);\n\n        //Label? Also remove from our labels list\n        if (markup.type === MarkupTypes.LABEL && markup.text) {\n          var i = this.markupLabels.indexOf(markup.text);\n          if (i !== -1) {\n            this.markupLabels.splice(i, 1);\n          }\n        }\n\n        //Remove from game\n        this.game.removeMarkup(x, y);\n        return;\n      }\n\n      //Clear tool used? Done\n      if (this.markupTool === MarkupTools.CLEAR) {\n        return;\n      }\n\n      //Text\n      else if (this.markupTool === MarkupTools.TEXT) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next text label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Number\n      else if (this.markupTool === MarkupTools.NUMBER) {\n        this.game.addMarkup(x, y, {\n          type: MarkupTypes.LABEL,\n          text: this.markupLabel\n        });\n\n        //Determine next number label\n        this.markupLabels.push(this.markupLabel);\n        this.determineMarkupLabel();\n      }\n\n      //Other markup\n      else {\n        this.game.addMarkup(x, y, this.markupTool);\n      }\n    };\n\n    /**\n     * Helper to set a stone\n     */\n    var setStone = function(x, y, isDrag) {\n\n      //Get the stone color\n      var color = this.setupToolColor();\n\n      //Trying to remove a stone\n      if (color === StoneColor.EMPTY) {\n        this.game.removeStone(x, y);\n      }\n\n      //Adding a stone\n      else {\n\n        //A stone there already of the same color? Just remove if not dragging\n        if (!isDrag && this.game.hasStone(x, y, color)) {\n          this.game.removeStone(x, y);\n          return;\n        }\n\n        //Any stone present?\n        else if (this.game.hasStone(x, y)) {\n          this.game.removeStone(x, y);\n        }\n\n        //Add stone now\n        this.game.addStone(x, y, color);\n      }\n\n      //Redraw markup\n      this.board.layers.markup.redrawCell(x, y);\n    };\n\n    /**\n     * Find all markup labels in current position\n     */\n    var findAllMarkupLabels = function() {\n\n      //Clear\n      this.markupLabels = [];\n\n      //Must have game\n      if (!this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get all markup from position\n      var markup = this.game.position.markup.all('type');\n      for (var i = 0; i < markup.length; i++) {\n        if (markup[i].type === MarkupTypes.LABEL && markup[i].text !== '') {\n          this.markupLabels.push(markup[i].text);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Active setup tool and markup tool\n      setupTool: SetupTools.BLACK,\n      markupTool: MarkupTools.TRIANGLE,\n\n      //Current markup labels on the board and current markup label\n      markupLabels: [],\n      markupLabel: '',\n\n      /**\n       * Set the setup tool\n       */\n      switchSetupTool: function(tool) {\n        this.setupTool = tool;\n      },\n\n      /**\n       * Set the markup tool\n       */\n      switchMarkupTool: function(tool) {\n        this.markupTool = tool;\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          this.determineMarkupLabel();\n        }\n      },\n\n      /**\n       * Conversion of setup tool to stone color\n       */\n      setupToolColor: function() {\n        switch (this.setupTool) {\n          case SetupTools.BLACK:\n            return StoneColor.B;\n          case SetupTools.WHITE:\n            return StoneColor.W;\n          default:\n            return StoneColor.EMPTY;\n        }\n      },\n\n      /**\n       * Set the new text markup label\n       */\n      setMarkupLabel: function(label) {\n        if (label) {\n          this.markupLabel = label;\n        }\n      },\n\n      /**\n       * Determine the new text markup label\n       */\n      determineMarkupLabel: function() {\n\n        //Clear\n        this.markupLabel = '';\n\n        //Check what tool we're using\n        switch (this.markupTool) {\n\n          //Text tool?\n          case MarkupTools.TEXT:\n            var i = 0;\n\n            //Loop while the label is present\n            while (!this.markupLabel || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n\n              //A-Z\n              if (i < 26) {\n                this.markupLabel = String.fromCharCode(aChar + i);\n              }\n\n              //a-z\n              else if (i < 52) {\n                this.markupLabel = String.fromCharCode(aCharLc + i - 26);\n              }\n\n              //AA, AB, AC, etc.\n              else {\n                this.markupLabel = String.fromCharCode(aChar + Math.floor(i / 26) - 2) +\n                  String.fromCharCode(aChar + (i % 26));\n              }\n\n              //Keep going\n              i++;\n            }\n            break;\n\n          //Number tool?\n          case MarkupTools.NUMBER:\n            this.markupLabel = 0;\n\n            //Loop while the label is present\n            while (this.markupLabel === 0 || this.markupLabels.indexOf(this.markupLabel) !== -1) {\n              this.markupLabel++;\n            }\n            break;\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeEdit = {\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Must have board\n        if (!this.board) {\n          return;\n        }\n\n        //Remove all hover items\n        this.board.removeAll('hover');\n\n        //Single coordinate?\n        if (!event.drag || (this.tool !== PlayerTools.SETUP && this.tool !== PlayerTools.MARKUP)) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //No dragging for labels\n        if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n          updateHoverMark.call(this);\n          return;\n        }\n\n        //Loop area\n        for (var x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n          for (var y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n            updateHoverMark.call(this, x, y, true);\n          }\n        }\n      },\n\n      /**\n       * Keydown handler\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //TODO: tool switching via keyboard input\n        }\n      },\n\n      /**\n       * Click handler\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        this.board.removeAll('hover');\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Try to play the move\n            if (!this.game.play(event.x, event.y)) {\n              return;\n            }\n            this.processPosition();\n            break;\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Set stone and update board\n            setStone.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Set markup and update board\n            setMarkup.call(this, event.x, event.y);\n            this.processPosition();\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Mouse drag handler\n       */\n      mouseDrag: function(event) {\n\n        //Initialize vars\n        var x, y;\n\n        //Remove all hover items now to restore actual stones and markup to the board,\n        //otherwise it will conflict when updating the board\n        if (this.board) {\n          this.board.removeAll('hover');\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Setup tool\n          case PlayerTools.SETUP:\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setStone.call(this, x, y, true);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n\n          //Markup tool\n          case PlayerTools.MARKUP:\n\n            //Don't do this for labels\n            if (this.markupTool === MarkupTools.TEXT || this.markupTool === MarkupTools.NUMBER) {\n              break;\n            }\n\n            //Loop dragging grid\n            for (x = event.drag.start.x; x <= event.drag.stop.x; x++) {\n              for (y = event.drag.start.y; y <= event.drag.stop.y; y++) {\n                setMarkup.call(this, x, y);\n              }\n            }\n\n            //Process position\n            this.processPosition();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeEdit.hover.call(this, event);\n      },\n\n      /**\n       * Path change\n       */\n      pathChange: function() {\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SETUP,\n          PlayerTools.MARKUP,\n          PlayerTools.SCORE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Find all markup labels in the current game position\n        findAllMarkupLabels.call(this);\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeEdit;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeReplay :: This module governs the \"replay\" mode of the player, e.g. traversing\n * through an existing game record without the ability to deviate from the tree or its variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Replay.Service', [\n  'ngGo',\n  'ngGo.Game.Scorer.Service'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeReplay', function(Player, PlayerModes, PlayerModeReplay) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeReplay.settingChange, PlayerModes.REPLAY);\n  Player.on('boardUpdate', PlayerModeReplay.boardUpdate, PlayerModes.REPLAY);\n  Player.on('pathChange', PlayerModeReplay.pathChange, PlayerModes.REPLAY);\n  Player.on('toolSwitch', PlayerModeReplay.toolSwitch, PlayerModes.REPLAY);\n  Player.on('modeEnter', PlayerModeReplay.modeEnter, PlayerModes.REPLAY);\n  Player.on('modeExit', PlayerModeReplay.modeExit, PlayerModes.REPLAY);\n  Player.on('click', PlayerModeReplay.click, PlayerModes.REPLAY);\n  Player.on('hover', PlayerModeReplay.hover, PlayerModes.REPLAY);\n\n  //Register the mode\n  Player.registerMode(PlayerModes.REPLAY, PlayerModeReplay);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeReplay', function() {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Auto play delay\n    auto_play_delay: 1000\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$interval', 'Player', 'PlayerModes', 'PlayerTools', 'MarkupTypes', 'GameScorer', function($interval, Player, PlayerModes, PlayerTools, MarkupTypes, GameScorer) {\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (!this.game.hasStone(x, y) && this.game.isMoveVariation(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n\n        //Score tool\n        case PlayerTools.SCORE:\n\n          //Hovering over a stone means it can be marked dead or alive\n          if (this.game.hasStone(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'markup',\n              value: MarkupTypes.MARK\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show move variations on the board\n     */\n    var showMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n\n        //Auto variation markup should never overwrite existing markup\n        if (this.board.has('markup', variations[i].move.x, variations[i].move.y)) {\n          continue;\n        }\n\n        //Add to board\n        this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n          type: this.board.theme.get('markup.variation.type'),\n          text: this.board.theme.get('markup.variation.text', i),\n          color: this.board.theme.get('markup.variation.color')\n        });\n      }\n    };\n\n    /**\n     * Helper to hide move variations from the board\n     */\n    var hideMoveVariations = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) move variations on the board\n     */\n    var drawMoveVariations = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get the current node\n      var node = this.game.getNode();\n      var variations;\n      if (!node) {\n        return;\n      }\n\n      //Child variations?\n      if (this.variationChildren && node.hasMoveVariations()) {\n        variations = node.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n\n      //Sibling variations?\n      if (this.variationSiblings && node.parent && node.parent.hasMoveVariations()) {\n        variations = node.parent.getMoveVariations();\n        if (show) {\n          showMoveVariations.call(this, variations);\n        }\n        else {\n          hideMoveVariations.call(this, variations);\n        }\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Auto play vars\n      autoPlaying: false,\n      autoPlayDelay: 1000,\n      autoPlayPromise: null,\n\n      /**\n       * Set auto play delay\n       */\n      setAutoPlayDelay: function(delay) {\n        if (this.autoPlayDelay !== delay) {\n          this.autoPlayDelay = delay;\n          this.broadcast('settingChange', 'autoPlayDelay');\n        }\n      },\n\n      /**\n       * Start auto play with a given delay\n       */\n      start: function(delay) {\n\n        //Not in replay mode or already auto playing?\n        if (this.mode !== PlayerModes.REPLAY || this.autoPlaying) {\n          return;\n        }\n\n        //Already auto playing, no game or no move children?\n        if (!this.game || !this.game.node.hasChildren()) {\n          return;\n        }\n\n        //Get self\n        var self = this;\n\n        //Determine delay\n        delay = (typeof delay === 'number') ? delay : this.autoPlayDelay;\n\n        //Switch tool\n        this.switchTool(PlayerTools.NONE);\n\n        //Create interval\n        this.autoPlaying = true;\n        this.autoPlayPromise = $interval(function() {\n\n          //Advance to the next node\n          self.next(0, true);\n\n          //Ran out of children?\n          if (!self.game.node.hasChildren()) {\n            self.stop();\n          }\n        }, delay);\n\n        //Broadcast event\n        this.broadcast('autoPlayStarted', this.game.node);\n      },\n\n      /**\n       * Stop auto play\n       */\n      stop: function() {\n\n        //Not in replay mode or not auto playing?\n        if (this.mode !== PlayerModes.REPLAY || !this.autoPlaying) {\n          return;\n        }\n\n        //Cancel interval\n        if (this.autoPlayPromise) {\n          $interval.cancel(this.autoPlayPromise);\n        }\n\n        //Clear flags\n        this.autoPlayPromise = null;\n        this.autoPlaying = false;\n\n        //Broadcast event\n        this.broadcast('autoPlayStopped', this.game.node);\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeReplay = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.setAutoPlayDelay(this.config.auto_play_delay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'variationMarkup') {\n          drawMoveVariations.call(this, this.variationMarkup);\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //What happens, depends on the active tool\n        switch (this.tool) {\n\n          //Move tool\n          case PlayerTools.MOVE:\n\n            //Check if we clicked a move variation, advance to the next position if so\n            if (this.game.isMoveVariation(event.x, event.y)) {\n              this.next(this.game.getMoveVariation(event.x, event.y));\n            }\n            break;\n\n          //Score tool, mark stones dead or alive\n          case PlayerTools.SCORE:\n\n            //Mark the clicked item and score the current game position\n            GameScorer.mark(event.x, event.y);\n            this.scoreGame();\n            break;\n        }\n\n        //Handle hover\n        PlayerModeReplay.hover.call(this, event);\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE,\n          PlayerTools.SCORE,\n          PlayerTools.NONE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Show move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Stop auto playing\n        if (this.autoPlaying) {\n          this.stop();\n        }\n\n        //Hide move variations\n        if (this.variationMarkup) {\n          drawMoveVariations.call(this, false);\n        }\n      },\n\n      /**\n       * Handler for tool switches\n       */\n      toolSwitch: function() {\n\n        //Switched to scoring?\n        if (this.tool === PlayerTools.SCORE) {\n\n          //Remember the current board state\n          this.statePreScoring = this.board.getState();\n\n          //Load game into scorer and score the game\n          GameScorer.load(this.game);\n          this.scoreGame();\n        }\n\n        //Back to another state?\n        else {\n          if (this.statePreScoring) {\n            this.board.restoreState(this.statePreScoring);\n            delete this.statePreScoring;\n          }\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeReplay;\n  }];\n});\n\n})(window, window.angular);\n\n(function(window, angular, undefined) {'use strict';\n\n/**\n * PlayerModeSolve :: This module governs the \"solve\" mode of the player, e.g. trying to solve\n * go problems and finding the right move or variations.\n */\n\n/**\n * Module definition and dependencies\n */\nangular.module('ngGo.Player.Mode.Solve.Service', [\n  'ngGo'\n])\n\n/**\n * Extend player functionality and register the mode\n */\n.run(['Player', 'PlayerModes', 'PlayerModeSolve', function(Player, PlayerModes, PlayerModeSolve) {\n\n  //Register event handlers\n  Player.on('settingChange', PlayerModeSolve.settingChange, PlayerModes.SOLVE);\n  Player.on('boardUpdate', PlayerModeSolve.boardUpdate, PlayerModes.SOLVE);\n  Player.on('pathChange', PlayerModeSolve.pathChange, PlayerModes.SOLVE);\n  Player.on('modeEnter', PlayerModeSolve.modeEnter, PlayerModes.SOLVE);\n  Player.on('modeExit', PlayerModeSolve.modeExit, PlayerModes.SOLVE);\n  Player.on('keydown', PlayerModeSolve.keyDown, PlayerModes.SOLVE);\n  Player.on('click', PlayerModeSolve.click, PlayerModes.SOLVE);\n  Player.on('hover', PlayerModeSolve.hover, PlayerModes.SOLVE);\n\n  //Register mode\n  Player.registerMode(PlayerModes.SOLVE, PlayerModeSolve);\n}])\n\n/**\n * Provider definition\n */\n.provider('PlayerModeSolve', ['StoneColor', function(StoneColor) {\n\n  /**\n   * Default configuration\n   */\n  var defaultConfig = {\n\n    //Player color\n    player_color: StoneColor.B,\n\n    //Show solution paths\n    solution_paths: false,\n\n    //Auto play settings\n    solve_auto_play: true,\n    solve_auto_play_delay: 500\n  };\n\n  /**\n   * Set global default configuration for players\n   */\n  this.setConfig = function(config) {\n    defaultConfig = angular.extend(defaultConfig, config);\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = ['$timeout', 'Player', 'PlayerModes', 'PlayerTools', 'KeyCodes', function($timeout, Player, PlayerModes, PlayerTools, KeyCodes) {\n\n    /**\n     * Check if we can make a move\n     */\n    var canMakeMove = function() {\n\n      //We can make a move when...\n\n      //...there is no auto play going on\n      if (!this.solveAutoPlay) {\n        return true;\n      }\n\n      //...we solved the puzzle already\n      if (this.problemSolved) {\n        return true;\n      }\n\n      //...we are off path\n      if (this.problemOffPath) {\n        return true;\n      }\n\n      //...it's our turn\n      if (this.game.getTurn() === this.playerColor) {\n        return true;\n      }\n\n      //Otherwise, we can't make a move\n      return false;\n    };\n\n    /**\n     * Helper to update the hover mark\n     */\n    var updateHoverMark = function(x, y) {\n\n      //If no coordinates specified, use last mouse coordinates\n      if (typeof x === 'undefined' || typeof y === 'undefined') {\n        x = this.mouse.lastX;\n        y = this.mouse.lastY;\n      }\n\n      //Falling outside of grid?\n      if (!this.board || !this.board.isOnBoard(x, y)) {\n        return;\n      }\n\n      //What happens, depends on the active tool\n      switch (this.tool) {\n\n        //Move tool\n        case PlayerTools.MOVE:\n\n          //Hovering over empty spot where we can make a move?\n          if (canMakeMove.call(this) && this.game.isValidMove(x, y)) {\n            this.board.add('hover', x, y, {\n              type: 'stones',\n              value: this.game.getTurn()\n            });\n          }\n          break;\n      }\n    };\n\n    /**\n     * Helper to show solution paths\n     */\n    var showSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        if (variations[i].solution === true) {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.valid.type'),\n            text: this.board.theme.get('markup.solution.valid.text', i),\n            scale: this.board.theme.get('markup.solution.valid.scale'),\n            color: this.board.theme.get('markup.solution.valid.color')\n          });\n        }\n        else {\n          this.board.add('markup', variations[i].move.x, variations[i].move.y, {\n            type: this.board.theme.get('markup.solution.invalid.type'),\n            text: this.board.theme.get('markup.solution.invalid.text', i),\n            scale: this.board.theme.get('markup.solution.invalid.scale'),\n            color: this.board.theme.get('markup.solution.invalid.color')\n          });\n        }\n      }\n    };\n\n    /**\n     * Helper to hide solution paths\n     */\n    var hideSolutionPaths = function(variations) {\n      for (var i = 0; i < variations.length; i++) {\n        this.board.remove('markup', variations[i].move.x, variations[i].move.y);\n      }\n    };\n\n    /**\n     * Draw (or clear) solution paths\n     */\n    var drawSolutionPaths = function(show) {\n\n      //Check if we can do something\n      if (!this.board || !this.game || !this.game.isLoaded()) {\n        return;\n      }\n\n      //Get node and variations\n      var node = this.game.getNode();\n      var variations = node.getMoveVariations();\n\n      //When showing, make sure it's not during the auto solver's move\n      if (show && !this.problemSolved && this.solveAutoPlay) {\n        if (this.game.getTurn() !== this.playerColor) {\n          hideSolutionPaths.call(this, variations);\n          return;\n        }\n      }\n\n      //Call helper\n      if (show) {\n        showSolutionPaths.call(this, variations);\n      }\n      else {\n        hideSolutionPaths.call(this, variations);\n      }\n    };\n\n    /**\n     * Player extension\n     */\n    angular.extend(Player, {\n\n      //Solved and off-path flags\n      problemSolved: false,\n      problemOffPath: false,\n\n      //Problem start path\n      problemStartPath: null,\n\n      //The player color\n      playerColor: 0,\n\n      //Solution paths\n      solutionPaths: false,\n\n      //Auto play vars\n      solveAutoPlay: true,\n      solveAutoPlayDelay: 500,\n\n      //Navigation blocked flag\n      solveNavigationBlocked: false,\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlay: function(autoPlay) {\n        if (this.solveAutoPlay !== autoPlay) {\n          this.solveAutoPlay = autoPlay;\n          this.broadcast('settingChange', 'solveAutoPlay');\n        }\n      },\n\n      /**\n       * Set solve auto play delay\n       */\n      setSolveAutoPlayDelay: function(delay) {\n        if (this.solveAutoPlayDelay !== delay) {\n          this.solveAutoPlayDelay = delay;\n          this.broadcast('settingChange', 'solveAutoPlayDelay');\n        }\n      },\n\n      /**\n       * Set player color\n       */\n      setPlayerColor: function(color) {\n        if (this.playerColor !== color) {\n          this.playerColor = color;\n          this.broadcast('settingChange', 'playerColor');\n        }\n      },\n\n      /**\n       * Get player color\n       */\n      getPlayerColor: function(asOnBoard) {\n        if (asOnBoard && this.board) {\n          return this.board.colorMultiplier * this.playerColor;\n        }\n        return this.playerColor;\n      },\n\n      /**\n       * Toggle solution paths\n       */\n      toggleSolutionPaths: function(solutionPaths) {\n\n        //Toggle if not given\n        if (typeof solutionPaths === 'undefined') {\n          solutionPaths = !this.solutionPaths;\n        }\n\n        //Change?\n        if (solutionPaths !== this.solutionPaths) {\n          this.solutionPaths = solutionPaths;\n          this.broadcast('settingChange', 'solutionPaths');\n        }\n      },\n\n      /**\n       * Auto play next move\n       */\n      autoPlayNext: function(immediately) {\n\n        //Must have game and children\n        if (!this.game || !this.game.isLoaded() || this.game.node.children.length === 0) {\n          return;\n        }\n\n        //Init vars\n        var children = [];\n        var self = this;\n        var i;\n\n        //When picking a child node, we always prefer to pick a valid solution\n        for (i = 0; i < this.game.node.children.length; i++) {\n          if (this.game.node.children[i].solution) {\n            children.push(this.game.node.children[i]);\n          }\n        }\n\n        //No solution nodes? Just use all nodes then.\n        if (children.length === 0) {\n          children = this.game.node.children;\n        }\n\n        //Pick a random child node\n        i = Math.floor(Math.random() * children.length);\n\n        //No delay?\n        if (immediately || !this.solveAutoPlayDelay) {\n          this.next(children[i]);\n          return;\n        }\n\n        //Block navigation and run the timeout\n        this.solveNavigationBlocked = true;\n        $timeout(function() {\n\n          //Move to next move and unblock navigation\n          self.next(children[i]);\n          self.solveNavigationBlocked = false;\n\n        }, this.solveAutoPlayDelay);\n      },\n\n      /**\n       * Start solving from the current game node\n       */\n      solve: function() {\n\n        //Must have a game\n        if (!this.game || !this.game.isLoaded()) {\n          return false;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Remember problem start path\n        this.problemStartPath = this.game.getPath(true);\n\n        //Restrict start of navigation to the current node\n        this.restrictNode();\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      },\n\n      /**\n       * Restart the problem\n       */\n      restartProblem: function() {\n\n        //Must be in solve mode, must have game\n        if (this.mode !== PlayerModes.SOLVE || !this.game || !this.game.isLoaded()) {\n          return;\n        }\n\n        //Reset flags\n        this.problemSolved = false;\n        this.problemOffPath = false;\n\n        //Go back to the start path\n        if (this.problemStartPath) {\n          this.goto(this.problemStartPath);\n        }\n\n        //Auto play next move if it's not our turn\n        if (this.solveAutoPlay && this.game.getTurn() !== this.playerColor) {\n          this.autoPlayNext();\n        }\n      }\n    });\n\n    /**\n     * Player mode definition\n     */\n    var PlayerModeSolve = {\n\n      /**\n       * Parse config instructions\n       */\n      parseConfig: function(config) {\n\n        //Extend from default config\n        this.config = angular.extend({}, this.config, defaultConfig, config || {});\n\n        //Process settings\n        this.toggleSolutionPaths(this.config.solution_paths);\n        this.setPlayerColor(this.config.player_color);\n        this.setSolveAutoPlay(this.config.solve_auto_play);\n        this.setSolveAutoPlayDelay(this.config.solve_auto_play_delay);\n      },\n\n      /**\n       * Setting changes handler\n       */\n      settingChange: function(event, setting) {\n\n        //Solution paths setting changes?\n        if (setting === 'solutionPaths') {\n          drawSolutionPaths.call(this, this.solutionPaths);\n        }\n\n        //Player color changed?\n        if (setting === 'playerColor') {\n\n          //Draw (or hide) solution paths\n          drawSolutionPaths.call(this, this.solutionPaths);\n\n          //Make an auto play move if it's not our turn\n          if (\n            !this.problemSolved && this.solveAutoPlay && this.game.getTurn() !== this.playerColor\n          ) {\n            this.autoPlayNext(true);\n          }\n        }\n      },\n\n      /**\n       * Hover handler\n       */\n      hover: function(event) {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this, event.x, event.y);\n        }\n      },\n\n      /**\n       * Board update event handler\n       */\n      boardUpdate: function() {\n\n        //Show move variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for keydown events\n       */\n      keyDown: function(event, keyboardEvent) {\n\n        //Switch key code\n        switch (keyboardEvent.keyCode) {\n\n          //Right arrow\n          case KeyCodes.RIGHT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeEnd) {\n\n                //Go forward one move if solved\n                if (this.problemSolved) {\n                  this.next();\n                }\n              }\n            }\n            break;\n\n          //Left arrow\n          case KeyCodes.LEFT:\n\n            //Arrow keys navigation enabled?\n            if (this.arrowKeysNavigation) {\n              keyboardEvent.preventDefault();\n\n              //Navigation not blocked and not reached the start?\n              if (!this.solveNavigationBlocked && this.game.node !== this.restrictNodeStart) {\n\n                //Go back one move\n                this.previous();\n\n                //Go back one more if this is not the player's turn and if\n                //the problem hasn't been solved yet\n                if (\n                  !this.problemSolved && this.solveAutoPlay &&\n                  this.game.getTurn() === -this.playerColor\n                ) {\n                  this.previous();\n                }\n              }\n            }\n            break;\n        }\n      },\n\n      /**\n       * Handler for mouse click events\n       */\n      click: function(event) {\n\n        //Falling outside of grid?\n        if (!this.board || !this.board.isOnBoard(event.x, event.y)) {\n          return;\n        }\n\n        //A valid variation\n        if (this.game.isMoveVariation(event.x, event.y)) {\n\n          //Get the node\n          var i = this.game.getMoveVariation(event.x, event.y);\n\n          //Advance to the next position and get the next node\n          this.next(i);\n          var node = this.game.getNode();\n\n          //No children left? Check if we solved it or not\n          if (node.children.length === 0) {\n            if (node.solution === true) {\n              this.problemSolved = true;\n              this.broadcast('solutionFound', node);\n            }\n            else {\n              this.broadcast('solutionWrong', node);\n            }\n          }\n\n          //Auto-play next move?\n          else if (!this.problemSolved && this.solveAutoPlay) {\n            this.autoPlayNext();\n          }\n        }\n\n        //Unknown variation, try to play\n        else if (this.game.play(event.x, event.y)) {\n          this.problemOffPath = true;\n          this.processPosition();\n          this.broadcast('solutionOffPath', this.game.getNode());\n        }\n      },\n\n      /**\n       * Path change event\n       */\n      pathChange: function() {\n\n        //Update hover mark\n        if (this.board) {\n          this.board.removeAll('hover');\n          updateHoverMark.call(this);\n        }\n      },\n\n      /**\n       * Handler for mode entry\n       */\n      modeEnter: function() {\n\n        //Set available tools for this mode\n        this.setTools([\n          PlayerTools.MOVE\n        ]);\n\n        //Set default tool\n        this.tool = this.tools[0];\n\n        //Draw solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, true);\n        }\n      },\n\n      /**\n       * Handler for mode exit\n       */\n      modeExit: function() {\n\n        //Hide any solution variations\n        if (this.solutionPaths) {\n          drawSolutionPaths.call(this, false);\n        }\n      }\n    };\n\n    //Return\n    return PlayerModeSolve;\n  }];\n}]);\n\n})(window, window.angular);\n"],"sourceRoot":"/source/"}